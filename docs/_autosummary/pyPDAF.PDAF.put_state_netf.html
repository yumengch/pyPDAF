<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>pyPDAF.PDAF.put_state_netf &#8212; pyPDAF  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=8e461078" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=27fed22d" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="pyPDAF.PDAF.put_state_pf" href="pyPDAF.PDAF.put_state_pf.html" />
    <link rel="prev" title="pyPDAF.PDAF.put_state_seik" href="pyPDAF.PDAF.put_state_seik.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="pypdaf-pdaf-put-state-netf">
<h1>pyPDAF.PDAF.put_state_netf<a class="headerlink" href="#pypdaf-pdaf-put-state-netf" title="Link to this heading">¶</a></h1>
<dl class="py function">
<dt class="sig sig-object py" id="pyPDAF.PDAF.put_state_netf">
<span class="sig-prename descclassname"><span class="pre">pyPDAF.PDAF.</span></span><span class="sig-name descname"><span class="pre">put_state_netf</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyPDAF.PDAF.put_state_netf" title="Link to this definition">¶</a></dt>
<dd><p>It is recommended to use <a class="reference internal" href="pyPDAF.PDAF.omi_put_state_global.html#pyPDAF.PDAF.omi_put_state_global" title="pyPDAF.PDAF.omi_put_state_global"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyPDAF.PDAF.omi_put_state_global()</span></code></a>
or <a class="reference internal" href="pyPDAF.PDAF.omi_put_state_nonlin_nondiagR.html#pyPDAF.PDAF.omi_put_state_nonlin_nondiagR" title="pyPDAF.PDAF.omi_put_state_nonlin_nondiagR"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyPDAF.PDAF.omi_put_state_nonlin_nondiagR()</span></code></a>.</p>
<p>PDAF-OMI modules require fewer user-supplied functions and improved efficiency.</p>
<p>This function will use Nonlinear Ensemble Transform Filter (NETF) <a class="footnote-reference brackets" href="#id2" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>
for a single DA step.</p>
<p>Compared to <a class="reference internal" href="pyPDAF.PDAF.assimilate_netf.html#pyPDAF.PDAF.assimilate_netf" title="pyPDAF.PDAF.assimilate_netf"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyPDAF.PDAF.assimilate_netf()</span></code></a>, this function has no <a class="reference internal" href="pyPDAF.PDAF.get_state.html#pyPDAF.PDAF.get_state" title="pyPDAF.PDAF.get_state"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_state()</span></code></a> call.
This means that the analysis is not post-processed, and distributed to the model forecast
by user-supplied functions. The next DA step will not be assigned by user-supplied functions as well.
This function is typically used when there are not enough CPUs to run the ensemble in parallel,
and some ensemble members have to be run serially. The <a class="reference internal" href="pyPDAF.PDAF.get_state.html#pyPDAF.PDAF.get_state" title="pyPDAF.PDAF.get_state"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyPDAF.PDAF.get_state()</span></code></a> function follows this
function call to ensure the sequential DA.</p>
<p>The nonlinear filter computes the distribution up to
the second moment similar to KF but using a nonlinear weighting similar to
particle filter. This leads to an equal weights assumption for prior ensemble.
The function should be called at each model step.</p>
<dl class="simple">
<dt>This function executes the user-supplied function in the following sequence:</dt><dd><ol class="arabic simple">
<li><p>py__collect_state_pdaf</p></li>
<li><p>py__prepoststep_state_pdaf</p></li>
<li><p>py__init_dim_obs_pdaf</p></li>
<li><p>py__init_obs_pdaf</p></li>
<li><p>py__obs_op_pdaf (for each ensemble member)</p></li>
<li><p>py__likelihood_pdaf</p></li>
<li><p>core DA algorithm</p></li>
</ol>
</dd>
</dl>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 1.0.0: </span>This function is replaced by <a class="reference internal" href="pyPDAF.PDAF.omi_put_state_global.html#pyPDAF.PDAF.omi_put_state_global" title="pyPDAF.PDAF.omi_put_state_global"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyPDAF.PDAF.omi_put_state_global()</span></code></a>
and <a class="reference internal" href="pyPDAF.PDAF.omi_put_state_nonlin_nondiagR.html#pyPDAF.PDAF.omi_put_state_nonlin_nondiagR" title="pyPDAF.PDAF.omi_put_state_nonlin_nondiagR"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyPDAF.PDAF.omi_put_state_nonlin_nondiagR()</span></code></a></p>
</div>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id2" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>Tödter, J., and B. Ahrens, 2015:
A second-order exact ensemble square root filter
for nonlinear data assimilation. Mon. Wea. Rev.,
143, 1347–1367, doi:10.1175/MWR-D-14-00108.1.</p>
</aside>
</aside>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>py__collect_state_pdaf</strong> (<em>Callable</em><em>[</em><em>dim_p:int</em><em>, </em><em>state_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>]</em>) – <p>Routine to collect a state vector</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>dim_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>pe-local state dimension</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>state_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>local state vector</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>state_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>local state vector</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__init_dim_obs_pdaf</strong> (<em>Callable</em><em>[</em><em>step:int</em><em>, </em><em>dim_obs_p:int</em><em>]</em>) – <p>Initialize dimension of observation vector</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>step</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>current time step</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_obs_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>dimension of observation vector</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>dim_obs_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>dimension of observation vector</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__obs_op_pdaf</strong> (<em>Callable</em><em>[</em><em>step:int</em><em>, </em><em>dim_p:int</em><em>, </em><em>dim_obs_p:int</em><em>, </em><em>state_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>m_state_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_obs_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>]</em>) – <p>Observation operator</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>step</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Current time step</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Size of state vector (local part in case of parallel decomposed state)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_obs_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Size of observation vector</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>state_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>Model state vector</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>m_state_p</strong><span class="classifier">ndarray[tuple[dim_obs_p], np.float64]</span></dt><dd><ul>
<li><p>Observed state vector (i.e. the result after applying the observation operator to state_p)</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>m_state_p</strong><span class="classifier">ndarray[tuple[dim_obs_p], np.float64]</span></dt><dd><ul>
<li><p>Observed state vector (i.e. the result after applying the observation operator to state_p)</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__init_obs_pdaf</strong> (<em>Callable</em><em>[</em><em>step:int</em><em>, </em><em>dim_obs_p:int</em><em>, </em><em>observation_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_obs_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>]</em>) – <p>Initialize observation vector</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>step</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Current time step</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_obs_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Size of the observation vector</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>observation_p</strong><span class="classifier">ndarray[tuple[dim_obs_p], np.float64]</span></dt><dd><ul>
<li><p>Vector of observations</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>observation_p</strong><span class="classifier">ndarray[tuple[dim_obs_p], np.float64]</span></dt><dd><ul>
<li><p>Vector of observations</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__prepoststep_pdaf</strong> (<em>Callable</em><em>[</em><em>step:int</em><em>, </em><em>dim_p:int</em><em>, </em><em>dim_ens:int</em><em>, </em><em>dim_ens_p:int</em><em>, </em><em>dim_obs_p:int</em><em>, </em><em>state_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>uinv : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_ens-1</em><em>, </em><em>dim_ens-1</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>ens_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_p</em><em>, </em><em>dim_ens</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>flag:int</em><em>]</em>) – <p>User supplied pre/poststep routine</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>step</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>current time step (negative for call after forecast)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>pe-local state dimension</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_ens</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>size of state ensemble</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_ens_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>pe-local size of ensemble</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_obs_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>pe-local dimension of observation vector</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>state_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>pe-local forecast/analysis state
(the array ‘state_p’ is not generally not
initialized in the case of seik.
it can be used freely here.)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>uinv</strong><span class="classifier">ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]</span></dt><dd><ul>
<li><p>inverse of matrix u</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>ens_p</strong><span class="classifier">ndarray[tuple[dim_p, dim_ens], np.float64]</span></dt><dd><ul>
<li><p>pe-local state ensemble</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>flag</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>pdaf status flag</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>state_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>pe-local forecast/analysis state
(the array ‘state_p’ is not generally not
initialized in the case of seik.
it can be used freely here.)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>uinv</strong><span class="classifier">ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]</span></dt><dd><ul>
<li><p>inverse of matrix u</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>ens_p</strong><span class="classifier">ndarray[tuple[dim_p, dim_ens], np.float64]</span></dt><dd><ul>
<li><p>pe-local state ensemble</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__likelihood_pdaf</strong> (<em>Callable</em><em>[</em><em>step:int</em><em>, </em><em>dim_obs_p:int</em><em>, </em><em>obs_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_obs_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>resid : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_obs_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>likely:float</em><em>]</em>) – <p>Compute observation likelihood for an ensemble member</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>step</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Current time step</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_obs_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Number of observations at current time step (i.e. the size of the observation vector)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>obs_p</strong><span class="classifier">ndarray[tuple[dim_obs_p], np.float64]</span></dt><dd><ul>
<li><p>Vector of observations</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>resid</strong><span class="classifier">ndarray[tuple[dim_obs_p], np.float64]</span></dt><dd><ul>
<li><p>Input vector holding the residual</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>likely</strong><span class="classifier">float</span></dt><dd><ul>
<li><p>Output value of the likelihood</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>likely</strong><span class="classifier">float</span></dt><dd><ul>
<li><p>Output value of the likelihood</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>flag</strong> – Status flag</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">pyPDAF</a></h1>



<p class="blurb">A Python interface to Parallel Data Assimilation Framework.</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=yumengch&repo=pyPDAF&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>






<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Manual.html">Userguide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../implementation.html">Design Details</a></li>
<li class="toctree-l1"><a class="reference internal" href="../API.html">API</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../API_legacy.html">API (legacy)</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../API_legacy.html#da-algorithms">DA algorithms</a></li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="../API_legacy.html">API (legacy)</a><ul>
      <li>Previous: <a href="pyPDAF.PDAF.put_state_seik.html" title="previous chapter">pyPDAF.PDAF.put_state_seik</a></li>
      <li>Next: <a href="pyPDAF.PDAF.put_state_pf.html" title="next chapter">pyPDAF.PDAF.put_state_pf</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2022 University of Reading and National Centre for Earth Observation.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.0.2</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../_sources/_autosummary/pyPDAF.PDAF.put_state_netf.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>