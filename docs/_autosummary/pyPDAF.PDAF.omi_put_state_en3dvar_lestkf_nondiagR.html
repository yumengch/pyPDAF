<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>pyPDAF.PDAF.omi_put_state_en3dvar_lestkf_nondiagR &#8212; pyPDAF  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=8e461078" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=27fed22d" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="pyPDAF.PDAF.omi_put_state_hyb3dvar_lestkf_nondiagR" href="pyPDAF.PDAF.omi_put_state_hyb3dvar_lestkf_nondiagR.html" />
    <link rel="prev" title="pyPDAF.PDAF.omi_put_state_lknetf_nondiagR" href="pyPDAF.PDAF.omi_put_state_lknetf_nondiagR.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="pypdaf-pdaf-omi-put-state-en3dvar-lestkf-nondiagr">
<h1>pyPDAF.PDAF.omi_put_state_en3dvar_lestkf_nondiagR<a class="headerlink" href="#pypdaf-pdaf-omi-put-state-en3dvar-lestkf-nondiagr" title="Link to this heading">¶</a></h1>
<dl class="py function">
<dt class="sig sig-object py" id="pyPDAF.PDAF.omi_put_state_en3dvar_lestkf_nondiagR">
<span class="sig-prename descclassname"><span class="pre">pyPDAF.PDAF.</span></span><span class="sig-name descname"><span class="pre">omi_put_state_en3dvar_lestkf_nondiagR</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyPDAF.PDAF.omi_put_state_en3dvar_lestkf_nondiagR" title="Link to this definition">¶</a></dt>
<dd><p>It is recommended to use <a class="reference internal" href="pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf_nondiagR.html#pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf_nondiagR" title="pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf_nondiagR"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf_nondiagR()</span></code></a>
or <a class="reference internal" href="pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf.html#pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf" title="pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf()</span></code></a>.</p>
<p>PDAFlocal-OMI modules require fewer user-supplied functions and improved efficiency.</p>
<dl class="simple">
<dt>3DEnVar for a single DA step without post-processing, distributing analysis, and setting next observation step,</dt><dd><p>where the ensemble anomaly is generated by LESTKF using non-diagnoal observation error covariance matrix.</p>
</dd>
</dl>
<p>Compared to <a class="reference internal" href="pyPDAF.PDAF.omi_assimilate_en3dvar_lestkf_nondiagR.html#pyPDAF.PDAF.omi_assimilate_en3dvar_lestkf_nondiagR" title="pyPDAF.PDAF.omi_assimilate_en3dvar_lestkf_nondiagR"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyPDAF.PDAF.omi_assimilate_en3dvar_lestkf_nondiagR()</span></code></a>, this function has no <a class="reference internal" href="pyPDAF.PDAF.get_state.html#pyPDAF.PDAF.get_state" title="pyPDAF.PDAF.get_state"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_state()</span></code></a> call.
This means that the analysis is not post-processed, and distributed to the model forecast
by user-supplied functions. The next DA step will not be assigned by user-supplied functions as well.
This function is typically used when there are not enough CPUs to run the ensemble in parallel,
and some ensemble members have to be run serially. The <a class="reference internal" href="pyPDAF.PDAF.get_state.html#pyPDAF.PDAF.get_state" title="pyPDAF.PDAF.get_state"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyPDAF.PDAF.get_state()</span></code></a> function follows this
function call to ensure the sequential DA.</p>
<p>The background error covariance matrix is estimated by ensemble.
The 3DEnVar only calculates the analysis of the ensemble mean.
An LESTKF is used to generate ensemble perturbations.
This function should be called at each model time step.</p>
<dl class="simple">
<dt>The user-supplied function are executed in the following sequence:</dt><dd><ol class="arabic simple">
<li><p>py__collect_state_pdaf</p></li>
<li><p>py__prepoststep_state_pdaf</p></li>
<li><p>py__init_dim_obs_pdaf</p></li>
<li><p>py__obs_op_pdaf</p></li>
<li><dl class="simple">
<dt>Starting the iterative optimisation:</dt><dd><ol class="arabic simple">
<li><p>py__cvt_ens_pdaf</p></li>
<li><p>py__obs_op_lin_pdaf</p></li>
<li><p>py__prodRinvA_pdaf</p></li>
<li><p>py__obs_op_adj_pdaf</p></li>
<li><p>py__cvt_adj_ens_pdaf</p></li>
<li><p>core DA algorithm</p></li>
</ol>
</dd>
</dl>
</li>
<li><p>py__cvt_ens_pdaf</p></li>
<li><dl class="simple">
<dt>Perform LESTKF:</dt><dd><ol class="arabic simple">
<li><p>py__init_n_domains_p_pdaf</p></li>
<li><p>py__init_dim_obs_pdaf</p></li>
<li><p>py__obs_op_pdaf
(for each ensemble member)</p></li>
<li><dl class="simple">
<dt>loop over each local domain:</dt><dd><ol class="arabic simple">
<li><p>py__init_dim_l_pdaf</p></li>
<li><p>py__init_dim_obs_l_pdaf</p></li>
<li><p>py__g2l_state_pdaf</p></li>
<li><p>py__prodRinvA_l_pdaf</p></li>
<li><p>core DA algorithm</p></li>
<li><p>py__l2g_state_pdaf</p></li>
</ol>
</dd>
</dl>
</li>
</ol>
</dd>
</dl>
</li>
</ol>
</dd>
</dl>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 1.0.0: </span>This function is replaced by <a class="reference internal" href="pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf_nondiagR.html#pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf_nondiagR" title="pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf_nondiagR"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf_nondiagR()</span></code></a>
and <a class="reference internal" href="pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf.html#pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf" title="pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf()</span></code></a></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>py__collect_state_pdaf</strong> (<em>Callable</em><em>[</em><em>dim_p:int</em><em>, </em><em>state_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>]</em>) – <p>Routine to collect a state vector</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>dim_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>pe-local state dimension</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>state_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>local state vector</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>state_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>local state vector</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__init_dim_obs_pdaf</strong> (<em>Callable</em><em>[</em><em>step:int</em><em>, </em><em>dim_obs_p:int</em><em>]</em>) – <p>Initialize dimension of full observation vector</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>step</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>current time step</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_obs_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>dimension of observation vector</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>dim_obs_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>dimension of observation vector</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__obs_op_pdaf</strong> (<em>Callable</em><em>[</em><em>step:int</em><em>, </em><em>dim_p:int</em><em>, </em><em>dim_obs_p:int</em><em>, </em><em>state_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>m_state_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_obs_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>]</em>) – <p>Full observation operator</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>step</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Current time step</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Size of state vector (local part in case of parallel decomposed state)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_obs_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Size of observation vector</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>state_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>Model state vector</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>m_state_p</strong><span class="classifier">ndarray[tuple[dim_obs_p], np.float64]</span></dt><dd><ul>
<li><p>Observed state vector (i.e. the result after applying the observation operator to state_p)</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>m_state_p</strong><span class="classifier">ndarray[tuple[dim_obs_p], np.float64]</span></dt><dd><ul>
<li><p>Observed state vector (i.e. the result after applying the observation operator to state_p)</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__prodRinvA_pdaf</strong> (<em>Callable</em><em>[</em><em>step:int</em><em>, </em><em>dim_obs_p:int</em><em>, </em><em>rank:int</em><em>, </em><em>obs_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_obs_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>A_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_obs_p</em><em>, </em><em>rank</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>C_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_obs_p</em><em>, </em><em>rank</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>]</em>) – <p>Provide product R^-1 A</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>step</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Current time step</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_obs_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Number of observations at current time step (i.e. the size of the observation vector)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>rank</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Number of the columns in the matrix processes here.
This is usually the ensemble size minus one
(or the rank of the initial covariance matrix)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>obs_p</strong><span class="classifier">ndarray[tuple[dim_obs_p], np.float64]</span></dt><dd><ul>
<li><p>Vector of observations</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>A_p</strong><span class="classifier">ndarray[tuple[dim_obs_p, rank], np.float64]</span></dt><dd><ul>
<li><p>Input matrix provided by PDAF</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>C_p</strong><span class="classifier">ndarray[tuple[dim_obs_p, rank], np.float64]</span></dt><dd><ul>
<li><p>Output matrix</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>C_p</strong><span class="classifier">ndarray[tuple[dim_obs_p, rank], np.float64]</span></dt><dd><ul>
<li><p>Output matrix</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__cvt_ens_pdaf</strong> (<em>Callable</em><em>[</em><em>iter:int</em><em>, </em><em>dim_p:int</em><em>, </em><em>dim_ens:int</em><em>, </em><em>dim_cvec_ens:int</em><em>, </em><em>ens_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_p</em><em>, </em><em>dim_ens</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>v_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_cvec_ens</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>Vv_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>]</em>) – <p>Apply control vector transform matrix to control vector</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>iter</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Iteration of optimization</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>PE-local dimension of state</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_ens</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Ensemble size</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_cvec_ens</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Dimension of control vector</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>ens_p</strong><span class="classifier">ndarray[tuple[dim_p, dim_ens], np.float64]</span></dt><dd><ul>
<li><p>PE-local ensemble</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>v_p</strong><span class="classifier">ndarray[tuple[dim_cvec_ens], np.float64]</span></dt><dd><ul>
<li><p>PE-local control vector</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>Vv_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>PE-local state increment</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>Vv_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>PE-local state increment</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__cvt_adj_ens_pdaf</strong> (<em>Callable</em><em>[</em><em>iter:int</em><em>, </em><em>dim_p:int</em><em>, </em><em>dim_ens:int</em><em>, </em><em>dim_cv_ens_p:int</em><em>, </em><em>ens_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_p</em><em>, </em><em>dim_ens</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>Vcv_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>cv_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_cv_ens_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>]</em>) – <p>Apply adjoint control vector transform matrix</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>iter</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Iteration of optimization</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>PE-local observation dimension</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_ens</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Ensemble size</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_cv_ens_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>PE-local dimension of control vector</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>ens_p</strong><span class="classifier">ndarray[tuple[dim_p, dim_ens], np.float64]</span></dt><dd><ul>
<li><p>PE-local ensemble</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>Vcv_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>PE-local input vector</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>cv_p</strong><span class="classifier">ndarray[tuple[dim_cv_ens_p], np.float64]</span></dt><dd><ul>
<li><p>PE-local result vector</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>cv_p</strong><span class="classifier">ndarray[tuple[dim_cv_ens_p], np.float64]</span></dt><dd><ul>
<li><p>PE-local result vector</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__obs_op_lin_pdaf</strong> (<em>Callable</em><em>[</em><em>step:int</em><em>, </em><em>dim_p:int</em><em>, </em><em>dim_obs_p:int</em><em>, </em><em>state_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>m_state_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_obs_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>]</em>) – <p>Linearized observation operator</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>step</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Current time step</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>PE-local dimension of state</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_obs_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Dimension of observed state</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>state_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>PE-local model state</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>m_state_p</strong><span class="classifier">ndarray[tuple[dim_obs_p], np.float64]</span></dt><dd><ul>
<li><p>PE-local observed state</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>m_state_p</strong><span class="classifier">ndarray[tuple[dim_obs_p], np.float64]</span></dt><dd><ul>
<li><p>PE-local observed state</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__obs_op_adj_pdaf</strong> (<em>Callable</em><em>[</em><em>step:int</em><em>, </em><em>dim_p:int</em><em>, </em><em>dim_obs_p:int</em><em>, </em><em>state_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>m_state_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_obs_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>]</em>) – <p>Adjoint observation operator</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>step</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Current time step</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>PE-local dimension of state</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_obs_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Dimension of observed state</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>state_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>PE-local model state</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>m_state_p</strong><span class="classifier">ndarray[tuple[dim_obs_p], np.float64]</span></dt><dd><ul>
<li><p>PE-local observed state</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>state_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>PE-local model state</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__prodRinvA_l_pdaf</strong> (<em>Callable</em><em>[</em><em>domain_p:int</em><em>, </em><em>step:int</em><em>, </em><em>dim_obs_l:int</em><em>, </em><em>rank:int</em><em>, </em><em>obs_l : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_obs_l</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>A_l : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_obs_l</em><em>, </em><em>rank</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>C_l : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_obs_l</em><em>, </em><em>rank</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>]</em>) – <p>Provide product R^-1 A for local analysis domain</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>domain_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Index of current local analysis domain</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>step</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Current time step</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_obs_l</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Number of local observations at current time step (i.e. the size of the local observation vector)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>rank</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Number of the columns in the matrix processes here.
This is usually the ensemble size minus one (or the rank of the initial covariance matrix)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>obs_l</strong><span class="classifier">ndarray[tuple[dim_obs_l], np.float64]</span></dt><dd><ul>
<li><p>Local vector of observations</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>A_l</strong><span class="classifier">ndarray[tuple[dim_obs_l, rank], np.float64]</span></dt><dd><ul>
<li><p>Input matrix provided by PDAF</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>C_l</strong><span class="classifier">ndarray[tuple[dim_obs_l, rank], np.float64]</span></dt><dd><ul>
<li><p>Output matrix</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>C_l</strong><span class="classifier">ndarray[tuple[dim_obs_l, rank], np.float64]</span></dt><dd><ul>
<li><p>Output matrix</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__init_n_domains_p_pdaf</strong> (<em>Callable</em><em>[</em><em>step:int</em><em>, </em><em>n_domains_p:int</em><em>]</em>) – <p>Provide number of local analysis domains</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>step</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>current time step</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>n_domains_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>pe-local number of analysis domains</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>n_domains_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>pe-local number of analysis domains</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__init_dim_l_pdaf</strong> (<em>Callable</em><em>[</em><em>step:int</em><em>, </em><em>domain_p:int</em><em>, </em><em>dim_l:int</em><em>]</em>) – <p>Init state dimension for local ana. domain</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>step</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>current time step</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>domain_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>current local analysis domain</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_l</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>local state dimension</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>dim_l</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>local state dimension</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__init_dim_obs_l_pdaf</strong> (<em>Callable</em><em>[</em><em>domain_p:int</em><em>, </em><em>step:int</em><em>, </em><em>dim_obs_f:int</em><em>, </em><em>dim_obs_l:int</em><em>]</em>) – <p>Initialize local dimimension of obs. vector</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>domain_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>index of current local analysis domain</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>step</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>current time step</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_obs_f</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>full dimension of observation vector</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_obs_l</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>local dimension of observation vector</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>dim_obs_l</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>local dimension of observation vector</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__g2l_state_pdaf</strong> (<em>Callable</em><em>[</em><em>step:int</em><em>, </em><em>domain_p:int</em><em>, </em><em>dim_p:int</em><em>, </em><em>state_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>dim_l:int</em><em>, </em><em>state_l : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_l</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>]</em>) – <p>Get state on local ana. domain from full state</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>step</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>current time step</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>domain_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>current local analysis domain</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>pe-local full state dimension</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>state_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>pe-local full state vector</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_l</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>local state dimension</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>state_l</strong><span class="classifier">ndarray[tuple[dim_l], np.float64]</span></dt><dd><ul>
<li><p>state vector on local analysis domain</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>state_l</strong><span class="classifier">ndarray[tuple[dim_l], np.float64]</span></dt><dd><ul>
<li><p>state vector on local analysis domain</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__l2g_state_pdaf</strong> (<em>Callable</em><em>[</em><em>step:int</em><em>, </em><em>domain_p:int</em><em>, </em><em>dim_l:int</em><em>, </em><em>state_l : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_l</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>dim_p:int</em><em>, </em><em>state_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>]</em>) – <p>Init full state from local state</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>step</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>current time step</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>domain_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>current local analysis domain</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_l</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>local state dimension</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>state_l</strong><span class="classifier">ndarray[tuple[dim_l], np.float64]</span></dt><dd><ul>
<li><p>state vector on local analysis domain</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>pe-local full state dimension</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>state_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>pe-local full state vector</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>state_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>pe-local full state vector</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__prepoststep_pdaf</strong> (<em>Callable</em><em>[</em><em>step:int</em><em>, </em><em>dim_p:int</em><em>, </em><em>dim_ens:int</em><em>, </em><em>dim_ens_p:int</em><em>, </em><em>dim_obs_p:int</em><em>, </em><em>state_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>uinv : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_ens-1</em><em>, </em><em>dim_ens-1</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>ens_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_p</em><em>, </em><em>dim_ens</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>flag:int</em><em>]</em>) – <p>User supplied pre/poststep routine</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>step</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>current time step (negative for call after forecast)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>pe-local state dimension</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_ens</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>size of state ensemble</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_ens_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>pe-local size of ensemble</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_obs_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>pe-local dimension of observation vector</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>state_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>pe-local forecast/analysis state
(the array ‘state_p’ is not generally not
initialized in the case of seik.
it can be used freely here.)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>uinv</strong><span class="classifier">ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]</span></dt><dd><ul>
<li><p>inverse of matrix u</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>ens_p</strong><span class="classifier">ndarray[tuple[dim_p, dim_ens], np.float64]</span></dt><dd><ul>
<li><p>pe-local state ensemble</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>flag</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>pdaf status flag</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>state_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>pe-local forecast/analysis state
(the array ‘state_p’ is not generally not
initialized in the case of seik.
it can be used freely here.)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>uinv</strong><span class="classifier">ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]</span></dt><dd><ul>
<li><p>inverse of matrix u</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>ens_p</strong><span class="classifier">ndarray[tuple[dim_p, dim_ens], np.float64]</span></dt><dd><ul>
<li><p>pe-local state ensemble</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>outflag</strong> (<em>int</em>) – Status flag</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>outflag</strong> – Status flag</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">pyPDAF</a></h1>



<p class="blurb">A Python interface to Parallel Data Assimilation Framework.</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=yumengch&repo=pyPDAF&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>






<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Manual.html">Userguide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../implementation.html">Design Details</a></li>
<li class="toctree-l1"><a class="reference internal" href="../API.html">API</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../API_legacy.html">API (legacy)</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../API_legacy.html#da-algorithms">DA algorithms</a></li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="../API_legacy.html">API (legacy)</a><ul>
      <li>Previous: <a href="pyPDAF.PDAF.omi_put_state_lknetf_nondiagR.html" title="previous chapter">pyPDAF.PDAF.omi_put_state_lknetf_nondiagR</a></li>
      <li>Next: <a href="pyPDAF.PDAF.omi_put_state_hyb3dvar_lestkf_nondiagR.html" title="next chapter">pyPDAF.PDAF.omi_put_state_hyb3dvar_lestkf_nondiagR</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2022 University of Reading and National Centre for Earth Observation.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.0.2</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../_sources/_autosummary/pyPDAF.PDAF.omi_put_state_en3dvar_lestkf_nondiagR.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>