<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>pyPDAF.PDAF.put_state_lseik &#8212; pyPDAF  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=8e461078" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=27fed22d" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="pyPDAF.PDAF.put_state_lnetf" href="pyPDAF.PDAF.put_state_lnetf.html" />
    <link rel="prev" title="pyPDAF.PDAF.put_state_letkf" href="pyPDAF.PDAF.put_state_letkf.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="pypdaf-pdaf-put-state-lseik">
<h1>pyPDAF.PDAF.put_state_lseik<a class="headerlink" href="#pypdaf-pdaf-put-state-lseik" title="Link to this heading">¶</a></h1>
<dl class="py function">
<dt class="sig sig-object py" id="pyPDAF.PDAF.put_state_lseik">
<span class="sig-prename descclassname"><span class="pre">pyPDAF.PDAF.</span></span><span class="sig-name descname"><span class="pre">put_state_lseik</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyPDAF.PDAF.put_state_lseik" title="Link to this definition">¶</a></dt>
<dd><p>It is recommended to use <a class="reference internal" href="pyPDAF.PDAF.localomi_put_state.html#pyPDAF.PDAF.localomi_put_state" title="pyPDAF.PDAF.localomi_put_state"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyPDAF.PDAF.localomi_put_state()</span></code></a>
or <a class="reference internal" href="pyPDAF.PDAF.localomi_put_state_nondiagR.html#pyPDAF.PDAF.localomi_put_state_nondiagR" title="pyPDAF.PDAF.localomi_put_state_nondiagR"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyPDAF.PDAF.localomi_put_state_nondiagR()</span></code></a>.</p>
<p>PDAF-OMI modules require fewer user-supplied functions and improved efficiency.</p>
<p>Local singular evolutive interpolated Kalman filter <a class="footnote-reference brackets" href="#id2" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> for a single DA step.</p>
<p>Compared to <a class="reference internal" href="pyPDAF.PDAF.assimilate_lseik.html#pyPDAF.PDAF.assimilate_lseik" title="pyPDAF.PDAF.assimilate_lseik"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyPDAF.PDAF.assimilate_lseik()</span></code></a>, this function has no <a class="reference internal" href="pyPDAF.PDAF.get_state.html#pyPDAF.PDAF.get_state" title="pyPDAF.PDAF.get_state"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_state()</span></code></a> call.
This means that the analysis is not post-processed, and distributed to the model forecast
by user-supplied functions. The next DA step will not be assigned by user-supplied functions as well.
This function is typically used when there are not enough CPUs to run the ensemble in parallel,
and some ensemble members have to be run serially. The <a class="reference internal" href="pyPDAF.PDAF.get_state.html#pyPDAF.PDAF.get_state" title="pyPDAF.PDAF.get_state"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyPDAF.PDAF.get_state()</span></code></a> function follows this
function call to ensure the sequential DA.</p>
<p>This function should be called at each model time step.</p>
<dl class="simple">
<dt>This function  executes the user-supplied functions in the following sequence:</dt><dd><ol class="arabic simple">
<li><p>py__collect_state_pdaf</p></li>
<li><p>py__prepoststep_state_pdaf</p></li>
<li><p>py__init_n_domains_p_pdaf</p></li>
<li><p>py__init_dim_obs_pdaf</p></li>
<li><p>py__obs_op_pdaf (for each ensemble member)</p></li>
<li><p>py__init_obs_pdaf
(if global adaptive forgetting factor <cite>type_forget=1</cite>
is used in <a class="reference internal" href="pyPDAF.PDAF.init.html#pyPDAF.PDAF.init" title="pyPDAF.PDAF.init"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyPDAF.PDAF.init()</span></code></a>)</p></li>
<li><p>py__init_obsvar_pdaf
(if global adaptive forgetting factor is used)</p></li>
<li><dl class="simple">
<dt>loop over each local domain:</dt><dd><ol class="arabic simple">
<li><p>py__init_dim_l_pdaf</p></li>
<li><p>py__init_dim_obs_l_pdaf</p></li>
<li><p>py__g2l_state_pdaf</p></li>
<li><p>py__g2l_obs_pdaf (localise mean ensemble in observation space)</p></li>
<li><p>py__init_obs_l_pdaf</p></li>
<li><p>py__g2l_obs_pdaf
(localise each ensemble member in observation space)</p></li>
<li><p>py__init_obsvar_l_pdaf
(only called if local adaptive forgetting factor <cite>type_forget=2</cite> is used)</p></li>
<li><p>py__prodRinvA_l_pdaf</p></li>
<li><p>core DA algorithm</p></li>
<li><p>py__l2g_state_pdaf</p></li>
</ol>
</dd>
</dl>
</li>
</ol>
</dd>
</dl>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 1.0.0: </span>This function is replaced by <a class="reference internal" href="pyPDAF.PDAF.localomi_put_state.html#pyPDAF.PDAF.localomi_put_state" title="pyPDAF.PDAF.localomi_put_state"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyPDAF.PDAF.localomi_put_state()</span></code></a>
and <a class="reference internal" href="pyPDAF.PDAF.localomi_put_state_nondiagR.html#pyPDAF.PDAF.localomi_put_state_nondiagR" title="pyPDAF.PDAF.localomi_put_state_nondiagR"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyPDAF.PDAF.localomi_put_state_nondiagR()</span></code></a></p>
</div>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id2" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>Pham, D. T., Verron, J., &amp; Roubaud, M. C. (1998).
A singular evolutive extended Kalman filter for data assimilation
in oceanography. Journal of Marine systems, 16(3-4), 323-340.</p>
</aside>
</aside>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>py__collect_state_pdaf</strong> (<em>Callable</em><em>[</em><em>dim_p:int</em><em>, </em><em>state_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>]</em>) – <p>Routine to collect a state vector</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>dim_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>pe-local state dimension</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>state_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>local state vector</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>state_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>local state vector</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__init_dim_obs_pdaf</strong> (<em>Callable</em><em>[</em><em>step:int</em><em>, </em><em>dim_obs_p:int</em><em>]</em>) – <p>Initialize dimension of observation vector</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>step</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>current time step</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_obs_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>dimension of observation vector</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>dim_obs_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>dimension of observation vector</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__obs_op_pdaf</strong> (<em>Callable</em><em>[</em><em>step:int</em><em>, </em><em>dim_p:int</em><em>, </em><em>dim_obs_p:int</em><em>, </em><em>state_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>m_state_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_obs_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>]</em>) – <p>Observation operator</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>step</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Current time step</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Size of state vector (local part in case of parallel decomposed state)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_obs_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Size of observation vector</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>state_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>Model state vector</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>m_state_p</strong><span class="classifier">ndarray[tuple[dim_obs_p], np.float64]</span></dt><dd><ul>
<li><p>Observed state vector (i.e. the result after applying the observation operator to state_p)</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>m_state_p</strong><span class="classifier">ndarray[tuple[dim_obs_p], np.float64]</span></dt><dd><ul>
<li><p>Observed state vector (i.e. the result after applying the observation operator to state_p)</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__init_obs_pdaf</strong> (<em>Callable</em><em>[</em><em>step:int</em><em>, </em><em>dim_obs_p:int</em><em>, </em><em>observation_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_obs_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>]</em>) – <p>Initialize PE-local observation vector</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>step</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Current time step</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_obs_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Size of the observation vector</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>observation_p</strong><span class="classifier">ndarray[tuple[dim_obs_p], np.float64]</span></dt><dd><ul>
<li><p>Vector of observations</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>observation_p</strong><span class="classifier">ndarray[tuple[dim_obs_p], np.float64]</span></dt><dd><ul>
<li><p>Vector of observations</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__init_obs_l_pdaf</strong> (<em>Callable</em><em>[</em><em>domain_p:int</em><em>, </em><em>step:int</em><em>, </em><em>dim_obs_l:int</em><em>, </em><em>observation_l : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_obs_l</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>]</em>) – <p>Init. observation vector on local analysis domain</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>domain_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Index of current local analysis domain</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>step</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Current time step</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_obs_l</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Local size of the observation vector</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>observation_l</strong><span class="classifier">ndarray[tuple[dim_obs_l], np.float64]</span></dt><dd><ul>
<li><p>Local vector of observations</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>observation_l</strong><span class="classifier">ndarray[tuple[dim_obs_l], np.float64]</span></dt><dd><ul>
<li><p>Local vector of observations</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__prepoststep_pdaf</strong> (<em>Callable</em><em>[</em><em>step:int</em><em>, </em><em>dim_p:int</em><em>, </em><em>dim_ens:int</em><em>, </em><em>dim_ens_p:int</em><em>, </em><em>dim_obs_p:int</em><em>, </em><em>state_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>uinv : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_ens-1</em><em>, </em><em>dim_ens-1</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>ens_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_p</em><em>, </em><em>dim_ens</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>flag:int</em><em>]</em>) – <p>User supplied pre/poststep routine</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>step</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>current time step (negative for call after forecast)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>pe-local state dimension</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_ens</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>size of state ensemble</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_ens_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>pe-local size of ensemble</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_obs_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>pe-local dimension of observation vector</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>state_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>pe-local forecast/analysis state
(the array ‘state_p’ is not generally not
initialized in the case of seik.
it can be used freely here.)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>uinv</strong><span class="classifier">ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]</span></dt><dd><ul>
<li><p>inverse of matrix u</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>ens_p</strong><span class="classifier">ndarray[tuple[dim_p, dim_ens], np.float64]</span></dt><dd><ul>
<li><p>pe-local state ensemble</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>flag</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>pdaf status flag</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>state_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>pe-local forecast/analysis state
(the array ‘state_p’ is not generally not
initialized in the case of seik.
it can be used freely here.)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>uinv</strong><span class="classifier">ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]</span></dt><dd><ul>
<li><p>inverse of matrix u</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>ens_p</strong><span class="classifier">ndarray[tuple[dim_p, dim_ens], np.float64]</span></dt><dd><ul>
<li><p>pe-local state ensemble</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__prodRinvA_l_pdaf</strong> (<em>Callable</em><em>[</em><em>domain_p:int</em><em>, </em><em>step:int</em><em>, </em><em>dim_obs_l:int</em><em>, </em><em>rank:int</em><em>, </em><em>obs_l : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_obs_l</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>A_l : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_obs_l</em><em>, </em><em>rank</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>C_l : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_obs_l</em><em>, </em><em>rank</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>]</em>) – <p>Provide product R^-1 A on local analysis domain</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>domain_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Index of current local analysis domain</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>step</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Current time step</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_obs_l</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Number of local observations at current time step (i.e. the size of the local observation vector)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>rank</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Number of the columns in the matrix processes here.
This is usually the ensemble size minus one (or the rank of the initial covariance matrix)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>obs_l</strong><span class="classifier">ndarray[tuple[dim_obs_l], np.float64]</span></dt><dd><ul>
<li><p>Local vector of observations</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>A_l</strong><span class="classifier">ndarray[tuple[dim_obs_l, rank], np.float64]</span></dt><dd><ul>
<li><p>Input matrix provided by PDAF</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>C_l</strong><span class="classifier">ndarray[tuple[dim_obs_l, rank], np.float64]</span></dt><dd><ul>
<li><p>Output matrix</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>C_l</strong><span class="classifier">ndarray[tuple[dim_obs_l, rank], np.float64]</span></dt><dd><ul>
<li><p>Output matrix</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__init_n_domains_p_pdaf</strong> (<em>Callable</em><em>[</em><em>step:int</em><em>, </em><em>n_domains_p:int</em><em>]</em>) – <p>Provide number of local analysis domains</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>step</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>current time step</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>n_domains_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>pe-local number of analysis domains</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>n_domains_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>pe-local number of analysis domains</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__init_dim_l_pdaf</strong> (<em>Callable</em><em>[</em><em>step:int</em><em>, </em><em>domain_p:int</em><em>, </em><em>dim_l:int</em><em>]</em>) – <p>Init state dimension for local ana. domain</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>step</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>current time step</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>domain_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>current local analysis domain</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_l</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>local state dimension</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>dim_l</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>local state dimension</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__init_dim_obs_l_pdaf</strong> (<em>Callable</em><em>[</em><em>domain_p:int</em><em>, </em><em>step:int</em><em>, </em><em>dim_obs_f:int</em><em>, </em><em>dim_obs_l:int</em><em>]</em>) – <p>Initialize dim. of obs. vector for local ana. domain</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>domain_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>index of current local analysis domain</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>step</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>current time step</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_obs_f</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>full dimension of observation vector</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_obs_l</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>local dimension of observation vector</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>dim_obs_l</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>local dimension of observation vector</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__g2l_state_pdaf</strong> (<em>Callable</em><em>[</em><em>step:int</em><em>, </em><em>domain_p:int</em><em>, </em><em>dim_p:int</em><em>, </em><em>state_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>dim_l:int</em><em>, </em><em>state_l : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_l</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>]</em>) – <p>Get state on local ana. domain from full state</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>step</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>current time step</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>domain_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>current local analysis domain</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>pe-local full state dimension</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>state_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>pe-local full state vector</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_l</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>local state dimension</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>state_l</strong><span class="classifier">ndarray[tuple[dim_l], np.float64]</span></dt><dd><ul>
<li><p>state vector on local analysis domain</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>state_l</strong><span class="classifier">ndarray[tuple[dim_l], np.float64]</span></dt><dd><ul>
<li><p>state vector on local analysis domain</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__l2g_state_pdaf</strong> (<em>Callable</em><em>[</em><em>step:int</em><em>, </em><em>domain_p:int</em><em>, </em><em>dim_l:int</em><em>, </em><em>state_l : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_l</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>dim_p:int</em><em>, </em><em>state_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>]</em>) – <p>Init full state from state on local analysis domain</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>step</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>current time step</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>domain_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>current local analysis domain</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_l</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>local state dimension</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>state_l</strong><span class="classifier">ndarray[tuple[dim_l], np.float64]</span></dt><dd><ul>
<li><p>state vector on local analysis domain</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>pe-local full state dimension</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>state_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>pe-local full state vector</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>state_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>pe-local full state vector</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__g2l_obs_pdaf</strong> (<em>Callable</em><em>[</em><em>domain_p:int</em><em>, </em><em>step:int</em><em>, </em><em>dim_obs_f:int</em><em>, </em><em>dim_obs_l:int</em><em>, </em><em>mstate_f : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_p</em><em>]</em><em>, </em><em>np.intc</em><em>]</em><em>, </em><em>dim_p:int</em><em>, </em><em>mstate_l : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_l</em><em>]</em><em>, </em><em>np.intc</em><em>]</em><em>, </em><em>dim_l:int</em><em>]</em>) – <p>Restrict full obs. vector to local analysis domain</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>domain_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Index of current local analysis domain</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>step</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Current time step</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_obs_f</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Size of full observation vector for model sub-domain</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_obs_l</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Size of observation vector for local analysis domain</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>mstate_f</strong><span class="classifier">ndarray[tuple[dim_p], np.intc]</span></dt><dd><ul>
<li><p>Full observation vector for model sub-domain</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Size of full observation vector for model sub-domain</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>mstate_l</strong><span class="classifier">ndarray[tuple[dim_l], np.intc]</span></dt><dd><ul>
<li><p>Observation vector for local analysis domain</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_l</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Size of observation vector for local analysis domain</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>mstate_l</strong><span class="classifier">ndarray[tuple[dim_l], np.intc]</span></dt><dd><ul>
<li><p>Observation vector for local analysis domain</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__init_obsvar_pdaf</strong> (<em>Callable</em><em>[</em><em>step:int</em><em>, </em><em>dim_obs_p:int</em><em>, </em><em>obs_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_obs_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>meanvar:float</em><em>]</em>) – <p>Initialize mean observation error variance</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>step</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Current time step</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_obs_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Size of observation vector</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>obs_p</strong><span class="classifier">ndarray[tuple[dim_obs_p], np.float64]</span></dt><dd><ul>
<li><p>Vector of observations</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>meanvar</strong><span class="classifier">float</span></dt><dd><ul>
<li><p>Mean observation error variance</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>meanvar</strong><span class="classifier">float</span></dt><dd><ul>
<li><p>Mean observation error variance</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__init_obsvar_l_pdaf</strong> (<em>Callable</em><em>[</em><em>domain_p:int</em><em>, </em><em>step:int</em><em>, </em><em>dim_obs_l:int</em><em>, </em><em>obs_l : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_obs_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>dim_obs_p:int</em><em>, </em><em>meanvar_l:float</em><em>]</em>) – <p>Initialize local mean observation error variance</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>domain_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Index of current local analysis domain</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>step</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Current time step</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_obs_l</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Local dimension of observation vector</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>obs_l</strong><span class="classifier">ndarray[tuple[dim_obs_p], np.float64]</span></dt><dd><ul>
<li><p>Local observation vector</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_obs_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Dimension of local observation vector</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>meanvar_l</strong><span class="classifier">float</span></dt><dd><ul>
<li><p>Mean local observation error variance</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>meanvar_l</strong><span class="classifier">float</span></dt><dd><ul>
<li><p>Mean local observation error variance</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>flag</strong> – Status flag</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">pyPDAF</a></h1>



<p class="blurb">A Python interface to Parallel Data Assimilation Framework.</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=yumengch&repo=pyPDAF&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>






<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Manual.html">Userguide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../implementation.html">Design Details</a></li>
<li class="toctree-l1"><a class="reference internal" href="../API.html">API</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../API_legacy.html">API (legacy)</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../API_legacy.html#da-algorithms">DA algorithms</a></li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="../API_legacy.html">API (legacy)</a><ul>
      <li>Previous: <a href="pyPDAF.PDAF.put_state_letkf.html" title="previous chapter">pyPDAF.PDAF.put_state_letkf</a></li>
      <li>Next: <a href="pyPDAF.PDAF.put_state_lnetf.html" title="next chapter">pyPDAF.PDAF.put_state_lnetf</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2022 University of Reading and National Centre for Earth Observation.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.0.2</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../_sources/_autosummary/pyPDAF.PDAF.put_state_lseik.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>