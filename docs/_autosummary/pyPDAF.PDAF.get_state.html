<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>pyPDAF.PDAF.get_state &#8212; pyPDAF  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=df3fedd5" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=27fed22d" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="pyPDAF.PDAF.assimilate_prepost" href="pyPDAF.PDAF.assimilate_prepost.html" />
    <link rel="prev" title="pyPDAF.PDAF.force_analysis" href="pyPDAF.PDAF.force_analysis.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="pypdaf-pdaf-get-state">
<h1>pyPDAF.PDAF.get_state<a class="headerlink" href="#pypdaf-pdaf-get-state" title="Link to this heading">¶</a></h1>
<dl class="py function">
<dt class="sig sig-object py" id="pyPDAF.PDAF.get_state">
<span class="sig-prename descclassname"><span class="pre">pyPDAF.PDAF.</span></span><span class="sig-name descname"><span class="pre">get_state</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyPDAF.PDAF.get_state" title="Link to this definition">¶</a></dt>
<dd><p>Distributing analysis state vector to an array.</p>
<p>The primary purpose of this function is to distribute
the analysis state vector to the model.
This is attained by the user-supplied function
<code class="xref py py-func docutils literal notranslate"><span class="pre">py__distribute_state_pdaf()</span></code>.
One can also use this function to get the state vector
for other purposes, e.g. to write the state vector to a file.</p>
<p>In this function, the user-supplied function
<code class="xref py py-func docutils literal notranslate"><span class="pre">py__next_observation_pdaf()</span></code> is executed
to specify the number of forecast time steps
until the next assimilation step.
One can also use the user-supplied function to
end the assimilation.</p>
<p>In an online DA system, this function also execute
the user-supplied function <code class="xref py py-func docutils literal notranslate"><span class="pre">py__prepoststep_state_pdaf()</span></code>,
when this function is first called. The purpose of this design
is to call this function right after <a class="reference internal" href="pyPDAF.PDAF.init.html#pyPDAF.PDAF.init" title="pyPDAF.PDAF.init"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyPDAF.PDAF.init()</span></code></a>
to process the initial ensemble before using it to
initialse model forecast. This user-supplied function
will not be called afterwards.</p>
<p>This function is also used in flexible parallel system
where the number of ensemble members are greater than
the parallel model tasks. In this case, this function
is called multiple times to distribute the analysis ensemble.</p>
<p>User-supplied function are executed in the following sequence:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>py__prepoststep_state_pdaf
(only in online system when first called)</p></li>
<li><p>py__distribute_state_pdaf</p></li>
<li><p>py__next_observation_pdaf</p></li>
</ol>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>steps</strong> (<em>int</em>) – number of forecast time steps for next assimilation
The input value can be an arbitrary integer</p></li>
<li><p><strong>doexit</strong> (<em>int</em>) – Whether to exit from forecasts</p></li>
<li><p><strong>py__next_observation_pdaf</strong> (<em>Callable</em><em>[</em><em>stepnow:int</em><em>, </em><em>nsteps:int</em><em>, </em><em>doexit:int</em><em>, </em><em>time:float</em><em>]</em>) – <p>Routine to provide number of forecast time steps until
next assimilations, model physical time and
end of assimilation cycles</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>stepnow</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>the current time step given by PDAF</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>nsteps</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>number of forecast time steps until next assimilation;
this can also be interpreted as
number of assimilation function calls
to perform a new assimilation</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>doexit</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>whether to exit forecasting (1 for exit)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>time</strong><span class="classifier">float</span></dt><dd><ul>
<li><p>current model (physical) time</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>nsteps</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>number of forecast time steps until next assimilation;
this can also be interpreted as
number of assimilation function calls
to perform a new assimilation</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>doexit</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>whether to exit forecasting (1 for exit)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>time</strong><span class="classifier">float</span></dt><dd><ul>
<li><p>current model (physical) time</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__distribute_state_pdaf</strong> (<em>Callable</em><em>[</em><em>dim_p:int</em><em>, </em><em>state_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>]</em>) – <p>distribute a state vector from pdaf to the model/any arrays</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>dim_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>PE-local state dimension</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>state_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>PE-local state vector</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>state_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>PE-local state vector</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__prepoststep_pdaf</strong> (<em>Callable</em><em>[</em><em>step:int</em><em>, </em><em>dim_p:int</em><em>, </em><em>dim_ens:int</em><em>, </em><em>dim_ens_l:int</em><em>, </em><em>dim_obs_p:int</em><em>, </em><em>state_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>uinv : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_ens-1</em><em>, </em><em>dim_ens-1</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>ens_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_p</em><em>, </em><em>dim_ens</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>flag:int</em><em>]</em>) – <p>Processing the ensemble when this function is called
by the first time in an online PDAF system
before distributing to the model to initialise the next forecast</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>step</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>current time step
(negative for call before analysis/preprocessing)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>PE-local state vector dimension</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_ens</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>number of ensemble members</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_ens_l</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>number of ensemble members run serially
on each model task</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_obs_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>PE-local dimension of observation vector</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>state_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>pe-local forecast/analysis state
(the array ‘state_p’ is generally not
initialised in the case of ESTKF/ETKF/EnKF/SEIK,
so it can be used freely here.)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>uinv</strong><span class="classifier">ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]</span></dt><dd><ul>
<li><p>Inverse of the transformation matrix in ETKF and ESKTF;
inverse of matrix formed by right singular vectors of error
covariance matrix of ensemble perturbations in SEIK/SEEK.
not used in EnKF.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>ens_p</strong><span class="classifier">ndarray[tuple[dim_p, dim_ens], np.float64]</span></dt><dd><ul>
<li><p>PE-local ensemble</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>flag</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>pdaf status flag</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>state_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>pe-local forecast/analysis state
(the array ‘state_p’ is generally not
initialised in the case of ESTKF/ETKF/EnKF/SEIK,
so it can be used freely here.)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>uinv</strong><span class="classifier">ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]</span></dt><dd><ul>
<li><p>Inverse of the transformation matrix in ETKF and ESKTF;
inverse of matrix formed by right singular vectors of error
covariance matrix of ensemble perturbations in SEIK/SEEK.
not used in EnKF.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>ens_p</strong><span class="classifier">ndarray[tuple[dim_p, dim_ens], np.float64]</span></dt><dd><ul>
<li><p>PE-local ensemble</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>flag</strong> (<em>int</em>) – Status flag</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>steps</strong> (<em>int</em>) – number of forecast time steps for next assimilation
The input value can be an arbitrary integer</p></li>
<li><p><strong>time</strong> (<em>float</em>) – current model time</p></li>
<li><p><strong>doexit</strong> (<em>int</em>) – Whether to exit from forecasts</p></li>
<li><p><strong>flag</strong> (<em>int</em>) – Status flag</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">pyPDAF</a></h1>



<p class="blurb">A Python interface to Parallel Data Assimilation Framework.</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=yumengch&repo=pyPDAF&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>






<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parallel.html">Parallelisation Strategy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../develop.html">Developer Guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../API.html">API</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../API.html#initialisation-and-finalisation">Initialisation and finalisation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../API.html#fully-parallel-da-algorithms"><cite>Fully parallel</cite> DA algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="../API.html#flexible-da-algorithms"><cite>Flexible</cite> DA algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="../API.html#omi-functions">OMI functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../API.html#local-module-functions">Local module functions</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../API.html#utilities">Utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../API.html#internal-matrix-operations">Internal matrix operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../API.html#internal-callback-functions">Internal callback functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../API_legacy.html">API (legacy)</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="../API.html">API</a><ul>
      <li>Previous: <a href="pyPDAF.PDAF.force_analysis.html" title="previous chapter">pyPDAF.PDAF.force_analysis</a></li>
      <li>Next: <a href="pyPDAF.PDAF.assimilate_prepost.html" title="next chapter">pyPDAF.PDAF.assimilate_prepost</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2022 University of Reading and National Centre for Earth Observation.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.1.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../_sources/_autosummary/pyPDAF.PDAF.get_state.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>