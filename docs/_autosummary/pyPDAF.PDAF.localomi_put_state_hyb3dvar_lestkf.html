<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf &#8212; pyPDAF  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=8e461078" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=27fed22d" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="pyPDAF.PDAF.omi_put_state_3dvar_nondiagR" href="pyPDAF.PDAF.omi_put_state_3dvar_nondiagR.html" />
    <link rel="prev" title="pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf" href="pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="pypdaf-pdaf-localomi-put-state-hyb3dvar-lestkf">
<h1>pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf<a class="headerlink" href="#pypdaf-pdaf-localomi-put-state-hyb3dvar-lestkf" title="Link to this heading">¶</a></h1>
<dl class="py function">
<dt class="sig sig-object py" id="pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf">
<span class="sig-prename descclassname"><span class="pre">pyPDAF.PDAF.</span></span><span class="sig-name descname"><span class="pre">localomi_put_state_hyb3dvar_lestkf</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf" title="Link to this definition">¶</a></dt>
<dd><p>Hybrid 3DEnVar for a single DA step using diagnoal observation error covariance matrix
without post-processing, distributing analysis, and setting next observation step.</p>
<p>Here, the background error covariance is hybridised by a static background error covariance,
and a flow-dependent background error covariance estimated from ensemble.</p>
<p>Compared to <a class="reference internal" href="pyPDAF.PDAF.localomi_assimilate_hyb3dvar_lestkf.html#pyPDAF.PDAF.localomi_assimilate_hyb3dvar_lestkf" title="pyPDAF.PDAF.localomi_assimilate_hyb3dvar_lestkf"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyPDAF.PDAF.localomi_assimilate_hyb3dvar_lestkf()</span></code></a>, this function has no <a class="reference internal" href="pyPDAF.PDAF.get_state.html#pyPDAF.PDAF.get_state" title="pyPDAF.PDAF.get_state"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_state()</span></code></a> call.
This means that the analysis is not post-processed, and distributed to the model forecast
by user-supplied functions. The next DA step will not be assigned by user-supplied functions as well.
This function is typically used when there are not enough CPUs to run the ensemble in parallel,
and some ensemble members have to be run serially. The <a class="reference internal" href="pyPDAF.PDAF.get_state.html#pyPDAF.PDAF.get_state" title="pyPDAF.PDAF.get_state"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyPDAF.PDAF.get_state()</span></code></a> function follows this
function call to ensure the sequential DA.</p>
<p>The 3DVar generates an ensemble mean and the ensemble perturbation is generated by
LESTKF in this implementation.
This function should be called at each model time step.</p>
<dl class="simple">
<dt>The user-supplied functions are executed in the following sequence:</dt><dd><ol class="arabic simple">
<li><p>py__collect_state_pdaf</p></li>
<li><p>py__prepoststep_state_pdaf</p></li>
<li><p>py__init_dim_obs_pdaf</p></li>
<li><p>py__obs_op_pdaf</p></li>
<li><dl class="simple">
<dt>The iterative optimisation:</dt><dd><ol class="arabic simple">
<li><p>py__cvt_pdaf</p></li>
<li><p>py__cvt_ens_pdaf</p></li>
<li><p>py__obs_op_lin_pdaf</p></li>
<li><p>py__obs_op_adj_pdaf</p></li>
<li><p>py__cvt_adj_pdaf</p></li>
<li><p>py__cvt_adj_ens_pdaf</p></li>
<li><p>core DA algorithm</p></li>
</ol>
</dd>
</dl>
</li>
<li><p>py__cvt_pdaf</p></li>
<li><p>py__cvt_ens_pdaf</p></li>
<li><dl class="simple">
<dt>Perform LESTKF:</dt><dd><ol class="arabic simple">
<li><p>py__init_n_domains_p_pdaf</p></li>
<li><p>py__init_dim_obs_pdaf</p></li>
<li><p>py__obs_op_pdaf
(for each ensemble member)</p></li>
<li><dl class="simple">
<dt>loop over each local domain:</dt><dd><ol class="arabic simple">
<li><p>py__init_dim_l_pdaf</p></li>
<li><p>py__init_dim_obs_l_pdaf</p></li>
<li><p>core DA algorithm</p></li>
</ol>
</dd>
</dl>
</li>
</ol>
</dd>
</dl>
</li>
</ol>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>py__collect_state_pdaf</strong> (<em>Callable</em><em>[</em><em>dim_p:int</em><em>, </em><em>state_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>]</em>) – <p>Routine to collect a state vector</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>dim_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>pe-local state dimension</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>state_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>local state vector</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>state_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>local state vector</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__init_dim_obs_pdaf</strong> (<em>Callable</em><em>[</em><em>step:int</em><em>, </em><em>dim_obs_p:int</em><em>]</em>) – <p>Initialize dimension of full observation vector</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>step</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>current time step</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_obs_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>dimension of observation vector</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>dim_obs_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>dimension of observation vector</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__obs_op_pdaf</strong> (<em>Callable</em><em>[</em><em>step:int</em><em>, </em><em>dim_p:int</em><em>, </em><em>dim_obs_p:int</em><em>, </em><em>state_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>m_state_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_obs_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>]</em>) – <p>Full observation operator</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>step</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Current time step</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Size of state vector (local part in case of parallel decomposed state)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_obs_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Size of observation vector</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>state_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>Model state vector</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>m_state_p</strong><span class="classifier">ndarray[tuple[dim_obs_p], np.float64]</span></dt><dd><ul>
<li><p>Observed state vector (i.e. the result after applying the observation operator to state_p)</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>m_state_p</strong><span class="classifier">ndarray[tuple[dim_obs_p], np.float64]</span></dt><dd><ul>
<li><p>Observed state vector (i.e. the result after applying the observation operator to state_p)</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__cvt_ens_pdaf</strong> (<em>Callable</em><em>[</em><em>iter:int</em><em>, </em><em>dim_p:int</em><em>, </em><em>dim_ens:int</em><em>, </em><em>dim_cvec_ens:int</em><em>, </em><em>ens_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_p</em><em>, </em><em>dim_ens</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>v_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_cvec_ens</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>Vv_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>]</em>) – <p>Apply control vector transform matrix to control vector</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>iter</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Iteration of optimization</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>PE-local dimension of state</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_ens</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Ensemble size</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_cvec_ens</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Dimension of control vector</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>ens_p</strong><span class="classifier">ndarray[tuple[dim_p, dim_ens], np.float64]</span></dt><dd><ul>
<li><p>PE-local ensemble</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>v_p</strong><span class="classifier">ndarray[tuple[dim_cvec_ens], np.float64]</span></dt><dd><ul>
<li><p>PE-local control vector</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>Vv_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>PE-local state increment</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>Vv_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>PE-local state increment</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__cvt_adj_ens_pdaf</strong> (<em>Callable</em><em>[</em><em>iter:int</em><em>, </em><em>dim_p:int</em><em>, </em><em>dim_ens:int</em><em>, </em><em>dim_cv_ens_p:int</em><em>, </em><em>ens_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_p</em><em>, </em><em>dim_ens</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>Vcv_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>cv_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_cv_ens_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>]</em>) – <p>Apply adjoint control vector transform matrix</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>iter</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Iteration of optimization</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>PE-local observation dimension</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_ens</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Ensemble size</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_cv_ens_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>PE-local dimension of control vector</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>ens_p</strong><span class="classifier">ndarray[tuple[dim_p, dim_ens], np.float64]</span></dt><dd><ul>
<li><p>PE-local ensemble</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>Vcv_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>PE-local input vector</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>cv_p</strong><span class="classifier">ndarray[tuple[dim_cv_ens_p], np.float64]</span></dt><dd><ul>
<li><p>PE-local result vector</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>cv_p</strong><span class="classifier">ndarray[tuple[dim_cv_ens_p], np.float64]</span></dt><dd><ul>
<li><p>PE-local result vector</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__cvt_pdaf</strong> (<em>Callable</em><em>[</em><em>iter:int</em><em>, </em><em>dim_p:int</em><em>, </em><em>dim_cvec:int</em><em>, </em><em>cv_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_cvec</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>Vv_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>]</em>) – <p>Apply control vector transform matrix to control vector</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>iter</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Iteration of optimization</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>PE-local observation dimension</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_cvec</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Dimension of control vector</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>cv_p</strong><span class="classifier">ndarray[tuple[dim_cvec], np.float64]</span></dt><dd><ul>
<li><p>PE-local control vector</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>Vv_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>PE-local result vector (state vector increment)</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>Vv_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>PE-local result vector (state vector increment)</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__cvt_adj_pdaf</strong> (<em>Callable</em><em>[</em><em>iter:int</em><em>, </em><em>dim_p:int</em><em>, </em><em>dim_cvec:int</em><em>, </em><em>Vcv_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>cv_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_cvec</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>]</em>) – <p>Apply adjoint control vector transform matrix</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>iter</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Iteration of optimization</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>PE-local observation dimension</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_cvec</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Dimension of control vector</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>Vcv_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>PE-local result vector (state vector increment)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>cv_p</strong><span class="classifier">ndarray[tuple[dim_cvec], np.float64]</span></dt><dd><ul>
<li><p>PE-local control vector</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>cv_p</strong><span class="classifier">ndarray[tuple[dim_cvec], np.float64]</span></dt><dd><ul>
<li><p>PE-local control vector</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__obs_op_lin_pdaf</strong> (<em>Callable</em><em>[</em><em>step:int</em><em>, </em><em>dim_p:int</em><em>, </em><em>dim_obs_p:int</em><em>, </em><em>state_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>m_state_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_obs_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>]</em>) – <p>Linearized observation operator</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>step</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Current time step</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>PE-local dimension of state</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_obs_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Dimension of observed state</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>state_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>PE-local model state</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>m_state_p</strong><span class="classifier">ndarray[tuple[dim_obs_p], np.float64]</span></dt><dd><ul>
<li><p>PE-local observed state</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>m_state_p</strong><span class="classifier">ndarray[tuple[dim_obs_p], np.float64]</span></dt><dd><ul>
<li><p>PE-local observed state</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__obs_op_adj_pdaf</strong> (<em>Callable</em><em>[</em><em>step:int</em><em>, </em><em>dim_p:int</em><em>, </em><em>dim_obs_p:int</em><em>, </em><em>state_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>m_state_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_obs_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>]</em>) – <p>Adjoint observation operator</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>step</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Current time step</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>PE-local dimension of state</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_obs_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>Dimension of observed state</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>state_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>PE-local model state</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>m_state_p</strong><span class="classifier">ndarray[tuple[dim_obs_p], np.float64]</span></dt><dd><ul>
<li><p>PE-local observed state</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>state_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>PE-local model state</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__init_n_domains_p_pdaf</strong> (<em>Callable</em><em>[</em><em>step:int</em><em>, </em><em>n_domains_p:int</em><em>]</em>) – <p>Provide number of local analysis domains</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>step</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>current time step</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>n_domains_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>pe-local number of analysis domains</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>n_domains_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>pe-local number of analysis domains</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__init_dim_l_pdaf</strong> (<em>Callable</em><em>[</em><em>step:int</em><em>, </em><em>domain_p:int</em><em>, </em><em>dim_l:int</em><em>]</em>) – <p>Init state dimension for local ana. domain</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>step</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>current time step</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>domain_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>current local analysis domain</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_l</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>local state dimension</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>dim_l</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>local state dimension</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__init_dim_obs_l_pdaf</strong> (<em>Callable</em><em>[</em><em>domain_p:int</em><em>, </em><em>step:int</em><em>, </em><em>dim_obs_f:int</em><em>, </em><em>dim_obs_l:int</em><em>]</em>) – <p>Initialize local dimimension of obs. vector</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>domain_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>index of current local analysis domain</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>step</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>current time step</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_obs_f</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>full dimension of observation vector</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_obs_l</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>local dimension of observation vector</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>dim_obs_l</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>local dimension of observation vector</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>py__prepoststep_pdaf</strong> (<em>Callable</em><em>[</em><em>step:int</em><em>, </em><em>dim_p:int</em><em>, </em><em>dim_ens:int</em><em>, </em><em>dim_ens_p:int</em><em>, </em><em>dim_obs_p:int</em><em>, </em><em>state_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_p</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>uinv : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_ens-1</em><em>, </em><em>dim_ens-1</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>ens_p : ndarray</em><em>[</em><em>tuple</em><em>[</em><em>dim_p</em><em>, </em><em>dim_ens</em><em>]</em><em>, </em><em>np.float64</em><em>]</em><em>, </em><em>flag:int</em><em>]</em>) – <p>User supplied pre/poststep routine</p>
<dl class="simple">
<dt><strong>Callback Parameters</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>step</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>current time step (negative for call after forecast)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>pe-local state dimension</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_ens</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>size of state ensemble</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_ens_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>pe-local size of ensemble</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dim_obs_p</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>pe-local dimension of observation vector</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>state_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>pe-local forecast/analysis state
(the array ‘state_p’ is not generally not
initialized in the case of seik.
it can be used freely here.)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>uinv</strong><span class="classifier">ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]</span></dt><dd><ul>
<li><p>inverse of matrix u</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>ens_p</strong><span class="classifier">ndarray[tuple[dim_p, dim_ens], np.float64]</span></dt><dd><ul>
<li><p>pe-local state ensemble</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>flag</strong><span class="classifier">int</span></dt><dd><ul>
<li><p>pdaf status flag</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Callback Returns</strong></dt><dd><ul>
<li><dl class="simple">
<dt><strong>state_p</strong><span class="classifier">ndarray[tuple[dim_p], np.float64]</span></dt><dd><ul>
<li><p>pe-local forecast/analysis state
(the array ‘state_p’ is not generally not
initialized in the case of seik.
it can be used freely here.)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>uinv</strong><span class="classifier">ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]</span></dt><dd><ul>
<li><p>inverse of matrix u</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>ens_p</strong><span class="classifier">ndarray[tuple[dim_p, dim_ens], np.float64]</span></dt><dd><ul>
<li><p>pe-local state ensemble</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>outflag</strong> (<em>int</em>) – Status flag</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>outflag</strong> – Status flag</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">pyPDAF</a></h1>



<p class="blurb">A Python interface to Parallel Data Assimilation Framework.</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=yumengch&repo=pyPDAF&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>






<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parallel.html">Parallelisation Strategy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Manual.html">Userguide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../implementation.html">Design Details</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../API.html">API</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../API.html#initialisation-and-finalisation">Initialisation and finalisation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../API.html#fully-parallel-da-algorithms"><cite>Fully parallel</cite> DA algorithms</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../API.html#flexible-da-algorithms"><cite>Flexible</cite> DA algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="../API.html#omi-functions">OMI functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../API.html#local-module-functions">Local module functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../API.html#utilities">Utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../API.html#internal-matrix-operations">Internal matrix operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../API.html#internal-callback-functions">Internal callback functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../API_legacy.html">API (legacy)</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="../API.html">API</a><ul>
      <li>Previous: <a href="pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf.html" title="previous chapter">pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf</a></li>
      <li>Next: <a href="pyPDAF.PDAF.omi_put_state_3dvar_nondiagR.html" title="next chapter">pyPDAF.PDAF.omi_put_state_3dvar_nondiagR</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2022 University of Reading and National Centre for Earth Observation.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.0.2</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../_sources/_autosummary/pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>