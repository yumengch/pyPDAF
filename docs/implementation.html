<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Design Details &#8212; pyPDAF  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css?v=c058f7c8" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=27fed22d" />
    <script src="_static/documentation_options.js?v=5929fcd5"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="API reference" href="API.html" />
    <link rel="prev" title="Userguide" href="Manual.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="design-details">
<h1>Design Details<a class="headerlink" href="#design-details" title="Link to this heading">¶</a></h1>
<p>The interface makes use of the <code class="docutils literal notranslate"><span class="pre">iso_c_binding</span></code> introduced in Fortran 2003 standard. This allows interoperability between C and Fortran. Meanwhile, Cython can call C functions based on given C declarations. Hence, the Fortran subroutines can be called as a C function based on its declarations in Cython.</p>
<p>One of the biggest benefit of using Cython instead of f2py is that C declarations conform to C standard and allow us to avoid undefined behaviors.</p>
<section id="pypdaf-wrapper-to-fortran-call">
<h2>pyPDAF wrapper to Fortran call<a class="headerlink" href="#pypdaf-wrapper-to-fortran-call" title="Link to this heading">¶</a></h2>
<p>In <code class="docutils literal notranslate"><span class="pre">pyPDAF.PDAF</span></code>, <code class="docutils literal notranslate"><span class="pre">.pxd</span></code> files define Fortran subroutines as external C functions. For example, the following Fortran subroutine interface:</p>
<div class="highlight-Fortran notranslate"><div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">c__PDAF_get_state</span><span class="p">(</span><span class="n">steps</span><span class="p">,</span><span class="w"> </span><span class="nb">time</span><span class="p">,</span><span class="w"> </span><span class="n">doexit</span><span class="p">,</span><span class="w"> </span><span class="p">&amp;</span>
<span class="w">                             </span><span class="n">U_next_observation</span><span class="p">,</span><span class="w"> </span><span class="p">&amp;</span>
<span class="w">                             </span><span class="n">U_distribute_state</span><span class="p">,</span><span class="w"> </span><span class="p">&amp;</span>
<span class="w">                             </span><span class="n">U_prepoststep</span><span class="p">,</span><span class="w"> </span><span class="n">flag</span><span class="p">)</span><span class="w"> </span><span class="k">bind</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="w">      </span><span class="c">! Flag and number of time steps</span>
<span class="w">      </span><span class="kt">INTEGER</span><span class="p">(</span><span class="kt">c_int</span><span class="p">),</span><span class="w"> </span><span class="k">INTENT</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">steps</span>
<span class="w">      </span><span class="c">! current model time</span>
<span class="w">      </span><span class="kt">REAL</span><span class="p">(</span><span class="kt">c_double</span><span class="p">),</span><span class="w"> </span><span class="k">INTENT</span><span class="p">(</span><span class="n">out</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="nb">time</span>
<span class="w">      </span><span class="c">! Whether to exit from forecasts</span>
<span class="w">      </span><span class="kt">INTEGER</span><span class="p">(</span><span class="kt">c_int</span><span class="p">),</span><span class="w"> </span><span class="k">INTENT</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">doexit</span>
<span class="w">      </span><span class="c">! Status flag</span>
<span class="w">      </span><span class="kt">INTEGER</span><span class="p">(</span><span class="kt">c_int</span><span class="p">),</span><span class="w"> </span><span class="k">INTENT</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">flag</span>
<span class="w">      </span><span class="c">! Provide time step and time of next observation</span>
<span class="w">      </span><span class="k">procedure</span><span class="p">(</span><span class="n">c__next_observation_pdaf</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">U_next_observation</span><span class="w"> </span>
<span class="w">      </span><span class="c">! Routine to distribute a state vector</span>
<span class="w">      </span><span class="k">procedure</span><span class="p">(</span><span class="n">c__distribute_state_pdaf</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">U_distribute_state</span><span class="w"> </span>
<span class="w">      </span><span class="c">! User supplied pre/poststep routine</span>
<span class="w">      </span><span class="k">procedure</span><span class="p">(</span><span class="n">c__prepoststep_pdaf</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">U_prepoststep</span>
<span class="k">end subroutine </span><span class="n">c__PDAF_get_state</span>
</pre></div>
</div>
<p>can be translated into:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">cdef</span><span class="w"> </span><span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">c__pdaf_get_state</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">steps</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">*</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">doexit</span><span class="p">,</span>
<span class="w">                                    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">c__next_observation_pdaf</span><span class="p">)(</span><span class="kt">int</span><span class="o">*</span><span class="p">,</span><span class="w">   </span><span class="kt">int</span><span class="o">*</span><span class="p">,</span>
<span class="w">                                                                     </span><span class="kt">int</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">*</span><span class="p">),</span>
<span class="w">                                    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">c__distribute_state_pdaf</span><span class="p">)(</span><span class="kt">int</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">*</span><span class="p">),</span>
<span class="w">                                    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">c__prepoststep_pdaf</span><span class="p">)(</span><span class="kt">int</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="p">,</span>
<span class="w">                                                                </span><span class="kt">int</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">*</span><span class="p">,</span>
<span class="w">                                                                </span><span class="kt">double</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="p">),</span>
<span class="w">                                    </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">flag</span><span class="p">);</span>
</pre></div>
</div>
<p>Here, all arguments in the C declaration are pointers because Fortran is by default pass by reference, and user-defined procedures are provided with explicit interface in the C declaration. This is a good benefits compared to the f2py approach, where more tuning is required in the signature file to enable user-supplied external functions.</p>
<p>To provide a more Pythonic interface, the above C call is wrapped by a Python definition:</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">get_state</span> <span class="p">(</span><span class="nb">int</span> <span class="n">steps</span><span class="p">,</span> <span class="nb">int</span> <span class="n">doexit</span><span class="p">,</span>
           <span class="n">py__next_observation_pdaf</span><span class="p">,</span>
           <span class="n">py__distribute_state_pdaf</span><span class="p">,</span>
           <span class="n">py__prepoststep_pdaf</span><span class="p">,</span>
           <span class="nb">int</span> <span class="n">flag</span>
          <span class="p">)</span>
</pre></div>
</div>
<p>such that the user can have:</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pyPDAF.PDAF</span> <span class="k">as</span> <span class="nn">PDAF</span>
<span class="n">PDAF</span><span class="o">.</span><span class="n">get_state</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="treatment-of-arguments">
<h2>Treatment of arguments<a class="headerlink" href="#treatment-of-arguments" title="Link to this heading">¶</a></h2>
<p>There are input and output arguments in Fortran subroutines. In <code class="docutils literal notranslate"><span class="pre">pyPDAF</span></code>, input arguments with <code class="docutils literal notranslate"><span class="pre">intent(in)</span></code> or <code class="docutils literal notranslate"><span class="pre">intent(inout)</span></code> are declared in Python function arguments, and arguments with <code class="docutils literal notranslate"><span class="pre">intent(inout)</span></code> or <code class="docutils literal notranslate"><span class="pre">intent(out)</span></code> are treated as returned values. For example, <code class="docutils literal notranslate"><span class="pre">double*</span> <span class="pre">time</span></code> is not present in the <code class="docutils literal notranslate"><span class="pre">get_state</span></code> Python function argument as it is an <code class="docutils literal notranslate"><span class="pre">intent(out)</span></code> argument. They are defined as <code class="docutils literal notranslate"><span class="pre">cdef</span> <span class="pre">double</span> <span class="pre">time</span></code> before calling <code class="docutils literal notranslate"><span class="pre">c__pdaf_get_state</span></code>.</p>
<p>For some detailed explanation of the following sections, it is recommended to read Cython documentation for <a class="reference external" href="https://cython.readthedocs.io/en/stable/src/userguide/memoryviews.html"> memory view</a>, and <a class="reference external" href="https://cython.readthedocs.io/en/stable/src/userguide/language_basics.html#differences-between-c-and-cython-expressions">syntax</a>.</p>
<section id="treatment-of-scalar-arguments">
<h3>Treatment of scalar arguments<a class="headerlink" href="#treatment-of-scalar-arguments" title="Link to this heading">¶</a></h3>
<p>In Cython, <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">steps</span></code> declares the argument as integer value, which can be directly passed to C function calls by accesing its reference using <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>.</p>
</section>
<section id="treatment-of-array-arguments">
<h3>Treatment of array arguments<a class="headerlink" href="#treatment-of-array-arguments" title="Link to this heading">¶</a></h3>
<p>In <code class="docutils literal notranslate"><span class="pre">pyPDAF</span></code>, all input arrays are numpy arrays. These arrays have to be convert to memoryview in Cython and then passed their reference to Fortran regardless of the shape of the array. To avoid problems with the different treatment of C ordering and Fortran ordering of multidimensional arrays, they’re all raveled using Fortran order, e.g. <code class="docutils literal notranslate"><span class="pre">np.ravel(a,</span> <span class="pre">order='F')</span></code>.</p>
<p>The same applies to the returned array, where we reshape the memoryview back to its original shape using <code class="docutils literal notranslate"><span class="pre">np.reshape(a,</span> <span class="pre">order='F')</span></code>.</p>
</section>
<section id="treatment-of-procedure-arguments-user-supplied-routines">
<h3>Treatment of procedure arguments (user-supplied routines)<a class="headerlink" href="#treatment-of-procedure-arguments-user-supplied-routines" title="Link to this heading">¶</a></h3>
<p>One of the most important aspects of PDAF is the user-supplied routines. This provides the flexibility to different models and observations. In <code class="docutils literal notranslate"><span class="pre">pyPDAF.UserFunc</span></code>, C functions are defined and declared with dummy Python functions. For example,</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">cdef</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">c__init_ens_pdaf</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">filtertype</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">dim_p</span><span class="p">,</span>
<span class="w">                            </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">dim_ens</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">*</span><span class="w"> </span><span class="n">state_p</span><span class="p">,</span>
<span class="w">                            </span><span class="kt">double</span><span class="o">*</span><span class="w"> </span><span class="n">uinv</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">*</span><span class="w"> </span><span class="n">ens_p</span><span class="p">,</span>
<span class="w">                            </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">flag</span>
<span class="w">                           </span><span class="p">);</span>
</pre></div>
</div>
<p>the above C function calls the dummy Python function defined as:</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">py__init_ens_pdaf</span><span class="p">(</span><span class="n">filtertype</span><span class="p">,</span> <span class="n">dim_p</span><span class="p">,</span> <span class="n">dim_ens</span><span class="p">,</span> <span class="n">state_p</span><span class="p">,</span> <span class="n">uinv</span><span class="p">,</span> <span class="n">ens_p</span><span class="p">,</span> <span class="n">flag</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;...Wrong py__init_ens_pdaf is called!!!...&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Hence, <code class="docutils literal notranslate"><span class="pre">pyPDAF</span></code> can raise an error if required user-supplied function is not given. In <code class="docutils literal notranslate"><span class="pre">pyPDAF.PDAF</span></code>, the user-supplied function has to be given to <code class="docutils literal notranslate"><span class="pre">pyPDAF.UserFunc</span></code>. Taking the previous example for <code class="docutils literal notranslate"><span class="pre">c__PDAF_get_state</span></code>, we have the following treatment:</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pyPDAF.UserFunc</span> <span class="k">as</span> <span class="nn">PDAFcython</span>
<span class="n">cimport</span> <span class="n">pyPDAF</span><span class="o">.</span><span class="n">UserFunc</span> <span class="k">as</span> <span class="n">c__PDAFcython</span>
<span class="c1"># giving user-supplied functions to UserFunc</span>
<span class="n">PDAFcython</span><span class="o">.</span><span class="n">py__next_observation_pdaf</span> <span class="o">=</span> <span class="n">py__next_observation_pdaf</span>
<span class="n">PDAFcython</span><span class="o">.</span><span class="n">py__distribute_state_pdaf</span> <span class="o">=</span> <span class="n">py__distribute_state_pdaf</span>
<span class="n">PDAFcython</span><span class="o">.</span><span class="n">py__prepoststep_pdaf</span> <span class="o">=</span> <span class="n">py__prepoststep_pdaf</span>
<span class="c1"># call the actual functions</span>
<span class="n">c__pdaf_get_state</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">steps</span><span class="p">,</span>
                   <span class="o">&amp;</span><span class="n">time</span><span class="p">,</span>
                   <span class="o">&amp;</span><span class="n">doexit</span><span class="p">,</span>
                   <span class="n">c__PDAFcython</span><span class="o">.</span><span class="n">c__next_observation_pdaf</span><span class="p">,</span>
                   <span class="n">c__PDAFcython</span><span class="o">.</span><span class="n">c__distribute_state_pdaf</span><span class="p">,</span>
                   <span class="n">c__PDAFcython</span><span class="o">.</span><span class="n">c__prepoststep_pdaf</span><span class="p">,</span>
                   <span class="o">&amp;</span><span class="n">flag</span>
                  <span class="p">)</span>
</pre></div>
</div>
<section id="treatment-of-array-input-in-user-supplied-routines">
<h4>Treatment of array input in user-supplied routines<a class="headerlink" href="#treatment-of-array-input-in-user-supplied-routines" title="Link to this heading">¶</a></h4>
<p>Because user-supplied routines are given as C pointers, we need to translate them into numpy array for Python function in a similar manner as <a class="reference internal" href="#treatment-of-array-arguments"><span class="std std-ref">Treatment of array arguments</span></a>, e.g. <code class="docutils literal notranslate"><span class="pre">state_p_np</span> <span class="pre">=</span> <span class="pre">np.asarray(&lt;double[:np.prod((dim_p[0]))]&gt;</span> <span class="pre">state_p).reshape((dim_p[0]),</span> <span class="pre">order='F')</span></code>.</p>
<section id="caveat">
<h5>Caveat<a class="headerlink" href="#caveat" title="Link to this heading">¶</a></h5>
<ol class="arabic simple">
<li><p>Fortran subroutines use pass by reference  by default</p></li>
<li><p>Python always pass/assignment by reference
The above two points can lead to undefined behavior. For example, in the user-supplied routines, we have Fortran interface:</p></li>
</ol>
<div class="highlight-Fortran notranslate"><div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">c__collect_state_pdaf</span><span class="p">(</span><span class="n">dim_p</span><span class="p">,</span><span class="w"> </span><span class="n">state_p</span><span class="p">)</span><span class="w"> </span><span class="k">bind</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="w">  </span><span class="k">use </span><span class="nb">iso_c_binding</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="kt">c_double</span><span class="p">,</span><span class="w"> </span><span class="kt">c_int</span>
<span class="kt">  </span><span class="k">implicit none</span>
<span class="w">  </span><span class="c">! pe-local state dimension</span>
<span class="w">  </span><span class="kt">integer</span><span class="p">(</span><span class="kt">c_int</span><span class="p">),</span><span class="w"> </span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">dim_p</span>
<span class="w">  </span><span class="c">! local state vector</span>
<span class="w">  </span><span class="kt">real</span><span class="p">(</span><span class="kt">c_double</span><span class="p">),</span><span class="w"> </span><span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">state_p</span><span class="p">(</span><span class="n">dim_p</span><span class="p">)</span>
<span class="k">end subroutine </span><span class="n">c__collect_state_pdaf</span>
</pre></div>
</div>
<p>If we provide the following Python routine:</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">collect_state_pdaf</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">assim_dim</span><span class="p">,</span> <span class="n">dim_p</span><span class="p">,</span> <span class="n">state_p</span><span class="p">):</span>
    <span class="n">state_p</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">field_p</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">assim_dim</span><span class="o">.</span><span class="n">dim_state_p</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">state_p</span>
</pre></div>
</div>
<p>The Python function changes the reference of <code class="docutils literal notranslate"><span class="pre">state_p</span></code> as the <code class="docutils literal notranslate"><span class="pre">reshape</span></code> method generates a new numpy array instance. Hence, it is necessary to add a layer of safety in <code class="docutils literal notranslate"><span class="pre">pyPDAF.UserFunc</span></code>, where we pass the return value to the original input numpy array. We further safeguard this behavor with an assertion.</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">state_p_np_tmp</span> <span class="o">=</span> <span class="n">py__collect_state_pdaf</span><span class="p">(</span><span class="n">dim_p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">state_p_np</span><span class="p">)</span>
<span class="n">state_p_np</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">state_p_np_tmp</span><span class="p">[:]</span>
<span class="n">cdef</span> <span class="n">double</span><span class="p">[::</span><span class="mi">1</span><span class="p">]</span> <span class="n">state_p_view</span> <span class="o">=</span> <span class="n">state_p_np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">state_p</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">state_p_view</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;reference (memory address) of state_p has changed in c__collect_state_pdaf.&#39;</span>
</pre></div>
</div>
</section>
</section>
</section>
</section>
<section id="note">
<h2>Note<a class="headerlink" href="#note" title="Link to this heading">¶</a></h2>
<p>In <code class="docutils literal notranslate"><span class="pre">pyPDAF/fortran</span></code>, <code class="docutils literal notranslate"><span class="pre">pyPDAF</span></code> provides <code class="docutils literal notranslate"><span class="pre">bind(C)</span></code> wrapper for common PDAF public subroutines with <code class="docutils literal notranslate"><span class="pre">iso_c_binding</span></code> arguments. Some subroutine uses assumed size arrays. The interoperability with C is recently supported in Fortran 2018 standard via <code class="docutils literal notranslate"><span class="pre">ISO_Fortran_binding.h</span></code> in C. To avoid unexpected issues for these new features, the dimension sizes are still given explicitly in the Fortran wrapper.</p>
<p>The same issue applies to allocatable array in derived types in PDAFomi feature, where <code class="docutils literal notranslate"><span class="pre">obs_f</span></code> and <code class="docutils literal notranslate"><span class="pre">obs_l</span></code> are used. Hence, an array of the derived type are defined in the fortran wrapper with setters for many class members. These can be changed later when Fortran 2018 standard is better supported.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">pyPDAF</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="Manual.html">Userguide</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Design Details</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#pypdaf-wrapper-to-fortran-call">pyPDAF wrapper to Fortran call</a></li>
<li class="toctree-l2"><a class="reference internal" href="#treatment-of-arguments">Treatment of arguments</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#treatment-of-scalar-arguments">Treatment of scalar arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="#treatment-of-array-arguments">Treatment of array arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="#treatment-of-procedure-arguments-user-supplied-routines">Treatment of procedure arguments (user-supplied routines)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#note">Note</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="API.html">API reference</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="Manual.html" title="previous chapter">Userguide</a></li>
      <li>Next: <a href="API.html" title="next chapter">API reference</a></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2022 University of Reading and National Centre for Earth Observation.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.0.2</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="_sources/implementation.md.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>