import sys
import numpy as np
from . cimport UserFunc as c__PDAFcython

try:
    import mpi4py
    mpi4py.rc.initialize = False
except ImportError:
    pass

# Global error handler
def global_except_hook(exctype, value, traceback):
    from traceback import print_exception
    try:
        import mpi4py.MPI

        if mpi4py.MPI.Is_initialized():
            try:
                sys.stderr.write("Uncaught exception was detected on rank {}. \n".format(
                    mpi4py.MPI.COMM_WORLD.Get_rank()))

                print_exception(exctype, value, traceback)
                sys.stderr.write("\n")
                sys.stderr.flush()
            finally:
                try:
                    mpi4py.MPI.COMM_WORLD.Abort(1)
                except Exception as e:
                    sys.stderr.write("MPI Abort failed, this process will hang.\n")
                    sys.stderr.flush()
                    raise e
        else:
            sys.__excepthook__(exctype, value, traceback)
    except ImportError:
        sys.__excepthook__(exctype, value, traceback)

sys.excepthook = global_except_hook


def assimilate_3dvar (py__collect_state_pdaf,
                      py__distribute_state_pdaf,
                      py__init_dim_obs_pdaf,
                      py__obs_op_pdaf,
                      py__init_obs_pdaf,
                      py__prodRinvA_pdaf,
                      py__cvt_pdaf,
                      py__cvt_adj_pdaf,
                      py__obs_op_lin_pdaf,
                      py__obs_op_adj_pdaf,
                      py__prepoststep_pdaf,
                      py__next_observation_pdaf
                     ):
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency.I.e., `pyPDAF.PDAF.omi_assimilate_3dvar` or `pyPDAF.PDAF.omi_assimilate_3dvar_nondiagR`. 
    Using 3DVar for DA without OMI. This is a deterministic filtering scheme. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.put_state_3dvar` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    5. py__init_obs_pdaf
    Starting the iterative optimisation:
    6. py__cvt_pdaf
    7. py__obs_op_lin_pdaf
    8. py__prodRinvA_pdaf
    9. py__obs_op_adj_pdaf
    10. py__cvt_adj_pdaf
    11. core DA algorithm
    After the iterations: 
    12. py__cvt_pdaf
    13. py__prepoststep_state_pdaf
    14. py__distribute_state_pdaf
    15. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], A_p : ndarray[tuple[dim_obs_p, rank], np.float64], C_p : ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p : ndarray[tuple[dim_cvec], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time


    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.prodRinvA_pdaf = <void*>py__prodRinvA_pdaf
    c__PDAFcython.cvt_pdaf = <void*>py__cvt_pdaf
    c__PDAFcython.cvt_adj_pdaf = <void*>py__cvt_adj_pdaf
    c__PDAFcython.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    c__PDAFcython.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    cdef int outflag

    c__pdaf_assimilate_3dvar (c__PDAFcython.c__collect_state_pdaf,
                              c__PDAFcython.c__distribute_state_pdaf,
                              c__PDAFcython.c__init_dim_obs_pdaf,
                              c__PDAFcython.c__obs_op_pdaf,
                              c__PDAFcython.c__init_obs_pdaf,
                              c__PDAFcython.c__prodRinvA_pdaf,
                              c__PDAFcython.c__cvt_pdaf,
                              c__PDAFcython.c__cvt_adj_pdaf,
                              c__PDAFcython.c__obs_op_lin_pdaf,
                              c__PDAFcython.c__obs_op_adj_pdaf,
                              c__PDAFcython.c__prepoststep_pdaf,
                              c__PDAFcython.c__next_observation_pdaf,
                              &outflag
                             )

    return outflag

def assimilate_en3dvar_estkf (py__collect_state_pdaf,
                              py__distribute_state_pdaf,
                              py__init_dim_obs_pdaf,
                              py__obs_op_pdaf,
                              py__init_obs_pdaf,
                              py__prodRinvA_pdaf,
                              py__cvt_ens_pdaf,
                              py__cvt_adj_ens_pdaf,
                              py__obs_op_lin_pdaf,
                              py__obs_op_adj_pdaf,
                              py__init_obsvar_pdaf,
                              py__prepoststep_pdaf,
                              py__next_observation_pdaf
                             ):
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.omi_assimilate_en3dvar_estkf` or `pyPDAF.PDAF.omi_assimilate_en3dvar_estkf_nondiagR`. 
    Using 3DEnVar for DA without OMI. The background error covariance matrix is estimated by ensemble. The 3DEnVar only calculates the analysis of the ensemble mean. An ESTKF is used to generate ensemble perturbations. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.put_state_en3dvar_estkf` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    5. py__init_obs_pdaf
    Starting the iterative optimisation:
    6. py__cvt_ens_pdaf
    7. py__obs_op_lin_pdaf
    8. py__prodRinvA_pdaf
    9. py__obs_op_adj_pdaf
    10. py__cvt_adj_ens_pdaf
    11. core 3DEnVar algorithm
    After the iterations: 
    12. py__cvt_ens_pdaf
    Perform ESTKF: 13. py__init_dim_obs_pdaf
    14. py__obs_op_pdaf (for ensemble mean)
    15. py__init_obs_pdaf
    16. py__obs_op_pdaf (for each ensemble member)
    17. py__init_obsvar_pdaf (only relevant for adaptive forgetting factor schemes)
    18. py__prodRinvA_pdaf
    19. core ESTKF algorithm
    20. py__prepoststep_state_pdaf
    21. py__distribute_state_pdaf
    22. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], A_p : ndarray[tuple[dim_obs_p, rank], np.float64], C_p : ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], v_p : ndarray[tuple[dim_cvec_ens], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_ens** : int

            * Ensemble size

        * **dim_cvec_ens** : int

            * Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_ens** : int

            * Ensemble size

        * **dim_cv_ens_p** : int

            * PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **meanvar** : float

            * Mean observation error variance

        **Callback Returns**

        * **meanvar** : float

            * Mean observation error variance

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time


    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.prodRinvA_pdaf = <void*>py__prodRinvA_pdaf
    c__PDAFcython.cvt_ens_pdaf = <void*>py__cvt_ens_pdaf
    c__PDAFcython.cvt_adj_ens_pdaf = <void*>py__cvt_adj_ens_pdaf
    c__PDAFcython.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    c__PDAFcython.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    c__PDAFcython.init_obsvar_pdaf = <void*>py__init_obsvar_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    cdef int outflag

    c__pdaf_assimilate_en3dvar_estkf (c__PDAFcython.c__collect_state_pdaf,
                                      c__PDAFcython.c__distribute_state_pdaf,
                                      c__PDAFcython.c__init_dim_obs_pdaf,
                                      c__PDAFcython.c__obs_op_pdaf,
                                      c__PDAFcython.c__init_obs_pdaf,
                                      c__PDAFcython.c__prodRinvA_pdaf,
                                      c__PDAFcython.c__cvt_ens_pdaf,
                                      c__PDAFcython.c__cvt_adj_ens_pdaf,
                                      c__PDAFcython.c__obs_op_lin_pdaf,
                                      c__PDAFcython.c__obs_op_adj_pdaf,
                                      c__PDAFcython.c__init_obsvar_pdaf,
                                      c__PDAFcython.c__prepoststep_pdaf,
                                      c__PDAFcython.c__next_observation_pdaf,
                                      &outflag
                                     )

    return outflag

def assimilate_en3dvar_lestkf (py__collect_state_pdaf,
                               py__distribute_state_pdaf,
                               py__init_dim_obs_pdaf,
                               py__obs_op_pdaf,
                               py__init_obs_pdaf,
                               py__prodRinvA_pdaf,
                               py__cvt_ens_pdaf,
                               py__cvt_adj_ens_pdaf,
                               py__obs_op_lin_pdaf,
                               py__obs_op_adj_pdaf,
                               py__init_dim_obs_f_pdaf,
                               py__obs_op_f_pdaf,
                               py__init_obs_f_pdaf,
                               py__init_obs_l_pdaf,
                               py__prodRinvA_l_pdaf,
                               py__init_n_domains_p_pdaf,
                               py__init_dim_l_pdaf,
                               py__init_dim_obs_l_pdaf,
                               py__g2l_state_pdaf,
                               py__l2g_state_pdaf,
                               py__g2l_obs_pdaf,
                               py__init_obsvar_pdaf,
                               py__init_obsvar_l_pdaf,
                               py__prepoststep_pdaf,
                               py__next_observation_pdaf,
                               int outflag
                              ):
    """It is recommended to use local module with OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_assimilate_en3dvar_lestkf` or `pyPDAF.PDAF.localomi_assimilate_en3dvar_lestkf_nondiagR`. 
    Using 3DEnVar for DA without OMI. The background error covariance matrix is estimated by ensemble. The 3DEnVar only calculates the analysis of the ensemble mean. An LESTKF is used to generate ensemble perturbations. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.put_state_en3dvar_lestkf` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    5. py__init_obs_pdaf
    Starting the iterative optimisation:
    6. py__cvt_ens_pdaf
    7. py__obs_op_lin_pdaf
    8. py__prodRinvA_pdaf
    9. py__obs_op_adj_pdaf
    10. py__cvt_adj_ens_pdaf
    11. core DA algorithm
    After the iterations: 
    12. py__cvt_ens_pdaf
    Perform LESTKF: 
    13. py__init_n_domains_p_pdaf
    14. py__init_dim_obs_pdaf
    15. py__obs_op_pdaf (for each ensemble member
    16. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init))(if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init)(if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init))(if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init))(if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init)(if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init
    17. py__init_obsvar_pdaf (if global adaptive forgetting factor is used)
    loop over each local domain:
    18. py__init_dim_l_pdaf
    19. py__init_dim_obs_l_pdaf
    20. py__g2l_state_pdaf
    21. py__g2l_obs_pdaf (localise mean ensemble in observation space)
    22. py__init_obs_l_pdaf
    23. py__g2l_obs_pdaf (localise each ensemble member in observation space)
    24. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used)(only called if local adaptive forgetting factor (type_forget=2
    25. py__prodRinvA_l_pdaf
    26. core DA algorithm
    27. py__l2g_state_pdaf
    28. py__prepoststep_state_pdaf
    29. py__distribute_state_pdaf
    30. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], A_p : ndarray[tuple[dim_obs_p, rank], np.float64], C_p : ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], v_p : ndarray[tuple[dim_cvec_ens], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_ens** : int

            * Ensemble size

        * **dim_cvec_ens** : int

            * Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_ens** : int

            * Ensemble size

        * **dim_cv_ens_p** : int

            * PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Acts as the full observation operator on some state vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f : ndarray[tuple[dim_obs_f], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_f** : int

            * Size of the full observation vector

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of observations

        **Callback Returns**

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of observations

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l : ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], A_l : ndarray[tuple[dim_obs_l, rank], np.float64], C_l : ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p : ndarray[tuple[dim_p], np.float64], dim_l:int, state_l : ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l : ndarray[tuple[dim_l], np.float64], dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f : ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l : ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_f** : int

            * Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            * Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * **dim_p** : int

            * Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * **dim_l** : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **meanvar** : float

            * Mean observation error variance

        **Callback Returns**

        * **meanvar** : float

            * Mean observation error variance

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * **dim_obs_p** : int

            * Dimension of local observation vector

        * **meanvar_l** : float

            * Mean local observation error variance

        **Callback Returns**

        * **meanvar_l** : float

            * Mean local observation error variance

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.prodRinvA_pdaf = <void*>py__prodRinvA_pdaf
    c__PDAFcython.cvt_ens_pdaf = <void*>py__cvt_ens_pdaf
    c__PDAFcython.cvt_adj_ens_pdaf = <void*>py__cvt_adj_ens_pdaf
    c__PDAFcython.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    c__PDAFcython.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    c__PDAFcython.init_dim_obs_f_pdaf = <void*>py__init_dim_obs_f_pdaf
    c__PDAFcython.obs_op_f_pdaf = <void*>py__obs_op_f_pdaf
    c__PDAFcython.init_obs_f_pdaf = <void*>py__init_obs_f_pdaf
    c__PDAFcython.init_obs_l_pdaf = <void*>py__init_obs_l_pdaf
    c__PDAFcython.prodRinvA_l_pdaf = <void*>py__prodRinvA_l_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.g2l_state_pdaf = <void*>py__g2l_state_pdaf
    c__PDAFcython.l2g_state_pdaf = <void*>py__l2g_state_pdaf
    c__PDAFcython.g2l_obs_pdaf = <void*>py__g2l_obs_pdaf
    c__PDAFcython.init_obsvar_pdaf = <void*>py__init_obsvar_pdaf
    c__PDAFcython.init_obsvar_l_pdaf = <void*>py__init_obsvar_l_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    c__pdaf_assimilate_en3dvar_lestkf (c__PDAFcython.c__collect_state_pdaf,
                                       c__PDAFcython.c__distribute_state_pdaf,
                                       c__PDAFcython.c__init_dim_obs_pdaf,
                                       c__PDAFcython.c__obs_op_pdaf,
                                       c__PDAFcython.c__init_obs_pdaf,
                                       c__PDAFcython.c__prodRinvA_pdaf,
                                       c__PDAFcython.c__cvt_ens_pdaf,
                                       c__PDAFcython.c__cvt_adj_ens_pdaf,
                                       c__PDAFcython.c__obs_op_lin_pdaf,
                                       c__PDAFcython.c__obs_op_adj_pdaf,
                                       c__PDAFcython.c__init_dim_obs_f_pdaf,
                                       c__PDAFcython.c__obs_op_f_pdaf,
                                       c__PDAFcython.c__init_obs_f_pdaf,
                                       c__PDAFcython.c__init_obs_l_pdaf,
                                       c__PDAFcython.c__prodRinvA_l_pdaf,
                                       c__PDAFcython.c__init_n_domains_p_pdaf,
                                       c__PDAFcython.c__init_dim_l_pdaf,
                                       c__PDAFcython.c__init_dim_obs_l_pdaf,
                                       c__PDAFcython.c__g2l_state_pdaf,
                                       c__PDAFcython.c__l2g_state_pdaf,
                                       c__PDAFcython.c__g2l_obs_pdaf,
                                       c__PDAFcython.c__init_obsvar_pdaf,
                                       c__PDAFcython.c__init_obsvar_l_pdaf,
                                       c__PDAFcython.c__prepoststep_pdaf,
                                       c__PDAFcython.c__next_observation_pdaf,
                                       &outflag
                                      )

    return outflag

def assimilate_enkf (py__collect_state_pdaf,
                     py__distribute_state_pdaf,
                     py__init_dim_obs_pdaf,
                     py__obs_op_pdaf,
                     py__init_obs_pdaf,
                     py__prepoststep_pdaf,
                     py__add_obs_err_pdaf,
                     py__init_obs_covar_pdaf,
                     py__next_observation_pdaf
                    ):
    """It is recommended to use :func:`pyPDAF.PDAF.omi_assimilate_global`
    or :func:`pyPDAF.PDAF.omi_assimilate_enkf_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions and improved efficiency.

    Using stochastic EnKF (ensemble Kalman filter) [1]_ for DA without OMI. This function should be called at each model time step. 

    The function is a combination of :func:`pyPDAF.PDAF.put_state_enkf` and :func:`pyPDAF.PDAF.get_state`.

    This function executes the user-supplied functions in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf (for ensemble mean)
        5. py__add_obs_err_pdaf
        6. py__init_obs_pdaf
        7. py__init_obscovar_pdaf
        8. py__obs_op_pdaf (for each ensemble member)
        9. core DA algorithm
        10. py__prepoststep_state_pdaf
        11. py__distribute_state_pdaf
        12. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by :func:`pyPDAF.PDAF.omi_assimilate_global`
       and :func:`pyPDAF.PDAF.omi_assimilate_enkf_nondiagR`

    References
    ----------
    .. [1] Evensen, G. (1994), 
           Sequential data assimilation with a nonlinear quasi-geostrophic model
           using Monte Carlo methods to forecast error statistics,
           J. Geophys. Res., 99(C5), 1014310162, doi:10.1029/94JC00572.

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__add_obs_err_pdaf : Callable[step:int, dim_obs_p:int, C_p : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]]
        Add obs error covariance R to HPH in EnKF

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Dimension of observation vector

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            * Matrix to that observation covariance R is added

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            * Matrix to that observation covariance R is added

    py__init_obs_covar_pdaf : Callable[step:int, dim_obs:int, dim_obs_p:int, covar:float, obs_p : ndarray[tuple[dim_obs_p], np.float64], isdiag:bool]
        Initialize obs. error cov. matrix R in EnKF

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs** : int

            * Global size of observation vector

        * **dim_obs_p** : int

            * Size of process-local observation vector

        * **covar** : float

            * Observation error covariance matrix

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Process-local vector of observations

        * **isdiag** : bool

            * 

        **Callback Returns**

        * **covar** : float

            * Observation error covariance matrix

        * **isdiag** : bool

            * 

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time


    Returns
    -------
    flag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.add_obs_err_pdaf = <void*>py__add_obs_err_pdaf
    c__PDAFcython.init_obs_covar_pdaf = <void*>py__init_obs_covar_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    cdef int flag

    c__pdaf_assimilate_enkf (c__PDAFcython.c__collect_state_pdaf,
                             c__PDAFcython.c__distribute_state_pdaf,
                             c__PDAFcython.c__init_dim_obs_pdaf,
                             c__PDAFcython.c__obs_op_pdaf,
                             c__PDAFcython.c__init_obs_pdaf,
                             c__PDAFcython.c__prepoststep_pdaf,
                             c__PDAFcython.c__add_obs_err_pdaf,
                             c__PDAFcython.c__init_obs_covar_pdaf,
                             c__PDAFcython.c__next_observation_pdaf,
                             &flag
                            )

    return flag

def assimilate_estkf (py__collect_state_pdaf,
                      py__distribute_state_pdaf,
                      py__init_dim_obs_pdaf,
                      py__obs_op_pdaf,
                      py__init_obs_pdaf,
                      py__prepoststep_pdaf,
                      py__prodRinvA_pdaf,
                      py__init_obsvar_pdaf,
                      py__next_observation_pdaf
                     ):
    """It is recommended to use :func:`pyPDAF.PDAF.omi_assimilate_global`
    or :func:`pyPDAF.PDAF.omi_assimilate_global_nondiagR` instead of this function.

    OMI functions need fewer user-supplied functions and improve DA efficiency.

    This function calls ESTKF (error space transform Kalman filter) [1]_.
    The ESTKF is a more efficient equivalent to the ETKF.

    The function should be called at each model time step.
    The function is a combination of :func:`pyPDAF.PDAF.put_state_estkf`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf (for ensemble mean)
        5. py__init_obs_pdaf
        6. py__obs_op_pdaf (for each ensemble member)
        7. py__init_obsvar_pdaf (only relevant for adaptive forgetting factor schemes)
        8. py__prodRinvA_pdaf
        9. core DA algorithm
        10. py__prepoststep_state_pdaf
        11. py__distribute_state_pdaf
        12. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by :func:`pyPDAF.PDAF.omi_assimilate_global`
       and :func:`pyPDAF.PDAF.omi_assimilate_global_nondiagR`

    References
    ----------
    .. [1] Nerger, L., Janji, T., Schrter, J., Hiller, W. (2012). 
           A unification of ensemble square root Kalman filters. 
           Monthly Weather Review, 140, 2335-2345. doi:10.1175/MWR-D-11-00102.1

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], A_p : ndarray[tuple[dim_obs_p, rank], np.float64], C_p : ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 HV

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **meanvar** : float

            * Mean observation error variance

        **Callback Returns**

        * **meanvar** : float

            * Mean observation error variance

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time


    Returns
    -------
    flag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.prodRinvA_pdaf = <void*>py__prodRinvA_pdaf
    c__PDAFcython.init_obsvar_pdaf = <void*>py__init_obsvar_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    cdef int flag

    c__pdaf_assimilate_estkf (c__PDAFcython.c__collect_state_pdaf,
                              c__PDAFcython.c__distribute_state_pdaf,
                              c__PDAFcython.c__init_dim_obs_pdaf,
                              c__PDAFcython.c__obs_op_pdaf,
                              c__PDAFcython.c__init_obs_pdaf,
                              c__PDAFcython.c__prepoststep_pdaf,
                              c__PDAFcython.c__prodRinvA_pdaf,
                              c__PDAFcython.c__init_obsvar_pdaf,
                              c__PDAFcython.c__next_observation_pdaf,
                              &flag
                             )

    return flag

def assimilate_etkf (py__collect_state_pdaf,
                     py__distribute_state_pdaf,
                     py__init_dim_obs_pdaf,
                     py__obs_op_pdaf,
                     py__init_obs_pdaf,
                     py__prepoststep_pdaf,
                     py__prodRinvA_pdaf,
                     py__init_obsvar_pdaf,
                     py__next_observation_pdaf
                    ):
    """It is recommended to use :func:`pyPDAF.PDAF.omi_assimilate_global`
    or :func:`pyPDAF.PDAF.omi_assimilate_global_nondiagR`.

    PDAFlocal-OMI modules require fewer user-supplied functions and improved efficiency.

    Using ETKF (ensemble transform Kalman filter) [1]_ for DA without OMI. The implementation is baed on [2]_.

    This function should be called at each model time step.
    The function is a combination of :func:`pyPDAF.PDAF.put_state_etkf` :func:and `pyPDAF.PDAF.get_state`.

    This function executes the user-supplied function in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf (for ensemble mean)
        5. py__init_obs_pdaf
        6. py__obs_op_pdaf (for each ensemble member)
        7. py__init_obsvar_pdaf (only relevant for adaptive forgetting factor schemes)
        8. py__prodRinvA_pdaf
        9. core DA algorithm
        10. py__prepoststep_state_pdaf
        11. py__distribute_state_pdaf
        12. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by :func:`pyPDAF.PDAF.omi_assimilate_global`
       and :func:`pyPDAF.PDAF.omi_assimilate_global_nondiagR`

    References
    ----------
    .. [1] Bishop, C. H., B. J. Etherton, and S. J. Majumdar (2001)
           Adaptive Sampling with the Ensemble Transform Kalman Filter.
           Part I: Theoretical Aspects. Mon. Wea. Rev., 129, 420436,
           doi: 10.1175/1520-0493(2001)129<0420:ASWTET>2.0.CO;2. 
    .. [2] Nerger, L., Janji, T., Schrter, J., Hiller, W. (2012). 
           A unification of ensemble square root Kalman filters. 
           Monthly Weather Review, 140, 2335-2345. doi:10.1175/MWR-D-11-00102.1

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], A_p : ndarray[tuple[dim_obs_p, rank], np.float64], C_p : ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 HV

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **meanvar** : float

            * Mean observation error variance

        **Callback Returns**

        * **meanvar** : float

            * Mean observation error variance

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time


    Returns
    -------
    flag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.prodRinvA_pdaf = <void*>py__prodRinvA_pdaf
    c__PDAFcython.init_obsvar_pdaf = <void*>py__init_obsvar_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    cdef int flag

    c__pdaf_assimilate_etkf (c__PDAFcython.c__collect_state_pdaf,
                             c__PDAFcython.c__distribute_state_pdaf,
                             c__PDAFcython.c__init_dim_obs_pdaf,
                             c__PDAFcython.c__obs_op_pdaf,
                             c__PDAFcython.c__init_obs_pdaf,
                             c__PDAFcython.c__prepoststep_pdaf,
                             c__PDAFcython.c__prodRinvA_pdaf,
                             c__PDAFcython.c__init_obsvar_pdaf,
                             c__PDAFcython.c__next_observation_pdaf,
                             &flag
                            )

    return flag

def assimilate_hyb3dvar_estkf (py__collect_state_pdaf,
                               py__distribute_state_pdaf,
                               py__init_dim_obs_pdaf,
                               py__obs_op_pdaf,
                               py__init_obs_pdaf,
                               py__prodRinvA_pdaf,
                               py__cvt_ens_pdaf,
                               py__cvt_adj_ens_pdaf,
                               py__cvt_pdaf,
                               py__cvt_adj_pdaf,
                               py__obs_op_lin_pdaf,
                               py__obs_op_adj_pdaf,
                               py__init_obsvar_pdaf,
                               py__prepoststep_pdaf,
                               py__next_observation_pdaf
                              ):
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.omi_assimilate_hyb3dvar_estkf` or `pyPDAF.PDAF.omi_assimilate_hyb3dvar_estkf_nondiagR`. 
    Using Hybrid 3DEnVar for DA without OMI. Here, the background error covariance is hybridised by a static background error covariance, and a flow-dependent background error covariance estimated from ensemble. The 3DVar generates an ensemble mean and the ensemble perturbation is generated by ESTKF in this implementation. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.put_state_hyb3dvar_estkf` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    5. py__init_obs_pdaf
    Starting the iterative optimisation:
    6. py__cvt_pdaf
    7. py__cvt_ens_pdaf
    8. py__obs_op_lin_pdaf
    9. py__prodRinvA_pdaf
    10. py__obs_op_adj_pdaf
    11. py__cvt_adj_pdaf
    12. py__cvt_adj_ens_pdaf
    13. core 3DEnVar algorithm
    After the iterations: 
    14. py__cvt_pdaf
    15. py__cvt_ens_pdaf
    Perform ESTKF: 16. py__init_dim_obs_pdaf
    17. py__obs_op_pdaf (for ensemble mean
    18. py__init_obs_pdaf
    19. py__obs_op_pdaf (for each ensemble member
    20. py__init_obsvar_pdaf (only relevant for adaptive forgetting factor schemes)
    21. py__prodRinvA_pdaf
    22. core ESTKF algorithm
    23. py__prepoststep_state_pdaf
    24. py__distribute_state_pdaf
    25. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], A_p : ndarray[tuple[dim_obs_p, rank], np.float64], C_p : ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], v_p : ndarray[tuple[dim_cvec_ens], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_ens** : int

            * Ensemble size

        * **dim_cvec_ens** : int

            * Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_ens** : int

            * Ensemble size

        * **dim_cv_ens_p** : int

            * PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p : ndarray[tuple[dim_cvec], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **meanvar** : float

            * Mean observation error variance

        **Callback Returns**

        * **meanvar** : float

            * Mean observation error variance

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time


    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.prodRinvA_pdaf = <void*>py__prodRinvA_pdaf
    c__PDAFcython.cvt_ens_pdaf = <void*>py__cvt_ens_pdaf
    c__PDAFcython.cvt_adj_ens_pdaf = <void*>py__cvt_adj_ens_pdaf
    c__PDAFcython.cvt_pdaf = <void*>py__cvt_pdaf
    c__PDAFcython.cvt_adj_pdaf = <void*>py__cvt_adj_pdaf
    c__PDAFcython.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    c__PDAFcython.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    c__PDAFcython.init_obsvar_pdaf = <void*>py__init_obsvar_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    cdef int outflag

    c__pdaf_assimilate_hyb3dvar_estkf (c__PDAFcython.c__collect_state_pdaf,
                                       c__PDAFcython.c__distribute_state_pdaf,
                                       c__PDAFcython.c__init_dim_obs_pdaf,
                                       c__PDAFcython.c__obs_op_pdaf,
                                       c__PDAFcython.c__init_obs_pdaf,
                                       c__PDAFcython.c__prodRinvA_pdaf,
                                       c__PDAFcython.c__cvt_ens_pdaf,
                                       c__PDAFcython.c__cvt_adj_ens_pdaf,
                                       c__PDAFcython.c__cvt_pdaf,
                                       c__PDAFcython.c__cvt_adj_pdaf,
                                       c__PDAFcython.c__obs_op_lin_pdaf,
                                       c__PDAFcython.c__obs_op_adj_pdaf,
                                       c__PDAFcython.c__init_obsvar_pdaf,
                                       c__PDAFcython.c__prepoststep_pdaf,
                                       c__PDAFcython.c__next_observation_pdaf,
                                       &outflag
                                      )

    return outflag

def assimilate_hyb3dvar_lestkf (py__collect_state_pdaf,
                                py__distribute_state_pdaf,
                                py__init_dim_obs_pdaf,
                                py__obs_op_pdaf,
                                py__init_obs_pdaf,
                                py__prodRinvA_pdaf,
                                py__cvt_ens_pdaf,
                                py__cvt_adj_ens_pdaf,
                                py__cvt_pdaf,
                                py__cvt_adj_pdaf,
                                py__obs_op_lin_pdaf,
                                py__obs_op_adj_pdaf,
                                py__init_dim_obs_f_pdaf,
                                py__obs_op_f_pdaf,
                                py__init_obs_f_pdaf,
                                py__init_obs_l_pdaf,
                                py__prodRinvA_l_pdaf,
                                py__init_n_domains_p_pdaf,
                                py__init_dim_l_pdaf,
                                py__init_dim_obs_l_pdaf,
                                py__g2l_state_pdaf,
                                py__l2g_state_pdaf,
                                py__g2l_obs_pdaf,
                                py__init_obsvar_pdaf,
                                py__init_obsvar_l_pdaf,
                                py__prepoststep_pdaf,
                                py__next_observation_pdaf
                               ):
    """It is recommended to use local module with OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_assimilate_hyb3dvar_lestkf` or `pyPDAF.PDAF.localomi_assimilate_hyb3dvar_lestkf_nondiagR`. 
    Using Hybrid 3DEnVar for DA without OMI. Here, the background error covariance is hybridised by a static background error covariance, and a flow-dependent background error covariance estimated from ensemble. The 3DVar generates an ensemble mean and the ensemble perturbation is generated by LESTKF in this implementation. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.put_state_hyb3dvar_lestkf` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    5. py__init_obs_pdaf
    Starting the iterative optimisation:
    6. py__cvt_pdaf
    7. py__cvt_ens_pdaf
    8. py__obs_op_lin_pdaf
    9. py__prodRinvA_pdaf
    10. py__obs_op_adj_pdaf
    11. py__cvt_adj_pdaf
    12. py__cvt_adj_ens_pdaf
    13. core DA algorithm
    After the iterations: 
    14. py__cvt_pdaf
    15. py__cvt_ens_pdaf
    Perform LESTKF: 
    16. py__init_n_domains_p_pdaf
    17. py__init_dim_obs_pdaf
    18. py__obs_op_pdaf (for each ensemble member
    19. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in `pyPDAF.PDAF.init`))
    20. py__init_obsvar_pdaf (if global adaptive forgetting factor is used)
    loop over each local domain:
    21. py__init_dim_l_pdaf
    22. py__init_dim_obs_l_pdaf
    23. py__g2l_state_pdaf
    24. py__g2l_obs_pdaf (localise mean ensemble in observation space)
    25. py__init_obs_l_pdaf
    26. py__g2l_obs_pdaf (localise each ensemble member in observation space)
    27. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used)
    28. py__prodRinvA_l_pdaf
    29. core DA algorithm
    30. py__l2g_state_pdaf
    31. py__prepoststep_state_pdaf
    32. py__distribute_state_pdaf
    33. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], A_p : ndarray[tuple[dim_obs_p, rank], np.float64], C_p : ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], v_p : ndarray[tuple[dim_cvec_ens], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_ens** : int

            * Ensemble size

        * **dim_cvec_ens** : int

            * Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_ens** : int

            * Ensemble size

        * **dim_cv_ens_p** : int

            * PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p : ndarray[tuple[dim_cvec], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f : ndarray[tuple[dim_obs_f], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_f** : int

            * Size of the full observation vector

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of observations

        **Callback Returns**

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of observations

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l : ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], A_l : ndarray[tuple[dim_obs_l, rank], np.float64], C_l : ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p : ndarray[tuple[dim_p], np.float64], dim_l:int, state_l : ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l : ndarray[tuple[dim_l], np.float64], dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f : ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l : ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_f** : int

            * Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            * Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * **dim_p** : int

            * Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * **dim_l** : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **meanvar** : float

            * Mean observation error variance

        **Callback Returns**

        * **meanvar** : float

            * Mean observation error variance

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * **dim_obs_p** : int

            * Dimension of local observation vector

        * **meanvar_l** : float

            * Mean local observation error variance

        **Callback Returns**

        * **meanvar_l** : float

            * Mean local observation error variance

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time


    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.prodRinvA_pdaf = <void*>py__prodRinvA_pdaf
    c__PDAFcython.cvt_ens_pdaf = <void*>py__cvt_ens_pdaf
    c__PDAFcython.cvt_adj_ens_pdaf = <void*>py__cvt_adj_ens_pdaf
    c__PDAFcython.cvt_pdaf = <void*>py__cvt_pdaf
    c__PDAFcython.cvt_adj_pdaf = <void*>py__cvt_adj_pdaf
    c__PDAFcython.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    c__PDAFcython.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    c__PDAFcython.init_dim_obs_f_pdaf = <void*>py__init_dim_obs_f_pdaf
    c__PDAFcython.obs_op_f_pdaf = <void*>py__obs_op_f_pdaf
    c__PDAFcython.init_obs_f_pdaf = <void*>py__init_obs_f_pdaf
    c__PDAFcython.init_obs_l_pdaf = <void*>py__init_obs_l_pdaf
    c__PDAFcython.prodRinvA_l_pdaf = <void*>py__prodRinvA_l_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.g2l_state_pdaf = <void*>py__g2l_state_pdaf
    c__PDAFcython.l2g_state_pdaf = <void*>py__l2g_state_pdaf
    c__PDAFcython.g2l_obs_pdaf = <void*>py__g2l_obs_pdaf
    c__PDAFcython.init_obsvar_pdaf = <void*>py__init_obsvar_pdaf
    c__PDAFcython.init_obsvar_l_pdaf = <void*>py__init_obsvar_l_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    cdef int outflag

    c__pdaf_assimilate_hyb3dvar_lestkf (c__PDAFcython.c__collect_state_pdaf,
                                        c__PDAFcython.c__distribute_state_pdaf,
                                        c__PDAFcython.c__init_dim_obs_pdaf,
                                        c__PDAFcython.c__obs_op_pdaf,
                                        c__PDAFcython.c__init_obs_pdaf,
                                        c__PDAFcython.c__prodRinvA_pdaf,
                                        c__PDAFcython.c__cvt_ens_pdaf,
                                        c__PDAFcython.c__cvt_adj_ens_pdaf,
                                        c__PDAFcython.c__cvt_pdaf,
                                        c__PDAFcython.c__cvt_adj_pdaf,
                                        c__PDAFcython.c__obs_op_lin_pdaf,
                                        c__PDAFcython.c__obs_op_adj_pdaf,
                                        c__PDAFcython.c__init_dim_obs_f_pdaf,
                                        c__PDAFcython.c__obs_op_f_pdaf,
                                        c__PDAFcython.c__init_obs_f_pdaf,
                                        c__PDAFcython.c__init_obs_l_pdaf,
                                        c__PDAFcython.c__prodRinvA_l_pdaf,
                                        c__PDAFcython.c__init_n_domains_p_pdaf,
                                        c__PDAFcython.c__init_dim_l_pdaf,
                                        c__PDAFcython.c__init_dim_obs_l_pdaf,
                                        c__PDAFcython.c__g2l_state_pdaf,
                                        c__PDAFcython.c__l2g_state_pdaf,
                                        c__PDAFcython.c__g2l_obs_pdaf,
                                        c__PDAFcython.c__init_obsvar_pdaf,
                                        c__PDAFcython.c__init_obsvar_l_pdaf,
                                        c__PDAFcython.c__prepoststep_pdaf,
                                        c__PDAFcython.c__next_observation_pdaf,
                                        &outflag
                                       )

    return outflag

def assimilate_lenkf (py__collect_state_pdaf,
                      py__distribute_state_pdaf,
                      py__init_dim_obs_pdaf,
                      py__obs_op_pdaf,
                      py__init_obs_pdaf,
                      py__prepoststep_pdaf,
                      py__localize_covar_pdaf,
                      py__add_obs_err_pdaf,
                      py__init_obs_covar_pdaf,
                      py__next_observation_pdaf
                     ):
    """It is recommended to use :func:`pyPDAF.PDAF.omi_assimilate_lenkf`
    or :func:`pyPDAF.PDAF.omi_assimilate_lenkf_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions and improved efficiency.

    Using stochastic EnKF (ensemble Kalman filter) with covariance localisation [1]_
    for DA without OMI.

    This is the only scheme for covariance localisation in PDAF.

    This function should be called at each model time step.
    The function is a combination of :func:`pyPDAF.PDAF.put_state_lenkf`
    and :func:`pyPDAF.PDAF.get_state`.

    The user-supplied function is executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf (for each ensemble member)
        5. py__localize_pdaf
        6. py__add_obs_err_pdaf
        7. py__init_obs_pdaf
        8. py__init_obscovar_pdaf
        9. py__obs_op_pdaf (repeated to reduce storage)
        10. core DA algorith
        11. py__prepoststep_state_pdaf
        12. py__distribute_state_pdaf
        13. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by :func:`pyPDAF.PDAF.omi_assimilate_lenkf`
       and :func:`pyPDAF.PDAF.omi_assimilate_lenkf_nondiagR`

    References
    ----------
    .. [1] Houtekamer, P. L., and H. L. Mitchell (1998): 
           Data Assimilation Using an Ensemble Kalman Filter Technique.
           Mon. Wea. Rev., 126, 796811,
           doi: 10.1175/1520-0493(1998)126<0796:DAUAEK>2.0.CO;2.

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__localize_covar_pdaf : Callable[dim_p:int, dim_obs:int, hp_p : ndarray[tuple[dim_obs, dim_p], np.float64], hph : ndarray[tuple[dim_obs, dim_obs], np.float64]]
        Apply localization to HP and HPH^T

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **dim_obs** : int

            * number of observations

        * **hp_p** : ndarray[tuple[dim_obs, dim_p], np.float64]

            * pe local part of matrix hp

        * **hph** : ndarray[tuple[dim_obs, dim_obs], np.float64]

            * matrix hph

        **Callback Returns**

        * **hp_p** : ndarray[tuple[dim_obs, dim_p], np.float64]

            * pe local part of matrix hp

        * **hph** : ndarray[tuple[dim_obs, dim_obs], np.float64]

            * matrix hph

    py__add_obs_err_pdaf : Callable[step:int, dim_obs_p:int, C_p : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]]
        Add obs error covariance R to HPH in EnKF

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Dimension of observation vector

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            * Matrix to that observation covariance R is added

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            * Matrix to that observation covariance R is added

    py__init_obs_covar_pdaf : Callable[step:int, dim_obs:int, dim_obs_p:int, covar:float, obs_p : ndarray[tuple[dim_obs_p], np.float64], isdiag:bool]
        Initialize obs. error cov. matrix R in EnKF

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs** : int

            * Global size of observation vector

        * **dim_obs_p** : int

            * Size of process-local observation vector

        * **covar** : float

            * Observation error covariance matrix

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Process-local vector of observations

        * **isdiag** : bool

            * 

        **Callback Returns**

        * **covar** : float

            * Observation error covariance matrix

        * **isdiag** : bool

            * 

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time


    Returns
    -------
    flag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.localize_covar_pdaf = <void*>py__localize_covar_pdaf
    c__PDAFcython.add_obs_err_pdaf = <void*>py__add_obs_err_pdaf
    c__PDAFcython.init_obs_covar_pdaf = <void*>py__init_obs_covar_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    cdef int flag

    c__pdaf_assimilate_lenkf (c__PDAFcython.c__collect_state_pdaf,
                              c__PDAFcython.c__distribute_state_pdaf,
                              c__PDAFcython.c__init_dim_obs_pdaf,
                              c__PDAFcython.c__obs_op_pdaf,
                              c__PDAFcython.c__init_obs_pdaf,
                              c__PDAFcython.c__prepoststep_pdaf,
                              c__PDAFcython.c__localize_covar_pdaf,
                              c__PDAFcython.c__add_obs_err_pdaf,
                              c__PDAFcython.c__init_obs_covar_pdaf,
                              c__PDAFcython.c__next_observation_pdaf,
                              &flag
                             )

    return flag

def assimilate_lestkf (py__collect_state_pdaf,
                       py__distribute_state_pdaf,
                       py__init_dim_obs_pdaf,
                       py__obs_op_pdaf,
                       py__init_obs_pdaf,
                       py__init_obs_l_pdaf,
                       py__prepoststep_pdaf,
                       py__prodRinvA_l_pdaf,
                       py__init_n_domains_p_pdaf,
                       py__init_dim_l_pdaf,
                       py__init_dim_obs_l_pdaf,
                       py__g2l_state_pdaf,
                       py__l2g_state_pdaf,
                       py__g2l_obs_pdaf,
                       py__init_obsvar_pdaf,
                       py__init_obsvar_l_pdaf,
                       py__next_observation_pdaf
                      ):
    """It is recommended to use :func:`pyPDAF.PDAF.localomi_assimilate`
    or :func:`pyPDAF.PDAF.localomi_assimilate_nondiagR`.

    PDAFlocal-OMI modules require fewer user-supplied functions and improved efficiency.

    Local ESTKF (error space transform Kalman filter) [1]_ for DA without OMI.
    The LESTKF is a more efficient equivalent to the LETKF.

    This function should be called at each model time step.
    The function is a combination of :func:`pyPDAF.PDAF.put_state_lestkf`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. py__init_obs_pdaf
           (if global adaptive forgetting factor `type_forget=1` is used
           in :func:`pyPDAF.PDAF.init`)
        7. py__init_obsvar_pdaf (if global adaptive forgetting factor is used)
        8. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. py__g2l_state_pdaf
            4. py__g2l_obs_pdaf (localise mean ensemble in observation space)
            5. py__init_obs_l_pdaf
            6. py__g2l_obs_pdaf
               (localise each ensemble member in observation space)
            7. py__init_obsvar_l_pdaf
               (only called if local adaptive forgetting factor `type_forget=2` is used)
            8. py__prodRinvA_l_pdaf
            9. core DA algorithm
            10. py__l2g_state_pdaf
        9. py__prepoststep_state_pdaf
        10. py__distribute_state_pdaf
        11. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by :func:`pyPDAF.PDAF.omi_assimilate_global`
       and :func:`pyPDAF.PDAF.localomi_assimilate`

    References
    ----------
    .. [1] Nerger, L., Janji, T., Schrter, J., Hiller, W. (2012). 
           A unification of ensemble square root Kalman filters. 
           Monthly Weather Review, 140, 2335-2345. doi:10.1175/MWR-D-11-00102.1

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l : ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], A_l : ndarray[tuple[dim_obs_l, rank], np.float64], C_l : ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p : ndarray[tuple[dim_p], np.float64], dim_l:int, state_l : ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l : ndarray[tuple[dim_l], np.float64], dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f : ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l : ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_f** : int

            * Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            * Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * **dim_p** : int

            * Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * **dim_l** : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **meanvar** : float

            * Mean observation error variance

        **Callback Returns**

        * **meanvar** : float

            * Mean observation error variance

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * **dim_obs_p** : int

            * Dimension of local observation vector

        * **meanvar_l** : float

            * Mean local observation error variance

        **Callback Returns**

        * **meanvar_l** : float

            * Mean local observation error variance

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time


    Returns
    -------
    flag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.init_obs_l_pdaf = <void*>py__init_obs_l_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.prodRinvA_l_pdaf = <void*>py__prodRinvA_l_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.g2l_state_pdaf = <void*>py__g2l_state_pdaf
    c__PDAFcython.l2g_state_pdaf = <void*>py__l2g_state_pdaf
    c__PDAFcython.g2l_obs_pdaf = <void*>py__g2l_obs_pdaf
    c__PDAFcython.init_obsvar_pdaf = <void*>py__init_obsvar_pdaf
    c__PDAFcython.init_obsvar_l_pdaf = <void*>py__init_obsvar_l_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    cdef int flag

    c__pdaf_assimilate_lestkf (c__PDAFcython.c__collect_state_pdaf,
                               c__PDAFcython.c__distribute_state_pdaf,
                               c__PDAFcython.c__init_dim_obs_pdaf,
                               c__PDAFcython.c__obs_op_pdaf,
                               c__PDAFcython.c__init_obs_pdaf,
                               c__PDAFcython.c__init_obs_l_pdaf,
                               c__PDAFcython.c__prepoststep_pdaf,
                               c__PDAFcython.c__prodRinvA_l_pdaf,
                               c__PDAFcython.c__init_n_domains_p_pdaf,
                               c__PDAFcython.c__init_dim_l_pdaf,
                               c__PDAFcython.c__init_dim_obs_l_pdaf,
                               c__PDAFcython.c__g2l_state_pdaf,
                               c__PDAFcython.c__l2g_state_pdaf,
                               c__PDAFcython.c__g2l_obs_pdaf,
                               c__PDAFcython.c__init_obsvar_pdaf,
                               c__PDAFcython.c__init_obsvar_l_pdaf,
                               c__PDAFcython.c__next_observation_pdaf,
                               &flag
                              )

    return flag

def assimilate_letkf (py__collect_state_pdaf,
                      py__distribute_state_pdaf,
                      py__init_dim_obs_pdaf,
                      py__obs_op_pdaf,
                      py__init_obs_pdaf,
                      py__init_obs_l_pdaf,
                      py__prepoststep_pdaf,
                      py__prodRinvA_l_pdaf,
                      py__init_n_domains_p_pdaf,
                      py__init_dim_l_pdaf,
                      py__init_dim_obs_l_pdaf,
                      py__g2l_state_pdaf,
                      py__l2g_state_pdaf,
                      py__g2l_obs_pdaf,
                      py__init_obsvar_pdaf,
                      py__init_obsvar_l_pdaf,
                      py__next_observation_pdaf
                     ):
    """It is recommended to use :func:`pyPDAF.PDAF.localomi_assimilate`
    or :func:`pyPDAF.PDAF.localomi_assimilate_nondiagR`.

    PDAFlocal-OMI modules require fewer user-supplied functions and improved efficiency.

    Local ensemble transform Kalman filter (LETKF) [1]_ for DA without OMI. Implementation is based on [2]_.
    Note that the LESTKF is a more efficient equivalent to the LETKF.

    This function should be called at each model time step.
    The function is a combination of :func:`pyPDAF.PDAF.put_state_letkf`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. py__init_obs_pdaf
           (if global adaptive forgetting factor `type_forget=1` is used
           in :func:`pyPDAF.PDAF.init`)
        7. py__init_obsvar_pdaf (if global adaptive forgetting factor is used)
        8. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. py__g2l_state_pdaf
            4. py__g2l_obs_pdaf (localise mean ensemble in observation space)
            5. py__init_obs_l_pdaf
            6. py__g2l_obs_pdaf (localise each ensemble member in observation space)
            7. py__init_obsvar_l_pdaf
               (only called if local adaptive forgetting factor `type_forget=2` is used)
            8. py__prodRinvA_l_pdaf
            9. core DA algorithm
            10. py__l2g_state_pdaf
        9. py__prepoststep_state_pdaf
        10. py__distribute_state_pdaf
        11. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by :func:`pyPDAF.PDAF.localomi_assimilate`
       and :func:`pyPDAF.PDAF.localomi_assimilate_nondiagR`

    References
    ----------
    .. [1] Hunt, B. R., Kostelich, E. J., & Szunyogh, I. (2007).
           Efficient data assimilation for spatiotemporal chaos:
           A local ensemble transform Kalman filter. 
           Physica D: Nonlinear Phenomena, 230(1-2), 112-126.
    .. [2] Nerger, L., Janji, T., Schrter, J., Hiller, W. (2012). 
           A unification of ensemble square root Kalman filters. 
           Monthly Weather Review, 140, 2335-2345. doi:10.1175/MWR-D-11-00102.1

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l : ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], A_l : ndarray[tuple[dim_obs_l, rank], np.float64], C_l : ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p : ndarray[tuple[dim_p], np.float64], dim_l:int, state_l : ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l : ndarray[tuple[dim_l], np.float64], dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f : ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l : ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_f** : int

            * Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            * Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * **dim_p** : int

            * Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * **dim_l** : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **meanvar** : float

            * Mean observation error variance

        **Callback Returns**

        * **meanvar** : float

            * Mean observation error variance

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * **dim_obs_p** : int

            * Dimension of local observation vector

        * **meanvar_l** : float

            * Mean local observation error variance

        **Callback Returns**

        * **meanvar_l** : float

            * Mean local observation error variance

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time


    Returns
    -------
    flag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.init_obs_l_pdaf = <void*>py__init_obs_l_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.prodRinvA_l_pdaf = <void*>py__prodRinvA_l_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.g2l_state_pdaf = <void*>py__g2l_state_pdaf
    c__PDAFcython.l2g_state_pdaf = <void*>py__l2g_state_pdaf
    c__PDAFcython.g2l_obs_pdaf = <void*>py__g2l_obs_pdaf
    c__PDAFcython.init_obsvar_pdaf = <void*>py__init_obsvar_pdaf
    c__PDAFcython.init_obsvar_l_pdaf = <void*>py__init_obsvar_l_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    cdef int flag

    c__pdaf_assimilate_letkf (c__PDAFcython.c__collect_state_pdaf,
                              c__PDAFcython.c__distribute_state_pdaf,
                              c__PDAFcython.c__init_dim_obs_pdaf,
                              c__PDAFcython.c__obs_op_pdaf,
                              c__PDAFcython.c__init_obs_pdaf,
                              c__PDAFcython.c__init_obs_l_pdaf,
                              c__PDAFcython.c__prepoststep_pdaf,
                              c__PDAFcython.c__prodRinvA_l_pdaf,
                              c__PDAFcython.c__init_n_domains_p_pdaf,
                              c__PDAFcython.c__init_dim_l_pdaf,
                              c__PDAFcython.c__init_dim_obs_l_pdaf,
                              c__PDAFcython.c__g2l_state_pdaf,
                              c__PDAFcython.c__l2g_state_pdaf,
                              c__PDAFcython.c__g2l_obs_pdaf,
                              c__PDAFcython.c__init_obsvar_pdaf,
                              c__PDAFcython.c__init_obsvar_l_pdaf,
                              c__PDAFcython.c__next_observation_pdaf,
                              &flag
                             )

    return flag

def assimilate_lnetf (py__collect_state_pdaf,
                      py__distribute_state_pdaf,
                      py__init_dim_obs_pdaf,
                      py__obs_op_pdaf,
                      py__init_obs_l_pdaf,
                      py__prepoststep_pdaf,
                      py__likelihood_l_pdaf,
                      py__init_n_domains_p_pdaf,
                      py__init_dim_l_pdaf,
                      py__init_dim_obs_l_pdaf,
                      py__g2l_state_pdaf,
                      py__l2g_state_pdaf,
                      py__g2l_obs_pdaf,
                      py__next_observation_pdaf
                     ):
    """It is recommended to use local module with OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_assimilate` or `pyPDAF.PDAF.localomi_assimilate_lnetf_nondiagR`. 
    This function will use Local Nonlinear Ensemble Transform Filter (LNETF) for DA without OMI. The nonlinear filter computes the distribution up to the second moment similar to KF but using a nonlinear weighting similar to particle filter. This leads to an equal weights assumption for prior ensemble. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.put_state_lnetf` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    6. py__init_dim_l_pdaf
    7. py__init_dim_obs_l_pdaf
    8. py__g2l_state_pdaf
    9. py__init_obs_l_pdaf
    10. py__g2l_obs_pdaf(localise each ensemble member in observation space)
    11. py__likelihood_l_pdaf
    12. core DA algorithm
    13. py__l2g_state_pdaf
    14. py__prepoststep_state_pdaf
    15. py__distribute_state_pdaf
    16. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l : ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], resid_l : ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            * nput vector holding the local residual

        * **likely_l** : float

            * Output value of the local likelihood

        **Callback Returns**

        * **likely_l** : float

            * Output value of the local likelihood

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p : ndarray[tuple[dim_p], np.float64], dim_l:int, state_l : ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l : ndarray[tuple[dim_l], np.float64], dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f : ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l : ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_f** : int

            * Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            * Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * **dim_p** : int

            * Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * **dim_l** : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time


    Returns
    -------
    flag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_l_pdaf = <void*>py__init_obs_l_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.likelihood_l_pdaf = <void*>py__likelihood_l_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.g2l_state_pdaf = <void*>py__g2l_state_pdaf
    c__PDAFcython.l2g_state_pdaf = <void*>py__l2g_state_pdaf
    c__PDAFcython.g2l_obs_pdaf = <void*>py__g2l_obs_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    cdef int flag

    c__pdaf_assimilate_lnetf (c__PDAFcython.c__collect_state_pdaf,
                              c__PDAFcython.c__distribute_state_pdaf,
                              c__PDAFcython.c__init_dim_obs_pdaf,
                              c__PDAFcython.c__obs_op_pdaf,
                              c__PDAFcython.c__init_obs_l_pdaf,
                              c__PDAFcython.c__prepoststep_pdaf,
                              c__PDAFcython.c__likelihood_l_pdaf,
                              c__PDAFcython.c__init_n_domains_p_pdaf,
                              c__PDAFcython.c__init_dim_l_pdaf,
                              c__PDAFcython.c__init_dim_obs_l_pdaf,
                              c__PDAFcython.c__g2l_state_pdaf,
                              c__PDAFcython.c__l2g_state_pdaf,
                              c__PDAFcython.c__g2l_obs_pdaf,
                              c__PDAFcython.c__next_observation_pdaf,
                              &flag
                             )

    return flag

def assimilate_lknetf (py__collect_state_pdaf,
                       py__distribute_state_pdaf,
                       py__init_dim_obs_pdaf,
                       py__obs_op_pdaf,
                       py__init_obs_pdaf,
                       py__init_obs_l_pdaf,
                       py__prepoststep_pdaf,
                       py__prodRinvA_l_pdaf,
                       py__prodRinvA_hyb_l_pdaf,
                       py__init_n_domains_p_pdaf,
                       py__init_dim_l_pdaf,
                       py__init_dim_obs_l_pdaf,
                       py__g2l_state_pdaf,
                       py__l2g_state_pdaf,
                       py__g2l_obs_pdaf,
                       py__init_obsvar_pdaf,
                       py__init_obsvar_l_pdaf,
                       py__likelihood_l_pdaf,
                       py__likelihood_hyb_l_pdaf,
                       py__next_observation_pdaf
                      ):
    """It is recommended to use local module with OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_assimilate` or `pyPDAF.PDAF.localomi_assimilate_lknetf_nondiagR`. 
    This function will is a hybridised LETKF and LNETF for DA without OMI. The LNETF computes the distribution up to the second moment similar to KF but using a nonlinear weighting similar to particle filter. This leads to an equal weights assumption for prior ensemble. The hybridisation with LETKF is expected to lead to improved performance for quasi-Gaussian problems. The function should be called at each model step. 
    
    The function is a combination of `pyPDAF.PDAF.put_state_lknetf` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    6. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init
    7. py__init_obsvar_pdaf (if global adaptive forgetting factor is used
    loop over each local domain:
    8. py__init_dim_l_pdaf
    9. py__init_dim_obs_l_pdaf
    10. py__g2l_state_pdaf
    11. py__g2l_obs_pdaf (localise each ensemble member in observation space)
    12. py__init_obs_l_pdaf
    13. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used
    14. py__prodRinvA_pdaf
    15. py__likelihood_l_pdaf
    16. core DA algorithm
    17. py__l2g_state_pdaf
    18. py__obs_op_pdaf (only called with `HKN` and `HNK` options called for each ensemble member
    19. py__likelihood_hyb_l_pda
    20. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used
    21. py__prodRinvA_hyb_l_pdaf
    22. py__prepoststep_state_pdaf
    23. py__distribute_state_pdaf
    24. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l : ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], A_l : ndarray[tuple[dim_obs_l, rank], np.float64], C_l : ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

    py__prodRinvA_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, dim_ens:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], gamma:float, A_l : ndarray[tuple[dim_obs_l, dim_ens], np.float64], C_l : ndarray[tuple[dim_obs_l, dim_ens], np.float64]]
        Provide product R^-1 A on local analysis domain with hybrid weight

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **dim_ens** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **gamma** : float

            * Hybrid weight provided by PDAF

        * **A_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            * Output matrix

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p : ndarray[tuple[dim_p], np.float64], dim_l:int, state_l : ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l : ndarray[tuple[dim_l], np.float64], dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f : ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l : ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_f** : int

            * Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            * Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * **dim_p** : int

            * Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * **dim_l** : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **meanvar** : float

            * Mean observation error variance

        **Callback Returns**

        * **meanvar** : float

            * Mean observation error variance

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * **dim_obs_p** : int

            * Dimension of local observation vector

        * **meanvar_l** : float

            * Mean local observation error variance

        **Callback Returns**

        * **meanvar_l** : float

            * Mean local observation error variance

    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], resid_l : ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute likelihood

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            * nput vector holding the local residual

        * **likely_l** : float

            * Output value of the local likelihood

        **Callback Returns**

        * **likely_l** : float

            * Output value of the local likelihood

    py__likelihood_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], resid_l : ndarray[tuple[dim_obs_l], np.float64], gamma:float, likely_l:float]
        Compute likelihood with hybrid weight

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Input vector holding the local residual

        * **gamma** : float

            * Hybrid weight provided by PDAF

        * **likely_l** : float

            * Output value of the local likelihood

        **Callback Returns**

        * **likely_l** : float

            * Output value of the local likelihood

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time


    Returns
    -------
    flag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.init_obs_l_pdaf = <void*>py__init_obs_l_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.prodRinvA_l_pdaf = <void*>py__prodRinvA_l_pdaf
    c__PDAFcython.prodRinvA_hyb_l_pdaf = <void*>py__prodRinvA_hyb_l_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.g2l_state_pdaf = <void*>py__g2l_state_pdaf
    c__PDAFcython.l2g_state_pdaf = <void*>py__l2g_state_pdaf
    c__PDAFcython.g2l_obs_pdaf = <void*>py__g2l_obs_pdaf
    c__PDAFcython.init_obsvar_pdaf = <void*>py__init_obsvar_pdaf
    c__PDAFcython.init_obsvar_l_pdaf = <void*>py__init_obsvar_l_pdaf
    c__PDAFcython.likelihood_l_pdaf = <void*>py__likelihood_l_pdaf
    c__PDAFcython.likelihood_hyb_l_pdaf = <void*>py__likelihood_hyb_l_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    cdef int flag

    c__pdaf_assimilate_lknetf (c__PDAFcython.c__collect_state_pdaf,
                               c__PDAFcython.c__distribute_state_pdaf,
                               c__PDAFcython.c__init_dim_obs_pdaf,
                               c__PDAFcython.c__obs_op_pdaf,
                               c__PDAFcython.c__init_obs_pdaf,
                               c__PDAFcython.c__init_obs_l_pdaf,
                               c__PDAFcython.c__prepoststep_pdaf,
                               c__PDAFcython.c__prodRinvA_l_pdaf,
                               c__PDAFcython.c__prodRinvA_hyb_l_pdaf,
                               c__PDAFcython.c__init_n_domains_p_pdaf,
                               c__PDAFcython.c__init_dim_l_pdaf,
                               c__PDAFcython.c__init_dim_obs_l_pdaf,
                               c__PDAFcython.c__g2l_state_pdaf,
                               c__PDAFcython.c__l2g_state_pdaf,
                               c__PDAFcython.c__g2l_obs_pdaf,
                               c__PDAFcython.c__init_obsvar_pdaf,
                               c__PDAFcython.c__init_obsvar_l_pdaf,
                               c__PDAFcython.c__likelihood_l_pdaf,
                               c__PDAFcython.c__likelihood_hyb_l_pdaf,
                               c__PDAFcython.c__next_observation_pdaf,
                               &flag
                              )

    return flag

def assimilate_lseik (py__collect_state_pdaf,
                      py__distribute_state_pdaf,
                      py__init_dim_obs_pdaf,
                      py__obs_op_pdaf,
                      py__init_obs_pdaf,
                      py__init_obs_l_pdaf,
                      py__prepoststep_pdaf,
                      py__prodRinvA_l_pdaf,
                      py__init_n_domains_p_pdaf,
                      py__init_dim_l_pdaf,
                      py__init_dim_obs_l_pdaf,
                      py__g2l_state_pdaf,
                      py__l2g_state_pdaf,
                      py__g2l_obs_pdaf,
                      py__init_obsvar_pdaf,
                      py__init_obsvar_l_pdaf,
                      py__next_observation_pdaf
                     ):
    """It is recommended to use local module with OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_assimilate` or `pyPDAF.PDAF.localomi_assimilate_nondiagR`. 
    Using local singular evolutive interpolated Kalman filter for DA without OMI. This is a domain localisation method. This function should be called at each model time step.
    
    The function is a combination of `pyPDAF.PDAF.put_state_lseik` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    6. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init
    7. py__init_obsvar_pdaf (if global adaptive forgetting factor is used
    loop over each local domain:
    8. py__init_dim_l_pdaf
    9. py__init_dim_obs_l_pdaf
    10. py__g2l_state_pdaf
    11. py__g2l_obs_pdaf (localise mean ensemble in observation space)
    12. py__init_obs_l_pdaf
    13. py__g2l_obs_pdaf (localise each ensemble member in observation space
    14. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used
    15. py__prodRinvA_l_pdaf
    16. core DA algorithm
    17. py__l2g_state_pdaf
    18. py__prepoststep_state_pdaf
    19. py__distribute_state_pdaf
    20. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l : ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], A_l : ndarray[tuple[dim_obs_l, rank], np.float64], C_l : ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p : ndarray[tuple[dim_p], np.float64], dim_l:int, state_l : ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l : ndarray[tuple[dim_l], np.float64], dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f : ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l : ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_f** : int

            * Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            * Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * **dim_p** : int

            * Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * **dim_l** : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **meanvar** : float

            * Mean observation error variance

        **Callback Returns**

        * **meanvar** : float

            * Mean observation error variance

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * **dim_obs_p** : int

            * Dimension of local observation vector

        * **meanvar_l** : float

            * Mean local observation error variance

        **Callback Returns**

        * **meanvar_l** : float

            * Mean local observation error variance

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time


    Returns
    -------
    flag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.init_obs_l_pdaf = <void*>py__init_obs_l_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.prodRinvA_l_pdaf = <void*>py__prodRinvA_l_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.g2l_state_pdaf = <void*>py__g2l_state_pdaf
    c__PDAFcython.l2g_state_pdaf = <void*>py__l2g_state_pdaf
    c__PDAFcython.g2l_obs_pdaf = <void*>py__g2l_obs_pdaf
    c__PDAFcython.init_obsvar_pdaf = <void*>py__init_obsvar_pdaf
    c__PDAFcython.init_obsvar_l_pdaf = <void*>py__init_obsvar_l_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    cdef int flag

    c__pdaf_assimilate_lseik (c__PDAFcython.c__collect_state_pdaf,
                              c__PDAFcython.c__distribute_state_pdaf,
                              c__PDAFcython.c__init_dim_obs_pdaf,
                              c__PDAFcython.c__obs_op_pdaf,
                              c__PDAFcython.c__init_obs_pdaf,
                              c__PDAFcython.c__init_obs_l_pdaf,
                              c__PDAFcython.c__prepoststep_pdaf,
                              c__PDAFcython.c__prodRinvA_l_pdaf,
                              c__PDAFcython.c__init_n_domains_p_pdaf,
                              c__PDAFcython.c__init_dim_l_pdaf,
                              c__PDAFcython.c__init_dim_obs_l_pdaf,
                              c__PDAFcython.c__g2l_state_pdaf,
                              c__PDAFcython.c__l2g_state_pdaf,
                              c__PDAFcython.c__g2l_obs_pdaf,
                              c__PDAFcython.c__init_obsvar_pdaf,
                              c__PDAFcython.c__init_obsvar_l_pdaf,
                              c__PDAFcython.c__next_observation_pdaf,
                              &flag
                             )

    return flag

def assimilate_netf (py__collect_state_pdaf,
                     py__distribute_state_pdaf,
                     py__init_dim_obs_pdaf,
                     py__obs_op_pdaf,
                     py__init_obs_pdaf,
                     py__prepoststep_pdaf,
                     py__likelihood_pdaf,
                     py__next_observation_pdaf
                    ):
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.omi_assimilate_global` or `pyPDAF.PDAF.omi_assimilate_nonlin_nondiagR`. 
    This function will use Nonlinear Ensemble Transform Filter (NETF) for DA without OMI. The nonlinear filter computes the distribution up to the second moment similar to KF but using a nonlinear weighting similar to particle filter. This leads to an equal weights assumption for prior ensemble. The function should be called at each model step. 
    
    The function is a combination of `pyPDAF.PDAF.put_state_netf` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__init_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    6. py__likelihood_pdaf
    7. core DA algorithm
    8. py__prepoststep_state_pdaf
    9. py__distribute_state_pdaf
    10. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__likelihood_pdaf : Callable[step:int, dim_obs_p:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], resid : ndarray[tuple[dim_obs_p], np.float64], likely:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **resid** : ndarray[tuple[dim_obs_p], np.float64]

            * Input vector holding the residual

        * **likely** : float

            * Output value of the likelihood

        **Callback Returns**

        * **likely** : float

            * Output value of the likelihood

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time


    Returns
    -------
    flag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.likelihood_pdaf = <void*>py__likelihood_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    cdef int flag

    c__pdaf_assimilate_netf (c__PDAFcython.c__collect_state_pdaf,
                             c__PDAFcython.c__distribute_state_pdaf,
                             c__PDAFcython.c__init_dim_obs_pdaf,
                             c__PDAFcython.c__obs_op_pdaf,
                             c__PDAFcython.c__init_obs_pdaf,
                             c__PDAFcython.c__prepoststep_pdaf,
                             c__PDAFcython.c__likelihood_pdaf,
                             c__PDAFcython.c__next_observation_pdaf,
                             &flag
                            )

    return flag

def assimilate_pf (py__collect_state_pdaf,
                   py__distribute_state_pdaf,
                   py__init_dim_obs_pdaf,
                   py__obs_op_pdaf,
                   py__init_obs_pdaf,
                   py__prepoststep_pdaf,
                   py__likelihood_pdaf,
                   py__next_observation_pdaf
                  ):
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.omi_assimilate_global` or `pyPDAF.PDAF.omi_assimilate_nonlin_nondiagR`. 
    This function will use particle filter for DA without OMI. This is a fully nonlinear filter. The function should be called at each model step. 
    
    The function is a combination of `pyPDAF.PDAF.put_state_pf` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__init_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    6. py__likelihood_pdaf
    7. core DA algorithm
    8. py__prepoststep_state_pdaf
    9. py__distribute_state_pdaf
    10. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__likelihood_pdaf : Callable[step:int, dim_obs_p:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], resid : ndarray[tuple[dim_obs_p], np.float64], likely:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **resid** : ndarray[tuple[dim_obs_p], np.float64]

            * Input vector holding the residual

        * **likely** : float

            * Output value of the likelihood

        **Callback Returns**

        * **likely** : float

            * Output value of the likelihood

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time


    Returns
    -------
    flag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.likelihood_pdaf = <void*>py__likelihood_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    cdef int flag

    c__pdaf_assimilate_pf (c__PDAFcython.c__collect_state_pdaf,
                           c__PDAFcython.c__distribute_state_pdaf,
                           c__PDAFcython.c__init_dim_obs_pdaf,
                           c__PDAFcython.c__obs_op_pdaf,
                           c__PDAFcython.c__init_obs_pdaf,
                           c__PDAFcython.c__prepoststep_pdaf,
                           c__PDAFcython.c__likelihood_pdaf,
                           c__PDAFcython.c__next_observation_pdaf,
                           &flag
                          )

    return flag

def assimilate_seek (py__collect_state_pdaf,
                     py__distribute_state_pdaf,
                     py__init_dim_obs_pdaf,
                     py__obs_op_pdaf,
                     py__init_obs_pdaf,
                     py__prepoststep_pdaf,
                     py__prodRinvA_pdaf,
                     py__next_observation_pdaf
                    ):
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.omi_assimilate_global` or `pyPDAF.PDAF.omi_assimilate_global_nondiagR`. 
    This function will use singular evolutive extended Kalman filter for DA without OMI. This is a deterministic Kalman filter. The function should be called at each model step.
    
    The function is a combination of `pyPDAF.PDAF.put_state_seek` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf (for ensemble mean
    5. py__init_obs_pdaf
    6. py__obs_op_pdaf (for each ensemble member
    7. py__prodRinvA_pdaf
    8. core DA algorithm
    9. py__prepoststep_state_pdaf
    10. py__distribute_state_pdaf
    11. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], A_p : ndarray[tuple[dim_obs_p, rank], np.float64], C_p : ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 HV

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time


    Returns
    -------
    flag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.prodRinvA_pdaf = <void*>py__prodRinvA_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    cdef int flag

    c__pdaf_assimilate_seek (c__PDAFcython.c__collect_state_pdaf,
                             c__PDAFcython.c__distribute_state_pdaf,
                             c__PDAFcython.c__init_dim_obs_pdaf,
                             c__PDAFcython.c__obs_op_pdaf,
                             c__PDAFcython.c__init_obs_pdaf,
                             c__PDAFcython.c__prepoststep_pdaf,
                             c__PDAFcython.c__prodRinvA_pdaf,
                             c__PDAFcython.c__next_observation_pdaf,
                             &flag
                            )

    return flag

def assimilate_seik (py__collect_state_pdaf,
                     py__distribute_state_pdaf,
                     py__init_dim_obs_pdaf,
                     py__obs_op_pdaf,
                     py__init_obs_pdaf,
                     py__prepoststep_pdaf,
                     py__prodRinvA_pdaf,
                     py__next_observation_pdaf
                    ):
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.omi_assimilate_global` or `pyPDAF.PDAF.omi_assimilate_nonlin_nondiagR`. 
    This function will use singular evolutive interpolated Kalman filter for DA without OMI. The function should be called at each model step.
    
    The function is a combination of `pyPDAF.PDAF.put_state_seik` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf (for ensemble mean
    5. py__init_obs_pdaf
    6. py__obs_op_pdaf (for each ensemble member
    7. py__init_obsvar_pdaf (only relevant for adaptive forgetting factor schemes)
    8. py__prodRinvA_pdaf
    9. core DA algorithm
    10. py__prepoststep_state_pdaf
    11. py__distribute_state_pdaf
    12. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], A_p : ndarray[tuple[dim_obs_p, rank], np.float64], C_p : ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 HV

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time


    Returns
    -------
    flag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.prodRinvA_pdaf = <void*>py__prodRinvA_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    cdef int flag

    c__pdaf_assimilate_seik (c__PDAFcython.c__collect_state_pdaf,
                             c__PDAFcython.c__distribute_state_pdaf,
                             c__PDAFcython.c__init_dim_obs_pdaf,
                             c__PDAFcython.c__obs_op_pdaf,
                             c__PDAFcython.c__init_obs_pdaf,
                             c__PDAFcython.c__prepoststep_pdaf,
                             c__PDAFcython.c__prodRinvA_pdaf,
                             c__PDAFcython.c__next_observation_pdaf,
                             &flag
                            )

    return flag

def assimilate_prepost (py__collect_state_pdaf,
                        py__distribute_state_pdaf,
                        py__prepoststep_pdaf,
                        py__next_observation_pdaf
                       ):
    """This function does not perform any DA. It is used to perform a preprocess and postprocess of the ensemble. Compared to `pyPDAF.PDAF.prepost`, this function sets assimilation flag.
    The function is a combination of `pyPDAF.PDAF.put_state_prepost` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf (preprocess, step < 0)
    3. py__prepoststep_state_pdaf (postprocess, step > 0
    4. py__distribute_state_pdaf
    5. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time


    Returns
    -------
    flag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    cdef int flag

    c__pdaf_assimilate_prepost (c__PDAFcython.c__collect_state_pdaf,
                                c__PDAFcython.c__distribute_state_pdaf,
                                c__PDAFcython.c__prepoststep_pdaf,
                                c__PDAFcython.c__next_observation_pdaf,
                                &flag
                               )

    return flag

def deallocate ():
    """This function finalise the PDAF systems including deaclloating all arrays in PDAF.

    """

    c__pdaf_deallocate ()

def diag_effsample (double[::1] weights
                   ):
    """This function calculates the effective sample size of a particle filter as defined in Doucet et al. 2001 p. 333.
    It is defined as the inverse of the sum of the squared particle filter weights. If the `n_eff=dim_sample`, all weights are identical, the filter has no influence. If `n_eff=0`, the filter is collapsed. This is typically called during the analysis step of a particle filter, e.g. in the analysis step of NETF and LNETF.

    Parameters
    ----------
    weights : ndarray[tuple[dim_sample], np.float64]
        weights of the samples

    Returns
    -------
    effSample : float
        effecfive sample size
    """

    cdef int dim_sample
    dim_sample = weights.shape[0]

    cdef double effSample

    c__pdaf_diag_effsample (&dim_sample,
                            &weights[0],
                            &effSample
                           )

    return effSample

def diag_ensstats (int element,
                   double[::1] state,
                   double[:,:] ens
                  ):
    """This function returns the skewness and kurtosis of the ensemble of a given element of the state vector. The definition used for kurtosis follows that used by Lawson and Hansen, Mon. Wea. Rev. 132 (2004) 1966
    

    Parameters
    ----------
    element : int
        Index of state vector/ensemble element to be used. If element=0, mean values over all elements are computed
    state : ndarray[tuple[dim], np.float64]
        State vector (typically ensemble mean)
    ens : ndarray[tuple[dim, dim_ens], np.float64]
        State ensemble

    Returns
    -------
    skewness : float
        Skewness of ensemble
    kurtosis : float
        Kurtosis of ensemble
    status : int
        Status flag (0=success)
    """

    cdef double[::1] ens_f = np.asfortranarray(ens).ravel(order="F")
    cdef int dim, dim_ens
    dim = ens.shape[0]
    dim_ens = ens.shape[1]

    cdef double skewness
    cdef double kurtosis
    cdef int status

    c__pdaf_diag_ensstats (&dim,
                           &dim_ens,
                           &element,
                           &state[0],
                           &ens_f[0],
                           &skewness,
                           &kurtosis,
                           &status
                          )

    return skewness, kurtosis, status

def diag_histogram (int ncall,
                    int element,
                    double[::1] state,
                    double[:,:] ens,
                    int[::1] hist
                   ):
    """This function returns a rank histogram of the ensemble. A rank histogram is used to diagnose the reliability of the ensemble. A perfectly reliable ensemble should have a uniform rank histogram. The function can be called in the pre/poststep routine of PDAF both before and after the analysis step to collect the histogram information.

    Parameters
    ----------
    ncall : int
        The number of calls used to increment the histogram and is needed to compute the delta-measure that describes the deviation from the ideal histogram.
    element : int
        Element of vector used for histogram. If element=0, all elements are used
    state : ndarray[tuple[dim], np.float64]
        Assumed truth
    ens : ndarray[tuple[dim, dim_ens], np.float64]
        Ensemble
    hist : ndarray[tuple[dim_ens+1], np.intc]
        Histogram about the state

    Returns
    -------
    hist : ndarray[tuple[dim_ens+1], np.intc]
         Histogram about the state
    delta : float
        deviation measure from flat histogram. It must be initialised to be 0
    status : int
        Status flag (0=success)
    """

    cdef double[::1] ens_f = np.asfortranarray(ens).ravel(order="F")
    cdef int dim, dim_ens
    dim = ens.shape[0]
    dim_ens = ens.shape[1]

    cdef double delta
    cdef int status

    c__pdaf_diag_histogram (&ncall,
                            &dim,
                            &dim_ens,
                            &element,
                            &state[0],
                            &ens_f[0],
                            &hist[0],
                            &delta,
                            &status
                           )

    return np.asarray(hist).reshape((dim_ens+1), order='F'), delta, status

def eofcovar (int[::1] dim_fields,
              int[::1] offsets,
              int remove_mstate,
              int do_mv,
              double[:,:] states,
              double[::1] meanstate,
              int verbose
             ):
    """EOF analysis of a state vectors at multiple time steps by singular value decomposition.

    Typically, this function is used with :func:`pyPDAF.PDAF.sampleens`
    to generate an ensemble of a chosen size 
    (up to the number of EOFs plus one).

    Here, the function performs a singular value decomposition of the ensemble anomaly of the input matrix,
    which is an ensemble formed by state vectors at multiple time steps.
    The singular values and corresponding singular vectors can be used to
    construct an error covariance matrix.
    This can be used as the initial error covariance for the initial ensemble.

    A multivariate scaling can be performed to ensure that all fields in the state vectors have unit variance.

    It can be useful to store more EOFs than one finally
    might want to use to have the flexibility to cary the ensemble size.

    See also `PDAF webpage <https://pdaf.awi.de/trac/wiki/EnsembleGeneration>`_

    Parameters
    ----------
    dim_fields : ndarray[tuple[nfields], np.intc]
        Size of each field, only used when `do_mv = 1`. Each field could be 2D or 3D so can have different sizes.
    offsets : ndarray[tuple[nfields], np.intc]
        Start position of each field.
        This variable is used only used when `do_mv = 1`.
        For example, if the state vector contains temperature and humidity, this array specifies the starting index of the two physical fields.
        The offset values start from 1.
    remove_mstate : int
        Subtract mean state from states (average over nstates dimension) before computing EOFs (`remove_mstate = 1`) or don't remove (`remove_mstate = 0`)
    do_mv : int
        Do multivariate scaling (`do_mv = 1`) or no scaling (`do_mv = 0`). Variable `nfields`, `dim_fields` and `offsets` are only used if `do_mv=1`.
    states : ndarray[tuple[dim_state, nstates], np.float64]
        State perturbations or an ensemble of state vectors
    meanstate : ndarray[tuple[dim_state], np.float64]
        Mean state (only changed if `remove_mstate=1`)
    verbose : int
        Verbosity flag

    Returns
    -------
    states : ndarray[tuple[dim_state, nstates], np.float64]
         State perturbations or an ensemble of state vectors
    stddev : ndarray[tuple[nfields], np.float64]
         Standard deviation of field variability. Without multivariate scaling (`do_mv=0`), it is `stddev = 1.0`.
    svals : ndarray[tuple[nstates], np.float64]
         Singular values scaled by `1/sqrt(nstates-1)`.
    svec : ndarray[tuple[dim_state, nstates], np.float64]
         Singular vectors
    meanstate : ndarray[tuple[dim_state], np.float64]
         Mean state (only changed if `remove_mstate=1`)
    status : int
        Status flag
    """

    cdef double[::1] states_f = np.asfortranarray(states).ravel(order="F")
    cdef int nfields, dim_state, nstates
    dim_state = states.shape[0]
    nstates = states.shape[1]
    nfields = dim_fields.shape[0]

    cdef double [::1] stddev = np.zeros((nfields), dtype=np.float64).ravel()
    cdef double [::1] svals = np.zeros((nstates), dtype=np.float64).ravel()
    cdef double [::1] svec = np.zeros((dim_state, nstates), dtype=np.float64).ravel()
    cdef int status

    c__pdaf_eofcovar (&dim_state,
                      &nstates,
                      &nfields,
                      &dim_fields[0],
                      &offsets[0],
                      &remove_mstate,
                      &do_mv,
                      &states_f[0],
                      &stddev[0],
                      &svals[0],
                      &svec[0],
                      &meanstate[0],
                      &verbose,
                      &status
                     )

    return np.asarray(states).reshape((dim_state, nstates), order='F'), np.asarray(stddev).reshape((nfields), order='F'), np.asarray(svals).reshape((nstates), order='F'), np.asarray(svec).reshape((dim_state, nstates), order='F'), np.asarray(meanstate).reshape((dim_state), order='F'), status

def gather_dim_obs_f (int dim_obs_p
                     ):
    """In the local filters (LESKTF, LETKF, LSEIK, LNETF) this function returns the total observation dimension from process-local observation dimensions. The function has to be called once before using any of the functions `pyPDAF.PDAF.gather_obs_f` or `pyPDAF.PDAF.gather_obs_f2`.
    This is because it stores the information on the process-local observation dimensions to allocate actual observation vectors. The routine is typically used in the routine `py__init_dim_obs_f_pdaf` if the analysis step of the local filters is parallelized.

    Parameters
    ----------
    dim_obs_p : int
        PE-local observation dimension

    Returns
    -------
    dim_obs_f : int
        Full observation dimension
    """

    cdef int dim_obs_f

    c__pdaf_gather_dim_obs_f (&dim_obs_p,
                              &dim_obs_f
                             )

    return dim_obs_f

def gather_obs_f (double[::1] obs_p,
                  int dimobs_f
                 ):
    """In the local filters (LESKTF, LETKF, LSEIK, LNETF) this function returns the total observation vector from process-local observations. The function depends on `pyPDAF.PDAF.gather_dim_obs_f` which defines the process-local observation dimensions. Further, the related routine `pyPDAF.PDAF.gather_obs_f2` is used to
    gather the associated 2D observation coordinates
    

    Parameters
    ----------
    obs_p : ndarray[tuple[dimobs_p], np.float64]
        PE-local vector
    dimobs_f : int
        dimension of full gathered obs

    Returns
    -------
    obs_f : ndarray[tuple[dimobs_f], np.float64]
         Full gathered vector
    status : int
        Status flag: (0) no error; (1) when PDAF_gather_dim_obs_f not executed before
    """

    cdef int dimobs_p
    dimobs_p = obs_p.shape[0]

    cdef double [::1] obs_f = np.zeros((dimobs_f), dtype=np.float64).ravel()
    cdef int status

    c__pdaf_gather_obs_f (&obs_p[0],
                          &dimobs_p,
                          &obs_f[0],
                          &dimobs_f,
                          &status
                         )

    return np.asarray(obs_f).reshape((dimobs_f), order='F'), status

def gather_obs_f2 (double[:,:] coords_p,
                   int dimobs_f
                  ):
    """In the local filters (LESKTF, LETKF, LSEIK, LNETF)
    this function returns the full observation coordinates from process-local observation coordinates. The function depends on `pyPDAF.PDAF.gather_dim_obs_f` which defines the process-local observation dimensions. Further, the related routine `pyPDAF.PDAF.gather_obs_f` is used to gather the associated observation vectors. 
    
    The routine is typically used in the routines `py__init_dim_obs_f_pdaf` if the analysis step of the local filters is parallelized.

    Parameters
    ----------
    coords_p : ndarray[tuple[nrows, dimobs_p], np.float64]
        PE-local array
    dimobs_f : int
        dimension of full gathered obs

    Returns
    -------
    coords_f : ndarray[tuple[nrows, dimobs_f], np.float64]
         Full gathered array
    status : int
        Status flag: (0) no error; (1) when PDAF_gather dim_obs_f not executed before
    """

    cdef double[::1] coords_p_f = np.asfortranarray(coords_p).ravel(order="F")
    cdef int nrows, dimobs_p
    nrows = coords_p.shape[0]
    dimobs_p = coords_p.shape[1]

    cdef double [::1] coords_f = np.zeros((nrows, dimobs_f), dtype=np.float64).ravel()
    cdef int status

    c__pdaf_gather_obs_f2 (&coords_p_f[0],
                           &dimobs_p,
                           &coords_f[0],
                           &dimobs_f,
                           &nrows,
                           &status
                          )

    return np.asarray(coords_f).reshape((nrows, dimobs_f), order='F'), status

def generate_obs (py__collect_state_pdaf,
                  py__distribute_state_pdaf,
                  py__init_dim_obs_pdaf,
                  py__obs_op_pdaf,
                  py__get_obs_f_pdaf,
                  py__init_obserr_f_pdaf,
                  py__prepoststep_pdaf,
                  py__next_observation_pdaf
                 ):
    """When diagonal observation error covariance matrix is used, it is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.omi_generate_obs`. 
    This function generates synthetic observations based on each member of model forecast. This is based on the usual implementation strategy for PDAF.
    
    The function is a combination of `pyPDAF.PDAF.put_state_generate_obs` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pda
    5. py__init_obserr_f_pdaf
    6. py__get_obs_f_pdaf
    7. py__prepoststep_state_pdaf
    8. py__distribute_state_pdaf
    9. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__get_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f : ndarray[tuple[dim_obs_f], np.float64]]
        Provide observation vector to user

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_f** : int

            * Size of the full observation vector

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of synthetic observations (process-local)

        **Callback Returns**

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of synthetic observations (process-local)

    py__init_obserr_f_pdaf : Callable[step:int, dim_obs_f:int, obs_f : ndarray[tuple[dim_obs_f], np.float64], obserr_f : ndarray[tuple[dim_obs_f], np.float64]]
        Initialize vector of observation error standard deviations

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_f** : int

            * Full dimension of observation vector

        * **obs_f** : ndarray[tuple[dim_obs_f], np.float64]

            * Full observation vector

        * **obserr_f** : ndarray[tuple[dim_obs_f], np.float64]

            * Full observation error stddev

        **Callback Returns**

        * **obserr_f** : ndarray[tuple[dim_obs_f], np.float64]

            * Full observation error stddev

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time


    Returns
    -------
    flag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.get_obs_f_pdaf = <void*>py__get_obs_f_pdaf
    c__PDAFcython.init_obserr_f_pdaf = <void*>py__init_obserr_f_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    cdef int flag

    c__pdaf_generate_obs (c__PDAFcython.c__collect_state_pdaf,
                          c__PDAFcython.c__distribute_state_pdaf,
                          c__PDAFcython.c__init_dim_obs_pdaf,
                          c__PDAFcython.c__obs_op_pdaf,
                          c__PDAFcython.c__get_obs_f_pdaf,
                          c__PDAFcython.c__init_obserr_f_pdaf,
                          c__PDAFcython.c__prepoststep_pdaf,
                          c__PDAFcython.c__next_observation_pdaf,
                          &flag
                         )

    return flag

def get_assim_flag ():
    """This function returns the flag that indicates if the DA is performed in the last time step. It only works for online DA systems. 


    Returns
    -------
    did_assim : int
        Flag: (1) for assimilation; (0) else
    """

    cdef int did_assim

    c__pdaf_get_assim_flag (&did_assim
                           )

    return did_assim

def get_ensstats ():
    """This is a diagnotics function for LKNETF which returns the skewness and kutosis used there. 


    Returns
    -------
    dims : ndarray[tuple[1], np.intc]
         dimension of pointer
    c_skew_ptr : ndarray[float]
        Skewness array
    c_kurt_ptr : ndarray[float]
        kurtosis array
    status : int
        Status flag
    """

    cdef int [::1] dims = np.zeros((1), dtype=np.intc).ravel()
    cdef double* c_skew_ptr
    cdef double* c_kurt_ptr
    cdef int status

    c__pdaf_get_ensstats (&dims[0],
                          &c_skew_ptr,
                          &c_kurt_ptr,
                          &status
                         )

    dims = np.asarray(dims)
    return np.asarray(<double[:np.prod(dims)]> c_skew_ptr).reshape(dims, order='F'), \
           np.asarray(<double[:np.prod(dims)]> c_kurt_ptr).reshape(dims, order='F'), \
           status

def get_localfilter ():
    """This function returns whether a local filter is used. 


    Returns
    -------
    lfilter : int
        Whether the filter is domain-localized (1) or not (0)
    """

    cdef int lfilter

    c__pdaf_get_localfilter (&lfilter
                            )

    return lfilter

def get_memberid (int memberid
                 ):
    """This function returns the ensemble member id on the current process. 
    For example, it can be called during the ensemble integration if ensemble-specific forcing is applied. It can also be used in the user-supplied functions such as `py__collect_state_pdaf` and `py__distribute_state_pdaf`.

    Parameters
    ----------
    memberid : int
        Index in the local ensemble

    Returns
    -------
    memberid : int
        Index in the local ensemble
    """

    c__pdaf_get_memberid (&memberid
                         )

    return memberid

def get_obsmemberid (int memberid
                    ):
    """This function returns the ensemble member id when observation operator is being applied. 
    This function is used specifically for user-supplied function `py__obs_op_pdaf`.

    Parameters
    ----------
    memberid : int
        Index in the local observed ensemble

    Returns
    -------
    memberid : int
        Index in the local observed ensemble
    """

    c__pdaf_get_obsmemberid (&memberid
                            )

    return memberid

def get_smootherens ():
    """This function returns the smoothed ensemble in earlier time steps. It is only used when the smoother options is used .


    Returns
    -------
    c_sens_point : ndarray[float]
        A smoother array
    maxlag : int
        Number of past timesteps processed in sens
    dims : ndarray[tuple[3], np.intc]
         dimension of pointer
    status : int
        Status flag
    """

    cdef double* c_sens_point
    cdef int maxlag
    cdef int [::1] dims = np.zeros((3), dtype=np.intc).ravel()
    cdef int status

    c__pdaf_get_smootherens (&c_sens_point,
                             &maxlag,
                             &dims[0],
                             &status
                            )

    dims = np.asarray(dims)
    return np.asarray(<double[:np.prod(dims)]> c_sens_point).reshape(dims, order='F'), \
           maxlag, status

def get_state (int steps,
               int doexit,
               py__next_observation_pdaf,
               py__distribute_state_pdaf,
               py__prepoststep_pdaf,
               int flag
              ):
    """Post-processing the analysis and distributing state vector back to the model.

    This function also sets the next model step for assimilation, or end the entire assimilation.

    The function executes the user-supplied function in the following sequence:

    1. py__prepoststep_state_pdaf

    2. py__distribute_state_pdaf

    3. py__next_observation_pdaf

    Parameters
    ----------
    steps : int
        Flag and number of time steps
    doexit : int
        Whether to exit from forecasts
    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    flag : int
        Status flag

    Returns
    -------
    steps : int
        Flag and number of time steps
    time : float
        current model time
    doexit : int
        Whether to exit from forecasts
    flag : int
        Status flag
    """

    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf

    cdef double time

    c__pdaf_get_state (&steps,
                       &time,
                       &doexit,
                       c__PDAFcython.c__next_observation_pdaf,
                       c__PDAFcython.c__distribute_state_pdaf,
                       c__PDAFcython.c__prepoststep_pdaf,
                       &flag
                      )

    return steps, time, doexit, flag

def init (int filtertype,
          int subtype,
          int stepnull,
          int[::1] param_int,
          double[::1] param_real,
          int COMM_model,
          int COMM_filter,
          int COMM_couple,
          int task_id,
          int n_modeltasks,
          bint in_filterpe,
          py__init_ens_pdaf,
          int in_screen
         ):
    """This function initialises the PDAF system. It is called once at the beginning of the assimilation. The function specifies the type of DA methods, parameters of the filters, the MPI communicators, and other parallel options.The function also provides an initial ensemble to the PDAF system by the user-supplied function which can be distribute to the model by `pyPDAF.PDAF.get_state`. 
    For the options and parameters of DA methods, check the `PDAF introduction page <https://pdaf.awi.de/trac/wiki/AvailableOptionsforInitPDAF.>` 
    The parallisation module in the repository example can be used directly for most cases. Explanation of the parallelisation strategy in PDAF can be found in https://pdaf.awi.de/trac/wiki/ImplementationConceptOnline#Parallelizationofthedataassimilationprogram and https://pdaf.awi.de/trac/wiki/AdaptParallelization

    Parameters
    ----------
    filtertype : int
        Type of filter
    subtype : int
        Sub-type of filter
    stepnull : int
        Initial time step of assimilation
    param_int : ndarray[tuple[dim_pint], np.intc]
        Integer parameter array
    param_real : ndarray[tuple[dim_preal], np.float64]
        Real parameter array
    COMM_model : int
        Model communicator
    COMM_filter : int
        Filter communicator
    COMM_couple : int
        Coupling communicator
    task_id : int
        Id of my ensemble task
    n_modeltasks : int
        Number of parallel model tasks
    in_filterpe : bool
        Is my PE a filter-PE?
    py__init_ens_pdaf : Callable[filtertype:int, dim_p:int, dim_ens:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User-supplied routine for ensemble initialization

        **Callback Parameters**

        * **filtertype** : int

            * type of filter to initialize

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of ensemble

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local model state

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * array not referenced for ensemble filters

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local model state

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * array not referenced for ensemble filters

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

    in_screen : int
        Control screen output:

    Returns
    -------
    param_int : ndarray[tuple[dim_pint], np.intc]
         Integer parameter array
    param_real : ndarray[tuple[dim_preal], np.float64]
         Real parameter array
    flag : int
        Status flag, 0: no error, error codes:
    """

    cdef int dim_pint, dim_preal
    dim_pint = param_int.shape[0]
    dim_preal = param_real.shape[0]

    c__PDAFcython.init_ens_pdaf = <void*>py__init_ens_pdaf
    c__PDAFcython.init_ens_pdaf_single_member = <void*>py__init_ens_pdaf

    cdef int flag

    if (filtertype == 0) or (filtertype == 200 and subtype == 0):
        c__pdaf_init (&filtertype, &subtype, &stepnull,
                      &param_int[0], &dim_pint,
                      &param_real[0], &dim_preal,
                      &COMM_model, &COMM_filter, &COMM_couple,
                      &task_id, &n_modeltasks, &in_filterpe,
                      c__PDAFcython.c__init_ens_pdaf_single_member,
                      &in_screen, &flag)
    else:
        c__pdaf_init (&filtertype,
                      &subtype,
                      &stepnull,
                      &param_int[0],
                      &dim_pint,
                      &param_real[0],
                      &dim_preal,
                      &COMM_model,
                      &COMM_filter,
                      &COMM_couple,
                      &task_id,
                      &n_modeltasks,
                      &in_filterpe,
                      c__PDAFcython.c__init_ens_pdaf,
                      &in_screen,
                      &flag
                     )

    return np.asarray(param_int).reshape((dim_pint), order='F'), np.asarray(param_real).reshape((dim_preal), order='F'), flag

def local_weight (int wtype,
                  int rtype,
                  double cradius,
                  double sradius,
                  double distance,
                  double[:,:] A,
                  double var_obs,
                  int verbose
                 ):
    """The function is used for localisation in the analysis step of a filter and computes a weight according to the specified distance and the settings for the localising function. Typically the function is called in `py__prodRinvA_l_pdaf` in the domain-localised filters. Also, the function is typically called for the LEnKF in the `py__localize_covar_pdaf`. 
    This function is usually only used in user-codes that do not use PDAF-OMI.

    Parameters
    ----------
    wtype : int
        Type of weight function
    rtype : int
        Type of regulated weighting
    cradius : float
        Cut-off radius (check `PDAF-OMI wiki <https://pdaf.awi.de/trac/wiki/OMI_observation_modules#init_dim_obs_l_OBSTYPE>`_)
    sradius : float
        Support radius (check `PDAF-OMI wiki <https://pdaf.awi.de/trac/wiki/OMI_observation_modules#init_dim_obs_l_OBSTYPE>`_)
    distance : float
        Distance to observation
    A : ndarray[tuple[nrows, ncols], np.float64]
        Input matrix
    var_obs : float
        Observation variance
    verbose : int
        Verbosity flag

    Returns
    -------
    weight : float
        Weights
    """

    cdef double[::1] A_f = np.asfortranarray(A).ravel(order="F")
    cdef int nrows, ncols
    nrows = A.shape[0]
    ncols = A.shape[1]

    cdef double weight

    c__pdaf_local_weight (&wtype,
                          &rtype,
                          &cradius,
                          &sradius,
                          &distance,
                          &nrows,
                          &ncols,
                          &A_f[0],
                          &var_obs,
                          &weight,
                          &verbose
                         )

    return weight

def print_info (int printtype
               ):
    """This function prints the wallclock time and memory measured by PDAF. This is called at the end of the DA program. 
    The function displays the following information: 
    - Memory required for the ensemble array, state vector, and transform matrix- Memory required by the analysis step- Memory required to perform the ensemble transformation

    Parameters
    ----------
    printtype : int
        - X=1: Basic timers - X=3: Timers showing the time spent int he different call-back routines (this variant was added with PDAF 1.15) - X=4: More detailed timers about parts of the filter algorithm (before PDAF 1.15, this was timer level 3) - X=5: Very detailed timers about various operations in the filter algorithm (before PDAF 1.15, this was timer level 4)
    """

    c__pdaf_print_info (&printtype
                       )

def put_state_3dvar (py__collect_state_pdaf,
                     py__init_dim_obs_pdaf,
                     py__obs_op_pdaf,
                     py__init_obs_pdaf,
                     py__prodRinvA_pdaf,
                     py__cvt_pdaf,
                     py__cvt_adj_pdaf,
                     py__obs_op_lin_pdaf,
                     py__obs_op_adj_pdaf,
                     py__prepoststep_pdaf
                    ):
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency.
    I.e., `pyPDAF.PDAF.omi_put_state_global` or `pyPDAF.PDAF.omi_put_state_global_nondiagR`. 
    Using 3DVar for DA without post-processing and analysis distribution to forecsat without OMI.
    This is a deterministic filtering scheme. This function is usually used in 'flexible' parallelisation, but 3dvar is deterministic and does not require ensemble.
    A `pyPDAF.PDAF.get_state` function should be used to post-process the state vector and distribute the state vector to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    5. py__init_obs_pdaf
    Starting the iterative optimisation:
    6. py__cvt_pdaf
    7. py__obs_op_lin_pdaf
    8. py__prodRinvA_pdaf
    9. py__obs_op_adj_pdaf
    10. py__cvt_adj_pdaf
    11. core DA algorithm
    After the iterations: 
    12. py__cvt_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], A_p : ndarray[tuple[dim_obs_p, rank], np.float64], C_p : ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p : ndarray[tuple[dim_cvec], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble


    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.prodRinvA_pdaf = <void*>py__prodRinvA_pdaf
    c__PDAFcython.cvt_pdaf = <void*>py__cvt_pdaf
    c__PDAFcython.cvt_adj_pdaf = <void*>py__cvt_adj_pdaf
    c__PDAFcython.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    c__PDAFcython.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf

    cdef int outflag

    c__pdaf_put_state_3dvar (c__PDAFcython.c__collect_state_pdaf,
                             c__PDAFcython.c__init_dim_obs_pdaf,
                             c__PDAFcython.c__obs_op_pdaf,
                             c__PDAFcython.c__init_obs_pdaf,
                             c__PDAFcython.c__prodRinvA_pdaf,
                             c__PDAFcython.c__cvt_pdaf,
                             c__PDAFcython.c__cvt_adj_pdaf,
                             c__PDAFcython.c__obs_op_lin_pdaf,
                             c__PDAFcython.c__obs_op_adj_pdaf,
                             c__PDAFcython.c__prepoststep_pdaf,
                             &outflag
                            )

    return outflag

def put_state_en3dvar_estkf (py__collect_state_pdaf,
                             py__init_dim_obs_pdaf,
                             py__obs_op_pdaf,
                             py__init_obs_pdaf,
                             py__prodRinvA_pdaf,
                             py__cvt_ens_pdaf,
                             py__cvt_adj_ens_pdaf,
                             py__obs_op_lin_pdaf,
                             py__obs_op_adj_pdaf,
                             py__init_obsvar_pdaf,
                             py__prepoststep_pdaf
                            ):
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency.
    I.e., `pyPDAF.PDAF.omi_put_state_en3dvar_estkf` or `pyPDAF.PDAF.omi_put_state_en3dvar_estkf_nondiagR`. 
    
    
    Using 3DEnVar for DA without post-processing and analysis distribution to forecsat without OMI.
    The background error covariance matrix is estimated by ensemble. The 3DEnVar only calculates the analysis of the ensemble mean.
    An ESTKF is used to generate ensemble perturbations. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    5. py__init_obs_pdaf
    Starting the iterative optimisation:
    6. py__cvt_ens_pdaf
    7. py__obs_op_lin_pdaf
    8. py__prodRinvA_pdaf
    9. py__obs_op_adj_pdaf
    10. py__cvt_adj_ens_pdaf
    11. core 3DEnVar algorithm
    After the iterations: 
    12. py__cvt_ens_pdaf
    Perform ESTKF: 13. py__init_dim_obs_pdaf
    14. py__obs_op_pdaf (for ensemble mean
    15. py__init_obs_pdaf
    16. py__obs_op_pdaf (for each ensemble member
    17. py__init_obsvar_pdaf (only relevant for adaptive forgetting factor schemes)
    18. py__prodRinvA_pdaf
    19. core ESTKF algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], A_p : ndarray[tuple[dim_obs_p, rank], np.float64], C_p : ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], v_p : ndarray[tuple[dim_cvec_ens], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_ens** : int

            * Ensemble size

        * **dim_cvec_ens** : int

            * Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_ens** : int

            * Ensemble size

        * **dim_cv_ens_p** : int

            * PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **meanvar** : float

            * Mean observation error variance

        **Callback Returns**

        * **meanvar** : float

            * Mean observation error variance

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble


    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.prodRinvA_pdaf = <void*>py__prodRinvA_pdaf
    c__PDAFcython.cvt_ens_pdaf = <void*>py__cvt_ens_pdaf
    c__PDAFcython.cvt_adj_ens_pdaf = <void*>py__cvt_adj_ens_pdaf
    c__PDAFcython.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    c__PDAFcython.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    c__PDAFcython.init_obsvar_pdaf = <void*>py__init_obsvar_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf

    cdef int outflag

    c__pdaf_put_state_en3dvar_estkf (c__PDAFcython.c__collect_state_pdaf,
                                     c__PDAFcython.c__init_dim_obs_pdaf,
                                     c__PDAFcython.c__obs_op_pdaf,
                                     c__PDAFcython.c__init_obs_pdaf,
                                     c__PDAFcython.c__prodRinvA_pdaf,
                                     c__PDAFcython.c__cvt_ens_pdaf,
                                     c__PDAFcython.c__cvt_adj_ens_pdaf,
                                     c__PDAFcython.c__obs_op_lin_pdaf,
                                     c__PDAFcython.c__obs_op_adj_pdaf,
                                     c__PDAFcython.c__init_obsvar_pdaf,
                                     c__PDAFcython.c__prepoststep_pdaf,
                                     &outflag
                                    )

    return outflag

def put_state_en3dvar_lestkf (py__collect_state_pdaf,
                              py__init_dim_obs_pdaf,
                              py__obs_op_pdaf,
                              py__init_obs_pdaf,
                              py__prodRinvA_pdaf,
                              py__cvt_ens_pdaf,
                              py__cvt_adj_ens_pdaf,
                              py__obs_op_lin_pdaf,
                              py__obs_op_adj_pdaf,
                              py__init_dim_obs_f_pdaf,
                              py__obs_op_f_pdaf,
                              py__init_obs_f_pdaf,
                              py__init_obs_l_pdaf,
                              py__prodRinvA_l_pdaf,
                              py__init_n_domains_p_pdaf,
                              py__init_dim_l_pdaf,
                              py__init_dim_obs_l_pdaf,
                              py__g2l_state_pdaf,
                              py__l2g_state_pdaf,
                              py__g2l_obs_pdaf,
                              py__init_obsvar_pdaf,
                              py__init_obsvar_l_pdaf,
                              py__prepoststep_pdaf
                             ):
    """It is recommended to use local module with OMI functionalities for fewer user-supplied functions and improved efficiency.
    I.e., `pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf` or `pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf_nondiagR`. 
    
    
    Using 3DEnVar for DA without post-processing and analysis distribution to forecsat without OMI.
    The background error covariance matrix is estimated by ensemble. The 3DEnVar only calculates the analysis of the ensemble mean.
    An LESTKF is used to generate ensemble perturbations. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    5. py__init_obs_pdaf
    Starting the iterative optimisation:
    6. py__cvt_ens_pdaf
    7. py__obs_op_lin_pdaf
    8. py__prodRinvA_pdaf
    9. py__obs_op_adj_pdaf
    10. py__cvt_adj_ens_pdaf
    11. core DA algorithm
    After the iterations: 
    12. py__cvt_ens_pdaf
    Perform LESTKF: 
    13. py__init_n_domains_p_pdaf
    14. py__init_dim_obs_pdaf
    15. py__obs_op_pdaf (for each ensemble member
    16. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init
    17. py__init_obsvar_pdaf (if global adaptive forgetting factor is used
    loop over each local domain:
    18. py__init_dim_l_pdaf
    19. py__init_dim_obs_l_pdaf
    20. py__g2l_state_pdaf
    21. py__g2l_obs_pdaf (localise mean ensemble in observation space)
    22. py__init_obs_l_pdaf
    23. py__g2l_obs_pdaf (localise each ensemble member in observation space
    24. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used
    25. py__prodRinvA_pdaf
    26. core DA algorithm
    27. py__l2g_state_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], A_p : ndarray[tuple[dim_obs_p, rank], np.float64], C_p : ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], v_p : ndarray[tuple[dim_cvec_ens], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_ens** : int

            * Ensemble size

        * **dim_cvec_ens** : int

            * Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_ens** : int

            * Ensemble size

        * **dim_cv_ens_p** : int

            * PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f : ndarray[tuple[dim_obs_f], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_f** : int

            * Size of the full observation vector

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of observations

        **Callback Returns**

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of observations

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l : ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], A_l : ndarray[tuple[dim_obs_l, rank], np.float64], C_l : ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p : ndarray[tuple[dim_p], np.float64], dim_l:int, state_l : ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l : ndarray[tuple[dim_l], np.float64], dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f : ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l : ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_f** : int

            * Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            * Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * **dim_p** : int

            * Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * **dim_l** : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **meanvar** : float

            * Mean observation error variance

        **Callback Returns**

        * **meanvar** : float

            * Mean observation error variance

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * **dim_obs_p** : int

            * Dimension of local observation vector

        * **meanvar_l** : float

            * Mean local observation error variance

        **Callback Returns**

        * **meanvar_l** : float

            * Mean local observation error variance

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble


    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.prodRinvA_pdaf = <void*>py__prodRinvA_pdaf
    c__PDAFcython.cvt_ens_pdaf = <void*>py__cvt_ens_pdaf
    c__PDAFcython.cvt_adj_ens_pdaf = <void*>py__cvt_adj_ens_pdaf
    c__PDAFcython.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    c__PDAFcython.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    c__PDAFcython.init_dim_obs_f_pdaf = <void*>py__init_dim_obs_f_pdaf
    c__PDAFcython.obs_op_f_pdaf = <void*>py__obs_op_f_pdaf
    c__PDAFcython.init_obs_f_pdaf = <void*>py__init_obs_f_pdaf
    c__PDAFcython.init_obs_l_pdaf = <void*>py__init_obs_l_pdaf
    c__PDAFcython.prodRinvA_l_pdaf = <void*>py__prodRinvA_l_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.g2l_state_pdaf = <void*>py__g2l_state_pdaf
    c__PDAFcython.l2g_state_pdaf = <void*>py__l2g_state_pdaf
    c__PDAFcython.g2l_obs_pdaf = <void*>py__g2l_obs_pdaf
    c__PDAFcython.init_obsvar_pdaf = <void*>py__init_obsvar_pdaf
    c__PDAFcython.init_obsvar_l_pdaf = <void*>py__init_obsvar_l_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf

    cdef int outflag

    c__pdaf_put_state_en3dvar_lestkf (c__PDAFcython.c__collect_state_pdaf,
                                      c__PDAFcython.c__init_dim_obs_pdaf,
                                      c__PDAFcython.c__obs_op_pdaf,
                                      c__PDAFcython.c__init_obs_pdaf,
                                      c__PDAFcython.c__prodRinvA_pdaf,
                                      c__PDAFcython.c__cvt_ens_pdaf,
                                      c__PDAFcython.c__cvt_adj_ens_pdaf,
                                      c__PDAFcython.c__obs_op_lin_pdaf,
                                      c__PDAFcython.c__obs_op_adj_pdaf,
                                      c__PDAFcython.c__init_dim_obs_f_pdaf,
                                      c__PDAFcython.c__obs_op_f_pdaf,
                                      c__PDAFcython.c__init_obs_f_pdaf,
                                      c__PDAFcython.c__init_obs_l_pdaf,
                                      c__PDAFcython.c__prodRinvA_l_pdaf,
                                      c__PDAFcython.c__init_n_domains_p_pdaf,
                                      c__PDAFcython.c__init_dim_l_pdaf,
                                      c__PDAFcython.c__init_dim_obs_l_pdaf,
                                      c__PDAFcython.c__g2l_state_pdaf,
                                      c__PDAFcython.c__l2g_state_pdaf,
                                      c__PDAFcython.c__g2l_obs_pdaf,
                                      c__PDAFcython.c__init_obsvar_pdaf,
                                      c__PDAFcython.c__init_obsvar_l_pdaf,
                                      c__PDAFcython.c__prepoststep_pdaf,
                                      &outflag
                                     )

    return outflag

def put_state_enkf (py__collect_state_pdaf,
                    py__init_dim_obs_pdaf,
                    py__obs_op_pdaf,
                    py__init_obs_pdaf,
                    py__prepoststep_pdaf,
                    py__add_obs_err_pdaf,
                    py__init_obs_covar_pdaf
                   ):
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.put_state_global` or `pyPDAF.PDAF.put_state_enkf_nondiagR`. 
    Using stochastic EnKF (ensemble Kalman filter) for DA without post-processing and analysis distribution to forecsat without OMI. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf (for ensemble mean
    5. py__add_obs_err_pdaf
    6. py__init_obs_pdaf
    7. py__init_obscovar_pdaf
    8. py__obs_op_pdaf (for each ensemble member
    9. core DA algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__add_obs_err_pdaf : Callable[step:int, dim_obs_p:int, C_p : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]]
        Add obs error covariance R to HPH in EnKF

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Dimension of observation vector

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            * Matrix to that observation covariance R is added

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            * Matrix to that observation covariance R is added

    py__init_obs_covar_pdaf : Callable[step:int, dim_obs:int, dim_obs_p:int, covar:float, obs_p : ndarray[tuple[dim_obs_p], np.float64], isdiag:bool]
        Initialize obs. error cov. matrix R in EnKF

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs** : int

            * Global size of observation vector

        * **dim_obs_p** : int

            * Size of process-local observation vector

        * **covar** : float

            * Observation error covariance matrix

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Process-local vector of observations

        * **isdiag** : bool

            * 

        **Callback Returns**

        * **covar** : float

            * Observation error covariance matrix

        * **isdiag** : bool

            * 


    Returns
    -------
    flag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.add_obs_err_pdaf = <void*>py__add_obs_err_pdaf
    c__PDAFcython.init_obs_covar_pdaf = <void*>py__init_obs_covar_pdaf

    cdef int flag

    c__pdaf_put_state_enkf (c__PDAFcython.c__collect_state_pdaf,
                            c__PDAFcython.c__init_dim_obs_pdaf,
                            c__PDAFcython.c__obs_op_pdaf,
                            c__PDAFcython.c__init_obs_pdaf,
                            c__PDAFcython.c__prepoststep_pdaf,
                            c__PDAFcython.c__add_obs_err_pdaf,
                            c__PDAFcython.c__init_obs_covar_pdaf,
                            &flag
                           )

    return flag

def put_state_estkf (py__collect_state_pdaf,
                     py__init_dim_obs_pdaf,
                     py__obs_op_pdaf,
                     py__init_obs_pdaf,
                     py__prepoststep_pdaf,
                     py__prodRinvA_pdaf,
                     py__init_obsvar_pdaf
                    ):
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.put_state_global` or `pyPDAF.PDAF.put_state_global_nondiagR`. 
    Using ESTKF (error space transform Kalman filter) for DA without post-processing and analysis distribution to forecsat without OMI. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. The ESTKF is a more efficient equivalent to the ETKF. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf (for ensemble mean
    5. py__init_obs_pdaf
    6. py__obs_op_pdaf (for each ensemble member
    7. py__init_obsvar_pdaf (only relevant for adaptive forgetting factor schemes)
    8. py__prodRinvA_pdaf
    9. core DA algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], A_p : ndarray[tuple[dim_obs_p, rank], np.float64], C_p : ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **meanvar** : float

            * Mean observation error variance

        **Callback Returns**

        * **meanvar** : float

            * Mean observation error variance


    Returns
    -------
    flag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.prodRinvA_pdaf = <void*>py__prodRinvA_pdaf
    c__PDAFcython.init_obsvar_pdaf = <void*>py__init_obsvar_pdaf

    cdef int flag

    c__pdaf_put_state_estkf (c__PDAFcython.c__collect_state_pdaf,
                             c__PDAFcython.c__init_dim_obs_pdaf,
                             c__PDAFcython.c__obs_op_pdaf,
                             c__PDAFcython.c__init_obs_pdaf,
                             c__PDAFcython.c__prepoststep_pdaf,
                             c__PDAFcython.c__prodRinvA_pdaf,
                             c__PDAFcython.c__init_obsvar_pdaf,
                             &flag
                            )

    return flag

def put_state_etkf (py__collect_state_pdaf,
                    py__init_dim_obs_pdaf,
                    py__obs_op_pdaf,
                    py__init_obs_pdaf,
                    py__prepoststep_pdaf,
                    py__prodRinvA_pdaf,
                    py__init_obsvar_pdaf
                   ):
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.put_state_global` or `pyPDAF.PDAF.put_state_global_nondiagR`. 
    Using ETKF (ensemble transform Kalman filter) for DA without post-processing and analysis distribution to forecsat without OMI. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf (for ensemble mean
    5. py__init_obs_pdaf
    6. py__obs_op_pdaf (for each ensemble member
    7. py__init_obsvar_pdaf (only relevant for adaptive forgetting factor schemes)
    8. py__prodRinvA_pdaf
    9. core DA algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], A_p : ndarray[tuple[dim_obs_p, rank], np.float64], C_p : ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **meanvar** : float

            * Mean observation error variance

        **Callback Returns**

        * **meanvar** : float

            * Mean observation error variance


    Returns
    -------
    flag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.prodRinvA_pdaf = <void*>py__prodRinvA_pdaf
    c__PDAFcython.init_obsvar_pdaf = <void*>py__init_obsvar_pdaf

    cdef int flag

    c__pdaf_put_state_etkf (c__PDAFcython.c__collect_state_pdaf,
                            c__PDAFcython.c__init_dim_obs_pdaf,
                            c__PDAFcython.c__obs_op_pdaf,
                            c__PDAFcython.c__init_obs_pdaf,
                            c__PDAFcython.c__prepoststep_pdaf,
                            c__PDAFcython.c__prodRinvA_pdaf,
                            c__PDAFcython.c__init_obsvar_pdaf,
                            &flag
                           )

    return flag

def put_state_generate_obs (py__collect_state_pdaf,
                            py__init_dim_obs_pdaf,
                            py__obs_op_pdaf,
                            py__get_obs_f_pdaf,
                            py__init_obserr_f_pdaf,
                            py__prepoststep_pdaf
                           ):
    """When diagonal observation error covariance matrix is used, it is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.omi_put_state_generate_obs`. 
    This function generates synthetic observations based on each member of model forecast. This function is for the case where the ensemble size is larger than the number of processors. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pda
    5. py__init_obserr_f_pdaf
    6. py__get_obs_f_pdaf
    7. py__prepoststep_state_pdaf
    8. py__distribute_state_pdaf
    9. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__get_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f : ndarray[tuple[dim_obs_f], np.float64]]
        Provide observation vector to user

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_f** : int

            * Size of the full observation vector

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of synthetic observations (process-local)

        **Callback Returns**

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of synthetic observations (process-local)

    py__init_obserr_f_pdaf : Callable[step:int, dim_obs_f:int, obs_f : ndarray[tuple[dim_obs_f], np.float64], obserr_f : ndarray[tuple[dim_obs_f], np.float64]]
        Initialize vector of observation errors

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_f** : int

            * Full dimension of observation vector

        * **obs_f** : ndarray[tuple[dim_obs_f], np.float64]

            * Full observation vector

        * **obserr_f** : ndarray[tuple[dim_obs_f], np.float64]

            * Full observation error stddev

        **Callback Returns**

        * **obserr_f** : ndarray[tuple[dim_obs_f], np.float64]

            * Full observation error stddev

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble


    Returns
    -------
    flag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.get_obs_f_pdaf = <void*>py__get_obs_f_pdaf
    c__PDAFcython.init_obserr_f_pdaf = <void*>py__init_obserr_f_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf

    cdef int flag

    c__pdaf_put_state_generate_obs (c__PDAFcython.c__collect_state_pdaf,
                                    c__PDAFcython.c__init_dim_obs_pdaf,
                                    c__PDAFcython.c__obs_op_pdaf,
                                    c__PDAFcython.c__get_obs_f_pdaf,
                                    c__PDAFcython.c__init_obserr_f_pdaf,
                                    c__PDAFcython.c__prepoststep_pdaf,
                                    &flag
                                   )

    return flag

def put_state_hyb3dvar_estkf (py__collect_state_pdaf,
                              py__init_dim_obs_pdaf,
                              py__obs_op_pdaf,
                              py__init_obs_pdaf,
                              py__prodRinvA_pdaf,
                              py__cvt_pdaf,
                              py__cvt_adj_pdaf,
                              py__cvt_ens_pdaf,
                              py__cvt_adj_ens_pdaf,
                              py__obs_op_lin_pdaf,
                              py__obs_op_adj_pdaf,
                              py__init_obsvar_pdaf,
                              py__prepoststep_pdaf
                             ):
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency.
    I.e., `pyPDAF.PDAF.omi_put_state_hyb3dvar_estkf` or `pyPDAF.PDAF.omi_put_state_hyb3dvar_estkf_nondiagR`. 
    
    
    Using Hybrid 3DEnVar for DA without post-processing and analysis distribution to forecsat without OMI.
    Here, the background error covariance is hybridised by a static background error covariance, and a flow-dependent background error covariance estimated from ensemble. The 3DVar generates an ensemble mean and the ensemble perturbation is generated by
    ESTKF in this implementation. 
    
    This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    5. py__init_obs_pdaf
    Starting the iterative optimisation:
    6. py__cvt_pdaf
    7. py__cvt_ens_pdaf
    8. py__obs_op_lin_pdaf
    9. py__prodRinvA_pdaf
    10. py__obs_op_adj_pdaf
    11. py__cvt_adj_pdaf
    12. py__cvt_adj_ens_pdaf
    13. core 3DEnVar algorithm
    After the iterations: 
    14. py__cvt_pdaf
    15. py__cvt_ens_pdaf
    Perform ESTKF: 16. py__init_dim_obs_pdaf
    17. py__obs_op_pdaf (for ensemble mean
    18. py__init_obs_pdaf
    19. py__obs_op_pdaf (for each ensemble member
    20. py__init_obsvar_pdaf (only relevant for adaptive forgetting factor schemes)
    21. py__prodRinvA_pdaf
    22. core ESTKF algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], A_p : ndarray[tuple[dim_obs_p, rank], np.float64], C_p : ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p : ndarray[tuple[dim_cvec], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], v_p : ndarray[tuple[dim_cvec_ens], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_ens** : int

            * Ensemble size

        * **dim_cvec_ens** : int

            * Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_ens** : int

            * Ensemble size

        * **dim_cv_ens_p** : int

            * PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **meanvar** : float

            * Mean observation error variance

        **Callback Returns**

        * **meanvar** : float

            * Mean observation error variance

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble


    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.prodRinvA_pdaf = <void*>py__prodRinvA_pdaf
    c__PDAFcython.cvt_pdaf = <void*>py__cvt_pdaf
    c__PDAFcython.cvt_adj_pdaf = <void*>py__cvt_adj_pdaf
    c__PDAFcython.cvt_ens_pdaf = <void*>py__cvt_ens_pdaf
    c__PDAFcython.cvt_adj_ens_pdaf = <void*>py__cvt_adj_ens_pdaf
    c__PDAFcython.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    c__PDAFcython.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    c__PDAFcython.init_obsvar_pdaf = <void*>py__init_obsvar_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf

    cdef int outflag

    c__pdaf_put_state_hyb3dvar_estkf (c__PDAFcython.c__collect_state_pdaf,
                                      c__PDAFcython.c__init_dim_obs_pdaf,
                                      c__PDAFcython.c__obs_op_pdaf,
                                      c__PDAFcython.c__init_obs_pdaf,
                                      c__PDAFcython.c__prodRinvA_pdaf,
                                      c__PDAFcython.c__cvt_pdaf,
                                      c__PDAFcython.c__cvt_adj_pdaf,
                                      c__PDAFcython.c__cvt_ens_pdaf,
                                      c__PDAFcython.c__cvt_adj_ens_pdaf,
                                      c__PDAFcython.c__obs_op_lin_pdaf,
                                      c__PDAFcython.c__obs_op_adj_pdaf,
                                      c__PDAFcython.c__init_obsvar_pdaf,
                                      c__PDAFcython.c__prepoststep_pdaf,
                                      &outflag
                                     )

    return outflag

def put_state_hyb3dvar_lestkf (py__collect_state_pdaf,
                               py__init_dim_obs_pdaf,
                               py__obs_op_pdaf,
                               py__init_obs_pdaf,
                               py__prodRinvA_pdaf,
                               py__cvt_ens_pdaf,
                               py__cvt_adj_ens_pdaf,
                               py__cvt_pdaf,
                               py__cvt_adj_pdaf,
                               py__obs_op_lin_pdaf,
                               py__obs_op_adj_pdaf,
                               py__init_dim_obs_f_pdaf,
                               py__obs_op_f_pdaf,
                               py__init_obs_f_pdaf,
                               py__init_obs_l_pdaf,
                               py__prodRinvA_l_pdaf,
                               py__init_n_domains_p_pdaf,
                               py__init_dim_l_pdaf,
                               py__init_dim_obs_l_pdaf,
                               py__g2l_state_pdaf,
                               py__l2g_state_pdaf,
                               py__g2l_obs_pdaf,
                               py__init_obsvar_pdaf,
                               py__init_obsvar_l_pdaf,
                               py__prepoststep_pdaf
                              ):
    """It is recommended to use local module with OMI functionalities for fewer user-supplied functions and improved efficiency.
    I.e., `pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf` or `pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf_nondiagR`. 
    
    
    Using Hybrid 3DEnVar for DA without post-processing and analysis distribution to forecsat without OMI.
    Here, the background error covariance is hybridised by a static background error covariance, and a flow-dependent background error covariance estimated from ensemble. The 3DVar generates an ensemble mean and the ensemble perturbation is generated by
    LESTKF in this implementation. 
    
    This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    5. py__init_obs_pdaf
    Starting the iterative optimisation:
    6. py__cvt_pdaf
    7. py__cvt_ens_pdaf
    8. py__obs_op_lin_pdaf
    9. py__prodRinvA_pdaf
    10. py__obs_op_adj_pdaf
    11. py__cvt_adj_pdaf
    12. py__cvt_adj_ens_pdaf
    13. core DA algorithm
    After the iterations: 
    14. py__cvt_pdaf
    15. py__cvt_ens_pdaf
    Perform LESTKF: 
    16. py__init_n_domains_p_pdaf
    17. py__init_dim_obs_pdaf
    18. py__obs_op_pdaf (for each ensemble member
    19. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in `pyPDAF.PDAF.init`))
    20. py__init_obsvar_pdaf (if global adaptive forgetting factor is used)
    loop over each local domain:
    21. py__init_dim_l_pdaf
    22. py__init_dim_obs_l_pdaf
    23. py__g2l_state_pdaf
    24. py__g2l_obs_pdaf (localise mean ensemble in observation space)
    25. py__init_obs_l_pdaf
    26. py__g2l_obs_pdaf (localise each ensemble member in observation space)
    27. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used)
    28. py__prodRinvA_pdaf
    29. core DA algorithm
    30. py__l2g_state_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], A_p : ndarray[tuple[dim_obs_p, rank], np.float64], C_p : ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], v_p : ndarray[tuple[dim_cvec_ens], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_ens** : int

            * Ensemble size

        * **dim_cvec_ens** : int

            * Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_ens** : int

            * Ensemble size

        * **dim_cv_ens_p** : int

            * PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p : ndarray[tuple[dim_cvec], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f : ndarray[tuple[dim_obs_f], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_f** : int

            * Size of the full observation vector

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of observations

        **Callback Returns**

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of observations

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l : ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], A_l : ndarray[tuple[dim_obs_l, rank], np.float64], C_l : ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p : ndarray[tuple[dim_p], np.float64], dim_l:int, state_l : ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l : ndarray[tuple[dim_l], np.float64], dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f : ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l : ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_f** : int

            * Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            * Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * **dim_p** : int

            * Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * **dim_l** : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **meanvar** : float

            * Mean observation error variance

        **Callback Returns**

        * **meanvar** : float

            * Mean observation error variance

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * **dim_obs_p** : int

            * Dimension of local observation vector

        * **meanvar_l** : float

            * Mean local observation error variance

        **Callback Returns**

        * **meanvar_l** : float

            * Mean local observation error variance

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble


    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.prodRinvA_pdaf = <void*>py__prodRinvA_pdaf
    c__PDAFcython.cvt_ens_pdaf = <void*>py__cvt_ens_pdaf
    c__PDAFcython.cvt_adj_ens_pdaf = <void*>py__cvt_adj_ens_pdaf
    c__PDAFcython.cvt_pdaf = <void*>py__cvt_pdaf
    c__PDAFcython.cvt_adj_pdaf = <void*>py__cvt_adj_pdaf
    c__PDAFcython.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    c__PDAFcython.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    c__PDAFcython.init_dim_obs_f_pdaf = <void*>py__init_dim_obs_f_pdaf
    c__PDAFcython.obs_op_f_pdaf = <void*>py__obs_op_f_pdaf
    c__PDAFcython.init_obs_f_pdaf = <void*>py__init_obs_f_pdaf
    c__PDAFcython.init_obs_l_pdaf = <void*>py__init_obs_l_pdaf
    c__PDAFcython.prodRinvA_l_pdaf = <void*>py__prodRinvA_l_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.g2l_state_pdaf = <void*>py__g2l_state_pdaf
    c__PDAFcython.l2g_state_pdaf = <void*>py__l2g_state_pdaf
    c__PDAFcython.g2l_obs_pdaf = <void*>py__g2l_obs_pdaf
    c__PDAFcython.init_obsvar_pdaf = <void*>py__init_obsvar_pdaf
    c__PDAFcython.init_obsvar_l_pdaf = <void*>py__init_obsvar_l_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf

    cdef int outflag

    c__pdaf_put_state_hyb3dvar_lestkf (c__PDAFcython.c__collect_state_pdaf,
                                       c__PDAFcython.c__init_dim_obs_pdaf,
                                       c__PDAFcython.c__obs_op_pdaf,
                                       c__PDAFcython.c__init_obs_pdaf,
                                       c__PDAFcython.c__prodRinvA_pdaf,
                                       c__PDAFcython.c__cvt_ens_pdaf,
                                       c__PDAFcython.c__cvt_adj_ens_pdaf,
                                       c__PDAFcython.c__cvt_pdaf,
                                       c__PDAFcython.c__cvt_adj_pdaf,
                                       c__PDAFcython.c__obs_op_lin_pdaf,
                                       c__PDAFcython.c__obs_op_adj_pdaf,
                                       c__PDAFcython.c__init_dim_obs_f_pdaf,
                                       c__PDAFcython.c__obs_op_f_pdaf,
                                       c__PDAFcython.c__init_obs_f_pdaf,
                                       c__PDAFcython.c__init_obs_l_pdaf,
                                       c__PDAFcython.c__prodRinvA_l_pdaf,
                                       c__PDAFcython.c__init_n_domains_p_pdaf,
                                       c__PDAFcython.c__init_dim_l_pdaf,
                                       c__PDAFcython.c__init_dim_obs_l_pdaf,
                                       c__PDAFcython.c__g2l_state_pdaf,
                                       c__PDAFcython.c__l2g_state_pdaf,
                                       c__PDAFcython.c__g2l_obs_pdaf,
                                       c__PDAFcython.c__init_obsvar_pdaf,
                                       c__PDAFcython.c__init_obsvar_l_pdaf,
                                       c__PDAFcython.c__prepoststep_pdaf,
                                       &outflag
                                      )

    return outflag

def put_state_lenkf (py__collect_state_pdaf,
                     py__init_dim_obs_pdaf,
                     py__obs_op_pdaf,
                     py__init_obs_pdaf,
                     py__prepoststep_pdaf,
                     py__localize_covar_pdaf,
                     py__add_obs_err_pdaf,
                     py__init_obs_covar_pdaf
                    ):
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.omi_put_state_lenkf` or `pyPDAF.PDAF.omi_put_state_lenkf_nondiagR`. 
    Using stochastic EnKF (ensemble Kalman filter) with covariance localisation for DA without post-processing and analysis distribution to forecsat without OMI. This is the only scheme for covariance localisation in PDAF. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf (for each ensemble member
    5. py__localize_pdaf
    6. py__add_obs_err_pdaf
    7. py__init_obs_pdaf
    8. py__init_obscovar_pdaf
    9. py__obs_op_pdaf (repeated to reduce storage
    10. core DA algorith
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__localize_covar_pdaf : Callable[dim_p:int, dim_obs:int, hp_p : ndarray[tuple[dim_obs, dim_p], np.float64], hph : ndarray[tuple[dim_obs, dim_obs], np.float64]]
        Apply localization to HP and HPH^T

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **dim_obs** : int

            * number of observations

        * **hp_p** : ndarray[tuple[dim_obs, dim_p], np.float64]

            * pe local part of matrix hp

        * **hph** : ndarray[tuple[dim_obs, dim_obs], np.float64]

            * matrix hph

        **Callback Returns**

        * **hp_p** : ndarray[tuple[dim_obs, dim_p], np.float64]

            * pe local part of matrix hp

        * **hph** : ndarray[tuple[dim_obs, dim_obs], np.float64]

            * matrix hph

    py__add_obs_err_pdaf : Callable[step:int, dim_obs_p:int, C_p : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]]
        Add obs error covariance R to HPH in EnKF

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Dimension of observation vector

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            * Matrix to that observation covariance R is added

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            * Matrix to that observation covariance R is added

    py__init_obs_covar_pdaf : Callable[step:int, dim_obs:int, dim_obs_p:int, covar:float, obs_p : ndarray[tuple[dim_obs_p], np.float64], isdiag:bool]
        Initialize obs. error cov. matrix R in EnKF

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs** : int

            * Global size of observation vector

        * **dim_obs_p** : int

            * Size of process-local observation vector

        * **covar** : float

            * Observation error covariance matrix

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Process-local vector of observations

        * **isdiag** : bool

            * 

        **Callback Returns**

        * **covar** : float

            * Observation error covariance matrix

        * **isdiag** : bool

            * 


    Returns
    -------
    flag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.localize_covar_pdaf = <void*>py__localize_covar_pdaf
    c__PDAFcython.add_obs_err_pdaf = <void*>py__add_obs_err_pdaf
    c__PDAFcython.init_obs_covar_pdaf = <void*>py__init_obs_covar_pdaf

    cdef int flag

    c__pdaf_put_state_lenkf (c__PDAFcython.c__collect_state_pdaf,
                             c__PDAFcython.c__init_dim_obs_pdaf,
                             c__PDAFcython.c__obs_op_pdaf,
                             c__PDAFcython.c__init_obs_pdaf,
                             c__PDAFcython.c__prepoststep_pdaf,
                             c__PDAFcython.c__localize_covar_pdaf,
                             c__PDAFcython.c__add_obs_err_pdaf,
                             c__PDAFcython.c__init_obs_covar_pdaf,
                             &flag
                            )

    return flag

def put_state_lestkf (py__collect_state_pdaf,
                      py__init_dim_obs_pdaf,
                      py__obs_op_pdaf,
                      py__init_obs_pdaf,
                      py__init_obs_l_pdaf,
                      py__prepoststep_pdaf,
                      py__prodRinvA_l_pdaf,
                      py__init_n_domains_p_pdaf,
                      py__init_dim_l_pdaf,
                      py__init_dim_obs_l_pdaf,
                      py__g2l_state_pdaf,
                      py__l2g_state_pdaf,
                      py__g2l_obs_pdaf,
                      py__init_obsvar_pdaf,
                      py__init_obsvar_l_pdaf
                     ):
    """It is recommended to use local module with OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_put_state` or `pyPDAF.PDAF.localomi_put_state_nondiagR`. 
    Using Local ESTKF (error space transform Kalman filter) for DA without post-processing and analysis distribution to forecsat without OMI. This is a domain localisation method. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. The LESTKF is a more efficient equivalent to the LETKF. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    6. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init
    7. py__init_obsvar_pdaf (if global adaptive forgetting factor is used
    loop over each local domain:
    8. py__init_dim_l_pdaf
    9. py__init_dim_obs_l_pdaf
    10. py__g2l_state_pdaf
    11. py__g2l_obs_pdaf (localise mean ensemble in observation space)
    12. py__init_obs_l_pdaf
    13. py__g2l_obs_pdaf (localise each ensemble member in observation space
    14. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used
    15. py__prodRinvA_l_pdaf
    16. core DA algorithm
    17. py__l2g_state_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l : ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], A_l : ndarray[tuple[dim_obs_l, rank], np.float64], C_l : ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p : ndarray[tuple[dim_p], np.float64], dim_l:int, state_l : ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l : ndarray[tuple[dim_l], np.float64], dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f : ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l : ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_f** : int

            * Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            * Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * **dim_p** : int

            * Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * **dim_l** : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **meanvar** : float

            * Mean observation error variance

        **Callback Returns**

        * **meanvar** : float

            * Mean observation error variance

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * **dim_obs_p** : int

            * Dimension of local observation vector

        * **meanvar_l** : float

            * Mean local observation error variance

        **Callback Returns**

        * **meanvar_l** : float

            * Mean local observation error variance


    Returns
    -------
    flag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.init_obs_l_pdaf = <void*>py__init_obs_l_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.prodRinvA_l_pdaf = <void*>py__prodRinvA_l_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.g2l_state_pdaf = <void*>py__g2l_state_pdaf
    c__PDAFcython.l2g_state_pdaf = <void*>py__l2g_state_pdaf
    c__PDAFcython.g2l_obs_pdaf = <void*>py__g2l_obs_pdaf
    c__PDAFcython.init_obsvar_pdaf = <void*>py__init_obsvar_pdaf
    c__PDAFcython.init_obsvar_l_pdaf = <void*>py__init_obsvar_l_pdaf

    cdef int flag

    c__pdaf_put_state_lestkf (c__PDAFcython.c__collect_state_pdaf,
                              c__PDAFcython.c__init_dim_obs_pdaf,
                              c__PDAFcython.c__obs_op_pdaf,
                              c__PDAFcython.c__init_obs_pdaf,
                              c__PDAFcython.c__init_obs_l_pdaf,
                              c__PDAFcython.c__prepoststep_pdaf,
                              c__PDAFcython.c__prodRinvA_l_pdaf,
                              c__PDAFcython.c__init_n_domains_p_pdaf,
                              c__PDAFcython.c__init_dim_l_pdaf,
                              c__PDAFcython.c__init_dim_obs_l_pdaf,
                              c__PDAFcython.c__g2l_state_pdaf,
                              c__PDAFcython.c__l2g_state_pdaf,
                              c__PDAFcython.c__g2l_obs_pdaf,
                              c__PDAFcython.c__init_obsvar_pdaf,
                              c__PDAFcython.c__init_obsvar_l_pdaf,
                              &flag
                             )

    return flag

def put_state_letkf (py__collect_state_pdaf,
                     py__init_dim_obs_pdaf,
                     py__obs_op_pdaf,
                     py__init_obs_pdaf,
                     py__init_obs_l_pdaf,
                     py__prepoststep_pdaf,
                     py__prodRinvA_l_pdaf,
                     py__init_n_domains_p_pdaf,
                     py__init_dim_l_pdaf,
                     py__init_dim_obs_l_pdaf,
                     py__g2l_state_pdaf,
                     py__l2g_state_pdaf,
                     py__g2l_obs_pdaf,
                     py__init_obsvar_pdaf,
                     py__init_obsvar_l_pdaf
                    ):
    """It is recommended to use local module with OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_put_state` or `pyPDAF.PDAF.localomi_put_state_nondiagR`. 
    Using local ensemble transform Kalman filter for DA without post-processing and analysis distribution to forecsat without OMI. This is a domain localisation method. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    6. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init
    7. py__init_obsvar_pdaf (if global adaptive forgetting factor is used
    loop over each local domain:
    8. py__init_dim_l_pdaf
    9. py__init_dim_obs_l_pdaf
    10. py__g2l_state_pdaf
    11. py__g2l_obs_pdaf (localise mean ensemble in observation space)
    12. py__init_obs_l_pdaf
    13. py__g2l_obs_pdaf (localise each ensemble member in observation space
    14. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used
    15. py__prodRinvA_l_pdaf
    16. core DA algorithm
    17. py__l2g_state_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l : ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], A_l : ndarray[tuple[dim_obs_l, rank], np.float64], C_l : ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p : ndarray[tuple[dim_p], np.float64], dim_l:int, state_l : ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l : ndarray[tuple[dim_l], np.float64], dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f : ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l : ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_f** : int

            * Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            * Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * **dim_p** : int

            * Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * **dim_l** : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **meanvar** : float

            * Mean observation error variance

        **Callback Returns**

        * **meanvar** : float

            * Mean observation error variance

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * **dim_obs_p** : int

            * Dimension of local observation vector

        * **meanvar_l** : float

            * Mean local observation error variance

        **Callback Returns**

        * **meanvar_l** : float

            * Mean local observation error variance


    Returns
    -------
    flag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.init_obs_l_pdaf = <void*>py__init_obs_l_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.prodRinvA_l_pdaf = <void*>py__prodRinvA_l_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.g2l_state_pdaf = <void*>py__g2l_state_pdaf
    c__PDAFcython.l2g_state_pdaf = <void*>py__l2g_state_pdaf
    c__PDAFcython.g2l_obs_pdaf = <void*>py__g2l_obs_pdaf
    c__PDAFcython.init_obsvar_pdaf = <void*>py__init_obsvar_pdaf
    c__PDAFcython.init_obsvar_l_pdaf = <void*>py__init_obsvar_l_pdaf

    cdef int flag

    c__pdaf_put_state_letkf (c__PDAFcython.c__collect_state_pdaf,
                             c__PDAFcython.c__init_dim_obs_pdaf,
                             c__PDAFcython.c__obs_op_pdaf,
                             c__PDAFcython.c__init_obs_pdaf,
                             c__PDAFcython.c__init_obs_l_pdaf,
                             c__PDAFcython.c__prepoststep_pdaf,
                             c__PDAFcython.c__prodRinvA_l_pdaf,
                             c__PDAFcython.c__init_n_domains_p_pdaf,
                             c__PDAFcython.c__init_dim_l_pdaf,
                             c__PDAFcython.c__init_dim_obs_l_pdaf,
                             c__PDAFcython.c__g2l_state_pdaf,
                             c__PDAFcython.c__l2g_state_pdaf,
                             c__PDAFcython.c__g2l_obs_pdaf,
                             c__PDAFcython.c__init_obsvar_pdaf,
                             c__PDAFcython.c__init_obsvar_l_pdaf,
                             &flag
                            )

    return flag

def put_state_lnetf (py__collect_state_pdaf,
                     py__init_dim_obs_pdaf,
                     py__obs_op_pdaf,
                     py__init_obs_l_pdaf,
                     py__prepoststep_pdaf,
                     py__likelihood_l_pdaf,
                     py__init_n_domains_p_pdaf,
                     py__init_dim_l_pdaf,
                     py__init_dim_obs_l_pdaf,
                     py__g2l_state_pdaf,
                     py__l2g_state_pdaf,
                     py__g2l_obs_pdaf
                    ):
    """It is recommended to use local module with OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_put_state` or `pyPDAF.PDAF.localomi_put_state_lnetf_nondiagR`. 
    This function will use Local Nonlinear Ensemble Transform Filter (LNETF) for DA without post-processing and analysis distribution to forecsat without OMI. The nonlinear filter computes the distribution up to the second moment similar to KF but using a nonlinear weighting similar to particle filter. This leads to an equal weights assumption for prior ensemble. 
    
    This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    6. py__init_dim_l_pdaf
    7. py__init_dim_obs_l_pdaf
    8. py__g2l_state_pdaf
    9. py__init_obs_l_pdaf
    10. py__g2l_obs_pdaf (localise each ensemble member in observation space)
    11. py__likelihood_l_pdaf
    12. core DA algorithm
    13. py__l2g_state_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l : ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], resid_l : ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            * nput vector holding the local residual

        * **likely_l** : float

            * Output value of the local likelihood

        **Callback Returns**

        * **likely_l** : float

            * Output value of the local likelihood

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p : ndarray[tuple[dim_p], np.float64], dim_l:int, state_l : ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l : ndarray[tuple[dim_l], np.float64], dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f : ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l : ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_f** : int

            * Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            * Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * **dim_p** : int

            * Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * **dim_l** : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain


    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_l_pdaf = <void*>py__init_obs_l_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.likelihood_l_pdaf = <void*>py__likelihood_l_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.g2l_state_pdaf = <void*>py__g2l_state_pdaf
    c__PDAFcython.l2g_state_pdaf = <void*>py__l2g_state_pdaf
    c__PDAFcython.g2l_obs_pdaf = <void*>py__g2l_obs_pdaf

    cdef int outflag

    c__pdaf_put_state_lnetf (c__PDAFcython.c__collect_state_pdaf,
                             c__PDAFcython.c__init_dim_obs_pdaf,
                             c__PDAFcython.c__obs_op_pdaf,
                             c__PDAFcython.c__init_obs_l_pdaf,
                             c__PDAFcython.c__prepoststep_pdaf,
                             c__PDAFcython.c__likelihood_l_pdaf,
                             c__PDAFcython.c__init_n_domains_p_pdaf,
                             c__PDAFcython.c__init_dim_l_pdaf,
                             c__PDAFcython.c__init_dim_obs_l_pdaf,
                             c__PDAFcython.c__g2l_state_pdaf,
                             c__PDAFcython.c__l2g_state_pdaf,
                             c__PDAFcython.c__g2l_obs_pdaf,
                             &outflag
                            )

    return outflag

def put_state_lknetf (py__collect_state_pdaf,
                      py__init_dim_obs_pdaf,
                      py__obs_op_pdaf,
                      py__init_obs_pdaf,
                      py__init_obs_l_pdaf,
                      py__prepoststep_pdaf,
                      py__prodRinvA_l_pdaf,
                      py__prodRinvA_hyb_l_pdaf,
                      py__init_n_domains_p_pdaf,
                      py__init_dim_l_pdaf,
                      py__init_dim_obs_l_pdaf,
                      py__g2l_state_pdaf,
                      py__l2g_state_pdaf,
                      py__g2l_obs_pdaf,
                      py__init_obsvar_pdaf,
                      py__init_obsvar_l_pdaf,
                      py__likelihood_l_pdaf,
                      py__likelihood_hyb_l_pdaf
                     ):
    """It is recommended to use local module with OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_put_state` or `pyPDAF.PDAF.localomi_put_state_lknetf_nondiagR`. 
    This function will is a hybridised LETKF and LNETF for DA without post-processing and analysis distribution to forecsat without OMI. The LNETF computes the distribution up to the second moment similar to KF but using a nonlinear weighting similar to particle filter. This leads to an equal weights assumption for prior ensemble. The hybridisation with LETKF is expected to lead to improved performance for quasi-Gaussian problems.  
    
    This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    6. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init
    7. py__init_obsvar_pdaf (if global adaptive forgetting factor is used
    loop over each local domain:
    8. py__init_dim_l_pdaf
    9. py__init_dim_obs_l_pdaf
    10. py__g2l_state_pdaf
    11. py__g2l_obs_pdaf (localise each ensemble member in observation space)
    12. py__init_obs_l_pdaf
    13. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used
    14. py__prodRinvA_pdaf
    15. py__likelihood_l_pdaf
    16. core DA algorithm
    17. py__l2g_state_pdaf
    18. py__obs_op_pdaf (only called with `HKN` and `HNK` options called for each ensemble member
    19. py__likelihood_hyb_l_pda
    20. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used
    21. py__prodRinvA_hyb_l_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l : ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], A_l : ndarray[tuple[dim_obs_l, rank], np.float64], C_l : ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

    py__prodRinvA_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, dim_ens:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], gamma:float, A_l : ndarray[tuple[dim_obs_l, dim_ens], np.float64], C_l : ndarray[tuple[dim_obs_l, dim_ens], np.float64]]
        Provide product R^-1 A on local analysis domain with hybrid weight

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **dim_ens** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **gamma** : float

            * Hybrid weight provided by PDAF

        * **A_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            * Output matrix

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p : ndarray[tuple[dim_p], np.float64], dim_l:int, state_l : ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l : ndarray[tuple[dim_l], np.float64], dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f : ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l : ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_f** : int

            * Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            * Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * **dim_p** : int

            * Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * **dim_l** : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **meanvar** : float

            * Mean observation error variance

        **Callback Returns**

        * **meanvar** : float

            * Mean observation error variance

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * **dim_obs_p** : int

            * Dimension of local observation vector

        * **meanvar_l** : float

            * Mean local observation error variance

        **Callback Returns**

        * **meanvar_l** : float

            * Mean local observation error variance

    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], resid_l : ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute likelihood

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            * nput vector holding the local residual

        * **likely_l** : float

            * Output value of the local likelihood

        **Callback Returns**

        * **likely_l** : float

            * Output value of the local likelihood

    py__likelihood_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], resid_l : ndarray[tuple[dim_obs_l], np.float64], gamma:float, likely_l:float]
        Compute likelihood with hybrid weight

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Input vector holding the local residual

        * **gamma** : float

            * Hybrid weight provided by PDAF

        * **likely_l** : float

            * Output value of the local likelihood

        **Callback Returns**

        * **likely_l** : float

            * Output value of the local likelihood


    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.init_obs_l_pdaf = <void*>py__init_obs_l_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.prodRinvA_l_pdaf = <void*>py__prodRinvA_l_pdaf
    c__PDAFcython.prodRinvA_hyb_l_pdaf = <void*>py__prodRinvA_hyb_l_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.g2l_state_pdaf = <void*>py__g2l_state_pdaf
    c__PDAFcython.l2g_state_pdaf = <void*>py__l2g_state_pdaf
    c__PDAFcython.g2l_obs_pdaf = <void*>py__g2l_obs_pdaf
    c__PDAFcython.init_obsvar_pdaf = <void*>py__init_obsvar_pdaf
    c__PDAFcython.init_obsvar_l_pdaf = <void*>py__init_obsvar_l_pdaf
    c__PDAFcython.likelihood_l_pdaf = <void*>py__likelihood_l_pdaf
    c__PDAFcython.likelihood_hyb_l_pdaf = <void*>py__likelihood_hyb_l_pdaf

    cdef int outflag

    c__pdaf_put_state_lknetf (c__PDAFcython.c__collect_state_pdaf,
                              c__PDAFcython.c__init_dim_obs_pdaf,
                              c__PDAFcython.c__obs_op_pdaf,
                              c__PDAFcython.c__init_obs_pdaf,
                              c__PDAFcython.c__init_obs_l_pdaf,
                              c__PDAFcython.c__prepoststep_pdaf,
                              c__PDAFcython.c__prodRinvA_l_pdaf,
                              c__PDAFcython.c__prodRinvA_hyb_l_pdaf,
                              c__PDAFcython.c__init_n_domains_p_pdaf,
                              c__PDAFcython.c__init_dim_l_pdaf,
                              c__PDAFcython.c__init_dim_obs_l_pdaf,
                              c__PDAFcython.c__g2l_state_pdaf,
                              c__PDAFcython.c__l2g_state_pdaf,
                              c__PDAFcython.c__g2l_obs_pdaf,
                              c__PDAFcython.c__init_obsvar_pdaf,
                              c__PDAFcython.c__init_obsvar_l_pdaf,
                              c__PDAFcython.c__likelihood_l_pdaf,
                              c__PDAFcython.c__likelihood_hyb_l_pdaf,
                              &outflag
                             )

    return outflag

def put_state_lseik (py__collect_state_pdaf,
                     py__init_dim_obs_pdaf,
                     py__obs_op_pdaf,
                     py__init_obs_pdaf,
                     py__init_obs_l_pdaf,
                     py__prepoststep_pdaf,
                     py__prodRinvA_l_pdaf,
                     py__init_n_domains_p_pdaf,
                     py__init_dim_l_pdaf,
                     py__init_dim_obs_l_pdaf,
                     py__g2l_state_pdaf,
                     py__l2g_state_pdaf,
                     py__g2l_obs_pdaf,
                     py__init_obsvar_pdaf,
                     py__init_obsvar_l_pdaf
                    ):
    """It is recommended to use local module with OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_put_state` or `pyPDAF.PDAF.localomi_put_state_nondiagR`. 
    Using local singular evolutive interpolated Kalman filter for DA without post-processing and analysis distribution to forecsat without OMI. This is a domain localisation method. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    6. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init
    7. py__init_obsvar_pdaf (if global adaptive forgetting factor is used
    loop over each local domain:
    8. py__init_dim_l_pdaf
    9. py__init_dim_obs_l_pdaf
    10. py__g2l_state_pdaf
    11. py__g2l_obs_pdaf (localise mean ensemble in observation space)
    12. py__init_obs_l_pdaf
    13. py__g2l_obs_pdaf (localise each ensemble member in observation space
    14. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used
    15. py__prodRinvA_l_pdaf
    16. core DA algorithm
    17. py__l2g_state_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l : ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], A_l : ndarray[tuple[dim_obs_l, rank], np.float64], C_l : ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p : ndarray[tuple[dim_p], np.float64], dim_l:int, state_l : ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l : ndarray[tuple[dim_l], np.float64], dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f : ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l : ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_f** : int

            * Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            * Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * **dim_p** : int

            * Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * **dim_l** : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **meanvar** : float

            * Mean observation error variance

        **Callback Returns**

        * **meanvar** : float

            * Mean observation error variance

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * **dim_obs_p** : int

            * Dimension of local observation vector

        * **meanvar_l** : float

            * Mean local observation error variance

        **Callback Returns**

        * **meanvar_l** : float

            * Mean local observation error variance


    Returns
    -------
    flag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.init_obs_l_pdaf = <void*>py__init_obs_l_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.prodRinvA_l_pdaf = <void*>py__prodRinvA_l_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.g2l_state_pdaf = <void*>py__g2l_state_pdaf
    c__PDAFcython.l2g_state_pdaf = <void*>py__l2g_state_pdaf
    c__PDAFcython.g2l_obs_pdaf = <void*>py__g2l_obs_pdaf
    c__PDAFcython.init_obsvar_pdaf = <void*>py__init_obsvar_pdaf
    c__PDAFcython.init_obsvar_l_pdaf = <void*>py__init_obsvar_l_pdaf

    cdef int flag

    c__pdaf_put_state_lseik (c__PDAFcython.c__collect_state_pdaf,
                             c__PDAFcython.c__init_dim_obs_pdaf,
                             c__PDAFcython.c__obs_op_pdaf,
                             c__PDAFcython.c__init_obs_pdaf,
                             c__PDAFcython.c__init_obs_l_pdaf,
                             c__PDAFcython.c__prepoststep_pdaf,
                             c__PDAFcython.c__prodRinvA_l_pdaf,
                             c__PDAFcython.c__init_n_domains_p_pdaf,
                             c__PDAFcython.c__init_dim_l_pdaf,
                             c__PDAFcython.c__init_dim_obs_l_pdaf,
                             c__PDAFcython.c__g2l_state_pdaf,
                             c__PDAFcython.c__l2g_state_pdaf,
                             c__PDAFcython.c__g2l_obs_pdaf,
                             c__PDAFcython.c__init_obsvar_pdaf,
                             c__PDAFcython.c__init_obsvar_l_pdaf,
                             &flag
                            )

    return flag

def put_state_netf (py__collect_state_pdaf,
                    py__init_dim_obs_pdaf,
                    py__obs_op_pdaf,
                    py__init_obs_pdaf,
                    py__prepoststep_pdaf,
                    py__likelihood_pdaf
                   ):
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.put_state_global` or `pyPDAF.PDAF.omi_put_state_nonlin_nondiagR`. 
    This function will use Nonlinear Ensemble Transform Filter (NETF) for DA without post-processing and analysis distribution to forecsat without OMI. The nonlinear filter computes the distribution up to the second moment similar to KF but using a nonlinear weighting similar to particle filter. This leads to an equal weights assumption for prior ensemble. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__init_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    6. py__likelihood_pdaf
    7. core DA algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__likelihood_pdaf : Callable[step:int, dim_obs_p:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], resid : ndarray[tuple[dim_obs_p], np.float64], likely:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **resid** : ndarray[tuple[dim_obs_p], np.float64]

            * Input vector holding the residual

        * **likely** : float

            * Output value of the likelihood

        **Callback Returns**

        * **likely** : float

            * Output value of the likelihood


    Returns
    -------
    flag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.likelihood_pdaf = <void*>py__likelihood_pdaf

    cdef int flag

    c__pdaf_put_state_netf (c__PDAFcython.c__collect_state_pdaf,
                            c__PDAFcython.c__init_dim_obs_pdaf,
                            c__PDAFcython.c__obs_op_pdaf,
                            c__PDAFcython.c__init_obs_pdaf,
                            c__PDAFcython.c__prepoststep_pdaf,
                            c__PDAFcython.c__likelihood_pdaf,
                            &flag
                           )

    return flag

def put_state_pf (py__collect_state_pdaf,
                  py__init_dim_obs_pdaf,
                  py__obs_op_pdaf,
                  py__init_obs_pdaf,
                  py__prepoststep_pdaf,
                  py__likelihood_pdaf
                 ):
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.put_state_global` or `pyPDAF.PDAF.omi_put_state_nonlin_nondiagR`. 
    This function will use particle filter for DA without post-processing and analysis distribution to forecsat without OMI. This is a fully nonlinear filter. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__init_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    6. py__likelihood_pdaf
    7. core DA algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__likelihood_pdaf : Callable[step:int, dim_obs_p:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], resid : ndarray[tuple[dim_obs_p], np.float64], likely:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **resid** : ndarray[tuple[dim_obs_p], np.float64]

            * Input vector holding the residual

        * **likely** : float

            * Output value of the likelihood

        **Callback Returns**

        * **likely** : float

            * Output value of the likelihood


    Returns
    -------
    flag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.likelihood_pdaf = <void*>py__likelihood_pdaf

    cdef int flag

    c__pdaf_put_state_pf (c__PDAFcython.c__collect_state_pdaf,
                          c__PDAFcython.c__init_dim_obs_pdaf,
                          c__PDAFcython.c__obs_op_pdaf,
                          c__PDAFcython.c__init_obs_pdaf,
                          c__PDAFcython.c__prepoststep_pdaf,
                          c__PDAFcython.c__likelihood_pdaf,
                          &flag
                         )

    return flag

def put_state_prepost (py__collect_state_pdaf,
                       py__prepoststep_pdaf
                      ):
    """This function does not perform any DA. It is used to preprocess the ensemble. To distribute the ensemble back to the model with post-processing, `pyPDAF.PDAF.get_state` function should be used afterwards.
    The sequence of the user-supplied functions is: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble


    Returns
    -------
    flag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf

    cdef int flag

    c__pdaf_put_state_prepost (c__PDAFcython.c__collect_state_pdaf,
                               c__PDAFcython.c__prepoststep_pdaf,
                               &flag
                              )

    return flag

def put_state_seek (py__collect_state_pdaf,
                    py__init_dim_obs_pdaf,
                    py__obs_op_pdaf,
                    py__init_obs_pdaf,
                    py__prepoststep_pdaf,
                    py__prodRinvA_pdaf
                   ):
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.put_state_global` or `pyPDAF.PDAF.put_state_global_nondiagR`. 
    This function will use singular evolutive extended Kalman filter for DA without post-processing and analysis distribution to forecsat without OMI. This function is usually used in 'flexible' parallelisation, but SEEK is deterministic and does not require ensemble. A `pyPDAF.PDAF.get_state` function should be used to post-process the state vector and distribute the state vector to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf (for ensemble mean
    5. py__init_obs_pdaf
    6. py__obs_op_pdaf (for each ensemble member
    7. py__prodRinvA_pdaf
    8. core DA algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], A_p : ndarray[tuple[dim_obs_p, rank], np.float64], C_p : ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 HV

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix


    Returns
    -------
    flag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.prodRinvA_pdaf = <void*>py__prodRinvA_pdaf

    cdef int flag

    c__pdaf_put_state_seek (c__PDAFcython.c__collect_state_pdaf,
                            c__PDAFcython.c__init_dim_obs_pdaf,
                            c__PDAFcython.c__obs_op_pdaf,
                            c__PDAFcython.c__init_obs_pdaf,
                            c__PDAFcython.c__prepoststep_pdaf,
                            c__PDAFcython.c__prodRinvA_pdaf,
                            &flag
                           )

    return flag

def put_state_seik (py__collect_state_pdaf,
                    py__init_dim_obs_pdaf,
                    py__obs_op_pdaf,
                    py__init_obs_pdaf,
                    py__prepoststep_pdaf,
                    py__prodRinvA_pdaf,
                    py__init_obsvar_pdaf
                   ):
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.put_state_global` or `pyPDAF.PDAF.put_state_global_nondiagR`. 
    This function will use singular evolutive interpolated Kalman filter for DA without post-processing and analysis distribution to forecsat without OMI. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf (for ensemble mean
    5. py__init_obs_pdaf
    6. py__obs_op_pdaf (for each ensemble member
    7. py__init_obsvar_pdaf (only relevant for adaptive forgetting factor schemes)
    8. py__prodRinvA_pdaf
    9. core DA algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], A_p : ndarray[tuple[dim_obs_p, rank], np.float64], C_p : ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **meanvar** : float

            * Mean observation error variance

        **Callback Returns**

        * **meanvar** : float

            * Mean observation error variance


    Returns
    -------
    flag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.prodRinvA_pdaf = <void*>py__prodRinvA_pdaf
    c__PDAFcython.init_obsvar_pdaf = <void*>py__init_obsvar_pdaf

    cdef int flag

    c__pdaf_put_state_seik (c__PDAFcython.c__collect_state_pdaf,
                            c__PDAFcython.c__init_dim_obs_pdaf,
                            c__PDAFcython.c__obs_op_pdaf,
                            c__PDAFcython.c__init_obs_pdaf,
                            c__PDAFcython.c__prepoststep_pdaf,
                            c__PDAFcython.c__prodRinvA_pdaf,
                            c__PDAFcython.c__init_obsvar_pdaf,
                            &flag
                           )

    return flag

def reset_forget (double forget_in
                 ):
    """This function allows a user to reset the forgetting factor manually during the assimilation process. For the local ensemble Kalman filters the forgetting factor can be set either globally of differently for each local analysis domain. For the LNETF and the global filters only a global setting of the forgeting factor is possible. In addition, the implementation of adaptive choices for the forgetting factor (beyond what is implemented in PDAF) are possible.

    Parameters
    ----------
    forget_in : float
        New value of forgetting factor
    """

    c__pdaf_reset_forget (&forget_in
                         )

def SampleEns (double[:,:] modes,
               double[::1] svals,
               double[::1] state,
               int verbose,
               int flag
              ):
    """This function generates an ensemble from singular values and their vectors (EOF modes) centred on given mean state. The singular values and vectors are derived from the ensemble anomalies which can be obtained from a long model trajectory using `pyPDAF.PDAF.eofcovar`.

    Parameters
    ----------
    modes : ndarray[tuple[dim, dim_ens-1], np.float64]
        Array of EOF modes
    svals : ndarray[tuple[dim_ens-1], np.float64]
        Vector of singular values
    state : ndarray[tuple[dim], np.float64]
        PE-local model mean state
    verbose : int
        Verbosity flag
    flag : int
        Status flag

    Returns
    -------
    modes : ndarray[tuple[dim, dim_ens-1], np.float64]
         Array of EOF modes
    state : ndarray[tuple[dim], np.float64]
         PE-local model mean state
    ens : ndarray[tuple[dim, dim_ens], np.float64]
         State ensemble
    flag : int
        Status flag
    """

    cdef double[::1] modes_f = np.asfortranarray(modes).ravel(order="F")
    cdef int dim, dim_ens
    dim = modes.shape[0]
    dim_ens = modes.shape[1]
    dim_ens = dim_ens + 1

    cdef double [::1] ens = np.zeros((dim, dim_ens), dtype=np.float64).ravel()

    c__pdaf_sampleens (&dim,
                       &dim_ens,
                       &modes_f[0],
                       &svals[0],
                       &state[0],
                       &ens[0],
                       &verbose,
                       &flag
                      )

    return np.asarray(modes).reshape((dim, dim_ens-1), order='F'), np.asarray(state).reshape((dim), order='F'), np.asarray(ens).reshape((dim, dim_ens), order='F'), flag

def set_debug_flag (int debugval
                   ):
    """This function activates the debug output of the PDAF. Starting from the use of this function, the debug infomation is sent to screen output.  The screen output end when the debug flag is set to 0. We recommend using debugging output for single local domain, e.g. `if domain_p = 1: pyPDAF.PDAF.set_debug_flag(1)`.
    

    Parameters
    ----------
    debugval : int
        Value of debugging flag; print debug information for >0
    """

    c__pdaf_set_debug_flag (&debugval
                           )

def set_ens_pointer ():
    """This function returns the ensemble array in a numpy array where the internal array data has the same memoery address as PDAF ensemble array.


    Returns
    -------
    c_ens_point : ndarray[float]
        Pointer to smoother array
    dims : ndarray[tuple[2], np.intc]
         dimension of the pointer
    status : int
        Status flag
    """

    cdef double* c_ens_point
    cdef int [::1] dims = np.zeros((2), dtype=np.intc).ravel()
    cdef int status

    c__pdaf_set_ens_pointer (&c_ens_point,
                             &dims[0],
                             &status
                            )

    dims = np.asarray(dims)
    return np.asarray(<double[:np.prod(dims)]> c_ens_point).reshape(dims, order='F'), \
           status

def set_smootherens (int maxlag
                    ):
    """This function can be used in the offline implementation when a smoother is used. It is typically called in `py__init_ens_pdaf` in the call to `pyPDAF.PDAF.PDAF_init`. The function `pyPDAF.PDAF.set_smootherens` is used when the smoother extension of a filter is used. In this case, the smoothed ensemble states at earlier times are stored in an internal array of PDAF. To be able to smooth post times, the smoother algorithm must have access to the past ensembles. In the offline mode the user has to manually fill the smoother ensemble array from ensembles read in from files. In the online mode, the smoother array is filled automatically during the cycles of forecast phases and analysis steps. 

    Parameters
    ----------
    maxlag : int
        Number of past timesteps processed in sens

    Returns
    -------
    c_sens_point : ndarray[float]
        Pointer to smoother array
    dims : ndarray[tuple[3], np.intc]
         dimension of the pointer
    status : int
        Status flag
    """

    cdef double* c_sens_point
    cdef int [::1] dims = np.zeros((3), dtype=np.intc).ravel()
    cdef int status

    c__pdaf_set_smootherens (&c_sens_point,
                             &maxlag,
                             &dims[0],
                             &status
                            )

    dims = np.asarray(dims)
    return np.asarray(<double[:np.prod(dims)]> c_sens_point).reshape(dims, order='F'), \
           status

def seik_TtimesA (double[:,:] A
                 ):
    """This is an internal function in PDAF where it perform matrix calculation of B = TA. This allows for two types of T matrix. The resulting matrix B is the transformation matrix act on the full forecast ensemble. Mathematical description of the function is the second term of Eq. (23) and the T matrix is defined in Eq. (13) in
    Nerger, L., Janji, T., Schrter, J., Hiller, W. (2012). A unification of ensemble square root Kalman filters. Monthly Weather Review, 140, 2335-2345. doi:10.1175/MWR-D-11-00102.1
    

    Parameters
    ----------
    A : ndarray[tuple[rank, dim_col], np.float64]
        Input matrix

    Returns
    -------
    B : ndarray[tuple[rank+1, dim_col], np.float64]
         Output matrix (TA)
    """

    cdef double[::1] A_f = np.asfortranarray(A).ravel(order="F")
    cdef int rank, dim_col
    rank = A.shape[0]
    dim_col = A.shape[1]

    cdef double [::1] B = np.zeros((rank+1, dim_col), dtype=np.float64).ravel()

    c__pdaf_seik_ttimesa (&rank,
                          &dim_col,
                          &A_f[0],
                          &B[0]
                         )

    return np.asarray(B).reshape((rank+1, dim_col), order='F')

def etkf_Tleft (double[:,:] A
               ):
    """This is an internal function in PDAF where it perform matrix calculation of B = TA. This function performs the second term of Eq. (34) i
    Nerger, L., Janji, T., Schrter, J., Hiller, W. (2012). A unification of ensemble square root Kalman filters. Monthly Weather Review, 140, 2335-2345. doi:10.1175/MWR-D-11-00102.1
    

    Parameters
    ----------
    A : ndarray[tuple[dim_ens, dim], np.float64]
        Input/output matrix

    Returns
    -------
    A : ndarray[tuple[dim_ens, dim], np.float64]
         Input/output matrix
    """

    cdef double[::1] A_f = np.asfortranarray(A).ravel(order="F")
    cdef int dim_ens, dim
    dim_ens = A.shape[0]
    dim = A.shape[1]

    c__pdaf_etkf_tleft (&dim_ens,
                        &dim,
                        &A_f[0]
                       )

    return np.asarray(A).reshape((dim_ens, dim), order='F')

def estkf_OmegaA (double[:,:] A
                 ):
    """This function is an internal function in PDAF. This function performs the second term of Eq. (29) i
    Nerger, L., Janji, T., Schrter, J., Hiller, W. (2012). A unification of ensemble square root Kalman filters. Monthly Weather Review, 140, 2335-2345. doi:10.1175/MWR-D-11-00102.1
    

    Parameters
    ----------
    A : ndarray[tuple[rank, dim_col], np.float64]
        Input matrix

    Returns
    -------
    B : ndarray[tuple[rank+1, dim_col], np.float64]
         Output matrix (TA)
    """

    cdef double[::1] A_f = np.asfortranarray(A).ravel(order="F")
    cdef int rank, dim_col
    rank = A.shape[0]
    dim_col = A.shape[1]

    cdef double [::1] B = np.zeros((rank+1, dim_col), dtype=np.float64).ravel()

    c__pdaf_estkf_omegaa (&rank,
                          &dim_col,
                          &A_f[0],
                          &B[0]
                         )

    return np.asarray(B).reshape((rank+1, dim_col), order='F')

def enkf_omega (int[::1] seed,
                double[:,:] omega,
                double norm,
                int otype,
                int screen
               ):
    """Generation of a random matrix with orthogonal basis following SEEK approach for EnKF with given properties.

    Parameters
    ----------
    seed : ndarray[tuple[4], np.intc]
        Seed for random number generation
    omega : ndarray[tuple[dim_ens, r], np.float64]
        Random matrix
    norm : float
        Norm for ensemble transformation
    otype : int
        Type of Omega: (1) Simple Gaussian random matrix (2) Columns of unit norm (3) Columns of norm dim_ens^(-1/2) (4) Projection orthogonal (1,..,1)^T (6) Combination of 2 and 4 (7) Combination of 3 and 4 (8) Rows of sum 0 and variance 1
    screen : int
        Verbosity flag

    Returns
    -------
    omega : ndarray[tuple[dim_ens, r], np.float64]
         Random matrix
    norm : float
        Norm for ensemble transformation
    """

    cdef double[::1] omega_f = np.asfortranarray(omega).ravel(order="F")
    cdef int dim_ens, r
    dim_ens = omega.shape[0]
    r = omega.shape[1]

    c__pdaf_enkf_omega (&seed[0],
                        &r,
                        &dim_ens,
                        &omega_f[0],
                        &norm,
                        &otype,
                        &screen
                       )

    return np.asarray(omega).reshape((dim_ens, r), order='F'), norm

def seik_omega (double[:,:] omega,
                int omegatype,
                int screen
               ):
    """Generation of a random matrix with orthogonal basis following SEIK approach.

    Parameters
    ----------
    omega : ndarray[tuple[rank+1, rank], np.float64]
        Matrix Omega
    omegatype : int
        Select type of Omega: (1) generated from random vectors (0) generated from deterministic vectors (Householder)
    screen : int
        Verbosity flag

    Returns
    -------
    omega : ndarray[tuple[rank+1, rank], np.float64]
         Matrix Omega
    """

    cdef double[::1] omega_f = np.asfortranarray(omega).ravel(order="F")
    cdef int rank
    rank = omega.shape[0]
    _ = omega.shape[1]
    rank = rank - 1

    c__pdaf_seik_omega (&rank,
                        &omega_f[0],
                        &omegatype,
                        &screen
                       )

    return np.asarray(omega).reshape((rank+1, rank), order='F')

def incremental (int steps,
                 py__dist_stateinc_pdaf
                ):
    """This is a helper function to apply analysis increment to model state in model forecast phase. It simply calls the user-supplied function. 

    Parameters
    ----------
    steps : int
        Time steps over which increment is distributed
    py__dist_stateinc_pdaf : Callable[dim_p:int, state_inc_p : ndarray[tuple[dim_p], np.float64], first:int, steps:int]
        Add state increment during integration

        **Callback Parameters**

        * **dim_p** : int

            * Dimension of PE-local state

        * **state_inc_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state vector

        * **first** : int

            * Flag for first call of each forecast

        * **steps** : int

            * number of time steps in forecast

        **Callback Returns**

    """

    c__PDAFcython.dist_stateinc_pdaf = <void*>py__dist_stateinc_pdaf

    c__pdaf_incremental (&steps,
                         c__PDAFcython.c__dist_stateinc_pdaf
                        )

def add_increment (double[::1] state_p
                  ):
    """This function directly adds analysis increment to given state vector without the need for user-supplied functions.

    Parameters
    ----------
    state_p : ndarray[tuple[dim_p], np.float64]
        State vector

    Returns
    -------
    state_p : ndarray[tuple[dim_p], np.float64]
         State vector
    """

    cdef int dim_p
    dim_p = state_p.shape[0]

    c__pdaf_add_increment (&dim_p,
                           &state_p[0]
                          )

    return np.asarray(state_p).reshape((dim_p), order='F')

def local_weights (int wtype,
                   double cradius,
                   double sradius,
                   double[::1] distance,
                   int verbose
                  ):
    """This function returns a vector of the localisation weights based on distance and localisation functions and radii. This function is particularly useful for mannually apply covariance localisations for state or observation errors.

    Parameters
    ----------
    wtype : int
        Type of weight function (0): unit weight (=1 up to distance=cradius) (1): exponential decrease (1/e at distance=sradius; 0 for distance>cradius) (2): 5th order polynomial (Gaspari&Cohn 1999; 0 for distance>cradius)
    cradius : float
        Parameter for cut-off
    sradius : float
        Support radius
    distance : ndarray[tuple[dim], np.float64]
        Array holding distances
    verbose : int
        Verbosity flag

    Returns
    -------
    weight : ndarray[tuple[dim], np.float64]
         Array for weights
    """

    cdef int dim
    dim = distance.shape[0]

    cdef double [::1] weight = np.zeros((dim), dtype=np.float64).ravel()

    c__pdaf_local_weights (&wtype,
                           &cradius,
                           &sradius,
                           &dim,
                           &distance[0],
                           &weight[0],
                           &verbose
                          )

    return np.asarray(weight).reshape((dim), order='F')

def diag_CRPS (int element,
               double[:,:] oens,
               double[::1] obs
              ):
    """Obtain a continuous rank probability score for an ensemble. The implementation is based on This function follows follows Hersbach, H., 2000: Decomposition of the Continuous Ranked Probability Score for Ensemble Prediction Systems. Wea. Forecasting, 15, 559570, https://doi.org/10.1175/1520-0434(2000)015<0559:DOTCRP>2.0.CO;2
    

    Parameters
    ----------
    element : int
        ID of element to be used. If element=0, mean values over all elements are computed
    oens : ndarray[tuple[dim, dim_ens], np.float64]
        State ensemble
    obs : ndarray[tuple[dim], np.float64]
        State ensemble

    Returns
    -------
    CRPS : float
        CRPS
    reli : float
        Reliability
    resol : float
        resolution
    uncert : float
        uncertainty
    status : int
        Status flag (0=success)
    """

    cdef double[::1] oens_f = np.asfortranarray(oens).ravel(order="F")
    cdef int dim, dim_ens
    dim = oens.shape[0]
    dim_ens = oens.shape[1]

    cdef double CRPS
    cdef double reli
    cdef double resol
    cdef double uncert
    cdef int status

    c__pdaf_diag_crps (&dim,
                       &dim_ens,
                       &element,
                       &oens_f[0],
                       &obs[0],
                       &CRPS,
                       &reli,
                       &resol,
                       &uncert,
                       &status
                      )

    return CRPS, reli, resol, uncert, status

def force_analysis ():
    """This function overwrite member index of the ensemble state by local_dim_ens (number of ensembles for current process, in full parallel setup, this is 1.) and the counter cnt_steps by nsteps-1.
    This forces that the analysis step is executed at the next call to PDAF assimilation functions.

    """

    c__pdaf_force_analysis ()

def gather_obs_f2_flex (int dim_obs_f,
                        double[:,:] coords_p
                       ):
    """In the local filters (LESKTF, LETKF, LSEIK, LNETF)
    this function returns the full observation coordinates from process-local observation coordinates. `pyPDAF.PDAF.gather_obs_f_flex` is used to get corresponding observations. Unlike `pyPDAF.PDAF.gather_obs_f2`, the function does not use depends on
    `pyPDAF.PDAF.gather_dim_obs_f`

    Parameters
    ----------
    dim_obs_f : int
        Full observation dimension
    coords_p : ndarray[tuple[nrows, dim_obs_p], np.float64]
        PE-local array

    Returns
    -------
    coords_f : ndarray[tuple[nrows, dim_obs_f], np.float64]
         Full gathered array
    status : int
        Status flag: (0) no error
    """

    cdef double[::1] coords_p_f = np.asfortranarray(coords_p).ravel(order="F")
    cdef int nrows, dim_obs_p
    nrows = coords_p.shape[0]
    dim_obs_p = coords_p.shape[1]

    cdef double [::1] coords_f = np.zeros((nrows, dim_obs_f), dtype=np.float64).ravel()
    cdef int status

    c__pdaf_gather_obs_f2_flex (&dim_obs_p,
                                &dim_obs_f,
                                &coords_p_f[0],
                                &coords_f[0],
                                &nrows,
                                &status
                               )

    return np.asarray(coords_f).reshape((nrows, dim_obs_f), order='F'), status

def gather_obs_f_flex (int dim_obs_f,
                       double[::1] obs_p
                      ):
    """In the local filters (LESKTF, LETKF, LSEIK, LNETF) this function returns the total observation vector from process-local observations. `pyPDAF.PDAF.gather_obs_f2_flex` is used to get corresponding coordinates.
    Unlike `pyPDAF.PDAF.gather_obs_f`, the function does not use depends on `pyPDAF.PDAF.gather_dim_obs_f`

    Parameters
    ----------
    dim_obs_f : int
        Full observation dimension
    obs_p : ndarray[tuple[dim_obs_p], np.float64]
        PE-local vector

    Returns
    -------
    obs_f : ndarray[tuple[dim_obs_f], np.float64]
         Full gathered vector
    status : int
        Status flag: (0) no error
    """

    cdef int dim_obs_p
    dim_obs_p = obs_p.shape[0]

    cdef double [::1] obs_f = np.zeros((dim_obs_f), dtype=np.float64).ravel()
    cdef int status

    c__pdaf_gather_obs_f_flex (&dim_obs_p,
                               &dim_obs_f,
                               &obs_p[0],
                               &obs_f[0],
                               &status
                              )

    return np.asarray(obs_f).reshape((dim_obs_f), order='F'), status

def prepost (py__collect_state_pdaf,
             py__distribute_state_pdaf,
             py__prepoststep_pdaf,
             py__next_observation_pdaf
            ):
    """This function does not perform any DA. It is used to perform a preprocess and postprocess of the ensemble. Compared to `pyPDAF.PDAF.assimilate_prepost`, this function does not set assimilation flag.
    The function is a combination of `pyPDAF.PDAF.put_state_prepost` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__prepoststep_state_pdaf
    4. py__distribute_state_pdaf
    5. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time


    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    cdef int outflag

    c__pdaf_prepost (c__PDAFcython.c__collect_state_pdaf,
                     c__PDAFcython.c__distribute_state_pdaf,
                     c__PDAFcython.c__prepoststep_pdaf,
                     c__PDAFcython.c__next_observation_pdaf,
                     &outflag
                    )

    return outflag

def set_memberid (int memberid
                 ):
    """This function sets the ensemble member index to given value.

    Parameters
    ----------
    memberid : int
        Index in the local ensemble

    Returns
    -------
    memberid : int
        Index in the local ensemble
    """

    c__pdaf_set_memberid (&memberid
                         )

    return memberid

def set_comm_pdaf (int in_COMM_pdaf
                  ):
    """This function sets the MPI communicator of PDAF. This is by default `MPI_COMM_WORLD`. 

    Parameters
    ----------
    in_COMM_pdaf : int
        MPI communicator for PDAF
    """

    c__pdaf_set_comm_pdaf (&in_COMM_pdaf
                          )

def set_offline_mode (int screen
                     ):
    """This function activates offline mode.

    Parameters
    ----------
    screen : int
        Verbosity flag
    """

    c__pdaf_set_offline_mode (&screen
                             )

def print_domain_stats (int n_domains_p
                       ):
    """This function make screen output of statistics of the local domains on current process.

    Parameters
    ----------
    n_domains_p : int
        Number of PE-local analysis domains
    """

    c__pdaf_print_domain_stats (&n_domains_p
                               )

def init_local_obsstats ():
    """This function initialise the observation statistics of local domain. This statistics can be updated by `pyPDAF.PDAF.incr_local_obsstats`, and can be viewed by `pyPDAF.PDAF.print_local_obsstats`.

    """

    c__pdaf_init_local_obsstats ()

def incr_local_obsstats (int dim_obs_l
                        ):
    """This function update the observation statistics of local domain. This statistics should be initialised by `pyPDAF.PDAF.init_local_obsstats`, and can be viewed by `pyPDAF.PDAF.print_local_obsstats`.

    Parameters
    ----------
    dim_obs_l : int
        Number of locally assimilated observations
    """

    c__pdaf_incr_local_obsstats (&dim_obs_l
                                )

def print_local_obsstats (int screen
                         ):
    """This function print the observation statistics of local domain on screen. This statistics should be initialised by `pyPDAF.PDAF.init_local_obsstats`, and can be updated by `pyPDAF.PDAF.incr_local_obsstats`.

    Parameters
    ----------
    screen : int
        Verbosity flag

    Returns
    -------
    n_domains_with_obs : int
        number of domains with observations
    """

    cdef int n_domains_with_obs

    c__pdaf_print_local_obsstats (&screen,
                                  &n_domains_with_obs
                                 )

    return n_domains_with_obs

def omit_obs_omi (double[::1] state_p,
                  double[:,:] ens_p,
                  double[::1] obs_p,
                  py__init_obs_pdaf,
                  py__obs_op_pdaf,
                  int compute_mean,
                  int screen
                 ):
    """This function computes innovation and omit corresponding observations in assimilation if the innovation is too large. This function is used by some of the global filters, e.g. EnKF, LEnKF, PF, NETF, with OMI.

    Parameters
    ----------
    state_p : ndarray[tuple[dim_p], np.float64]
        on exit: PE-local forecast mean state
    ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]
        PE-local state ensemble
    obs_p : ndarray[tuple[dim_obs_p], np.float64]
        PE-local observation vector
    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    compute_mean : int
        (1) compute mean; (0) state_p holds mean
    screen : int
        Verbosity flag

    Returns
    -------
    state_p : ndarray[tuple[dim_p], np.float64]
         on exit: PE-local forecast mean state
    obs_p : ndarray[tuple[dim_obs_p], np.float64]
         PE-local observation vector
    """

    cdef double[::1] ens_p_f = np.asfortranarray(ens_p).ravel(order="F")
    cdef int dim_p, dim_ens, dim_obs_p
    dim_p = ens_p.shape[0]
    dim_ens = ens_p.shape[1]
    dim_obs_p = obs_p.shape[0]

    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf

    c__pdaf_omit_obs_omi (&dim_p,
                          &dim_obs_p,
                          &dim_ens,
                          &state_p[0],
                          &ens_p_f[0],
                          &obs_p[0],
                          c__PDAFcython.c__init_obs_pdaf,
                          c__PDAFcython.c__obs_op_pdaf,
                          &compute_mean,
                          &screen
                         )

    return np.asarray(state_p).reshape((dim_p), order='F'), np.asarray(obs_p).reshape((dim_obs_p), order='F')

def diag_CRPS_nompi (int element,
                     double[:,:] oens,
                     double[::1] obs
                    ):
    """Obtain a continuous rank probability score for an ensemble without using MPI parallelisation. The implementation is based on This function follows follows Hersbach, H., 2000: Decomposition of the Continuous Ranked Probability Score for Ensemble Prediction Systems. Wea. Forecasting, 15, 559570, https://doi.org/10.1175/1520-0434(2000)015<0559:DOTCRP>2.0.CO;2
    

    Parameters
    ----------
    element : int
        ID of element to be used If element=0, mean values over all elements are computed
    oens : ndarray[tuple[dim, dim_ens], np.float64]
        State ensemble
    obs : ndarray[tuple[dim], np.float64]
        State ensemble

    Returns
    -------
    CRPS : float
        CRPS
    reli : float
        Reliability
    resol : float
        resolution
    uncert : float
        uncertainty
    status : int
        Status flag (0=success)
    """

    cdef double[::1] oens_f = np.asfortranarray(oens).ravel(order="F")
    cdef int dim, dim_ens
    dim = oens.shape[0]
    dim_ens = oens.shape[1]

    cdef double CRPS
    cdef double reli
    cdef double resol
    cdef double uncert
    cdef int status

    c__pdaf_diag_crps_nompi (&dim,
                             &dim_ens,
                             &element,
                             &oens_f[0],
                             &obs[0],
                             &CRPS,
                             &reli,
                             &resol,
                             &uncert,
                             &status
                            )

    return CRPS, reli, resol, uncert, status

def omi_init (int n_obs
             ):
    """This function initialise the number of observation types in OMI by allocating an array of `obs_f` derived types instances. This should be called before any other OMI functions.

    Parameters
    ----------
    n_obs : int
        number of observations
    """

    c__pdafomi_init (&n_obs
                    )

def omi_set_doassim (int i_obs,
                     int doassim
                    ):
    """This function sets the `doassim` attribute of `obs_f` typically used in user-supplied function `py__init_dim_obs_pdaf`. If `doassim` is set to 0, the observation is not assimilated in the DA system. See https://pdaf.awi.de/trac/wiki/OMI_observation_modules#thisobsdoassim

    Parameters
    ----------
    i_obs : int
        index of observation types
    doassim : int
        0) do not assimilate; 1) assimilate the observation type
    """

    c__pdafomi_set_doassim (&i_obs,
                            &doassim
                           )

def omi_set_disttype (int i_obs,
                      int disttype
                     ):
    """This function sets the `disttype` attribute of `obs_f` typically used in user-supplied function `py__init_dim_obs_pdaf`. `disttype` determines the way the distance between observation and model grid is calculated in OMI. See https://pdaf.awi.de/trac/wiki/OMI_observation_modules#thisobsdisttype

    Parameters
    ----------
    i_obs : int
        index of observations
    disttype : int
        0) Cartesian; 1) Cartesian periodic 2) Approximation to geographic distance in metres using latitude and longitude expressed in radians 3) Using Haversine formula to compute distance in metres between two points on the surface of a sphere 10) 3D Cartesian distance for 2D+1D factorised localisation where horizontal and vertical distances are treated separately 11) 3D Cartesian periodic distance for 2D+1D factorised localisation where horizontal and vertical distances are treated separately 12) Same as 2) for horizontal distance but vertical distance is in units chosen by users 13) Same as 3) for horizontal distance but vertical distance is in units chosen by users
    """

    c__pdafomi_set_disttype (&i_obs,
                             &disttype
                            )

def omi_set_ncoord (int i_obs,
                    int ncoord
                   ):
    """This function sets the `ncoord` attribute of `obs_f` typically used in user-supplied function `py__init_dim_obs_pdaf`. This is the dimension of coordinates of the observation. 

    Parameters
    ----------
    i_obs : int
        index of observations
    ncoord : int
        Dimension of the observation coordinate
    """

    c__pdafomi_set_ncoord (&i_obs,
                           &ncoord
                          )

def omi_set_id_obs_p (int i_obs,
                      int[:,:] id_obs_p
                     ):
    """Setting the `id_obs_p` attribute of `obs_f`.

    The function is typically used in user-supplied function `py__init_dim_obs_pdaf`.

    Here, `id_obs_p(nrows, dim_obs_p)` is a 2D array of integers.
    The value of `nrows` depends on the observation operator used for an observation.

    Examples:

    - `nrows=1`: observations are located on model grid point.
      In this case, `id_obs_p` stores the index of the state vector (starting from 1) corresponds to the observations,
      e.g. `id_obs_p[0, j] = i` means that the location and variable of the `i`-th element of the state vector
      is the same as the `j`-th observation.

    - `nrows=4`: each observation corresponds to 4 indices of elements in the state vector.
       In this case,
       the location of these elements is used to perform bi-linear interpolation
       from model grid to observation location.
       This information is used in the :func:`pyPDAF.PDAF.omi_obs_op_gridavg`
       and :func:`pyPDAF.PDAF.omi_obs_op_interp_lin` functions.
       When interpolation is needed,
       the weighting of the interpolation is done
       in the :func:`pyPDAF.PDAF.omi_get_interp_coeff_lin`,
       :func:`pyPDAF.PDAF.omi_get_interp_coeff_lin1D`,
       and :func:`pyPDAF.PDAF.omi_get_interp_coeff_tri` functions.
       The details of interpolation setup can be found at
       `PDAF wiki page <https://pdaf.awi.de/trac/wiki/OMI_observation_operators#Initializinginterpolationcoefficients>`_.


    Parameters
    ----------
    i_obs : int
        index of observations
    id_obs_p : ndarray[tuple[nrows, dim_obs_p], np.intc]
        indice corresponds to observations in the state vector
    """

    cdef int[::1] id_obs_p_f = np.asfortranarray(id_obs_p).ravel(order="F")
    cdef int nrows, dim_obs_p
    nrows = id_obs_p.shape[0]
    dim_obs_p = id_obs_p.shape[1]

    c__pdafomi_set_id_obs_p (&i_obs,
                             &nrows,
                             &dim_obs_p,
                             &id_obs_p_f[0]
                            )

def omi_set_icoeff_p (int i_obs,
                      double[:,:] icoeff_p
                     ):
    """This function sets the `icoeff_p` attribute of `obs_f` typically used in user-supplied function `py__init_dim_obs_pdaf`. `icoeff_p(nrows, dim_obs_p)` is a 2D array of real number used to implement
    interpolations. This is used in tandem with `id_obs_p`. Checking the documentation of `pyPDAF.PDAF.omi_set_id_obs_p` for some details. Also, see https://pdaf.awi.de/trac/wiki/OMI_observation_operators#Initializinginterpolationcoefficients for setting these values.

    Parameters
    ----------
    i_obs : int
        index of observations
    icoeff_p : ndarray[tuple[nrows, dim_obs_p], np.float64]
        weighting coefficients for interpolations
    """

    cdef double[::1] icoeff_p_f = np.asfortranarray(icoeff_p).ravel(order="F")
    cdef int nrows, dim_obs_p
    nrows = icoeff_p.shape[0]
    dim_obs_p = icoeff_p.shape[1]

    c__pdafomi_set_icoeff_p (&i_obs,
                             &nrows,
                             &dim_obs_p,
                             &icoeff_p_f[0]
                            )

def omi_set_domainsize (int i_obs,
                        double[::1] domainsize
                       ):
    """This function sets the `domainsize` attribute of `obs_f` typically used in user-supplied function `py__init_dim_obs_pdaf`. `domainsize(ncoord)` is the size of the domain in each spatial dimension. This information is used to compute the Cartesian disance with periodic boundary. If the value of one dimension is `<=0`, no periodicity is assumed in that dimension. 

    Parameters
    ----------
    i_obs : int
        index of observations
    domainsize : ndarray[tuple[ncoord], np.float64]
        Size of the domain in each dimension
    """

    cdef int ncoord
    ncoord = domainsize.shape[0]

    c__pdafomi_set_domainsize (&i_obs,
                               &ncoord,
                               &domainsize[0]
                              )

def omi_set_obs_err_type (int i_obs,
                          int obs_err_type
                         ):
    """This function sets the `obs_err_type` attribute of `obs_f` typically used in user-supplied function `py__init_dim_obs_pdaf`. `obs_err_type` is an integer that specifies the type of observation error. 

    Parameters
    ----------
    i_obs : int
        index of observations
    obs_err_type : int
        0) Gaussian (default); 1) double exponential (Laplacian)
    """

    c__pdafomi_set_obs_err_type (&i_obs,
                                 &obs_err_type
                                )

def omi_set_use_global_obs (int i_obs,
                            int use_global_obs
                           ):
    """This function sets the `use_global_obs` attribute of `obs_f` typically used in user-supplied function `py__init_dim_obs_pdaf`. In the domain-localized filters (LESTK, LETKF, LSEIK, LNETF) observations are assimilated that are located within the localization around some grid point. When a model uses parallelisation with domain-decomposition some of these observations might belong to a different process-domain. In the default mode (use_global_obs=1) PDAF-OMI gathers all globally available observations so that each process has access to all observations.
    It can be more efficient to limit the observations on a process-domain to those observations that are located inside the domain or within the localization radius around it. Then, in the local analyses less observations have to be checked for their distance. Setting use_global_obs=0 activates this feature. However, it needs additional preparations to make PDAF-OMI aware of the limiting coordinates of a process sub-domain. See https://pdaf.awi.de/trac/wiki/OMI_use_global_obs for the use of `pyPDAF.PDAF.omi_set_domain_limits`.

    Parameters
    ----------
    i_obs : int
        index of observations
    use_global_obs : int
        0) Using process-local observations; 1) using cross-process observations (default)
    """

    c__pdafomi_set_use_global_obs (&i_obs,
                                   &use_global_obs
                                  )

def omi_set_inno_omit (int i_obs,
                       double inno_omit
                      ):
    """This function sets the `inno_omit` attribute of `obs_f` typically used in user-supplied function `py__init_dim_obs_pdaf`. Setting this variable to a value > 0.0 activates the functionality that observations are omitted (made irrelevant) from the analysis update if the difference of their value and the ensemble mean to too large. If inno_omit=2.0, an observation would be omitted if the squared difference between the observed ensemble mean state and the observation value is larger than 2 times the observation error variance
    See https://pdaf.awi.de/trac/wiki/PDAFomi_additional_functionality#Omittingobservationsthatarepotentialoutliers

    Parameters
    ----------
    i_obs : int
        index of observations
    inno_omit : float
        Threshold of innovation to be omitted
    """

    c__pdafomi_set_inno_omit (&i_obs,
                              &inno_omit
                             )

def omi_set_inno_omit_ivar (int i_obs,
                            double inno_omit_ivar
                           ):
    """This function sets the `inno_omit_ivar` attribute of `obs_f` typically used in user-supplied function `py__init_dim_obs_pdaf`. This is used to specify the inverse of the observations variance to omit the observation. By default it is `1e-12` for a large observation error, but users can adjust this value to ensure that the observation is omitted based on applications
    

    Parameters
    ----------
    i_obs : int
        index of observations
    inno_omit_ivar : float
        Inverse of observation variance for omiited observations
    """

    c__pdafomi_set_inno_omit_ivar (&i_obs,
                                   &inno_omit_ivar
                                  )

def omi_gather_obs (int i_obs,
                    double[::1] obs_p,
                    double[::1] ivar_obs_p,
                    double[:,:] ocoord_p,
                    double cradius
                   ):
    """This function is typically called in the user-supplied function `py__init_dim_obs_pdaf`. This function returns the full observation dimensioin from process-local observations. It also sets the observation vector, its coordinates, and the inverse of the observation variance. This function furtuer sets the localisation radius in OMI.

    Parameters
    ----------
    i_obs : int
        index of observations
    obs_p : ndarray[tuple[dim_obs_p], np.float64]
        pe-local observation vector
    ivar_obs_p : ndarray[tuple[dim_obs_p], np.float64]
        pe-local inverse observation error variance
    ocoord_p : ndarray[tuple[thisobs(i_obs)%ncoord, dim_obs_p], np.float64]
        pe-local observation coordinates
    cradius : float
        localization radius

    Returns
    -------
    dim_obs : int
        Full number of observations
    """

    cdef double[::1] ocoord_p_f = np.asfortranarray(ocoord_p).ravel(order="F")
    cdef int dim_obs_p
    _ = ocoord_p.shape[0]
    dim_obs_p = ocoord_p.shape[1]

    cdef int dim_obs

    c__pdafomi_gather_obs (&i_obs,
                           &dim_obs_p,
                           &obs_p[0],
                           &ivar_obs_p[0],
                           &ocoord_p_f[0],
                           &cradius,
                           &dim_obs
                          )

    return dim_obs

def omi_gather_obsstate (int i_obs,
                         double[::1] obsstate_p,
                         double[::1] obsstate_f
                        ):
    """This function is used to implement custom observation operators. See https://pdaf.awi.de/trac/wiki/OMI_observation_operators#Implementingyourownobservationoperator

    Parameters
    ----------
    i_obs : int
        index of observations
    obsstate_p : ndarray[tuple[thisobs(i_obs)%dim_obs_p], np.float64]
        Vector of process-local observed state
    obsstate_f : ndarray[tuple[nobs_f_all], np.float64]
        Full observed vector for all types

    Returns
    -------
    obsstate_f : ndarray[tuple[nobs_f_all], np.float64]
         Full observed vector for all types
    """

    cdef int nobs_f_all
    nobs_f_all = obsstate_f.shape[0]

    c__pdafomi_gather_obsstate (&i_obs,
                                &obsstate_p[0],
                                &obsstate_f[0],
                                &nobs_f_all
                               )

    return np.asarray(obsstate_f).reshape((nobs_f_all), order='F')

def omi_set_domain_limits (double[:,:] lim_coords
                          ):
    """This is used to set the domain limits for the use of `pyPDAF.PDAF.omi_set_use_global_obs`.Currently, it only supports 2D limitations. See https://pdaf.awi.de/trac/wiki/PDAFomi_additional_functionality#PDAFomi_set_domain_limit
    

    Parameters
    ----------
    lim_coords : ndarray[tuple[2, 2], np.float64]
        geographic coordinate array (1: longitude, 2: latitude)
    """

    cdef double[::1] lim_coords_f = np.asfortranarray(lim_coords).ravel(order="F")
    c__pdafomi_set_domain_limits (&lim_coords_f[0]
                                 )

def omi_set_debug_flag (int debugval
                       ):
    """This sets the debug flag for OMI. If set to 1, debug information is printed to the screen.
    The debug flag can be set to 0 to stop the debugging. See https://pdaf.awi.de/trac/wiki/OMI_debugging

    Parameters
    ----------
    debugval : int
        Value for debugging flag
    """

    c__pdafomi_set_debug_flag (&debugval
                              )

def omi_deallocate_obs (int i_obs
                       ):
    """It deallocates teh OMI-internal obsrevation arrays but this should not be called as it is called internally in PDAF.

    Parameters
    ----------
    i_obs : int
        index of observations
    """

    c__pdafomi_deallocate_obs (&i_obs
                              )

def omi_obs_op_gridpoint (int i_obs,
                          double[::1] state_p,
                          double[::1] obs_f_all
                         ):
    """A (partial) identity observation operator

    This observation operator is used when observations and model use the same grid. 

    The observations operator selects state vectors where observations are present. 

    The function is used in the user-supplied function `py__obs_op_pdaf`. 

    

    Parameters
    ----------
    i_obs : int
        index of observations
    state_p : ndarray[tuple[dim_p], np.float64]
        PE-local model state (dim_p)
    obs_f_all : ndarray[tuple[nobs_f_all], np.float64]
        Full observed state for all observation types (nobs_f_all)

    Returns
    -------
    obs_f_all : ndarray[tuple[nobs_f_all], np.float64]
         Full observed state for all observation types (nobs_f_all)
    """

    cdef int dim_p, nobs_f_all
    dim_p = state_p.shape[0]
    nobs_f_all = obs_f_all.shape[0]

    c__pdafomi_obs_op_gridpoint (&i_obs,
                                 &state_p[0],
                                 &dim_p,
                                 &obs_f_all[0],
                                 &nobs_f_all
                                )

    return np.asarray(obs_f_all).reshape((nobs_f_all), order='F')

def omi_obs_op_gridavg (int i_obs,
                        int nrows,
                        double[::1] state_p,
                        double[::1] obs_f_all
                       ):
    """Observation operator that average values on given model grid points.

    The averaged model grid points are specified in `id_obs_p` property of `obs_f`,
    which can be set in :func:`pyPDAF.PDAF.omi_set_id_obs_p`.

    The function is used in the user-supplied function `py__obs_op_pdaf`. 

    Parameters
    ----------
    i_obs : int
        index of observations
    nrows : int
        Number of values to be averaged
    state_p : ndarray[tuple[dim_p], np.float64]
        PE-local model state (dim_p)
    obs_f_all : ndarray[tuple[nobs_f_all], np.float64]
        Full observed state for all observation types (nobs_f_all)

    Returns
    -------
    obs_f_all : ndarray[tuple[nobs_f_all], np.float64]
         Full observed state for all observation types (nobs_f_all)
    """

    cdef int dim_p, nobs_f_all
    dim_p = state_p.shape[0]
    nobs_f_all = obs_f_all.shape[0]

    c__pdafomi_obs_op_gridavg (&i_obs,
                               &nrows,
                               &state_p[0],
                               &dim_p,
                               &obs_f_all[0],
                               &nobs_f_all
                              )

    return np.asarray(obs_f_all).reshape((nobs_f_all), order='F')

def omi_obs_op_interp_lin (int i_obs,
                           int nrows,
                           double[::1] state_p,
                           double[::1] obs_f_all
                          ):
    """Observation operator that linearly interpolates model grid values to observation location.

    The grid points used by linear interpolation is specified in `id_obs_p` of `obs_f`,
    which can be set by :func:`pyPDAF.PDAF.omi_set_id_obs_p`.

    The function also requires `icoeff_p` attribute of `obs_f`,
    which can be set by :func:`pyPDAF.PDAF.omi_set_icoeff_p`

    The interpolation coefficient can be obtained by :func:`pyPDAF.PDAF.omi_get_interp_coeff_lin1D`,
    :func:`pyPDAF.PDAF.omi_get_interp_coeff_lin`, and
    :func:`pyPDAF.PDAF.omi_get_interp_coeff_tri`

    The details of interpolation setup can be found at
    `PDAF wiki page <https://pdaf.awi.de/trac/wiki/OMI_observation_operators#Initializinginterpolationcoefficients>`_

    The function is used in the user-supplied function `py__obs_op_pdaf`. 

    Parameters
    ----------
    i_obs : int
        index of observations
    nrows : int
        Number of values to be averaged
    state_p : ndarray[tuple[dim_p], np.float64]
        PE-local model state (dim_p)
    obs_f_all : ndarray[tuple[nobs_f_all], np.float64]
        Full observed state for all observation types (nobs_f_all)

    Returns
    -------
    obs_f_all : ndarray[tuple[nobs_f_all], np.float64]
         Full observed state for all observation types (nobs_f_all)
    """

    cdef int dim_p, nobs_f_all
    dim_p = state_p.shape[0]
    nobs_f_all = obs_f_all.shape[0]

    c__pdafomi_obs_op_interp_lin (&i_obs,
                                  &nrows,
                                  &state_p[0],
                                  &dim_p,
                                  &obs_f_all[0],
                                  &nobs_f_all
                                 )

    return np.asarray(obs_f_all).reshape((nobs_f_all), order='F')

def omi_obs_op_adj_gridavg (int i_obs,
                            int nrows,
                            double[::1] state_p,
                            double[::1] obs_f_all
                           ):
    """The adjoint observation operator of :func:`pyPDAF.PDAF.omi_obs_op_gridavg`.

    Parameters
    ----------
    i_obs : int
        index of observations
    nrows : int
        Number of values to be averaged
    state_p : ndarray[tuple[dim_p], np.float64]
        PE-local model state (dim_p)
    obs_f_all : ndarray[tuple[nobs_f_all], np.float64]
        Full observed state for all observation types (nobs_f_all)

    Returns
    -------
    state_p : ndarray[tuple[dim_p], np.float64]
         PE-local model state (dim_p)
    """

    cdef int dim_p, nobs_f_all
    dim_p = state_p.shape[0]
    nobs_f_all = obs_f_all.shape[0]

    c__pdafomi_obs_op_adj_gridavg (&i_obs,
                                   &nrows,
                                   &state_p[0],
                                   &dim_p,
                                   &obs_f_all[0],
                                   &nobs_f_all
                                  )

    return np.asarray(state_p).reshape((dim_p), order='F')

def omi_obs_op_adj_gridpoint (int i_obs,
                              double[::1] state_p,
                              double[::1] obs_f_all
                             ):
    """The adjoint observation operator of :func:`pyPDAF.PDAF.omi_obs_op_gridpoint`.

    Parameters
    ----------
    i_obs : int
        index of observations
    state_p : ndarray[tuple[dim_p], np.float64]
        PE-local model state (dim_p)
    obs_f_all : ndarray[tuple[nobs_f_all], np.float64]
        Full observed state for all observation types (nobs_f_all)

    Returns
    -------
    state_p : ndarray[tuple[dim_p], np.float64]
         PE-local model state (dim_p)
    """

    cdef int dim_p, nobs_f_all
    dim_p = state_p.shape[0]
    nobs_f_all = obs_f_all.shape[0]

    c__pdafomi_obs_op_adj_gridpoint (&i_obs,
                                     &state_p[0],
                                     &dim_p,
                                     &obs_f_all[0],
                                     &nobs_f_all
                                    )

    return np.asarray(state_p).reshape((dim_p), order='F')

def omi_obs_op_adj_interp_lin (int i_obs,
                               int nrows,
                               double[::1] state_p,
                               double[::1] obs_f_all
                              ):
    """The adjoint observation operator of :func:`pyPDAF.PDAF.omi_obs_op_interp_lin`.

    Parameters
    ----------
    i_obs : int
        index of observations
    nrows : int
        Number of values to be averaged
    state_p : ndarray[tuple[dim_p], np.float64]
        PE-local model state (dim_p)
    obs_f_all : ndarray[tuple[nobs_f_all], np.float64]
        Full observed state for all observation types (nobs_f_all)

    Returns
    -------
    state_p : ndarray[tuple[dim_p], np.float64]
         PE-local model state (dim_p)
    """

    cdef int dim_p, nobs_f_all
    dim_p = state_p.shape[0]
    nobs_f_all = obs_f_all.shape[0]

    c__pdafomi_obs_op_adj_interp_lin (&i_obs,
                                      &nrows,
                                      &state_p[0],
                                      &dim_p,
                                      &obs_f_all[0],
                                      &nobs_f_all
                                     )

    return np.asarray(state_p).reshape((dim_p), order='F')

def omi_get_interp_coeff_tri (double[:,:] gpc,
                              double[::1] oc,
                              double[::1] icoeff
                             ):
    """The coefficient for linear interpolation in 2D on unstructure triangular grid.

    The resulting coefficient is used in :func:`omi_obs_op_interp_lin`.

    This function is for triangular model grid interpolation coefficients determined as barycentric coordinates.

    Parameters
    ----------
    gpc : ndarray[tuple[3, 2], np.float64]
        Coordinates of grid points with dimension of (3, 2). 3 grid points surrounding the observation; each containing lon and lat coordinates. The order of the grid points in gcoords has to be consistent with the order of the indices specified in `id_obs_p` of `obs_f`.
    oc : ndarray[tuple[2], np.float64]
        Coordinates of observation (targeted location); dim(2)
    icoeff : ndarray[tuple[3], np.float64]
        Interpolation coefficients; dim(3)

    Returns
    -------
    icoeff : ndarray[tuple[3], np.float64]
         Interpolation coefficients; dim(3)
    """

    cdef double[::1] gpc_f = np.asfortranarray(gpc).ravel(order="F")
    c__pdafomi_get_interp_coeff_tri (&gpc_f[0],
                                     &oc[0],
                                     &icoeff[0]
                                    )

    return np.asarray(icoeff).reshape((3), order='F')

def omi_get_interp_coeff_lin1D (double[::1] gpc,
                                double oc,
                                double[::1] icoeff
                               ):
    """The coefficient for linear interpolation in 1D.

    The resulting coefficient is used in :func:`omi_obs_op_interp_lin`.

    

    Parameters
    ----------
    gpc : ndarray[tuple[2], np.float64]
        Coordinates of grid points surrounding the observations (dim=2)
    oc : float
        Coordinates of observation (targeted location)
    icoeff : ndarray[tuple[2], np.float64]
        Interpolation coefficients (dim=2)

    Returns
    -------
    icoeff : ndarray[tuple[2], np.float64]
         Interpolation coefficients (dim=2)
    """

    c__pdafomi_get_interp_coeff_lin1d (&gpc[0],
                                       &oc,
                                       &icoeff[0]
                                      )

    return np.asarray(icoeff).reshape((2), order='F')

def omi_get_interp_coeff_lin (double[:,:] gpc,
                              double[::1] oc,
                              double[::1] icoeff
                             ):
    """The coefficient for linear interpolation up to 3D.

    The resulting coefficient is used in :func:`omi_obs_op_interp_lin`.

    See introduction in `PDAF-OMI wiki page 
    <https://pdaf.awi.de/trac/wiki/OMI_observation_operators#PDAFomi_get_interp_coeff_lin>`_

    Parameters
    ----------
    gpc : ndarray[tuple[num_gp, n_dim], np.float64]
        Coordinates of grid points The order of the grid points in gcoords has to be consistent with the order of the indices specified in `id_obs_p` of `obs_f`.
    oc : ndarray[tuple[n_dim], np.float64]
        Coordinates of observation
    icoeff : ndarray[tuple[num_gp], np.float64]
        Interpolation coefficients (num_gp)

    Returns
    -------
    icoeff : ndarray[tuple[num_gp], np.float64]
         Interpolation coefficients (num_gp)
    """

    cdef double[::1] gpc_f = np.asfortranarray(gpc).ravel(order="F")
    cdef int num_gp, n_dim
    num_gp = gpc.shape[0]
    n_dim = gpc.shape[1]

    c__pdafomi_get_interp_coeff_lin (&num_gp,
                                     &n_dim,
                                     &gpc_f[0],
                                     &oc[0],
                                     &icoeff[0]
                                    )

    return np.asarray(icoeff).reshape((num_gp), order='F')

def omi_assimilate_3dvar (py__collect_state_pdaf,
                          py__distribute_state_pdaf,
                          py__init_dim_obs_pdaf,
                          py__obs_op_pdaf,
                          py__cvt_pdaf,
                          py__cvt_adj_pdaf,
                          py__obs_op_lin_pdaf,
                          py__obs_op_adj_pdaf,
                          py__prepoststep_pdaf,
                          py__next_observation_pdaf,
                          int outflag
                         ):
    """Using 3DVar for DA with diagonal observation error covariance matrix.
    This is a deterministic filtering scheme. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.omi_put_state_3dvar`
    and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_pdaf
    6. py__obs_op_lin_pdaf
    7. py__obs_op_adj_pdaf
    8. py__cvt_adj_pdaf
    9. core DA algorithm
    After the iterations: 
    10. py__cvt_pdaf
    11. py__prepoststep_state_pdaf
    12. py__distribute_state_pdaf
    13. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p : ndarray[tuple[dim_cvec], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.cvt_pdaf = <void*>py__cvt_pdaf
    c__PDAFcython.cvt_adj_pdaf = <void*>py__cvt_adj_pdaf
    c__PDAFcython.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    c__PDAFcython.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    c__pdafomi_assimilate_3dvar (c__PDAFcython.c__collect_state_pdaf,
                                 c__PDAFcython.c__distribute_state_pdaf,
                                 c__PDAFcython.c__init_dim_obs_pdaf,
                                 c__PDAFcython.c__obs_op_pdaf,
                                 c__PDAFcython.c__cvt_pdaf,
                                 c__PDAFcython.c__cvt_adj_pdaf,
                                 c__PDAFcython.c__obs_op_lin_pdaf,
                                 c__PDAFcython.c__obs_op_adj_pdaf,
                                 c__PDAFcython.c__prepoststep_pdaf,
                                 c__PDAFcython.c__next_observation_pdaf,
                                 &outflag
                                )

    return outflag

def omi_assimilate_en3dvar_estkf (py__collect_state_pdaf,
                                  py__distribute_state_pdaf,
                                  py__init_dim_obs_pdaf,
                                  py__obs_op_pdaf,
                                  py__cvt_ens_pdaf,
                                  py__cvt_adj_ens_pdaf,
                                  py__obs_op_lin_pdaf,
                                  py__obs_op_adj_pdaf,
                                  py__prepoststep_pdaf,
                                  py__next_observation_pdaf,
                                  int outflag
                                 ):
    """Using 3DEnVar for DA with diagonal observation error covariance matrix.
    The background error covariance matrix is estimated by ensemble. The 3DEnVar only calculates the analysis of the ensemble mean.
    An ESTKF is used to generate ensemble perturbations. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.omi_put_state_en3dvar_estkf`
    and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_ens_pdaf
    6. py__obs_op_lin_pdaf
    7. py__obs_op_adj_pdaf
    8. py__cvt_adj_ens_pdaf
    9. core 3DEnVar algorithm
    After the iterations: 
    10. py__cvt_ens_pdaf
    Perform ESTKF: 11. py__init_dim_obs_pdaf
    12. py__obs_op_pdaf (for ensemble mean
    13. py__obs_op_pdaf (for each ensemble member
    14. core ESTKF algorithm
    15. py__prepoststep_state_pdaf
    16. py__distribute_state_pdaf
    17. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], v_p : ndarray[tuple[dim_cvec_ens], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_ens** : int

            * Ensemble size

        * **dim_cvec_ens** : int

            * Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_ens** : int

            * Ensemble size

        * **dim_cv_ens_p** : int

            * PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.cvt_ens_pdaf = <void*>py__cvt_ens_pdaf
    c__PDAFcython.cvt_adj_ens_pdaf = <void*>py__cvt_adj_ens_pdaf
    c__PDAFcython.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    c__PDAFcython.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    c__pdafomi_assimilate_en3dvar_estkf (c__PDAFcython.c__collect_state_pdaf,
                                         c__PDAFcython.c__distribute_state_pdaf,
                                         c__PDAFcython.c__init_dim_obs_pdaf,
                                         c__PDAFcython.c__obs_op_pdaf,
                                         c__PDAFcython.c__cvt_ens_pdaf,
                                         c__PDAFcython.c__cvt_adj_ens_pdaf,
                                         c__PDAFcython.c__obs_op_lin_pdaf,
                                         c__PDAFcython.c__obs_op_adj_pdaf,
                                         c__PDAFcython.c__prepoststep_pdaf,
                                         c__PDAFcython.c__next_observation_pdaf,
                                         &outflag
                                        )

    return outflag

def omi_assimilate_en3dvar_lestkf (py__collect_state_pdaf,
                                   py__distribute_state_pdaf,
                                   py__init_dim_obs_pdaf,
                                   py__obs_op_pdaf,
                                   py__cvt_ens_pdaf,
                                   py__cvt_adj_ens_pdaf,
                                   py__obs_op_lin_pdaf,
                                   py__obs_op_adj_pdaf,
                                   py__init_n_domains_p_pdaf,
                                   py__init_dim_l_pdaf,
                                   py__init_dim_obs_l_pdaf,
                                   py__g2l_state_pdaf,
                                   py__l2g_state_pdaf,
                                   py__prepoststep_pdaf,
                                   py__next_observation_pdaf,
                                   int outflag
                                  ):
    """It is recommended to use `pyPDAF.PDAF.localomi_assimilate_en3dvar_lestkf` for better efficiency. 
    
   
    Using 3DEnVar for DA with diagonal observation error covariance matrix.
    The background error covariance matrix is estimated by ensemble. The 3DEnVar only calculates the analysis of the ensemble mean.
    An LESTKF is used to generate ensemble perturbations. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.omi_put_state_en3dvar_lestkf`
    and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_ens_pdaf
    6. py__obs_op_lin_pdaf
    7. py__obs_op_adj_pdaf
    8. py__cvt_adj_ens_pdaf
    9. core DA algorithm
    After the iterations: 
    10. py__cvt_ens_pdaf
    Perform LESTKF: 
    11. py__init_n_domains_p_pdaf
    12. py__init_dim_obs_pdaf
    13. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    14. py__init_dim_l_pdaf
    15. py__init_dim_obs_l_pdaf
    16. py__g2l_state_pdaf (localise mean ensemble in observation space)
    17. core DA algorithm
    18. py__l2g_state_pdaf
    19. py__prepoststep_state_pdaf
    20. py__distribute_state_pdaf
    21. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], v_p : ndarray[tuple[dim_cvec_ens], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_ens** : int

            * Ensemble size

        * **dim_cvec_ens** : int

            * Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_ens** : int

            * Ensemble size

        * **dim_cv_ens_p** : int

            * PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p : ndarray[tuple[dim_p], np.float64], dim_l:int, state_l : ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l : ndarray[tuple[dim_l], np.float64], dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Init full state from local state

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.cvt_ens_pdaf = <void*>py__cvt_ens_pdaf
    c__PDAFcython.cvt_adj_ens_pdaf = <void*>py__cvt_adj_ens_pdaf
    c__PDAFcython.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    c__PDAFcython.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.g2l_state_pdaf = <void*>py__g2l_state_pdaf
    c__PDAFcython.l2g_state_pdaf = <void*>py__l2g_state_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    c__pdafomi_assimilate_en3dvar_lestkf (c__PDAFcython.c__collect_state_pdaf,
                                          c__PDAFcython.c__distribute_state_pdaf,
                                          c__PDAFcython.c__init_dim_obs_pdaf,
                                          c__PDAFcython.c__obs_op_pdaf,
                                          c__PDAFcython.c__cvt_ens_pdaf,
                                          c__PDAFcython.c__cvt_adj_ens_pdaf,
                                          c__PDAFcython.c__obs_op_lin_pdaf,
                                          c__PDAFcython.c__obs_op_adj_pdaf,
                                          c__PDAFcython.c__init_n_domains_p_pdaf,
                                          c__PDAFcython.c__init_dim_l_pdaf,
                                          c__PDAFcython.c__init_dim_obs_l_pdaf,
                                          c__PDAFcython.c__g2l_state_pdaf,
                                          c__PDAFcython.c__l2g_state_pdaf,
                                          c__PDAFcython.c__prepoststep_pdaf,
                                          c__PDAFcython.c__next_observation_pdaf,
                                          &outflag
                                         )

    return outflag

def omi_assimilate_global (py__collect_state_pdaf,
                           py__distribute_state_pdaf,
                           py__init_dim_obs_pdaf,
                           py__obs_op_pdaf,
                           py__prepoststep_pdaf,
                           py__next_observation_pdaf
                          ):
    """Global filters for DA except for 3DVars with diagonal observation error covariance matrix.

    The function is a combination of :func:`pyPDAF.PDAF.omi_put_state_global`
    and :func:`pyPDAF.PDAF.get_state`.

    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence:

    1. py__collect_state_pdaf

    2. py__prepoststep_state_pdaf

    3. py__init_dim_obs_pdaf

    4. py__obs_op_pdaf (for ensemble mean

    5. py__obs_op_pdaf (for each ensemble member

    6. core DA algorithm

    7. py__prepoststep_state_pdaf

    8. py__distribute_state_pdaf

    9. py__next_observation_pdaf

    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time


    Returns
    -------
    flag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    cdef int flag

    c__pdafomi_assimilate_global (c__PDAFcython.c__collect_state_pdaf,
                                  c__PDAFcython.c__distribute_state_pdaf,
                                  c__PDAFcython.c__init_dim_obs_pdaf,
                                  c__PDAFcython.c__obs_op_pdaf,
                                  c__PDAFcython.c__prepoststep_pdaf,
                                  c__PDAFcython.c__next_observation_pdaf,
                                  &flag
                                 )

    return flag

def omi_assimilate_hyb3dvar_estkf (py__collect_state_pdaf,
                                   py__distribute_state_pdaf,
                                   py__init_dim_obs_pdaf,
                                   py__obs_op_pdaf,
                                   py__cvt_ens_pdaf,
                                   py__cvt_adj_ens_pdaf,
                                   py__cvt_pdaf,
                                   py__cvt_adj_pdaf,
                                   py__obs_op_lin_pdaf,
                                   py__obs_op_adj_pdaf,
                                   py__prepoststep_pdaf,
                                   py__next_observation_pdaf,
                                   int outflag
                                  ):
    """Using Hybrid 3DEnVar for DA with diagonal observation error covariance matrix.
    Here, the background error covariance is hybridised by a static background error covariance, and a flow-dependent background error covariance estimated from ensemble. The 3DVar generates an ensemble mean and the ensemble perturbation is generated by
    ESTKF in this implementation. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.omi_put_state_hyb3dvar_estkf`
    and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_pdaf
    6. py__cvt_ens_pdaf
    7. py__obs_op_lin_pdaf
    8. py__obs_op_adj_pdaf
    9. py__cvt_adj_pdaf
    10. py__cvt_adj_ens_pdaf
    11. core 3DEnVar algorithm
    After the iterations: 
    12. py__cvt_pdaf
    13. py__cvt_ens_pdaf
    Perform ESTKF: 14. py__init_dim_obs_pdaf
    15. py__obs_op_pdaf (for ensemble mean
    16. py__obs_op_pdaf (for each ensemble member
    17. core ESTKF algorithm
    18. py__prepoststep_state_pdaf
    19. py__distribute_state_pdaf
    20. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], v_p : ndarray[tuple[dim_cvec_ens], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply ensemble control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_ens** : int

            * Ensemble size

        * **dim_cvec_ens** : int

            * Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint ensemble control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_ens** : int

            * Ensemble size

        * **dim_cv_ens_p** : int

            * PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p : ndarray[tuple[dim_cvec], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.cvt_ens_pdaf = <void*>py__cvt_ens_pdaf
    c__PDAFcython.cvt_adj_ens_pdaf = <void*>py__cvt_adj_ens_pdaf
    c__PDAFcython.cvt_pdaf = <void*>py__cvt_pdaf
    c__PDAFcython.cvt_adj_pdaf = <void*>py__cvt_adj_pdaf
    c__PDAFcython.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    c__PDAFcython.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    c__pdafomi_assimilate_hyb3dvar_estkf (c__PDAFcython.c__collect_state_pdaf,
                                          c__PDAFcython.c__distribute_state_pdaf,
                                          c__PDAFcython.c__init_dim_obs_pdaf,
                                          c__PDAFcython.c__obs_op_pdaf,
                                          c__PDAFcython.c__cvt_ens_pdaf,
                                          c__PDAFcython.c__cvt_adj_ens_pdaf,
                                          c__PDAFcython.c__cvt_pdaf,
                                          c__PDAFcython.c__cvt_adj_pdaf,
                                          c__PDAFcython.c__obs_op_lin_pdaf,
                                          c__PDAFcython.c__obs_op_adj_pdaf,
                                          c__PDAFcython.c__prepoststep_pdaf,
                                          c__PDAFcython.c__next_observation_pdaf,
                                          &outflag
                                         )

    return outflag

def omi_assimilate_hyb3dvar_lestkf (py__collect_state_pdaf,
                                    py__distribute_state_pdaf,
                                    py__init_dim_obs_pdaf,
                                    py__obs_op_pdaf,
                                    py__cvt_ens_pdaf,
                                    py__cvt_adj_ens_pdaf,
                                    py__cvt_pdaf,
                                    py__cvt_adj_pdaf,
                                    py__obs_op_lin_pdaf,
                                    py__obs_op_adj_pdaf,
                                    py__init_n_domains_p_pdaf,
                                    py__init_dim_l_pdaf,
                                    py__init_dim_obs_l_pdaf,
                                    py__g2l_state_pdaf,
                                    py__l2g_state_pdaf,
                                    py__prepoststep_pdaf,
                                    py__next_observation_pdaf,
                                    int outflag
                                   ):
    """It is recommended to use `pyPDAF.PDAF.localomi_assimilate_hyb3dvar_lestkf` for better efficiency. 
    
   
    Using Hybrid 3DEnVar for DA with diagonal observation error covariance matrix.
    Here, the background error covariance is hybridised by a static background error covariance, and a flow-dependent background error covariance estimated from ensemble. The 3DVar generates an ensemble mean and the ensemble perturbation is generated by
    LESTKF in this implementation. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.omi_put_state_hyb3dvar_lestkf`
    and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_pdaf
    6. py__cvt_ens_pdaf
    7. py__obs_op_lin_pdaf
    8. py__obs_op_adj_pdaf
    9. py__cvt_adj_pdaf
    10. py__cvt_adj_ens_pdaf
    11. core DA algorithm
    After the iterations: 
    12. py__cvt_pdaf
    13. py__cvt_ens_pdaf
    Perform LESTKF: 
    14. py__init_n_domains_p_pdaf
    15. py__init_dim_obs_pdaf
    16. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    17. py__init_dim_l_pdaf
    18. py__init_dim_obs_l_pdaf
    19. py__g2l_state_pdaf
    20. py__init_obs_l_pdaf
    21. core DA algorithm
    22. py__l2g_state_pdaf
    23. py__prepoststep_state_pdaf
    24. py__distribute_state_pdaf
    25. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], v_p : ndarray[tuple[dim_cvec_ens], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_ens** : int

            * Ensemble size

        * **dim_cvec_ens** : int

            * Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_ens** : int

            * Ensemble size

        * **dim_cv_ens_p** : int

            * PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p : ndarray[tuple[dim_cvec], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p : ndarray[tuple[dim_p], np.float64], dim_l:int, state_l : ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l : ndarray[tuple[dim_l], np.float64], dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Init full state from local state

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.cvt_ens_pdaf = <void*>py__cvt_ens_pdaf
    c__PDAFcython.cvt_adj_ens_pdaf = <void*>py__cvt_adj_ens_pdaf
    c__PDAFcython.cvt_pdaf = <void*>py__cvt_pdaf
    c__PDAFcython.cvt_adj_pdaf = <void*>py__cvt_adj_pdaf
    c__PDAFcython.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    c__PDAFcython.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.g2l_state_pdaf = <void*>py__g2l_state_pdaf
    c__PDAFcython.l2g_state_pdaf = <void*>py__l2g_state_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    c__pdafomi_assimilate_hyb3dvar_lestkf (c__PDAFcython.c__collect_state_pdaf,
                                           c__PDAFcython.c__distribute_state_pdaf,
                                           c__PDAFcython.c__init_dim_obs_pdaf,
                                           c__PDAFcython.c__obs_op_pdaf,
                                           c__PDAFcython.c__cvt_ens_pdaf,
                                           c__PDAFcython.c__cvt_adj_ens_pdaf,
                                           c__PDAFcython.c__cvt_pdaf,
                                           c__PDAFcython.c__cvt_adj_pdaf,
                                           c__PDAFcython.c__obs_op_lin_pdaf,
                                           c__PDAFcython.c__obs_op_adj_pdaf,
                                           c__PDAFcython.c__init_n_domains_p_pdaf,
                                           c__PDAFcython.c__init_dim_l_pdaf,
                                           c__PDAFcython.c__init_dim_obs_l_pdaf,
                                           c__PDAFcython.c__g2l_state_pdaf,
                                           c__PDAFcython.c__l2g_state_pdaf,
                                           c__PDAFcython.c__prepoststep_pdaf,
                                           c__PDAFcython.c__next_observation_pdaf,
                                           &outflag
                                          )

    return outflag

def omi_assimilate_lenkf (py__collect_state_pdaf,
                          py__distribute_state_pdaf,
                          py__init_dim_obs_pdaf,
                          py__obs_op_pdaf,
                          py__prepoststep_pdaf,
                          py__localize_covar_pdaf,
                          py__next_observation_pdaf
                         ):
    """Using stochastic EnKF (ensemble Kalman filter) with covariance localisation for DA  with diagonal observation error covariance matrix. This is the only scheme for covariance localisation in PDAF. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.omi_put_state_lenkf` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf (for each ensemble member
    5. py__localize_pdaf
    6. py__obs_op_pdaf (repeated to reduce storage
    7. core DA algorith
    8. py__prepoststep_state_pdaf
    9. py__distribute_state_pdaf
    10. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__localize_covar_pdaf : Callable[dim_p:int, dim_obs:int, hp_p : ndarray[tuple[dim_obs, dim_p], np.float64], hph : ndarray[tuple[dim_obs, dim_obs], np.float64]]
        Apply localization to HP and HPH^T

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **dim_obs** : int

            * number of observations

        * **hp_p** : ndarray[tuple[dim_obs, dim_p], np.float64]

            * pe local part of matrix hp

        * **hph** : ndarray[tuple[dim_obs, dim_obs], np.float64]

            * matrix hph

        **Callback Returns**

        * **hp_p** : ndarray[tuple[dim_obs, dim_p], np.float64]

            * pe local part of matrix hp

        * **hph** : ndarray[tuple[dim_obs, dim_obs], np.float64]

            * matrix hph

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time


    Returns
    -------
    flag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.localize_covar_pdaf = <void*>py__localize_covar_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    cdef int flag

    c__pdafomi_assimilate_lenkf (c__PDAFcython.c__collect_state_pdaf,
                                 c__PDAFcython.c__distribute_state_pdaf,
                                 c__PDAFcython.c__init_dim_obs_pdaf,
                                 c__PDAFcython.c__obs_op_pdaf,
                                 c__PDAFcython.c__prepoststep_pdaf,
                                 c__PDAFcython.c__localize_covar_pdaf,
                                 c__PDAFcython.c__next_observation_pdaf,
                                 &flag
                                )

    return flag

def omi_assimilate_local (py__collect_state_pdaf,
                          py__distribute_state_pdaf,
                          py__init_dim_obs_pdaf,
                          py__obs_op_pdaf,
                          py__prepoststep_pdaf,
                          py__init_n_domains_p_pdaf,
                          py__init_dim_l_pdaf,
                          py__init_dim_obs_l_pdaf,
                          py__g2l_state_pdaf,
                          py__l2g_state_pdaf,
                          py__next_observation_pdaf
                         ):
    """It is recommended to use `pyPDAF.PDAF.localomi_assimilate` for better efficiency.Using domain localised filters for DA with diagonal observation error covariance matrix. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.omi_put_state_local` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    6. py__init_dim_l_pdaf
    7. py__init_dim_obs_l_pdaf
    8. py__g2l_state_pdaf
    9. py__init_obs_l_pdaf
    10. core DA algorithm
    11. py__l2g_state_pdaf
    12. py__prepoststep_state_pdaf
    13. py__distribute_state_pdaf
    14. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p : ndarray[tuple[dim_p], np.float64], dim_l:int, state_l : ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l : ndarray[tuple[dim_l], np.float64], dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time


    Returns
    -------
    flag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.g2l_state_pdaf = <void*>py__g2l_state_pdaf
    c__PDAFcython.l2g_state_pdaf = <void*>py__l2g_state_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    cdef int flag

    c__pdafomi_assimilate_local (c__PDAFcython.c__collect_state_pdaf,
                                 c__PDAFcython.c__distribute_state_pdaf,
                                 c__PDAFcython.c__init_dim_obs_pdaf,
                                 c__PDAFcython.c__obs_op_pdaf,
                                 c__PDAFcython.c__prepoststep_pdaf,
                                 c__PDAFcython.c__init_n_domains_p_pdaf,
                                 c__PDAFcython.c__init_dim_l_pdaf,
                                 c__PDAFcython.c__init_dim_obs_l_pdaf,
                                 c__PDAFcython.c__g2l_state_pdaf,
                                 c__PDAFcython.c__l2g_state_pdaf,
                                 c__PDAFcython.c__next_observation_pdaf,
                                 &flag
                                )

    return flag

def omi_generate_obs (py__collect_state_pdaf,
                      py__distribute_state_pdaf,
                      py__init_dim_obs_pdaf,
                      py__obs_op_pdaf,
                      py__get_obs_f_pdaf,
                      py__prepoststep_pdaf,
                      py__next_observation_pdaf
                     ):
    """This function generates synthetic observations based on each member of model forecast with diagonal observation error covariance matrix. This is based on the usual implementation strategy for PDAF.
    
    The function calls `pyPDAF.PDAF.generate_obs`  and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pda
    5. py__get_obs_f_pdaf
    6. py__prepoststep_state_pdaf
    7. py__distribute_state_pdaf
    8. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__get_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f : ndarray[tuple[dim_obs_f], np.float64]]
        Provide observation vector to user

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_f** : int

            * Size of the full observation vector

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of synthetic observations (process-local)

        **Callback Returns**

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of synthetic observations (process-local)

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time


    Returns
    -------
    flag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.get_obs_f_pdaf = <void*>py__get_obs_f_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    cdef int flag

    c__pdafomi_generate_obs (c__PDAFcython.c__collect_state_pdaf,
                             c__PDAFcython.c__distribute_state_pdaf,
                             c__PDAFcython.c__init_dim_obs_pdaf,
                             c__PDAFcython.c__obs_op_pdaf,
                             c__PDAFcython.c__get_obs_f_pdaf,
                             c__PDAFcython.c__prepoststep_pdaf,
                             c__PDAFcython.c__next_observation_pdaf,
                             &flag
                            )

    return flag

def omi_put_state_3dvar (py__collect_state_pdaf,
                         py__init_dim_obs_pdaf,
                         py__obs_op_pdaf,
                         py__cvt_pdaf,
                         py__cvt_adj_pdaf,
                         py__obs_op_lin_pdaf,
                         py__obs_op_adj_pdaf,
                         py__prepoststep_pdaf,
                         int outflag
                        ):
    """Using 3DVar for DA without post-processing and analysis distribution to forecsat with diagonal observation error covariance matrix.
    This is a deterministic filtering scheme. This function is usually used in 'flexible' parallelisation, but 3dvar is deterministic and does not require ensemble.
    A `pyPDAF.PDAF.get_state` function should be used to post-process the state vector and distribute the state vector to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_pdaf
    6. py__obs_op_lin_pdaf
    7. py__obs_op_adj_pdaf
    8. py__cvt_adj_pdaf
    9. core DA algorithm
    After the iterations: 
    10. py__cvt_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p : ndarray[tuple[dim_cvec], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.cvt_pdaf = <void*>py__cvt_pdaf
    c__PDAFcython.cvt_adj_pdaf = <void*>py__cvt_adj_pdaf
    c__PDAFcython.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    c__PDAFcython.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf

    c__pdafomi_put_state_3dvar (c__PDAFcython.c__collect_state_pdaf,
                                c__PDAFcython.c__init_dim_obs_pdaf,
                                c__PDAFcython.c__obs_op_pdaf,
                                c__PDAFcython.c__cvt_pdaf,
                                c__PDAFcython.c__cvt_adj_pdaf,
                                c__PDAFcython.c__obs_op_lin_pdaf,
                                c__PDAFcython.c__obs_op_adj_pdaf,
                                c__PDAFcython.c__prepoststep_pdaf,
                                &outflag
                               )

    return outflag

def omi_put_state_en3dvar_estkf (py__collect_state_pdaf,
                                 py__init_dim_obs_pdaf,
                                 py__obs_op_pdaf,
                                 py__cvt_ens_pdaf,
                                 py__cvt_adj_ens_pdaf,
                                 py__obs_op_lin_pdaf,
                                 py__obs_op_adj_pdaf,
                                 py__prepoststep_pdaf,
                                 int outflag
                                ):
    """Using 3DEnVar for DA without post-processing and analysis distribution to forecsat with diagonal observation error covariance matrix.
    The background error covariance matrix is estimated by ensemble. The 3DEnVar only calculates the analysis of the ensemble mean.
    An ESTKF is used to generate ensemble perturbations. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_ens_pdaf
    6. py__obs_op_lin_pdaf
    7. py__obs_op_adj_pdaf
    8. py__cvt_adj_ens_pdaf
    9. core 3DEnVar algorithm
    After the iterations: 
    10. py__cvt_ens_pdaf
    Perform ESTKF: 11. py__init_dim_obs_pdaf
    12. py__obs_op_pdaf (for ensemble mean
    13. py__obs_op_pdaf (for each ensemble member (only relevant for adaptive forgetting factor schemes)
    14. core ESTKF algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], v_p : ndarray[tuple[dim_cvec_ens], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_ens** : int

            * Ensemble size

        * **dim_cvec_ens** : int

            * Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_ens** : int

            * Ensemble size

        * **dim_cv_ens_p** : int

            * PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.cvt_ens_pdaf = <void*>py__cvt_ens_pdaf
    c__PDAFcython.cvt_adj_ens_pdaf = <void*>py__cvt_adj_ens_pdaf
    c__PDAFcython.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    c__PDAFcython.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf

    c__pdafomi_put_state_en3dvar_estkf (c__PDAFcython.c__collect_state_pdaf,
                                        c__PDAFcython.c__init_dim_obs_pdaf,
                                        c__PDAFcython.c__obs_op_pdaf,
                                        c__PDAFcython.c__cvt_ens_pdaf,
                                        c__PDAFcython.c__cvt_adj_ens_pdaf,
                                        c__PDAFcython.c__obs_op_lin_pdaf,
                                        c__PDAFcython.c__obs_op_adj_pdaf,
                                        c__PDAFcython.c__prepoststep_pdaf,
                                        &outflag
                                       )

    return outflag

def omi_put_state_en3dvar_lestkf (py__collect_state_pdaf,
                                  py__init_dim_obs_pdaf,
                                  py__obs_op_pdaf,
                                  py__cvt_ens_pdaf,
                                  py__cvt_adj_ens_pdaf,
                                  py__obs_op_lin_pdaf,
                                  py__obs_op_adj_pdaf,
                                  py__init_n_domains_p_pdaf,
                                  py__init_dim_l_pdaf,
                                  py__init_dim_obs_l_pdaf,
                                  py__g2l_state_pdaf,
                                  py__l2g_state_pdaf,
                                  py__prepoststep_pdaf,
                                  int outflag
                                 ):
    """It is recommended to use `pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf` for better efficiency. 
    
   
    Using 3DEnVar for DA without post-processing and analysis distribution to forecsat with diagonal observation error covariance matrix.
    The background error covariance matrix is estimated by ensemble. The 3DEnVar only calculates the analysis of the ensemble mean.
    An LESTKF is used to generate ensemble perturbations. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_ens_pdaf
    6. py__obs_op_lin_pdaf
    7. py__obs_op_adj_pdaf
    8. py__cvt_adj_ens_pdaf
    9. core DA algorithm
    After the iterations: 
    10. py__cvt_ens_pdaf
    Perform LESTKF: 
    11. py__init_n_domains_p_pdaf
    12. py__init_dim_obs_pdaf
    13. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    14. py__init_dim_l_pdaf
    15. py__init_dim_obs_l_pdaf
    16. py__g2l_state_pdaf
    17. core DA algorithm
    18. py__l2g_state_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], v_p : ndarray[tuple[dim_cvec_ens], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_ens** : int

            * Ensemble size

        * **dim_cvec_ens** : int

            * Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_ens** : int

            * Ensemble size

        * **dim_cv_ens_p** : int

            * PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p : ndarray[tuple[dim_p], np.float64], dim_l:int, state_l : ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l : ndarray[tuple[dim_l], np.float64], dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Init full state from local state

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.cvt_ens_pdaf = <void*>py__cvt_ens_pdaf
    c__PDAFcython.cvt_adj_ens_pdaf = <void*>py__cvt_adj_ens_pdaf
    c__PDAFcython.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    c__PDAFcython.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.g2l_state_pdaf = <void*>py__g2l_state_pdaf
    c__PDAFcython.l2g_state_pdaf = <void*>py__l2g_state_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf

    c__pdafomi_put_state_en3dvar_lestkf (c__PDAFcython.c__collect_state_pdaf,
                                         c__PDAFcython.c__init_dim_obs_pdaf,
                                         c__PDAFcython.c__obs_op_pdaf,
                                         c__PDAFcython.c__cvt_ens_pdaf,
                                         c__PDAFcython.c__cvt_adj_ens_pdaf,
                                         c__PDAFcython.c__obs_op_lin_pdaf,
                                         c__PDAFcython.c__obs_op_adj_pdaf,
                                         c__PDAFcython.c__init_n_domains_p_pdaf,
                                         c__PDAFcython.c__init_dim_l_pdaf,
                                         c__PDAFcython.c__init_dim_obs_l_pdaf,
                                         c__PDAFcython.c__g2l_state_pdaf,
                                         c__PDAFcython.c__l2g_state_pdaf,
                                         c__PDAFcython.c__prepoststep_pdaf,
                                         &outflag
                                        )

    return outflag

def omi_put_state_generate_obs (py__collect_state_pdaf,
                                py__init_dim_obs_pdaf,
                                py__obs_op_pdaf,
                                py__get_obs_f_pdaf,
                                py__prepoststep_pdaf
                               ):
    """This function generates synthetic observations based on each member of model forecast with diagonal observation error covariance matrix. This function is for the case where the ensemble size is larger than the number of processors. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pda
    5. py__get_obs_f_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__get_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f : ndarray[tuple[dim_obs_f], np.float64]]
        Provide observation vector to user

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_f** : int

            * Size of the full observation vector

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of synthetic observations (process-local)

        **Callback Returns**

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of synthetic observations (process-local)

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble


    Returns
    -------
    flag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.get_obs_f_pdaf = <void*>py__get_obs_f_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf

    cdef int flag

    c__pdafomi_put_state_generate_obs (c__PDAFcython.c__collect_state_pdaf,
                                       c__PDAFcython.c__init_dim_obs_pdaf,
                                       c__PDAFcython.c__obs_op_pdaf,
                                       c__PDAFcython.c__get_obs_f_pdaf,
                                       c__PDAFcython.c__prepoststep_pdaf,
                                       &flag
                                      )

    return flag

def omi_put_state_global (py__collect_state_pdaf,
                          py__init_dim_obs_pdaf,
                          py__obs_op_pdaf,
                          py__prepoststep_pdaf
                         ):
    """Global filters for DA except for 3DVars
    without post-processing and analysis distribution to forecsat
    with diagonal observation error covariance matrix.

    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence: 
    1. py__collect_state_pdaf

    2. py__prepoststep_state_pdaf

    3. py__init_dim_obs_pdaf

    4. py__obs_op_pdaf (for ensemble mean)

    5. py__obs_op_pdaf (for each ensemble member)

    6. core DA algorithm

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble


    Returns
    -------
    flag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf

    cdef int flag

    c__pdafomi_put_state_global (c__PDAFcython.c__collect_state_pdaf,
                                 c__PDAFcython.c__init_dim_obs_pdaf,
                                 c__PDAFcython.c__obs_op_pdaf,
                                 c__PDAFcython.c__prepoststep_pdaf,
                                 &flag
                                )

    return flag

def omi_put_state_hyb3dvar_estkf (py__collect_state_pdaf,
                                  py__init_dim_obs_pdaf,
                                  py__obs_op_pdaf,
                                  py__cvt_ens_pdaf,
                                  py__cvt_adj_ens_pdaf,
                                  py__cvt_pdaf,
                                  py__cvt_adj_pdaf,
                                  py__obs_op_lin_pdaf,
                                  py__obs_op_adj_pdaf,
                                  py__prepoststep_pdaf,
                                  int outflag
                                 ):
    """Using 3DEnVar for DA without post-processing and analysis distribution to forecsat with diagonal observation error covariance matrix.
    Here, the background error covariance is hybridised by a static background error covariance, and a flow-dependent background error covariance estimated from ensemble. The 3DVar generates an ensemble mean and the ensemble perturbation is generated by
    ESTKF in this implementation. 
    
    This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_ens_pdaf
    6. py__obs_op_lin_pdaf
    7. py__obs_op_adj_pdaf
    8. py__cvt_adj_ens_pdaf
    9. core 3DEnVar algorithm
    After the iterations: 
    10. py__cvt_ens_pdaf
    Perform ESTKF: 11. py__init_dim_obs_pdaf
    12. py__obs_op_pdaf (for ensemble mean
    13. py__obs_op_pdaf (for each ensemble member
    14. core ESTKF algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], v_p : ndarray[tuple[dim_cvec_ens], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply ensemble control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_ens** : int

            * Ensemble size

        * **dim_cvec_ens** : int

            * Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint ensemble control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_ens** : int

            * Ensemble size

        * **dim_cv_ens_p** : int

            * PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p : ndarray[tuple[dim_cvec], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.cvt_ens_pdaf = <void*>py__cvt_ens_pdaf
    c__PDAFcython.cvt_adj_ens_pdaf = <void*>py__cvt_adj_ens_pdaf
    c__PDAFcython.cvt_pdaf = <void*>py__cvt_pdaf
    c__PDAFcython.cvt_adj_pdaf = <void*>py__cvt_adj_pdaf
    c__PDAFcython.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    c__PDAFcython.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf

    c__pdafomi_put_state_hyb3dvar_estkf (c__PDAFcython.c__collect_state_pdaf,
                                         c__PDAFcython.c__init_dim_obs_pdaf,
                                         c__PDAFcython.c__obs_op_pdaf,
                                         c__PDAFcython.c__cvt_ens_pdaf,
                                         c__PDAFcython.c__cvt_adj_ens_pdaf,
                                         c__PDAFcython.c__cvt_pdaf,
                                         c__PDAFcython.c__cvt_adj_pdaf,
                                         c__PDAFcython.c__obs_op_lin_pdaf,
                                         c__PDAFcython.c__obs_op_adj_pdaf,
                                         c__PDAFcython.c__prepoststep_pdaf,
                                         &outflag
                                        )

    return outflag

def omi_put_state_hyb3dvar_lestkf (py__collect_state_pdaf,
                                   py__init_dim_obs_pdaf,
                                   py__obs_op_pdaf,
                                   py__cvt_ens_pdaf,
                                   py__cvt_adj_ens_pdaf,
                                   py__cvt_pdaf,
                                   py__cvt_adj_pdaf,
                                   py__obs_op_lin_pdaf,
                                   py__obs_op_adj_pdaf,
                                   py__init_n_domains_p_pdaf,
                                   py__init_dim_l_pdaf,
                                   py__init_dim_obs_l_pdaf,
                                   py__g2l_state_pdaf,
                                   py__l2g_state_pdaf,
                                   py__prepoststep_pdaf,
                                   int outflag
                                  ):
    """It is recommended to use `pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf` for better efficiency. 
    
   
    Using 3DEnVar for DA without post-processing and analysis distribution to forecsat with diagonal observation error covariance matrix.
    Here, the background error covariance is hybridised by a static background error covariance, and a flow-dependent background error covariance estimated from ensemble. The 3DVar generates an ensemble mean and the ensemble perturbation is generated by
    LESTKF in this implementation. 
    
    This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_ens_pdaf
    6. py__obs_op_lin_pdaf
    7. py__obs_op_adj_pdaf
    8. py__cvt_adj_ens_pdaf
    9. core DA algorithm
    After the iterations: 
    10. py__cvt_ens_pdaf
    Perform LESTKF: 
    11. py__init_n_domains_p_pdaf
    12. py__init_dim_obs_pdaf
    13. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    14. py__init_dim_l_pdaf
    15. py__init_dim_obs_l_pdaf
    16. py__g2l_state_pdaf (localise mean ensemble in observation space)
    17. core DA algorithm
    18. py__l2g_state_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], v_p : ndarray[tuple[dim_cvec_ens], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_ens** : int

            * Ensemble size

        * **dim_cvec_ens** : int

            * Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_ens** : int

            * Ensemble size

        * **dim_cv_ens_p** : int

            * PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p : ndarray[tuple[dim_cvec], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p : ndarray[tuple[dim_p], np.float64], dim_l:int, state_l : ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l : ndarray[tuple[dim_l], np.float64], dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Init full state from local state

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.cvt_ens_pdaf = <void*>py__cvt_ens_pdaf
    c__PDAFcython.cvt_adj_ens_pdaf = <void*>py__cvt_adj_ens_pdaf
    c__PDAFcython.cvt_pdaf = <void*>py__cvt_pdaf
    c__PDAFcython.cvt_adj_pdaf = <void*>py__cvt_adj_pdaf
    c__PDAFcython.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    c__PDAFcython.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.g2l_state_pdaf = <void*>py__g2l_state_pdaf
    c__PDAFcython.l2g_state_pdaf = <void*>py__l2g_state_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf

    c__pdafomi_put_state_hyb3dvar_lestkf (c__PDAFcython.c__collect_state_pdaf,
                                          c__PDAFcython.c__init_dim_obs_pdaf,
                                          c__PDAFcython.c__obs_op_pdaf,
                                          c__PDAFcython.c__cvt_ens_pdaf,
                                          c__PDAFcython.c__cvt_adj_ens_pdaf,
                                          c__PDAFcython.c__cvt_pdaf,
                                          c__PDAFcython.c__cvt_adj_pdaf,
                                          c__PDAFcython.c__obs_op_lin_pdaf,
                                          c__PDAFcython.c__obs_op_adj_pdaf,
                                          c__PDAFcython.c__init_n_domains_p_pdaf,
                                          c__PDAFcython.c__init_dim_l_pdaf,
                                          c__PDAFcython.c__init_dim_obs_l_pdaf,
                                          c__PDAFcython.c__g2l_state_pdaf,
                                          c__PDAFcython.c__l2g_state_pdaf,
                                          c__PDAFcython.c__prepoststep_pdaf,
                                          &outflag
                                         )

    return outflag

def omi_put_state_lenkf (py__collect_state_pdaf,
                         py__init_dim_obs_pdaf,
                         py__obs_op_pdaf,
                         py__prepoststep_pdaf,
                         py__localize_covar_pdaf
                        ):
    """Using stochastic EnKF (ensemble Kalman filter) with covariance localisation for DA without post-processing and analysis distribution to forecsat with diagonal observation error covariance matrix. This is the only scheme for covariance localisation in PDAF. This is the only scheme for covariance localisation in PDAF. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf (for each ensemble member
    5. py__localize_pdaf
    6. py__obs_op_pdaf (repeated to reduce storage
    7. core DA algorith
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__localize_covar_pdaf : Callable[dim_p:int, dim_obs:int, hp_p : ndarray[tuple[dim_obs, dim_p], np.float64], hph : ndarray[tuple[dim_obs, dim_obs], np.float64]]
        Apply localization to HP and HPH^T

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **dim_obs** : int

            * number of observations

        * **hp_p** : ndarray[tuple[dim_obs, dim_p], np.float64]

            * pe local part of matrix hp

        * **hph** : ndarray[tuple[dim_obs, dim_obs], np.float64]

            * matrix hph

        **Callback Returns**

        * **hp_p** : ndarray[tuple[dim_obs, dim_p], np.float64]

            * pe local part of matrix hp

        * **hph** : ndarray[tuple[dim_obs, dim_obs], np.float64]

            * matrix hph


    Returns
    -------
    flag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.localize_covar_pdaf = <void*>py__localize_covar_pdaf

    cdef int flag

    c__pdafomi_put_state_lenkf (c__PDAFcython.c__collect_state_pdaf,
                                c__PDAFcython.c__init_dim_obs_pdaf,
                                c__PDAFcython.c__obs_op_pdaf,
                                c__PDAFcython.c__prepoststep_pdaf,
                                c__PDAFcython.c__localize_covar_pdaf,
                                &flag
                               )

    return flag

def omi_put_state_local (py__collect_state_pdaf,
                         py__init_dim_obs_pdaf,
                         py__obs_op_pdaf,
                         py__prepoststep_pdaf,
                         py__init_n_domains_p_pdaf,
                         py__init_dim_l_pdaf,
                         py__init_dim_obs_l_pdaf,
                         py__g2l_state_pdaf,
                         py__l2g_state_pdaf
                        ):
    """It is recommended to use `pyPDAF.PDAF.localomi_put_state` for better efficiency. 
    
    Using domain localised filters for DA without post-processing and analysis distribution to forecsat with diagonal observation error covariance matrix. This is a domain localisation method. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. The LESTKF is a more efficient equivalent to the LETKF. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    6. py__init_dim_l_pdaf
    7. py__init_dim_obs_l_pdaf
    8. py__g2l_state_pdaf
    9. core DA algorithm
    10. py__l2g_state_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p : ndarray[tuple[dim_p], np.float64], dim_l:int, state_l : ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l : ndarray[tuple[dim_l], np.float64], dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector


    Returns
    -------
    flag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.g2l_state_pdaf = <void*>py__g2l_state_pdaf
    c__PDAFcython.l2g_state_pdaf = <void*>py__l2g_state_pdaf

    cdef int flag

    c__pdafomi_put_state_local (c__PDAFcython.c__collect_state_pdaf,
                                c__PDAFcython.c__init_dim_obs_pdaf,
                                c__PDAFcython.c__obs_op_pdaf,
                                c__PDAFcython.c__prepoststep_pdaf,
                                c__PDAFcython.c__init_n_domains_p_pdaf,
                                c__PDAFcython.c__init_dim_l_pdaf,
                                c__PDAFcython.c__init_dim_obs_l_pdaf,
                                c__PDAFcython.c__g2l_state_pdaf,
                                c__PDAFcython.c__l2g_state_pdaf,
                                &flag
                               )

    return flag

def omi_init_obs_f_cb (int step,
                       int dim_obs_f,
                       double[::1] observation_f
                      ):
    """This function is an internal PDAF-OMI function that is used as a call-back function to initialise the observation vector. This could be used to modify the observation vector when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`.

    Parameters
    ----------
    step : int
        Current time step
    dim_obs_f : int
        Dimension of full observation vector
    observation_f : ndarray[tuple[dim_obs_f], np.float64]
        Full observation vector

    Returns
    -------
    observation_f : ndarray[tuple[dim_obs_f], np.float64]
         Full observation vector
    """

    c__pdafomi_init_obs_f_cb (&step,
                              &dim_obs_f,
                              &observation_f[0]
                             )

    return np.asarray(observation_f).reshape((dim_obs_f), order='F')

def omi_init_obsvar_cb (int step,
                        int dim_obs_p,
                        double[::1] obs_p,
                        double meanvar
                       ):
    """This function is an internal PDAF function that is used as a call-back function to initialise the observation error variance. This could be used to modify the observation variance when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`.

    Parameters
    ----------
    step : int
        Current time step
    dim_obs_p : int
        PE-local dimension of observation vector
    obs_p : ndarray[tuple[dim_obs_p], np.float64]
        PE-local observation vector
    meanvar : float
        Mean observation error variance

    Returns
    -------
    meanvar : float
        Mean observation error variance
    """

    c__pdafomi_init_obsvar_cb (&step,
                               &dim_obs_p,
                               &obs_p[0],
                               &meanvar
                              )

    return meanvar

def omi_g2l_obs_cb (int domain_p,
                    int step,
                    int dim_obs_f,
                    int dim_obs_l,
                    double[::1] ostate_f,
                    double[::1] ostate_l
                   ):
    """This function is an internal PDAF-OMI function that is used as a call-back function to convert between global and local observation vectors in domain localisation.
    

    Parameters
    ----------
    domain_p : int
        Index of current local analysis domain
    step : int
        Current time step
    dim_obs_f : int
        Dimension of full PE-local observation vector
    dim_obs_l : int
        Dimension of local observation vector
    ostate_f : ndarray[tuple[dim_obs_f], np.float64]
        Full PE-local obs.ervation vector
    ostate_l : ndarray[tuple[dim_obs_l], np.float64]
        Observation vector on local domain

    Returns
    -------
    ostate_l : ndarray[tuple[dim_obs_l], np.float64]
         Observation vector on local domain
    """

    c__pdafomi_g2l_obs_cb (&domain_p,
                           &step,
                           &dim_obs_f,
                           &dim_obs_l,
                           &ostate_f[0],
                           &ostate_l[0]
                          )

    return np.asarray(ostate_l).reshape((dim_obs_l), order='F')

def omi_init_obs_l_cb (int domain_p,
                       int step,
                       int dim_obs_l,
                       double[::1] observation_l
                      ):
    """This function is an internal PDAF-OMI function that is used as a call-back function to initialise local observation vector in domain localisation. This could be used to modify the observation variance when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`.

    Parameters
    ----------
    domain_p : int
        Index of current local analysis domain index
    step : int
        Current time step
    dim_obs_l : int
        Local dimension of observation vector
    observation_l : ndarray[tuple[dim_obs_l], np.float64]
        Local observation vector

    Returns
    -------
    observation_l : ndarray[tuple[dim_obs_l], np.float64]
         Local observation vector
    """

    c__pdafomi_init_obs_l_cb (&domain_p,
                              &step,
                              &dim_obs_l,
                              &observation_l[0]
                             )

    return np.asarray(observation_l).reshape((dim_obs_l), order='F')

def omi_init_obsvar_l_cb (int domain_p,
                          int step,
                          int dim_obs_l,
                          double[::1] obs_l,
                          double meanvar_l
                         ):
    """This function is an internal PDAF-OMI function that is used as a call-back function to initialise local observation vector in domain localisation. This could be used to modify the observation variance when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`.

    Parameters
    ----------
    domain_p : int
        Index of current local analysis domain
    step : int
        Current time step
    dim_obs_l : int
        Local dimension of observation vector
    obs_l : ndarray[tuple[dim_obs_l], np.float64]
        Local observation vector
    meanvar_l : float
        Mean local observation error variance

    Returns
    -------
    meanvar_l : float
        Mean local observation error variance
    """

    c__pdafomi_init_obsvar_l_cb (&domain_p,
                                 &step,
                                 &dim_obs_l,
                                 &obs_l[0],
                                 &meanvar_l
                                )

    return meanvar_l

def omi_prodRinvA_l_cb (int domain_p,
                        int step,
                        int dim_obs_l,
                        int rank,
                        double[::1] obs_l,
                        double[::1,:] A_l,
                        double[::1,:] C_l
                       ):
    """This function is an internal PDAF-OMI function that is used as a call-back function to perform the matrix multiplication inverse of local observation error covariance and a matrix A in domain localisation. This could be used to modify the observation variance when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`.

    Parameters
    ----------
    domain_p : int
        Index of current local analysis domain
    step : int
        Current time step
    dim_obs_l : int
        Dimension of local observation vector
    rank : int
        Rank of initial covariance matrix
    obs_l : ndarray[tuple[dim_obs_l], np.float64]
        Local vector of observations
    A_l : ndarray[tuple[dim_obs_l, rank], np.float64]
        Input matrix
    C_l : ndarray[tuple[dim_obs_l, rank], np.float64]
        Output matrix

    Returns
    -------
    A_l : ndarray[tuple[dim_obs_l, rank], np.float64]
         Input matrix
    C_l : ndarray[tuple[dim_obs_l, rank], np.float64]
         Output matrix
    """

    cdef double[::1] A_l_f = np.asfortranarray(A_l).ravel(order="F")
    cdef double[::1] C_l_f = np.asfortranarray(C_l).ravel(order="F")
    c__pdafomi_prodrinva_l_cb (&domain_p,
                               &step,
                               &dim_obs_l,
                               &rank,
                               &obs_l[0],
                               &A_l_f[0],
                               &C_l_f[0]
                              )

    return np.asarray(A_l).reshape((dim_obs_l, rank), order='F'), np.asarray(C_l).reshape((dim_obs_l, rank), order='F')

def omi_likelihood_l_cb (int domain_p,
                         int step,
                         int dim_obs_l,
                         double[::1] obs_l,
                         double[::1] resid_l,
                         double lhood_l
                        ):
    """This is an internal PDAF-OMI function that is used as a call-back function to compute the likelihood of the observation for a given ensemble member according to the observations used for the local analysis in the localized LNETF. This could be used to modify the observation variance when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`. See https://pdaf.awi.de/trac/wiki/U_likelihood_l

    Parameters
    ----------
    domain_p : int
        Current local analysis domain
    step : int
        Current time step
    dim_obs_l : int
        PE-local dimension of obs. vector
    obs_l : ndarray[tuple[dim_obs_l], np.float64]
        PE-local vector of observations
    resid_l : ndarray[tuple[dim_obs_l], np.float64]
        Input vector of residuum
    lhood_l : float
        Output vector - log likelihood

    Returns
    -------
    resid_l : ndarray[tuple[dim_obs_l], np.float64]
         Input vector of residuum
    lhood_l : float
        Output vector - log likelihood
    """

    c__pdafomi_likelihood_l_cb (&domain_p,
                                &step,
                                &dim_obs_l,
                                &obs_l[0],
                                &resid_l[0],
                                &lhood_l
                               )

    return np.asarray(resid_l).reshape((dim_obs_l), order='F'), lhood_l

def omi_prodRinvA_cb (int step,
                      int dim_obs_p,
                      int ncol,
                      double[::1] obs_p,
                      double[::1,:] A_p,
                      double[::1,:] C_p
                     ):
    """This function is an internal PDAF-OMI function that is used as a call-back function to perform the matrix multiplication inverse of observation errro covariance and a matrix A. This could be used to modify the observation variance when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`.

    Parameters
    ----------
    step : int
        Current time step
    dim_obs_p : int
        Dimension of PE-local observation vector
    ncol : int
        Number of columns in A_p and C_p
    obs_p : ndarray[tuple[dim_obs_p], np.float64]
        PE-local vector of observations
    A_p : ndarray[tuple[dim_obs_p, ncol], np.float64]
        Input matrix
    C_p : ndarray[tuple[dim_obs_p, ncol], np.float64]
        Output matrix

    Returns
    -------
    C_p : ndarray[tuple[dim_obs_p, ncol], np.float64]
         Output matrix
    """

    cdef double[::1] A_p_f = np.asfortranarray(A_p).ravel(order="F")
    cdef double[::1] C_p_f = np.asfortranarray(C_p).ravel(order="F")
    c__pdafomi_prodrinva_cb (&step,
                             &dim_obs_p,
                             &ncol,
                             &obs_p[0],
                             &A_p_f[0],
                             &C_p_f[0]
                            )

    return np.asarray(C_p).reshape((dim_obs_p, ncol), order='F')

def omi_likelihood_cb (int step,
                       int dim_obs,
                       double[::1] obs,
                       double[::1] resid,
                       double lhood
                      ):
    """This is an internal PDAF-OMI function that is used as a call-back function to compute the likelihood of the observation for a given ensemble member according to the observations used for the local analysis for NETF or particle filter. This could be used to modify the observation variance when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`. See https://pdaf.awi.de/trac/wiki/U_likelihood_l

    Parameters
    ----------
    step : int
        Current time step
    dim_obs : int
        PE-local dimension of obs. vector
    obs : ndarray[tuple[dim_obs], np.float64]
        PE-local vector of observations
    resid : ndarray[tuple[dim_obs], np.float64]
        Input vector of residuum
    lhood : float
        Output vector - log likelihood

    Returns
    -------
    lhood : float
        Output vector - log likelihood
    """

    c__pdafomi_likelihood_cb (&step,
                              &dim_obs,
                              &obs[0],
                              &resid[0],
                              &lhood
                             )

    return lhood

def omi_add_obs_error_cb (int step,
                          int dim_obs_p,
                          double[::1,:] C_p
                         ):
    """This is an internal PDAF-OMI function that is used as a call-back function to add random observation error to stochastic EnKF. This could be used to modify the observation variance when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`. See https://pdaf.awi.de/trac/wiki/U_likelihood_l

    Parameters
    ----------
    step : int
        Current time step
    dim_obs_p : int
        Dimension of PE-local observation vector
    C_p : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]
        Matrix to which R is added

    Returns
    -------
    C_p : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]
         Matrix to which R is added
    """

    cdef double[::1] C_p_f = np.asfortranarray(C_p).ravel(order="F")
    c__pdafomi_add_obs_error_cb (&step,
                                 &dim_obs_p,
                                 &C_p_f[0]
                                )

    return np.asarray(C_p).reshape((dim_obs_p, dim_obs_p), order='F')

def omi_init_obscovar_cb (int step,
                          int dim_obs,
                          int dim_obs_p,
                          double[::1,:] covar,
                          double[::1] m_state_p,
                          bint isdiag
                         ):
    """This is an internal PDAF-OMI function that is used as a call-back function to construct a full observation error covariance matrix used only in stochastic EnKF. This could be used to modify the observation variance when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`.

    Parameters
    ----------
    step : int
        Current time step
    dim_obs : int
        Dimension of observation vector
    dim_obs_p : int
        PE-local dimension of obs. vector
    covar : ndarray[tuple[dim_obs, dim_obs], np.float64]
        Observation error covar. matrix
    m_state_p : ndarray[tuple[dim_obs_p], np.float64]
        Observation vector
    isdiag : bool
        Whether matrix R is diagonal

    Returns
    -------
    covar : ndarray[tuple[dim_obs, dim_obs], np.float64]
         Observation error covar. matrix
    isdiag : bool
        Whether matrix R is diagonal
    """

    cdef double[::1] covar_f = np.asfortranarray(covar).ravel(order="F")
    c__pdafomi_init_obscovar_cb (&step,
                                 &dim_obs,
                                 &dim_obs_p,
                                 &covar_f[0],
                                 &m_state_p[0],
                                 &isdiag
                                )

    return np.asarray(covar).reshape((dim_obs, dim_obs), order='F'), isdiag

def omi_init_obserr_f_cb (int step,
                          int dim_obs_f,
                          double[::1] obs_f,
                          double[::1] obserr_f
                         ):
    """This is an internal PDAF-OMI function that is used as a call-back function to construct a full observation error covariance matrix used only in stochastic EnKF. This could be used to modify the observation variance when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`.

    Parameters
    ----------
    step : int
        Current time step
    dim_obs_f : int
        Full dimension of observation vector
    obs_f : ndarray[tuple[dim_obs_f], np.float64]
        Full observation vector
    obserr_f : ndarray[tuple[dim_obs_f], np.float64]
        Full observation error stddev

    Returns
    -------
    obserr_f : ndarray[tuple[dim_obs_f], np.float64]
         Full observation error stddev
    """

    c__pdafomi_init_obserr_f_cb (&step,
                                 &dim_obs_f,
                                 &obs_f[0],
                                 &obserr_f[0]
                                )

    return np.asarray(obserr_f).reshape((dim_obs_f), order='F')

def omi_prodRinvA_hyb_l_cb (int domain_p,
                            int step,
                            int dim_obs_l,
                            int rank,
                            double[::1] obs_l,
                            double alpha,
                            double[::1,:] A_l,
                            double[::1,:] C_l
                           ):
    """This function is an internal PDAF-OMI function that is used as a call-back function to perform the matrix multiplication inverse of local observation error covariance and a matrix A in LKNETF. This could be used to modify the observation variance when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`.

    Parameters
    ----------
    domain_p : int
        Index of current local analysis domain
    step : int
        Current time step
    dim_obs_l : int
        Dimension of local observation vector
    rank : int
        Rank of initial covariance matrix
    obs_l : ndarray[tuple[dim_obs_l], np.float64]
        Local vector of observations
    alpha : float
        Hybrid weight
    A_l : ndarray[tuple[dim_obs_l, rank], np.float64]
        Input matrix
    C_l : ndarray[tuple[dim_obs_l, rank], np.float64]
        Output matrix

    Returns
    -------
    A_l : ndarray[tuple[dim_obs_l, rank], np.float64]
         Input matrix
    C_l : ndarray[tuple[dim_obs_l, rank], np.float64]
         Output matrix
    """

    cdef double[::1] A_l_f = np.asfortranarray(A_l).ravel(order="F")
    cdef double[::1] C_l_f = np.asfortranarray(C_l).ravel(order="F")
    c__pdafomi_prodrinva_hyb_l_cb (&domain_p,
                                   &step,
                                   &dim_obs_l,
                                   &rank,
                                   &obs_l[0],
                                   &alpha,
                                   &A_l_f[0],
                                   &C_l_f[0]
                                  )

    return np.asarray(A_l).reshape((dim_obs_l, rank), order='F'), np.asarray(C_l).reshape((dim_obs_l, rank), order='F')

def omi_likelihood_hyb_l_cb (int domain_p,
                             int step,
                             int dim_obs_l,
                             double[::1] obs_l,
                             double[::1] resid_l,
                             double alpha,
                             double lhood_l
                            ):
    """This is an internal PDAF-OMI function that is used as a call-back function to compute the likelihood of the observation for a given ensemble member according to the observations used for the local analysis in LKNETF. This could be used to modify the observation variance when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`. See https://pdaf.awi.de/trac/wiki/U_likelihood_l

    Parameters
    ----------
    domain_p : int
        Current local analysis domain
    step : int
        Current time step
    dim_obs_l : int
        PE-local dimension of obs. vector
    obs_l : ndarray[tuple[dim_obs_l], np.float64]
        PE-local vector of observations
    resid_l : ndarray[tuple[dim_obs_l], np.float64]
        Input vector of residuum
    alpha : float
        Hybrid weight
    lhood_l : float
        Output vector - log likelihood

    Returns
    -------
    resid_l : ndarray[tuple[dim_obs_l], np.float64]
         Input vector of residuum
    lhood_l : float
        Output vector - log likelihood
    """

    c__pdafomi_likelihood_hyb_l_cb (&domain_p,
                                    &step,
                                    &dim_obs_l,
                                    &obs_l[0],
                                    &resid_l[0],
                                    &alpha,
                                    &lhood_l
                                   )

    return np.asarray(resid_l).reshape((dim_obs_l), order='F'), lhood_l

def omi_obsstats_l (int screen
                   ):
    """This function is called in the update routine of local filters and write statistics on locally used and excluded observations.

    Parameters
    ----------
    screen : int
        Verbosity flag
    """

    c__pdafomi_obsstats_l (&screen
                          )

def omi_weights_l (int verbose,
                   int locweight,
                   double[::1] cradius,
                   double[::1] sradius,
                   double[:,:] matA,
                   double[::1] ivar_obs_l,
                   double[::1] dist_l
                  ):
    """This function computes a weight vector according to the distances of observations from the local analysis domain with a vector of localisation radius.

    Parameters
    ----------
    verbose : int
        Verbosity flag
    locweight : int
        Types of localization function 0) unit weight; 1) exponential; 2) 5-th order polynomial; 3) 5-th order polynomial with regulatioin using mean variance; 4) 5-th order polynomial with regulatioin using variance of single observation point;
    cradius : ndarray[tuple[nobs_l], np.float64]
        Vector of localization cut-off radii; observation weight=0 if distance > cradius
    sradius : ndarray[tuple[nobs_l], np.float64]
        Vector of support radii of localization function. It has no impact if locweight=0; 	weight = exp(-d / sradius) if locweight=1; weight = 0 if d >= sradius else f(sradius, distance) if locweight in [2,3,4].
    matA : ndarray[tuple[nobs_l, ncols], np.float64]
        
    ivar_obs_l : ndarray[tuple[nobs_l], np.float64]
        Local vector of inverse obs. variances (nobs_l)
    dist_l : ndarray[tuple[nobs_l], np.float64]
        Local vector of obs. distances (nobs_l)

    Returns
    -------
    weight_l : ndarray[tuple[nobs_l], np.float64]
         Output: vector of weights
    """

    cdef double[::1] matA_f = np.asfortranarray(matA).ravel(order="F")
    cdef int nobs_l, ncols
    nobs_l = matA.shape[0]
    ncols = matA.shape[1]

    cdef double [::1] weight_l = np.zeros((nobs_l), dtype=np.float64).ravel()

    c__pdafomi_weights_l (&verbose,
                          &nobs_l,
                          &ncols,
                          &locweight,
                          &cradius[0],
                          &sradius[0],
                          &matA_f[0],
                          &ivar_obs_l[0],
                          &dist_l[0],
                          &weight_l[0]
                         )

    return np.asarray(weight_l).reshape((nobs_l), order='F')

def omi_weights_l_sgnl (int verbose,
                        int locweight,
                        double cradius,
                        double sradius,
                        double[:,:] matA,
                        double[::1] ivar_obs_l,
                        double[::1] dist_l
                       ):
    """This function computes a weight vector according to the distances of observations from the local analysis domain with given localisation radius.

    Parameters
    ----------
    verbose : int
        Verbosity flag
    locweight : int
        Types of localization function 0) unit weight; 1) exponential; 2) 5-th order polynomial; 3) 5-th order polynomial with regulatioin using mean variance; 4) 5-th order polynomial with regulatioin using variance of single observation point;
    cradius : float
        Vector of localization cut-off radii; observation weight=0 if distance > cradius
    sradius : float
        Vector of support radii of localization function. It has no impact if locweight=0; 	weight = exp(-d / sradius) if locweight=1; weight = 0 if d >= sradius else f(sradius, distance) if locweight in [2,3,4].
    matA : ndarray[tuple[nobs_l, ncols], np.float64]
        
    ivar_obs_l : ndarray[tuple[nobs_l], np.float64]
        Local vector of inverse obs. variances (nobs_l)
    dist_l : ndarray[tuple[nobs_l], np.float64]
        Local vector of obs. distances (nobs_l)

    Returns
    -------
    weight_l : ndarray[tuple[nobs_l], np.float64]
         Output: vector of weights
    """

    cdef double[::1] matA_f = np.asfortranarray(matA).ravel(order="F")
    cdef int nobs_l, ncols
    nobs_l = matA.shape[0]
    ncols = matA.shape[1]

    cdef double [::1] weight_l = np.zeros((nobs_l), dtype=np.float64).ravel()

    c__pdafomi_weights_l_sgnl (&verbose,
                               &nobs_l,
                               &ncols,
                               &locweight,
                               &cradius,
                               &sradius,
                               &matA_f[0],
                               &ivar_obs_l[0],
                               &dist_l[0],
                               &weight_l[0]
                              )

    return np.asarray(weight_l).reshape((nobs_l), order='F')

def omi_check_error (int flag
                    ):
    """This function returns the value of the PDAF-OMI internal error flag.

    Parameters
    ----------
    flag : int
        Error flag

    Returns
    -------
    flag : int
        Error flag
    """

    c__pdafomi_check_error (&flag
                           )

    return flag

def omi_gather_obsdims ():
    """This function gathers the information about the full dimension of each observation type in each process-local subdomain.

    """

    c__pdafomi_gather_obsdims ()

def omi_obsstats (int screen
                 ):
    """The function is called in the update routine of global filters and writes statistics on used and excluded observations.

    Parameters
    ----------
    screen : int
        Verbosity flag
    """

    c__pdafomi_obsstats (&screen
                        )

def omi_init_dim_obs_l_iso (int i_obs,
                            double[::1] coords_l,
                            int locweight,
                            double cradius,
                            double sradius,
                            int cnt_obs_l
                           ):
    """The function has to be called in `init_dim_obs_l_OBTYPE` in each observation module if a domain-localized filter (LESTKF/LETKF/LNETF/LSEIK)is used. It initialises the local observation information for PDAF-OMI for a single local analysis domain. This is used for isotropic localisation where the localisation radius is the same in all directions.

    Parameters
    ----------
    i_obs : int
        index of observation type
    coords_l : ndarray[tuple[ncoord], np.float64]
        Coordinates of current analysis domain
    locweight : int
        Types of localization function 0) unit weight; 1) exponential; 2) 5-th order polynomial; 3) 5-th order polynomial with regulatioin using mean variance; 4) 5-th order polynomial with regulatioin using variance of single observation point;
    cradius : float
        Vector of localization cut-off radii; observation weight=0 if distance > cradius
    sradius : float
        Vector of support radii of localization function. It has no impact if locweight=0; 	weight = exp(-d / sradius) if locweight=1; weight = 0 if d >= sradius else f(sradius, distance) if locweight in [2,3,4].
    cnt_obs_l : int
        Local dimension of current observation vector

    Returns
    -------
    cnt_obs_l : int
        Local dimension of current observation vector
    """

    cdef int ncoord
    ncoord = coords_l.shape[0]

    c__pdafomi_init_dim_obs_l_iso (&i_obs,
                                   &ncoord,
                                   &coords_l[0],
                                   &locweight,
                                   &cradius,
                                   &sradius,
                                   &cnt_obs_l
                                  )

    return cnt_obs_l

def omi_init_dim_obs_l_noniso (int i_obs,
                               double[::1] coords_l,
                               int locweight,
                               double[::1] cradius,
                               double[::1] sradius,
                               int cnt_obs_l
                              ):
    """The function has to be called in `init_dim_obs_l_OBTYPE` in each observation module if a domain-localized filter (LESTKF/LETKF/LNETF/LSEIK)is used. It initialises the local observation information for PDAF-OMI for a single local analysis domain. This is used for non-isotropic localisation where the localisation radius is different in each direction. See https://pdaf.awi.de/trac/wiki/OMI_observation_modules#init_dim_obs_l_OBSTYPE and https://pdaf.awi.de/trac/wiki/PDAFomi_init_dim_obs_l#Settingsfornon-isotropiclocalization.

    Parameters
    ----------
    i_obs : int
        index of observation type
    coords_l : ndarray[tuple[ncoord], np.float64]
        Coordinates of current analysis domain
    locweight : int
        Types of localization function 0) unit weight; 1) exponential; 2) 5-th order polynomial; 3) 5-th order polynomial with regulatioin using mean variance; 4) 5-th order polynomial with regulatioin using variance of single observation point;
    cradius : ndarray[tuple[ncoord], np.float64]
        Vector of localization cut-off radii; observation weight=0 if distance > cradius
    sradius : ndarray[tuple[ncoord], np.float64]
        Vector of support radii of localization function. It has no impact if locweight=0; 	weight = exp(-d / sradius) if locweight=1; weight = 0 if d >= sradius else f(sradius, distance) if locweight in [2,3,4].
    cnt_obs_l : int
        Local dimension of current observation vector

    Returns
    -------
    cnt_obs_l : int
        Local dimension of current observation vector
    """

    cdef int ncoord
    ncoord = coords_l.shape[0]

    c__pdafomi_init_dim_obs_l_noniso (&i_obs,
                                      &ncoord,
                                      &coords_l[0],
                                      &locweight,
                                      &cradius[0],
                                      &sradius[0],
                                      &cnt_obs_l
                                     )

    return cnt_obs_l

def omi_init_dim_obs_l_noniso_locweights (int i_obs,
                                          double[::1] coords_l,
                                          int[::1] locweights,
                                          double[::1] cradius,
                                          double[::1] sradius,
                                          int cnt_obs_l
                                         ):
    """The function has to be called in `init_dim_obs_l_OBTYPE` in each observation module if a domain-localized filter (LESTKF/LETKF/LNETF/LSEIK)is used. It initialises the local observation information for PDAF-OMI for a single local analysis domain. This is used for non-isotropic localisation and different weight functions for horizontal and vertical directions. See https://pdaf.awi.de/trac/wiki/OMI_observation_modules#init_dim_obs_l_OBSTYPE and https://pdaf.awi.de/trac/wiki/PDAFomi_init_dim_obs_l#Settingdifferentweightfunctsforhorizontalandverticaldirections.

    Parameters
    ----------
    i_obs : int
        index of observation type
    coords_l : ndarray[tuple[ncoord], np.float64]
        Coordinates of current analysis domain
    locweights : ndarray[tuple[2], np.intc]
        Types of localization function 0) unit weight; 1) exponential; 2) 5-th order polynomial; 3) 5-th order polynomial with regulatioin using mean variance; 4) 5-th order polynomial with regulatioin using variance of single observation point; The first dimension is horizontal weight function and the second is the vertical function
    cradius : ndarray[tuple[ncoord], np.float64]
        Vector of localization cut-off radii for each dimension; observation weight=0 if distance > cradius
    sradius : ndarray[tuple[ncoord], np.float64]
        Vector of support radii of localization function for each dimension. It has no impact if locweight=0; 	weight = exp(-d / sradius) if locweight=1; weight = 0 if d >= sradius else f(sradius, distance) if locweight in [2,3,4].
    cnt_obs_l : int
        Local dimension of current observation vector

    Returns
    -------
    cnt_obs_l : int
        Local dimension of current observation vector
    """

    cdef int ncoord
    ncoord = coords_l.shape[0]

    c__pdafomi_init_dim_obs_l_noniso_locweights (&i_obs,
                                                 &ncoord,
                                                 &coords_l[0],
                                                 &locweights[0],
                                                 &cradius[0],
                                                 &sradius[0],
                                                 &cnt_obs_l
                                                )

    return cnt_obs_l

def omi_localize_covar_iso (int i_obs,
                            int locweight,
                            double cradius,
                            double sradius,
                            double[:,:] coords,
                            double[:,:] HP,
                            double[:,:] HPH
                           ):
    """The function has to be called in `localize_covar_OBTYPE` in each observation module. It applies the covariance localisation in stochastic EnKF. This is used for isotropic localisation where the localisation radius is the same in all directions. See https://pdaf.awi.de/trac/wiki/PDAFomi_localize_covar

    Parameters
    ----------
    i_obs : int
        index of observation type
    locweight : int
        Types of localization function 0) unit weight; 1) exponential; 2) 5-th order polynomial; 3) 5-th order polynomial with regulatioin using mean variance; 4) 5-th order polynomial with regulatioin using variance of single observation point;
    cradius : float
        Vector of localization cut-off radii; observation weight=0 if distance > cradius
    sradius : float
        Vector of support radii of localization function. It has no impact if locweight=0; 	weight = exp(-d / sradius) if locweight=1; weight = 0 if d >= sradius else f(sradius, distance) if locweight in [2,3,4].
    coords : ndarray[tuple[ncoord, dim_p], np.float64]
        Coordinates of state vector elements
    HP : ndarray[tuple[dim_obs, dim_p], np.float64]
        Matrix HP, dimension (nobs, dim)
    HPH : ndarray[tuple[dim_obs, dim_obs], np.float64]
        Matrix HPH, dimension (nobs, nobs)

    Returns
    -------
    HP : ndarray[tuple[dim_obs, dim_p], np.float64]
         Matrix HP, dimension (nobs, dim)
    HPH : ndarray[tuple[dim_obs, dim_obs], np.float64]
         Matrix HPH, dimension (nobs, nobs)
    """

    cdef double[::1] coords_f = np.asfortranarray(coords).ravel(order="F")
    cdef double[::1] HP_f = np.asfortranarray(HP).ravel(order="F")
    cdef double[::1] HPH_f = np.asfortranarray(HPH).ravel(order="F")
    cdef int ncoord, dim_p, dim_obs
    ncoord = coords.shape[0]
    dim_p = coords.shape[1]
    dim_obs = HP.shape[0]
    _ = HP.shape[1]

    c__pdafomi_localize_covar_iso (&i_obs,
                                   &dim_p,
                                   &dim_obs,
                                   &ncoord,
                                   &locweight,
                                   &cradius,
                                   &sradius,
                                   &coords_f[0],
                                   &HP_f[0],
                                   &HPH_f[0]
                                  )

    return np.asarray(HP).reshape((dim_obs, dim_p), order='F'), np.asarray(HPH).reshape((dim_obs, dim_obs), order='F')

def omi_localize_covar_noniso (int i_obs,
                               int locweight,
                               double[::1] cradius,
                               double[::1] sradius,
                               double[:,:] coords,
                               double[:,:] HP,
                               double[:,:] HPH
                              ):
    """The function has to be called in `localize_covar_OBTYPE` in each observation module. It applies the covariance localisation in stochastic EnKF. This is used for non-isotropic localisation where the localisation radius is different. See https://pdaf.awi.de/trac/wiki/PDAFomi_localize_covar

    Parameters
    ----------
    i_obs : int
        Data type with full observation
    locweight : int
        Types of localization function 0) unit weight; 1) exponential; 2) 5-th order polynomial; 3) 5-th order polynomial with regulatioin using mean variance; 4) 5-th order polynomial with regulatioin using variance of single observation point;
    cradius : ndarray[tuple[ncoord], np.float64]
        Vector of localization cut-off radii for each dimension; observation weight=0 if distance > cradius
    sradius : ndarray[tuple[ncoord], np.float64]
        Vector of support radii of localization function for each dimension. It has no impact if locweight=0; 	weight = exp(-d / sradius) if locweight=1; weight = 0 if d >= sradius else f(sradius, distance) if locweight in [2,3,4].
    coords : ndarray[tuple[ncoord, dim_p], np.float64]
        Coordinates of state vector elements
    HP : ndarray[tuple[dim_obs, dim_p], np.float64]
        Matrix HP, dimension (nobs, dim)
    HPH : ndarray[tuple[dim_obs, dim_obs], np.float64]
        Matrix HPH, dimension (nobs, nobs)

    Returns
    -------
    HP : ndarray[tuple[dim_obs, dim_p], np.float64]
         Matrix HP, dimension (nobs, dim)
    HPH : ndarray[tuple[dim_obs, dim_obs], np.float64]
         Matrix HPH, dimension (nobs, nobs)
    """

    cdef double[::1] coords_f = np.asfortranarray(coords).ravel(order="F")
    cdef double[::1] HP_f = np.asfortranarray(HP).ravel(order="F")
    cdef double[::1] HPH_f = np.asfortranarray(HPH).ravel(order="F")
    cdef int ncoord, dim_p, dim_obs
    ncoord = coords.shape[0]
    dim_p = coords.shape[1]
    dim_obs = HP.shape[0]
    _ = HP.shape[1]

    c__pdafomi_localize_covar_noniso (&i_obs,
                                      &dim_p,
                                      &dim_obs,
                                      &ncoord,
                                      &locweight,
                                      &cradius[0],
                                      &sradius[0],
                                      &coords_f[0],
                                      &HP_f[0],
                                      &HPH_f[0]
                                     )

    return np.asarray(HP).reshape((dim_obs, dim_p), order='F'), np.asarray(HPH).reshape((dim_obs, dim_obs), order='F')

def omi_localize_covar_noniso_locweights (int i_obs,
                                          int[::1] locweights,
                                          double[::1] cradius,
                                          double[::1] sradius,
                                          double[:,:] coords,
                                          double[:,:] HP,
                                          double[:,:] HPH
                                         ):
    """The function has to be called in `localize_covar_OBTYPE` in each observation module. It applies the covariance localisation in stochastic EnKF. This is used for non-isotropic localisation with different weight function for horizontal and vertical directions. where the localisation radius is different. See https://pdaf.awi.de/trac/wiki/PDAFomi_localize_covar

    Parameters
    ----------
    i_obs : int
        index of observation type
    locweights : ndarray[tuple[2], np.intc]
        Types of localization function 0) unit weight; 1) exponential; 2) 5-th order polynomial; 3) 5-th order polynomial with regulatioin using mean variance; 4) 5-th order polynomial with regulatioin using variance of single observation point; The first dimension is horizontal weight function and the second is the vertical function
    cradius : ndarray[tuple[ncoord], np.float64]
        Vector of localization cut-off radii for each dimension; observation weight=0 if distance > cradius
    sradius : ndarray[tuple[ncoord], np.float64]
        Vector of support radii of localization function for each dimension. It has no impact if locweight=0; 	weight = exp(-d / sradius) if locweight=1; weight = 0 if d >= sradius else f(sradius, distance) if locweight in [2,3,4].
    coords : ndarray[tuple[ncoord, dim_p], np.float64]
        Coordinates of state vector elements
    HP : ndarray[tuple[dim_obs, dim_p], np.float64]
        Matrix HP, dimension (nobs, dim)
    HPH : ndarray[tuple[dim_obs, dim_obs], np.float64]
        Matrix HPH, dimension (nobs, nobs)

    Returns
    -------
    HP : ndarray[tuple[dim_obs, dim_p], np.float64]
         Matrix HP, dimension (nobs, dim)
    HPH : ndarray[tuple[dim_obs, dim_obs], np.float64]
         Matrix HPH, dimension (nobs, nobs)
    """

    cdef double[::1] coords_f = np.asfortranarray(coords).ravel(order="F")
    cdef double[::1] HP_f = np.asfortranarray(HP).ravel(order="F")
    cdef double[::1] HPH_f = np.asfortranarray(HPH).ravel(order="F")
    cdef int ncoord, dim_p, dim_obs
    ncoord = coords.shape[0]
    dim_p = coords.shape[1]
    dim_obs = HP.shape[0]
    _ = HP.shape[1]

    c__pdafomi_localize_covar_noniso_locweights (&i_obs,
                                                 &dim_p,
                                                 &dim_obs,
                                                 &ncoord,
                                                 &locweights[0],
                                                 &cradius[0],
                                                 &sradius[0],
                                                 &coords_f[0],
                                                 &HP_f[0],
                                                 &HPH_f[0]
                                                )

    return np.asarray(HP).reshape((dim_obs, dim_p), order='F'), np.asarray(HPH).reshape((dim_obs, dim_obs), order='F')

def omi_omit_by_inno_l_cb (int domain_p,
                           int dim_obs_l,
                           double[::1] resid_l,
                           double[::1] obs_l
                          ):
    """The function is called during the analysis step on each local analysis domain. It checks the size of the innovation and sets the observation error to a high value if the squared innovation exceeds a limit relative to the observation error variance.This function is an internal PDAF-OMI function that is used as a call-back function. This could be used to modify the observation vector when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`.

    Parameters
    ----------
    domain_p : int
        Current local analysis domain
    dim_obs_l : int
        PE-local dimension of obs. vector
    resid_l : ndarray[tuple[dim_obs_l], np.float64]
        Input vector of residuum
    obs_l : ndarray[tuple[dim_obs_l], np.float64]
        Input vector of local observations

    Returns
    -------
    resid_l : ndarray[tuple[dim_obs_l], np.float64]
         Input vector of residuum
    obs_l : ndarray[tuple[dim_obs_l], np.float64]
         Input vector of local observations
    """

    c__pdafomi_omit_by_inno_l_cb (&domain_p,
                                  &dim_obs_l,
                                  &resid_l[0],
                                  &obs_l[0]
                                 )

    return np.asarray(resid_l).reshape((dim_obs_l), order='F'), np.asarray(obs_l).reshape((dim_obs_l), order='F')

def omi_omit_by_inno_cb (int dim_obs_f,
                         double[::1] resid_f,
                         double[::1] obs_f
                        ):
    """The function is called during the analysis step of a global filter. It checks the size of the innovation and sets the observation error to a high value if the squared innovation exceeds a limit relative to the observation error variance.This function is called in the update routine of local filters and write statistics on locally used and excluded observations.This function is an internal PDAF-OMI function that is used as a call-back function. This could be used to modify the observation vector when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`.

    Parameters
    ----------
    dim_obs_f : int
        Full dimension of obs. vector
    resid_f : ndarray[tuple[dim_obs_f], np.float64]
        Input vector of residuum
    obs_f : ndarray[tuple[dim_obs_f], np.float64]
        Input vector of full observations

    Returns
    -------
    resid_f : ndarray[tuple[dim_obs_f], np.float64]
         Input vector of residuum
    obs_f : ndarray[tuple[dim_obs_f], np.float64]
         Input vector of full observations
    """

    c__pdafomi_omit_by_inno_cb (&dim_obs_f,
                                &resid_f[0],
                                &obs_f[0]
                               )

    return np.asarray(resid_f).reshape((dim_obs_f), order='F'), np.asarray(obs_f).reshape((dim_obs_f), order='F')

def omi_set_localization (int i_obs,
                          double cradius,
                          double sradius,
                          int locweight
                         ):
    """This function sets localization information (locweight, cradius, sradius) in OMI, and allocates local arrays for cradius and sradius, i.e. `obs_l`. This variant is for isotropic localization. The function is used by user-supplied implementations of `pyPDAF.PDAF.omi_init_dim_obs_l_iso`. 

    Parameters
    ----------
    i_obs : int
        Observation type index
    cradius : float
        Vector of localization cut-off radii; observation weight=0 if distance > cradius
    sradius : float
        Vector of support radii of localization function. It has no impact if locweight=0; 	weight = exp(-d / sradius) if locweight=1; weight = 0 if d >= sradius else f(sradius, distance) if locweight in [2,3,4].
    locweight : int
        Types of localization function 0) unit weight; 1) exponential; 2) 5-th order polynomial; 3) 5-th order polynomial with regulatioin using mean variance; 4) 5-th order polynomial with regulatioin using variance of single observation point;

    Returns
    -------
    i_obs : int
        Observation type index
    """

    c__pdafomi_set_localization (&i_obs,
                                 &cradius,
                                 &sradius,
                                 &locweight
                                )

    return i_obs

def omi_set_localization_noniso (int i_obs,
                                 double[::1] cradius,
                                 double[::1] sradius,
                                 int locweight,
                                 int locweight_v
                                ):
    """This function sets localization information (locweight, cradius, sradius) in OMI, and allocates local arrays for cradius and sradius, i.e. `obs_l`. This variant is for non-isotropic localization. The function is used by user-supplied implementations of `pyPDAF.PDAF.omi_init_dim_obs_l_noniso`. 

    Parameters
    ----------
    i_obs : int
        Type of observation index
    cradius : ndarray[tuple[nradii], np.float64]
        Vector of localization cut-off radii; observation weight=0 if distance > cradius
    sradius : ndarray[tuple[nradii], np.float64]
        Vector of support radii of localization function. It has no impact if locweight=0; 	weight = exp(-d / sradius) if locweight=1; weight = 0 if d >= sradius else f(sradius, distance) if locweight in [2,3,4].
    locweight : int
        Types of localization function 0) unit weight; 1) exponential; 2) 5-th order polynomial; 3) 5-th order polynomial with regulatioin using mean variance; 4) 5-th order polynomial with regulatioin using variance of single observation point;
    locweight_v : int
        Type of localization function in vertical direction (only for nradii=3)

    Returns
    -------
    i_obs : int
        Type of observation index
    """

    cdef int nradii
    nradii = cradius.shape[0]

    c__pdafomi_set_localization_noniso (&i_obs,
                                        &nradii,
                                        &cradius[0],
                                        &sradius[0],
                                        &locweight,
                                        &locweight_v
                                       )

    return i_obs

def omi_set_dim_obs_l (int i_obs,
                       int cnt_obs_l_all,
                       int cnt_obs_l
                      ):
    """This function initialises number local observations. It also returns number of local observations up to the current observation type. It is used by a user-supplied implementations of `pyPDAF.PDAF.omi_init_dim_obs_l_xxx`.

    Parameters
    ----------
    i_obs : int
        Type of observation index
    cnt_obs_l_all : int
        Local dimension of observation vector over all obs. types
    cnt_obs_l : int
        Local dimension of single observation type vector

    Returns
    -------
    i_obs : int
        Type of observation index
    cnt_obs_l_all : int
        Local dimension of observation vector over all obs. types
    cnt_obs_l : int
        Local dimension of single observation type vector
    """

    c__pdafomi_set_dim_obs_l (&i_obs,
                              &cnt_obs_l_all,
                              &cnt_obs_l
                             )

    return i_obs, cnt_obs_l_all, cnt_obs_l

def omi_store_obs_l_index (int i_obs,
                           int idx,
                           int id_obs_l,
                           double distance,
                           double cradius_l,
                           double sradius_l
                          ):
    """This function stores the mapping index between the global and local observation vectors, the distance and the cradius and sradius for a single observations in OMI. This variant is for non-factorised localisation. The function is used by user-supplied implementations of `pyPDAF.PDAF.omi_init_dim_obs_l_iso` or `pyPDAF.PDAF.omi_init_dim_obs_l_noniso`. 

    Parameters
    ----------
    i_obs : int
        Type of observation index
    idx : int
        < Element of local observation array to be filled
    id_obs_l : int
        < Index of local observation in full observation array
    distance : float
        < Distance between local analysis domain and observation
    cradius_l : float
        < cut-off radius for this local observation; observation weight=0 if distance > cradius (directional radius in case of non-isotropic localization)
    sradius_l : float
        < support radius for this local observation (directional radius in case of non-isotropic localization) Vector of support radii of localization function. It has no impact if locweight=0; 	weight = exp(-d / sradius) if locweight=1; weight = 0 if d >= sradius else f(sradius, distance) if locweight in [2,3,4].

    Returns
    -------
    i_obs : int
        Type of observation index
    """

    c__pdafomi_store_obs_l_index (&i_obs,
                                  &idx,
                                  &id_obs_l,
                                  &distance,
                                  &cradius_l,
                                  &sradius_l
                                 )

    return i_obs

def omi_store_obs_l_index_vdist (int i_obs,
                                 int idx,
                                 int id_obs_l,
                                 double distance,
                                 double cradius_l,
                                 double sradius_l,
                                 double vdist
                                ):
    """This function stores the mapping index between the global and local observation vectors, the distance and the cradius and sradius for a single observations in OMI. This variant is for 2D+1D factorised localisation.
    The function is used by user-supplied implementations of `pyPDAF.PDAF.omi_init_dim_obs_l_noniso_locweights`.

    Parameters
    ----------
    i_obs : int
        Type of observation index
    idx : int
        < Element of local observation array to be filled
    id_obs_l : int
        < Index of local observation in full observation array
    distance : float
        < Distance between local analysis domain and observation
    cradius_l : float
        < cut-off radius for this local observation (directional radius in case of non-isotropic localization)
    sradius_l : float
        < support radius for this local observation (directional radius in case of non-isotropic localization)
    vdist : float
        < support radius in vertical direction for 2+1D factorized localization

    Returns
    -------
    i_obs : int
        Type of observation index
    """

    c__pdafomi_store_obs_l_index_vdist (&i_obs,
                                        &idx,
                                        &id_obs_l,
                                        &distance,
                                        &cradius_l,
                                        &sradius_l,
                                        &vdist
                                       )

    return i_obs

def omi_assimilate_3dvar_nondiagR (py__collect_state_pdaf,
                                   py__distribute_state_pdaf,
                                   py__init_dim_obs_pdaf,
                                   py__obs_op_pdaf,
                                   py__prodRinvA_pdaf,
                                   py__cvt_pdaf,
                                   py__cvt_adj_pdaf,
                                   py__obs_op_lin_pdaf,
                                   py__obs_op_adj_pdaf,
                                   py__prepoststep_pdaf,
                                   py__next_observation_pdaf,
                                   int outflag
                                  ):
    """Using 3DVar for DA with non-diagonal observation error covariance matrix.
    This is a deterministic filtering scheme. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.omi_put_state_3dvar_nondiagR`
    and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_pdaf
    6. py__obs_op_lin_pdaf
    7. py__prodRinvA_pdaf
    8. py__obs_op_adj_pdaf
    9. py__cvt_adj_pdaf
    10. core DA algorithm
    After the iterations: 
    11. py__cvt_pdaf
    12. py__prepoststep_state_pdaf
    13. py__distribute_state_pdaf
    14. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], A_p : ndarray[tuple[dim_obs_p, rank], np.float64], C_p : ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p : ndarray[tuple[dim_cvec], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.prodRinvA_pdaf = <void*>py__prodRinvA_pdaf
    c__PDAFcython.cvt_pdaf = <void*>py__cvt_pdaf
    c__PDAFcython.cvt_adj_pdaf = <void*>py__cvt_adj_pdaf
    c__PDAFcython.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    c__PDAFcython.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    c__pdafomi_assimilate_3dvar_nondiagr (c__PDAFcython.c__collect_state_pdaf,
                                          c__PDAFcython.c__distribute_state_pdaf,
                                          c__PDAFcython.c__init_dim_obs_pdaf,
                                          c__PDAFcython.c__obs_op_pdaf,
                                          c__PDAFcython.c__prodRinvA_pdaf,
                                          c__PDAFcython.c__cvt_pdaf,
                                          c__PDAFcython.c__cvt_adj_pdaf,
                                          c__PDAFcython.c__obs_op_lin_pdaf,
                                          c__PDAFcython.c__obs_op_adj_pdaf,
                                          c__PDAFcython.c__prepoststep_pdaf,
                                          c__PDAFcython.c__next_observation_pdaf,
                                          &outflag
                                         )

    return outflag

def omi_assimilate_en3dvar_estkf_nondiagR (py__collect_state_pdaf,
                                           py__distribute_state_pdaf,
                                           py__init_dim_obs_pdaf,
                                           py__obs_op_pdaf,
                                           py__prodRinvA_pdaf,
                                           py__cvt_ens_pdaf,
                                           py__cvt_adj_ens_pdaf,
                                           py__obs_op_lin_pdaf,
                                           py__obs_op_adj_pdaf,
                                           py__prepoststep_pdaf,
                                           py__next_observation_pdaf,
                                           int outflag
                                          ):
    """Using 3DEnVar for DA with non-diagonal observation error covariance matrix.
    The background error covariance matrix is estimated by ensemble. The 3DEnVar only calculates the analysis of the ensemble mean.
    An ESTKF is used to generate ensemble perturbations. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.omi_put_state_en3dvar_estkf_nondiagR`
    and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_ens_pdaf
    6. py__obs_op_lin_pdaf
    7. py__prodRinvA_pdaf
    8. py__obs_op_adj_pdaf
    9. py__cvt_adj_ens_pdaf
    10. core 3DEnVar algorithm
    After the iterations: 
    11. py__cvt_ens_pdaf
    Perform ESTKF: 12. py__init_dim_obs_pdaf
    13. py__obs_op_pdaf (for ensemble mean
    14. py__obs_op_pdaf (for each ensemble member
    15. py__prodRinvA_pdaf
    16. core ESTKF algorithm
    17. py__prepoststep_state_pdaf
    18. py__distribute_state_pdaf
    19. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], A_p : ndarray[tuple[dim_obs_p, rank], np.float64], C_p : ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], v_p : ndarray[tuple[dim_cvec_ens], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_ens** : int

            * Ensemble size

        * **dim_cvec_ens** : int

            * Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_ens** : int

            * Ensemble size

        * **dim_cv_ens_p** : int

            * PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.prodRinvA_pdaf = <void*>py__prodRinvA_pdaf
    c__PDAFcython.cvt_ens_pdaf = <void*>py__cvt_ens_pdaf
    c__PDAFcython.cvt_adj_ens_pdaf = <void*>py__cvt_adj_ens_pdaf
    c__PDAFcython.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    c__PDAFcython.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    c__pdafomi_assimilate_en3dvar_estkf_nondiagr (c__PDAFcython.c__collect_state_pdaf,
                                                  c__PDAFcython.c__distribute_state_pdaf,
                                                  c__PDAFcython.c__init_dim_obs_pdaf,
                                                  c__PDAFcython.c__obs_op_pdaf,
                                                  c__PDAFcython.c__prodRinvA_pdaf,
                                                  c__PDAFcython.c__cvt_ens_pdaf,
                                                  c__PDAFcython.c__cvt_adj_ens_pdaf,
                                                  c__PDAFcython.c__obs_op_lin_pdaf,
                                                  c__PDAFcython.c__obs_op_adj_pdaf,
                                                  c__PDAFcython.c__prepoststep_pdaf,
                                                  c__PDAFcython.c__next_observation_pdaf,
                                                  &outflag
                                                 )

    return outflag

def omi_assimilate_en3dvar_lestkf_nondiagR (py__collect_state_pdaf,
                                            py__distribute_state_pdaf,
                                            py__init_dim_obs_pdaf,
                                            py__obs_op_pdaf,
                                            py__prodRinvA_pdaf,
                                            py__cvt_ens_pdaf,
                                            py__cvt_adj_ens_pdaf,
                                            py__obs_op_lin_pdaf,
                                            py__obs_op_adj_pdaf,
                                            py__prodRinvA_l_pdaf,
                                            py__init_n_domains_p_pdaf,
                                            py__init_dim_l_pdaf,
                                            py__init_dim_obs_l_pdaf,
                                            py__g2l_state_pdaf,
                                            py__l2g_state_pdaf,
                                            py__prepoststep_pdaf,
                                            py__next_observation_pdaf,
                                            int outflag
                                           ):
    """It is recommended to use local module for fewer user-supplied functions and improved efficiency.
    I.e., `pyPDAF.PDAF.localomi_assimilate_en3dvar_lestkf_nondiagR`. 
    
    
    Using 3DEnVar for DA with non-diagonal observation error covariance matrix.
    The background error covariance matrix is estimated by ensemble. The 3DEnVar only calculates the analysis of the ensemble mean.
    An LESTKF is used to generate ensemble perturbations. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.omi_put_state_en3dvar_lestkf_nondiagR`
    and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_ens_pdaf
    6. py__obs_op_lin_pdaf
    7. py__prodRinvA_pdaf
    8. py__obs_op_adj_pdaf
    9. py__cvt_adj_ens_pdaf
    10. core DA algorithm
    After the iterations: 
    11. py__cvt_ens_pdaf
    Perform LESTKF: 
    12. py__init_n_domains_p_pdaf
    13. py__init_dim_obs_pdaf
    14. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    15. py__init_dim_l_pdaf
    16. py__init_dim_obs_l_pdaf
    17. py__g2l_state_pdaf (localise mean ensemble in observation space)
    18. py__prodRinvA_l_pdaf
    19. core DA algorithm
    20. py__l2g_state_pdaf
    21. py__prepoststep_state_pdaf
    22. py__distribute_state_pdaf
    23. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], A_p : ndarray[tuple[dim_obs_p, rank], np.float64], C_p : ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], v_p : ndarray[tuple[dim_cvec_ens], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_ens** : int

            * Ensemble size

        * **dim_cvec_ens** : int

            * Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_ens** : int

            * Ensemble size

        * **dim_cv_ens_p** : int

            * PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], A_l : ndarray[tuple[dim_obs_l, rank], np.float64], C_l : ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A for local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p : ndarray[tuple[dim_p], np.float64], dim_l:int, state_l : ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l : ndarray[tuple[dim_l], np.float64], dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Init full state from local state

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.prodRinvA_pdaf = <void*>py__prodRinvA_pdaf
    c__PDAFcython.cvt_ens_pdaf = <void*>py__cvt_ens_pdaf
    c__PDAFcython.cvt_adj_ens_pdaf = <void*>py__cvt_adj_ens_pdaf
    c__PDAFcython.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    c__PDAFcython.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    c__PDAFcython.prodRinvA_l_pdaf = <void*>py__prodRinvA_l_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.g2l_state_pdaf = <void*>py__g2l_state_pdaf
    c__PDAFcython.l2g_state_pdaf = <void*>py__l2g_state_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    c__pdafomi_assimilate_en3dvar_lestkf_nondiagr (c__PDAFcython.c__collect_state_pdaf,
                                                   c__PDAFcython.c__distribute_state_pdaf,
                                                   c__PDAFcython.c__init_dim_obs_pdaf,
                                                   c__PDAFcython.c__obs_op_pdaf,
                                                   c__PDAFcython.c__prodRinvA_pdaf,
                                                   c__PDAFcython.c__cvt_ens_pdaf,
                                                   c__PDAFcython.c__cvt_adj_ens_pdaf,
                                                   c__PDAFcython.c__obs_op_lin_pdaf,
                                                   c__PDAFcython.c__obs_op_adj_pdaf,
                                                   c__PDAFcython.c__prodRinvA_l_pdaf,
                                                   c__PDAFcython.c__init_n_domains_p_pdaf,
                                                   c__PDAFcython.c__init_dim_l_pdaf,
                                                   c__PDAFcython.c__init_dim_obs_l_pdaf,
                                                   c__PDAFcython.c__g2l_state_pdaf,
                                                   c__PDAFcython.c__l2g_state_pdaf,
                                                   c__PDAFcython.c__prepoststep_pdaf,
                                                   c__PDAFcython.c__next_observation_pdaf,
                                                   &outflag
                                                  )

    return outflag

def omi_assimilate_enkf_nondiagR (py__collect_state_pdaf,
                                  py__distribute_state_pdaf,
                                  py__init_dim_obs_pdaf,
                                  py__obs_op_pdaf,
                                  py__add_obs_err_pdaf,
                                  py__init_obs_covar_pdaf,
                                  py__prepoststep_pdaf,
                                  py__next_observation_pdaf
                                 ):
    """Using stochastic EnKF (ensemble Kalman filter) for DA with non-diagonal observation error covariance matrix. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.omi_put_state_enkf_nondiagR` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf (for ensemble mean
    5. py__add_obs_err_pdaf
    6. py__init_obscovar_pdaf
    7. py__obs_op_pdaf (for each ensemble member
    8. core DA algorithm
    9. py__prepoststep_state_pdaf
    10. py__distribute_state_pdaf
    11. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__add_obs_err_pdaf : Callable[step:int, dim_obs_p:int, C_p : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]]
        Add obs error covariance R to HPH in EnKF

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Dimension of observation vector

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            * Matrix to that observation covariance R is added

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            * Matrix to that observation covariance R is added

    py__init_obs_covar_pdaf : Callable[step:int, dim_obs:int, dim_obs_p:int, covar:float, obs_p : ndarray[tuple[dim_obs_p], np.float64], isdiag:bool]
        Initialize obs. error cov. matrix R in EnKF

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs** : int

            * Global size of observation vector

        * **dim_obs_p** : int

            * Size of process-local observation vector

        * **covar** : float

            * Observation error covariance matrix

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Process-local vector of observations

        * **isdiag** : bool

            * 

        **Callback Returns**

        * **covar** : float

            * Observation error covariance matrix

        * **isdiag** : bool

            * 

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time


    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.add_obs_err_pdaf = <void*>py__add_obs_err_pdaf
    c__PDAFcython.init_obs_covar_pdaf = <void*>py__init_obs_covar_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    cdef int outflag

    c__pdafomi_assimilate_enkf_nondiagr (c__PDAFcython.c__collect_state_pdaf,
                                         c__PDAFcython.c__distribute_state_pdaf,
                                         c__PDAFcython.c__init_dim_obs_pdaf,
                                         c__PDAFcython.c__obs_op_pdaf,
                                         c__PDAFcython.c__add_obs_err_pdaf,
                                         c__PDAFcython.c__init_obs_covar_pdaf,
                                         c__PDAFcython.c__prepoststep_pdaf,
                                         c__PDAFcython.c__next_observation_pdaf,
                                         &outflag
                                        )

    return outflag

def omi_assimilate_global_nondiagR (py__collect_state_pdaf,
                                    py__distribute_state_pdaf,
                                    py__init_dim_obs_pdaf,
                                    py__obs_op_pdaf,
                                    py__prodRinvA_pdaf,
                                    py__prepoststep_pdaf,
                                    py__next_observation_pdaf
                                   ):
    """Global DA filters for DA except for 3DVars
    with non-diagonal observation error covariance matrix.

    The function is a combination of :func:`pyPDAF.PDAF.omi_put_state_global_nondiagR`
    and :func:`pyPDAF.PDAF.get_state`.

    This function should be called at each model time step.

    The user-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf (for ensemble mean)
        5. py__obs_op_pdaf (for each ensemble member)
        6. py__prodRinvA_pdaf
        7. core DA algorithm
        8. py__prepoststep_state_pdaf
        9. py__distribute_state_pdaf
        10. py__next_observation_pdaf

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], A_p : ndarray[tuple[dim_obs_p, rank], np.float64], C_p : ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time


    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.prodRinvA_pdaf = <void*>py__prodRinvA_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    cdef int outflag

    c__pdafomi_assimilate_global_nondiagr (c__PDAFcython.c__collect_state_pdaf,
                                           c__PDAFcython.c__distribute_state_pdaf,
                                           c__PDAFcython.c__init_dim_obs_pdaf,
                                           c__PDAFcython.c__obs_op_pdaf,
                                           c__PDAFcython.c__prodRinvA_pdaf,
                                           c__PDAFcython.c__prepoststep_pdaf,
                                           c__PDAFcython.c__next_observation_pdaf,
                                           &outflag
                                          )

    return outflag

def omi_assimilate_hyb3dvar_estkf_nondiagR (py__collect_state_pdaf,
                                            py__distribute_state_pdaf,
                                            py__init_dim_obs_pdaf,
                                            py__obs_op_pdaf,
                                            py__prodRinvA_pdaf,
                                            py__cvt_ens_pdaf,
                                            py__cvt_adj_ens_pdaf,
                                            py__cvt_pdaf,
                                            py__cvt_adj_pdaf,
                                            py__obs_op_lin_pdaf,
                                            py__obs_op_adj_pdaf,
                                            py__prepoststep_pdaf,
                                            py__next_observation_pdaf,
                                            int outflag
                                           ):
    """Using Hybrid 3DEnVar for DA with non-diagonal observation error covariance matrix.
    Here, the background error covariance is hybridised by a static background error covariance, and a flow-dependent background error covariance estimated from ensemble. The 3DVar generates an ensemble mean and the ensemble perturbation is generated by
    ESTKF in this implementation. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.omi_put_state_hyb3dvar_estkf_nondiagR`
    and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_pdaf
    6. py__cvt_ens_pdaf
    7. py__obs_op_lin_pdaf
    8. py__prodRinvA_pdaf
    9. py__obs_op_adj_pdaf
    10. py__cvt_adj_pdaf
    11. py__cvt_adj_ens_pdaf
    12. core 3DEnVar algorithm
    After the iterations: 
    13. py__cvt_pdaf
    14. py__cvt_ens_pdaf
    Perform ESTKF: 15. py__init_dim_obs_pdaf
    16. py__obs_op_pdaf (for ensemble mean
    17. py__obs_op_pdaf (for each ensemble member
    18. py__prodRinvA_pdaf
    19. core ESTKF algorithm
    20. py__prepoststep_state_pdaf
    21. py__distribute_state_pdaf
    22. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], A_p : ndarray[tuple[dim_obs_p, rank], np.float64], C_p : ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], v_p : ndarray[tuple[dim_cvec_ens], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply ensemble control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_ens** : int

            * Ensemble size

        * **dim_cvec_ens** : int

            * Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint ensemble control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_ens** : int

            * Ensemble size

        * **dim_cv_ens_p** : int

            * PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p : ndarray[tuple[dim_cvec], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.prodRinvA_pdaf = <void*>py__prodRinvA_pdaf
    c__PDAFcython.cvt_ens_pdaf = <void*>py__cvt_ens_pdaf
    c__PDAFcython.cvt_adj_ens_pdaf = <void*>py__cvt_adj_ens_pdaf
    c__PDAFcython.cvt_pdaf = <void*>py__cvt_pdaf
    c__PDAFcython.cvt_adj_pdaf = <void*>py__cvt_adj_pdaf
    c__PDAFcython.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    c__PDAFcython.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    c__pdafomi_assimilate_hyb3dvar_estkf_nondiagr (c__PDAFcython.c__collect_state_pdaf,
                                                   c__PDAFcython.c__distribute_state_pdaf,
                                                   c__PDAFcython.c__init_dim_obs_pdaf,
                                                   c__PDAFcython.c__obs_op_pdaf,
                                                   c__PDAFcython.c__prodRinvA_pdaf,
                                                   c__PDAFcython.c__cvt_ens_pdaf,
                                                   c__PDAFcython.c__cvt_adj_ens_pdaf,
                                                   c__PDAFcython.c__cvt_pdaf,
                                                   c__PDAFcython.c__cvt_adj_pdaf,
                                                   c__PDAFcython.c__obs_op_lin_pdaf,
                                                   c__PDAFcython.c__obs_op_adj_pdaf,
                                                   c__PDAFcython.c__prepoststep_pdaf,
                                                   c__PDAFcython.c__next_observation_pdaf,
                                                   &outflag
                                                  )

    return outflag

def omi_assimilate_hyb3dvar_lestkf_nondiagR (py__collect_state_pdaf,
                                             py__distribute_state_pdaf,
                                             py__init_dim_obs_pdaf,
                                             py__obs_op_pdaf,
                                             py__prodRinvA_pdaf,
                                             py__cvt_ens_pdaf,
                                             py__cvt_adj_ens_pdaf,
                                             py__cvt_pdaf,
                                             py__cvt_adj_pdaf,
                                             py__obs_op_lin_pdaf,
                                             py__obs_op_adj_pdaf,
                                             py__prodRinvA_l_pdaf,
                                             py__init_n_domains_p_pdaf,
                                             py__init_dim_l_pdaf,
                                             py__init_dim_obs_l_pdaf,
                                             py__g2l_state_pdaf,
                                             py__l2g_state_pdaf,
                                             py__prepoststep_pdaf,
                                             py__next_observation_pdaf,
                                             int outflag
                                            ):
    """It is recommended to use local module for fewer user-supplied functions and improved efficiency.
    I.e., `pyPDAF.PDAF.localomi_assimilate_hyb3dvar_lestkf_nondiagR`. 
    
    
    Using Hybrid 3DEnVar for DA with non-diagonal observation error covariance matrix.
    Here, the background error covariance is hybridised by a static background error covariance, and a flow-dependent background error covariance estimated from ensemble. The 3DVar generates an ensemble mean and the ensemble perturbation is generated by
    LESTKF in this implementation. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.omi_put_state_hyb3dvar_lestkf_nondiagR`
    and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_pdaf
    6. py__cvt_ens_pdaf
    7. py__obs_op_lin_pdaf
    8. py__prodRinvA_pdaf
    9. py__obs_op_adj_pdaf
    10. py__cvt_adj_pdaf
    11. py__cvt_adj_ens_pdaf
    12. core DA algorithm
    After the iterations: 
    13. py__cvt_pdaf
    14. py__cvt_ens_pdaf
    Perform LESTKF: 
    15. py__init_n_domains_p_pdaf
    16. py__init_dim_obs_pdaf
    17. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    18. py__init_dim_l_pdaf
    19. py__init_dim_obs_l_pdaf
    20. py__g2l_state_pdaf
    21. py__init_obs_l_pdaf
    22. py__prodRinvA_l_pdaf
    23. core DA algorithm
    24. py__l2g_state_pdaf
    25. py__prepoststep_state_pdaf
    26. py__distribute_state_pdaf
    27. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], A_p : ndarray[tuple[dim_obs_p, rank], np.float64], C_p : ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], v_p : ndarray[tuple[dim_cvec_ens], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_ens** : int

            * Ensemble size

        * **dim_cvec_ens** : int

            * Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_ens** : int

            * Ensemble size

        * **dim_cv_ens_p** : int

            * PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p : ndarray[tuple[dim_cvec], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], A_l : ndarray[tuple[dim_obs_l, rank], np.float64], C_l : ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A for local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p : ndarray[tuple[dim_p], np.float64], dim_l:int, state_l : ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l : ndarray[tuple[dim_l], np.float64], dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Init full state from local state

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.prodRinvA_pdaf = <void*>py__prodRinvA_pdaf
    c__PDAFcython.cvt_ens_pdaf = <void*>py__cvt_ens_pdaf
    c__PDAFcython.cvt_adj_ens_pdaf = <void*>py__cvt_adj_ens_pdaf
    c__PDAFcython.cvt_pdaf = <void*>py__cvt_pdaf
    c__PDAFcython.cvt_adj_pdaf = <void*>py__cvt_adj_pdaf
    c__PDAFcython.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    c__PDAFcython.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    c__PDAFcython.prodRinvA_l_pdaf = <void*>py__prodRinvA_l_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.g2l_state_pdaf = <void*>py__g2l_state_pdaf
    c__PDAFcython.l2g_state_pdaf = <void*>py__l2g_state_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    c__pdafomi_assimilate_hyb3dvar_lestkf_nondiagr (c__PDAFcython.c__collect_state_pdaf,
                                                    c__PDAFcython.c__distribute_state_pdaf,
                                                    c__PDAFcython.c__init_dim_obs_pdaf,
                                                    c__PDAFcython.c__obs_op_pdaf,
                                                    c__PDAFcython.c__prodRinvA_pdaf,
                                                    c__PDAFcython.c__cvt_ens_pdaf,
                                                    c__PDAFcython.c__cvt_adj_ens_pdaf,
                                                    c__PDAFcython.c__cvt_pdaf,
                                                    c__PDAFcython.c__cvt_adj_pdaf,
                                                    c__PDAFcython.c__obs_op_lin_pdaf,
                                                    c__PDAFcython.c__obs_op_adj_pdaf,
                                                    c__PDAFcython.c__prodRinvA_l_pdaf,
                                                    c__PDAFcython.c__init_n_domains_p_pdaf,
                                                    c__PDAFcython.c__init_dim_l_pdaf,
                                                    c__PDAFcython.c__init_dim_obs_l_pdaf,
                                                    c__PDAFcython.c__g2l_state_pdaf,
                                                    c__PDAFcython.c__l2g_state_pdaf,
                                                    c__PDAFcython.c__prepoststep_pdaf,
                                                    c__PDAFcython.c__next_observation_pdaf,
                                                    &outflag
                                                   )

    return outflag

def omi_assimilate_lenkf_nondiagR (py__collect_state_pdaf,
                                   py__distribute_state_pdaf,
                                   py__init_dim_obs_pdaf,
                                   py__obs_op_pdaf,
                                   py__prepoststep_pdaf,
                                   py__localize_covar_pdaf,
                                   py__add_obs_err_pdaf,
                                   py__init_obs_covar_pdaf,
                                   py__next_observation_pdaf
                                  ):
    """Using stochastic EnKF (ensemble Kalman filter) with covariance localisation for DA with non-diagonal observation error covariance matrix. This is the only scheme for covariance localisation in PDAF. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.omi_put_state_lenkf_nondiagR` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf (for each ensemble member
    5. py__localize_pdaf
    6. py__add_obs_err_pdaf
    7. py__init_obscovar_pdaf
    8. py__obs_op_pdaf (repeated to reduce storage
    9. core DA algorith
    10. py__prepoststep_state_pdaf
    11. py__distribute_state_pdaf
    12. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__localize_covar_pdaf : Callable[dim_p:int, dim_obs:int, hp_p : ndarray[tuple[dim_obs, dim_p], np.float64], hph : ndarray[tuple[dim_obs, dim_obs], np.float64]]
        Apply localization to HP and HPH^T

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **dim_obs** : int

            * number of observations

        * **hp_p** : ndarray[tuple[dim_obs, dim_p], np.float64]

            * pe local part of matrix hp

        * **hph** : ndarray[tuple[dim_obs, dim_obs], np.float64]

            * matrix hph

        **Callback Returns**

        * **hp_p** : ndarray[tuple[dim_obs, dim_p], np.float64]

            * pe local part of matrix hp

        * **hph** : ndarray[tuple[dim_obs, dim_obs], np.float64]

            * matrix hph

    py__add_obs_err_pdaf : Callable[step:int, dim_obs_p:int, C_p : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]]
        Add obs error covariance R to HPH in EnKF

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Dimension of observation vector

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            * Matrix to that observation covariance R is added

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            * Matrix to that observation covariance R is added

    py__init_obs_covar_pdaf : Callable[step:int, dim_obs:int, dim_obs_p:int, covar:float, obs_p : ndarray[tuple[dim_obs_p], np.float64], isdiag:bool]
        Initialize obs. error cov. matrix R in EnKF

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs** : int

            * Global size of observation vector

        * **dim_obs_p** : int

            * Size of process-local observation vector

        * **covar** : float

            * Observation error covariance matrix

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Process-local vector of observations

        * **isdiag** : bool

            * 

        **Callback Returns**

        * **covar** : float

            * Observation error covariance matrix

        * **isdiag** : bool

            * 

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time


    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.localize_covar_pdaf = <void*>py__localize_covar_pdaf
    c__PDAFcython.add_obs_err_pdaf = <void*>py__add_obs_err_pdaf
    c__PDAFcython.init_obs_covar_pdaf = <void*>py__init_obs_covar_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    cdef int outflag

    c__pdafomi_assimilate_lenkf_nondiagr (c__PDAFcython.c__collect_state_pdaf,
                                          c__PDAFcython.c__distribute_state_pdaf,
                                          c__PDAFcython.c__init_dim_obs_pdaf,
                                          c__PDAFcython.c__obs_op_pdaf,
                                          c__PDAFcython.c__prepoststep_pdaf,
                                          c__PDAFcython.c__localize_covar_pdaf,
                                          c__PDAFcython.c__add_obs_err_pdaf,
                                          c__PDAFcython.c__init_obs_covar_pdaf,
                                          c__PDAFcython.c__next_observation_pdaf,
                                          &outflag
                                         )

    return outflag

def omi_assimilate_lknetf_nondiagR (py__collect_state_pdaf,
                                    py__distribute_state_pdaf,
                                    py__init_dim_obs_pdaf,
                                    py__obs_op_pdaf,
                                    py__prepoststep_pdaf,
                                    py__init_n_domains_p_pdaf,
                                    py__init_dim_l_pdaf,
                                    py__init_dim_obs_l_pdaf,
                                    py__prodRinvA_l_pdaf,
                                    py__prodRinvA_hyb_l_pdaf,
                                    py__likelihood_l_pdaf,
                                    py__likelihood_hyb_l_pdaf,
                                    py__g2l_state_pdaf,
                                    py__l2g_state_pdaf,
                                    py__next_observation_pdaf
                                   ):
    """It is recommended to use local module for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_assimilate_lknetf_nondiagR`. 
    Using LKNETF for DA with non-diagonal observation error covariance matrix. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.omi_put_state_lknetf_nondiagR` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    6. py__init_dim_l_pdaf
    7. py__init_dim_obs_l_pdaf
    8. py__g2l_state_pdaf
    9. py__prodRinvA_pdaf
    10. py__likelihood_l_pdaf
    11. core DA algorithm
    12. py__l2g_state_pdaf
    13. py__obs_op_pdaf (only called with `HKN` and `HNK` options called for each ensemble member
    14. py__likelihood_hyb_l_pda
    15. py__prodRinvA_hyb_l_pdaf
    16. py__prepoststep_state_pdaf
    17. py__distribute_state_pdaf
    18. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], A_l : ndarray[tuple[dim_obs_l, rank], np.float64], C_l : ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

    py__prodRinvA_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, dim_ens:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], gamma:float, A_l : ndarray[tuple[dim_obs_l, dim_ens], np.float64], C_l : ndarray[tuple[dim_obs_l, dim_ens], np.float64]]
        Provide product R^-1 A on local analysis domain with hybrid weight

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **dim_ens** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **gamma** : float

            * Hybrid weight provided by PDAF

        * **A_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            * Output matrix

    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], resid_l : ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            * nput vector holding the local residual

        * **likely_l** : float

            * Output value of the local likelihood

        **Callback Returns**

        * **likely_l** : float

            * Output value of the local likelihood

    py__likelihood_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], resid_l : ndarray[tuple[dim_obs_l], np.float64], gamma:float, likely_l:float]
        Compute likelihood with hybrid weight

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Input vector holding the local residual

        * **gamma** : float

            * Hybrid weight provided by PDAF

        * **likely_l** : float

            * Output value of the local likelihood

        **Callback Returns**

        * **likely_l** : float

            * Output value of the local likelihood

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p : ndarray[tuple[dim_p], np.float64], dim_l:int, state_l : ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l : ndarray[tuple[dim_l], np.float64], dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time


    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.prodRinvA_l_pdaf = <void*>py__prodRinvA_l_pdaf
    c__PDAFcython.prodRinvA_hyb_l_pdaf = <void*>py__prodRinvA_hyb_l_pdaf
    c__PDAFcython.likelihood_l_pdaf = <void*>py__likelihood_l_pdaf
    c__PDAFcython.likelihood_hyb_l_pdaf = <void*>py__likelihood_hyb_l_pdaf
    c__PDAFcython.g2l_state_pdaf = <void*>py__g2l_state_pdaf
    c__PDAFcython.l2g_state_pdaf = <void*>py__l2g_state_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    cdef int outflag

    c__pdafomi_assimilate_lknetf_nondiagr (c__PDAFcython.c__collect_state_pdaf,
                                           c__PDAFcython.c__distribute_state_pdaf,
                                           c__PDAFcython.c__init_dim_obs_pdaf,
                                           c__PDAFcython.c__obs_op_pdaf,
                                           c__PDAFcython.c__prepoststep_pdaf,
                                           c__PDAFcython.c__init_n_domains_p_pdaf,
                                           c__PDAFcython.c__init_dim_l_pdaf,
                                           c__PDAFcython.c__init_dim_obs_l_pdaf,
                                           c__PDAFcython.c__prodRinvA_l_pdaf,
                                           c__PDAFcython.c__prodRinvA_hyb_l_pdaf,
                                           c__PDAFcython.c__likelihood_l_pdaf,
                                           c__PDAFcython.c__likelihood_hyb_l_pdaf,
                                           c__PDAFcython.c__g2l_state_pdaf,
                                           c__PDAFcython.c__l2g_state_pdaf,
                                           c__PDAFcython.c__next_observation_pdaf,
                                           &outflag
                                          )

    return outflag

def omi_assimilate_lnetf_nondiagR (py__collect_state_pdaf,
                                   py__distribute_state_pdaf,
                                   py__init_dim_obs_pdaf,
                                   py__obs_op_pdaf,
                                   py__prepoststep_pdaf,
                                   py__init_n_domains_p_pdaf,
                                   py__init_dim_l_pdaf,
                                   py__init_dim_obs_l_pdaf,
                                   py__likelihood_l_pdaf,
                                   py__g2l_state_pdaf,
                                   py__l2g_state_pdaf,
                                   py__next_observation_pdaf
                                  ):
    """It is recommended to use local module for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_assimilate_lnetf_nondiagR`. 
    Using LNETF for DA with non-diagonal observation error covariance matrix. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.omi_put_state_lnetf_nondiagR` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    6. py__init_dim_l_pdaf
    7. py__init_dim_obs_l_pdaf
    8. py__g2l_state_pdaf
    9. py__likelihood_l_pdaf
    10. core DA algorithm
    11. py__l2g_state_pdaf
    12. py__prepoststep_state_pdaf
    13. py__distribute_state_pdaf
    14. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], resid_l : ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            * nput vector holding the local residual

        * **likely_l** : float

            * Output value of the local likelihood

        **Callback Returns**

        * **likely_l** : float

            * Output value of the local likelihood

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p : ndarray[tuple[dim_p], np.float64], dim_l:int, state_l : ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l : ndarray[tuple[dim_l], np.float64], dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time


    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.likelihood_l_pdaf = <void*>py__likelihood_l_pdaf
    c__PDAFcython.g2l_state_pdaf = <void*>py__g2l_state_pdaf
    c__PDAFcython.l2g_state_pdaf = <void*>py__l2g_state_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    cdef int outflag

    c__pdafomi_assimilate_lnetf_nondiagr (c__PDAFcython.c__collect_state_pdaf,
                                          c__PDAFcython.c__distribute_state_pdaf,
                                          c__PDAFcython.c__init_dim_obs_pdaf,
                                          c__PDAFcython.c__obs_op_pdaf,
                                          c__PDAFcython.c__prepoststep_pdaf,
                                          c__PDAFcython.c__init_n_domains_p_pdaf,
                                          c__PDAFcython.c__init_dim_l_pdaf,
                                          c__PDAFcython.c__init_dim_obs_l_pdaf,
                                          c__PDAFcython.c__likelihood_l_pdaf,
                                          c__PDAFcython.c__g2l_state_pdaf,
                                          c__PDAFcython.c__l2g_state_pdaf,
                                          c__PDAFcython.c__next_observation_pdaf,
                                          &outflag
                                         )

    return outflag

def omi_assimilate_local_nondiagR (py__collect_state_pdaf,
                                   py__distribute_state_pdaf,
                                   py__init_dim_obs_pdaf,
                                   py__obs_op_pdaf,
                                   py__prepoststep_pdaf,
                                   py__init_n_domains_p_pdaf,
                                   py__init_dim_l_pdaf,
                                   py__init_dim_obs_l_pdaf,
                                   py__prodRinvA_l_pdaf,
                                   py__g2l_state_pdaf,
                                   py__l2g_state_pdaf,
                                   py__next_observation_pdaf
                                  ):
    """It is recommended to use local module for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_assimilate_nondiagR`. 
    Using domain localised filters for DA with non-diagonal observation error covariance matrix. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.omi_put_state_local_nondiagR` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    6. py__init_dim_l_pdaf
    7. py__init_dim_obs_l_pdaf
    8. py__g2l_state_pdaf
    9. py__init_obs_l_pdaf
    10. py__prodRinvA_l_pdaf
    11. core DA algorithm
    12. py__l2g_state_pdaf
    13. py__prepoststep_state_pdaf
    14. py__distribute_state_pdaf
    15. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], A_l : ndarray[tuple[dim_obs_l, rank], np.float64], C_l : ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p : ndarray[tuple[dim_p], np.float64], dim_l:int, state_l : ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l : ndarray[tuple[dim_l], np.float64], dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time


    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.prodRinvA_l_pdaf = <void*>py__prodRinvA_l_pdaf
    c__PDAFcython.g2l_state_pdaf = <void*>py__g2l_state_pdaf
    c__PDAFcython.l2g_state_pdaf = <void*>py__l2g_state_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    cdef int outflag

    c__pdafomi_assimilate_local_nondiagr (c__PDAFcython.c__collect_state_pdaf,
                                          c__PDAFcython.c__distribute_state_pdaf,
                                          c__PDAFcython.c__init_dim_obs_pdaf,
                                          c__PDAFcython.c__obs_op_pdaf,
                                          c__PDAFcython.c__prepoststep_pdaf,
                                          c__PDAFcython.c__init_n_domains_p_pdaf,
                                          c__PDAFcython.c__init_dim_l_pdaf,
                                          c__PDAFcython.c__init_dim_obs_l_pdaf,
                                          c__PDAFcython.c__prodRinvA_l_pdaf,
                                          c__PDAFcython.c__g2l_state_pdaf,
                                          c__PDAFcython.c__l2g_state_pdaf,
                                          c__PDAFcython.c__next_observation_pdaf,
                                          &outflag
                                         )

    return outflag

def omi_assimilate_nonlin_nondiagR (py__collect_state_pdaf,
                                    py__distribute_state_pdaf,
                                    py__init_dim_obs_pdaf,
                                    py__obs_op_pdaf,
                                    py__likelihood_pdaf,
                                    py__prepoststep_pdaf,
                                    py__next_observation_pdaf
                                   ):
    """Using nonlinear filters (particle filter, NETF) for DA except for 3DVars with non-diagonal observation error covariance matrix.
    The function is a combination of `pyPDAF.PDAF.put_state_nonlin_nondiagR` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function This function should be called at each model time step. 
    
    in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf (for ensemble mean
    5. py__obs_op_pdaf (for each ensemble member
    6. py__likelihood_pdaf
    7. core DA algorithm
    8. py__prepoststep_state_pdaf
    9. py__distribute_state_pdaf
    10. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__likelihood_pdaf : Callable[step:int, dim_obs_p:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], resid : ndarray[tuple[dim_obs_p], np.float64], likely:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **resid** : ndarray[tuple[dim_obs_p], np.float64]

            * Input vector holding the residual

        * **likely** : float

            * Output value of the likelihood

        **Callback Returns**

        * **likely** : float

            * Output value of the likelihood

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time


    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.likelihood_pdaf = <void*>py__likelihood_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    cdef int outflag

    c__pdafomi_assimilate_nonlin_nondiagr (c__PDAFcython.c__collect_state_pdaf,
                                           c__PDAFcython.c__distribute_state_pdaf,
                                           c__PDAFcython.c__init_dim_obs_pdaf,
                                           c__PDAFcython.c__obs_op_pdaf,
                                           c__PDAFcython.c__likelihood_pdaf,
                                           c__PDAFcython.c__prepoststep_pdaf,
                                           c__PDAFcython.c__next_observation_pdaf,
                                           &outflag
                                          )

    return outflag

def omi_put_state_3dvar_nondiagR (py__collect_state_pdaf,
                                  py__init_dim_obs_pdaf,
                                  py__obs_op_pdaf,
                                  py__prodRinvA_pdaf,
                                  py__cvt_pdaf,
                                  py__cvt_adj_pdaf,
                                  py__obs_op_lin_pdaf,
                                  py__obs_op_adj_pdaf,
                                  py__prepoststep_pdaf,
                                  int outflag
                                 ):
    """Using 3DVar for DA with non-diagonal observation error covariance matrix
    without post-processing and analysis distribution to forecsat without OMI. This is a deterministic filtering scheme. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_pdaf
    6. py__obs_op_lin_pdaf
    7. py__prodRinvA_pdaf
    8. py__obs_op_adj_pdaf
    9. py__cvt_adj_pdaf
    10. core DA algorithm
    After the iterations: 
    11. py__cvt_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], A_p : ndarray[tuple[dim_obs_p, rank], np.float64], C_p : ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p : ndarray[tuple[dim_cvec], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.prodRinvA_pdaf = <void*>py__prodRinvA_pdaf
    c__PDAFcython.cvt_pdaf = <void*>py__cvt_pdaf
    c__PDAFcython.cvt_adj_pdaf = <void*>py__cvt_adj_pdaf
    c__PDAFcython.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    c__PDAFcython.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf

    c__pdafomi_put_state_3dvar_nondiagr (c__PDAFcython.c__collect_state_pdaf,
                                         c__PDAFcython.c__init_dim_obs_pdaf,
                                         c__PDAFcython.c__obs_op_pdaf,
                                         c__PDAFcython.c__prodRinvA_pdaf,
                                         c__PDAFcython.c__cvt_pdaf,
                                         c__PDAFcython.c__cvt_adj_pdaf,
                                         c__PDAFcython.c__obs_op_lin_pdaf,
                                         c__PDAFcython.c__obs_op_adj_pdaf,
                                         c__PDAFcython.c__prepoststep_pdaf,
                                         &outflag
                                        )

    return outflag

def omi_put_state_en3dvar_estkf_nondiagR (py__collect_state_pdaf,
                                          py__init_dim_obs_pdaf,
                                          py__obs_op_pdaf,
                                          py__prodRinvA_pdaf,
                                          py__cvt_ens_pdaf,
                                          py__cvt_adj_ens_pdaf,
                                          py__obs_op_lin_pdaf,
                                          py__obs_op_adj_pdaf,
                                          py__prepoststep_pdaf,
                                          int outflag
                                         ):
    """Using 3DEnVar for DA with non-diagonal observation error covariance matrix
    without post-processing and analysis distribution to forecsat without OMI. The background error covariance matrix is estimated by ensemble. The 3DEnVar only calculates the analysis of the ensemble mean.
    An ESTKF is used to generate ensemble perturbations. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_ens_pdaf
    6. py__obs_op_lin_pdaf
    7. py__prodRinvA_pdaf
    8. py__obs_op_adj_pdaf
    9. py__cvt_adj_ens_pdaf
    10. core 3DEnVar algorithm
    After the iterations: 
    11. py__cvt_ens_pdaf
    Perform ESTKF: 12. py__init_dim_obs_pdaf
    13. py__obs_op_pdaf (for ensemble mean
    14. py__obs_op_pdaf (for each ensemble member
    15. py__prodRinvA_pdaf
    16. core ESTKF algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], A_p : ndarray[tuple[dim_obs_p, rank], np.float64], C_p : ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], v_p : ndarray[tuple[dim_cvec_ens], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_ens** : int

            * Ensemble size

        * **dim_cvec_ens** : int

            * Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_ens** : int

            * Ensemble size

        * **dim_cv_ens_p** : int

            * PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.prodRinvA_pdaf = <void*>py__prodRinvA_pdaf
    c__PDAFcython.cvt_ens_pdaf = <void*>py__cvt_ens_pdaf
    c__PDAFcython.cvt_adj_ens_pdaf = <void*>py__cvt_adj_ens_pdaf
    c__PDAFcython.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    c__PDAFcython.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf

    c__pdafomi_put_state_en3dvar_estkf_nondiagr (c__PDAFcython.c__collect_state_pdaf,
                                                 c__PDAFcython.c__init_dim_obs_pdaf,
                                                 c__PDAFcython.c__obs_op_pdaf,
                                                 c__PDAFcython.c__prodRinvA_pdaf,
                                                 c__PDAFcython.c__cvt_ens_pdaf,
                                                 c__PDAFcython.c__cvt_adj_ens_pdaf,
                                                 c__PDAFcython.c__obs_op_lin_pdaf,
                                                 c__PDAFcython.c__obs_op_adj_pdaf,
                                                 c__PDAFcython.c__prepoststep_pdaf,
                                                 &outflag
                                                )

    return outflag

def omi_put_state_en3dvar_lestkf_nondiagR (py__collect_state_pdaf,
                                           py__init_dim_obs_pdaf,
                                           py__obs_op_pdaf,
                                           py__prodRinvA_pdaf,
                                           py__cvt_ens_pdaf,
                                           py__cvt_adj_ens_pdaf,
                                           py__obs_op_lin_pdaf,
                                           py__obs_op_adj_pdaf,
                                           py__prodRinvA_l_pdaf,
                                           py__init_n_domains_p_pdaf,
                                           py__init_dim_l_pdaf,
                                           py__init_dim_obs_l_pdaf,
                                           py__g2l_state_pdaf,
                                           py__l2g_state_pdaf,
                                           py__prepoststep_pdaf,
                                           int outflag
                                          ):
    """It is recommended to use local module for fewer user-supplied functions and improved efficiency.
    I.e., `pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf_nondiagR`. 
    
    
    Using 3DEnVar for DA with non-diagonal observation error covariance matrix
    without post-processing and analysis distribution to forecsat without OMI. The background error covariance matrix is estimated by ensemble. The 3DEnVar only calculates the analysis of the ensemble mean.
    An LESTKF is used to generate ensemble perturbations. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_ens_pdaf
    6. py__obs_op_lin_pdaf
    7. py__prodRinvA_pdaf
    8. py__obs_op_adj_pdaf
    9. py__cvt_adj_ens_pdaf
    10. core DA algorithm
    After the iterations: 
    11. py__cvt_ens_pdaf
    Perform LESTKF: 
    12. py__init_n_domains_p_pdaf
    13. py__init_dim_obs_pdaf
    14. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    15. py__init_dim_l_pdaf
    16. py__init_dim_obs_l_pdaf
    17. py__g2l_state_pdaf (localise mean ensemble in observation space)
    18. py__prodRinvA_l_pdaf
    19. core DA algorithm
    20. py__l2g_state_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], A_p : ndarray[tuple[dim_obs_p, rank], np.float64], C_p : ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], v_p : ndarray[tuple[dim_cvec_ens], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_ens** : int

            * Ensemble size

        * **dim_cvec_ens** : int

            * Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_ens** : int

            * Ensemble size

        * **dim_cv_ens_p** : int

            * PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], A_l : ndarray[tuple[dim_obs_l, rank], np.float64], C_l : ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A for local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p : ndarray[tuple[dim_p], np.float64], dim_l:int, state_l : ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l : ndarray[tuple[dim_l], np.float64], dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Init full state from local state

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.prodRinvA_pdaf = <void*>py__prodRinvA_pdaf
    c__PDAFcython.cvt_ens_pdaf = <void*>py__cvt_ens_pdaf
    c__PDAFcython.cvt_adj_ens_pdaf = <void*>py__cvt_adj_ens_pdaf
    c__PDAFcython.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    c__PDAFcython.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    c__PDAFcython.prodRinvA_l_pdaf = <void*>py__prodRinvA_l_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.g2l_state_pdaf = <void*>py__g2l_state_pdaf
    c__PDAFcython.l2g_state_pdaf = <void*>py__l2g_state_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf

    c__pdafomi_put_state_en3dvar_lestkf_nondiagr (c__PDAFcython.c__collect_state_pdaf,
                                                  c__PDAFcython.c__init_dim_obs_pdaf,
                                                  c__PDAFcython.c__obs_op_pdaf,
                                                  c__PDAFcython.c__prodRinvA_pdaf,
                                                  c__PDAFcython.c__cvt_ens_pdaf,
                                                  c__PDAFcython.c__cvt_adj_ens_pdaf,
                                                  c__PDAFcython.c__obs_op_lin_pdaf,
                                                  c__PDAFcython.c__obs_op_adj_pdaf,
                                                  c__PDAFcython.c__prodRinvA_l_pdaf,
                                                  c__PDAFcython.c__init_n_domains_p_pdaf,
                                                  c__PDAFcython.c__init_dim_l_pdaf,
                                                  c__PDAFcython.c__init_dim_obs_l_pdaf,
                                                  c__PDAFcython.c__g2l_state_pdaf,
                                                  c__PDAFcython.c__l2g_state_pdaf,
                                                  c__PDAFcython.c__prepoststep_pdaf,
                                                  &outflag
                                                 )

    return outflag

def omi_put_state_enkf_nondiagR (py__collect_state_pdaf,
                                 py__init_dim_obs_pdaf,
                                 py__obs_op_pdaf,
                                 py__add_obs_err_pdaf,
                                 py__init_obs_covar_pdaf,
                                 py__prepoststep_pdaf
                                ):
    """Using stochastic EnKF (ensemble Kalman filter) for DA with non-diagonal observation error covariance matrix. without post-processing and analysis distribution to forecsat without OMI. This function should be called at each model time step. 
    
    This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf (for ensemble mean
    5. py__add_obs_err_pdaf
    6. py__init_obscovar_pdaf
    7. py__obs_op_pdaf (for each ensemble member
    8. core DA algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__add_obs_err_pdaf : Callable[step:int, dim_obs_p:int, C_p : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]]
        Add obs error covariance R to HPH in EnKF

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Dimension of observation vector

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            * Matrix to that observation covariance R is added

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            * Matrix to that observation covariance R is added

    py__init_obs_covar_pdaf : Callable[step:int, dim_obs:int, dim_obs_p:int, covar:float, obs_p : ndarray[tuple[dim_obs_p], np.float64], isdiag:bool]
        Initialize obs. error cov. matrix R in EnKF

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs** : int

            * Global size of observation vector

        * **dim_obs_p** : int

            * Size of process-local observation vector

        * **covar** : float

            * Observation error covariance matrix

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Process-local vector of observations

        * **isdiag** : bool

            * 

        **Callback Returns**

        * **covar** : float

            * Observation error covariance matrix

        * **isdiag** : bool

            * 

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble


    Returns
    -------
    outflag : int
        
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.add_obs_err_pdaf = <void*>py__add_obs_err_pdaf
    c__PDAFcython.init_obs_covar_pdaf = <void*>py__init_obs_covar_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf

    cdef int outflag

    c__pdafomi_put_state_enkf_nondiagr (c__PDAFcython.c__collect_state_pdaf,
                                        c__PDAFcython.c__init_dim_obs_pdaf,
                                        c__PDAFcython.c__obs_op_pdaf,
                                        c__PDAFcython.c__add_obs_err_pdaf,
                                        c__PDAFcython.c__init_obs_covar_pdaf,
                                        c__PDAFcython.c__prepoststep_pdaf,
                                        &outflag
                                       )

    return outflag

def omi_put_state_global_nondiagR (py__collect_state_pdaf,
                                   py__init_dim_obs_pdaf,
                                   py__obs_op_pdaf,
                                   py__prodRinvA_pdaf,
                                   py__prepoststep_pdaf
                                  ):
    """Global filters for DA except for 3DVars
    with non-diagonal observation error covariance matrix
    without post-processing and analysis distribution to forecsat.

    This function is usually used in 'flexible' parallelisation
    where the ensemble size is larger than the available number of processes.

    This function should be called at each model time step.

    A :func:`pyPDAF.PDAF.get_state` function is typically
    used afterwards to post-process and distribute the ensemble
    to the model after this function.

    This function should be called at each model time step.

    The function executes the user-supplied function
    in the following sequence:

    1. py__collect_state_pdaf

    2. py__prepoststep_state_pdaf

    3. py__init_dim_obs_pdaf

    4. py__obs_op_pdaf (for ensemble mean)

    5. py__obs_op_pdaf (for each ensemble member)

    6. py__prodRinvA_pdaf

    7. core DA algorithm

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], A_p : ndarray[tuple[dim_obs_p, rank], np.float64], C_p : ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble


    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.prodRinvA_pdaf = <void*>py__prodRinvA_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf

    cdef int outflag

    c__pdafomi_put_state_global_nondiagr (c__PDAFcython.c__collect_state_pdaf,
                                          c__PDAFcython.c__init_dim_obs_pdaf,
                                          c__PDAFcython.c__obs_op_pdaf,
                                          c__PDAFcython.c__prodRinvA_pdaf,
                                          c__PDAFcython.c__prepoststep_pdaf,
                                          &outflag
                                         )

    return outflag

def omi_put_state_hyb3dvar_estkf_nondiagR (py__collect_state_pdaf,
                                           py__init_dim_obs_pdaf,
                                           py__obs_op_pdaf,
                                           py__prodRinvA_pdaf,
                                           py__cvt_ens_pdaf,
                                           py__cvt_adj_ens_pdaf,
                                           py__cvt_pdaf,
                                           py__cvt_adj_pdaf,
                                           py__obs_op_lin_pdaf,
                                           py__obs_op_adj_pdaf,
                                           py__prepoststep_pdaf,
                                           int outflag
                                          ):
    """Using Hybrid 3DEnVar for DA with non-diagonal observation error covariance matrix
    without post-processing and analysis distribution to forecsat without OMI. Here, the background error covariance is hybridised by a static background error covariance, and a flow-dependent background error covariance estimated from ensemble. The 3DVar generates an ensemble mean and the ensemble perturbation is generated by
    ESTKF in this implementation. This function should be called at each model time step. 
    
    This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_pdaf
    6. py__cvt_ens_pdaf
    7. py__obs_op_lin_pdaf
    8. py__prodRinvA_pdaf
    9. py__obs_op_adj_pdaf
    10. py__cvt_adj_pdaf
    11. py__cvt_adj_ens_pdaf
    12. core 3DEnVar algorithm
    After the iterations: 
    13. py__cvt_pdaf
    14. py__cvt_ens_pdaf
    Perform ESTKF: 15. py__init_dim_obs_pdaf
    16. py__obs_op_pdaf (for ensemble mean
    17. py__obs_op_pdaf (for each ensemble member
    18. py__prodRinvA_pdaf
    19. core ESTKF algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], A_p : ndarray[tuple[dim_obs_p, rank], np.float64], C_p : ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], v_p : ndarray[tuple[dim_cvec_ens], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply ensemble control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_ens** : int

            * Ensemble size

        * **dim_cvec_ens** : int

            * Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint ensemble control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_ens** : int

            * Ensemble size

        * **dim_cv_ens_p** : int

            * PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p : ndarray[tuple[dim_cvec], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.prodRinvA_pdaf = <void*>py__prodRinvA_pdaf
    c__PDAFcython.cvt_ens_pdaf = <void*>py__cvt_ens_pdaf
    c__PDAFcython.cvt_adj_ens_pdaf = <void*>py__cvt_adj_ens_pdaf
    c__PDAFcython.cvt_pdaf = <void*>py__cvt_pdaf
    c__PDAFcython.cvt_adj_pdaf = <void*>py__cvt_adj_pdaf
    c__PDAFcython.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    c__PDAFcython.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf

    c__pdafomi_put_state_hyb3dvar_estkf_nondiagr (c__PDAFcython.c__collect_state_pdaf,
                                                  c__PDAFcython.c__init_dim_obs_pdaf,
                                                  c__PDAFcython.c__obs_op_pdaf,
                                                  c__PDAFcython.c__prodRinvA_pdaf,
                                                  c__PDAFcython.c__cvt_ens_pdaf,
                                                  c__PDAFcython.c__cvt_adj_ens_pdaf,
                                                  c__PDAFcython.c__cvt_pdaf,
                                                  c__PDAFcython.c__cvt_adj_pdaf,
                                                  c__PDAFcython.c__obs_op_lin_pdaf,
                                                  c__PDAFcython.c__obs_op_adj_pdaf,
                                                  c__PDAFcython.c__prepoststep_pdaf,
                                                  &outflag
                                                 )

    return outflag

def omi_put_state_hyb3dvar_lestkf_nondiagR (py__collect_state_pdaf,
                                            py__init_dim_obs_pdaf,
                                            py__obs_op_pdaf,
                                            py__prodRinvA_pdaf,
                                            py__cvt_ens_pdaf,
                                            py__cvt_adj_ens_pdaf,
                                            py__cvt_pdaf,
                                            py__cvt_adj_pdaf,
                                            py__obs_op_lin_pdaf,
                                            py__obs_op_adj_pdaf,
                                            py__prodRinvA_l_pdaf,
                                            py__init_n_domains_p_pdaf,
                                            py__init_dim_l_pdaf,
                                            py__init_dim_obs_l_pdaf,
                                            py__g2l_state_pdaf,
                                            py__l2g_state_pdaf,
                                            py__prepoststep_pdaf,
                                            int outflag
                                           ):
    """It is recommended to use local module for fewer user-supplied functions and improved efficiency.
    I.e., `pyPDAF.PDAF.localomi_assimilate_hyb3dvar_lestkf_nondiagR`. 
    
    
    Using Hybrid 3DEnVar for DA with non-diagonal observation error covariance matrix
    without post-processing and analysis distribution to forecsat without OMI. Here, the background error covariance is hybridised by a static background error covariance, and a flow-dependent background error covariance estimated from ensemble. The 3DVar generates an ensemble mean and the ensemble perturbation is generated by
    LESTKF in this implementation. This function should be called at each model time step. 
    
    This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_pdaf
    6. py__cvt_ens_pdaf
    7. py__obs_op_lin_pdaf
    8. py__prodRinvA_pdaf
    9. py__obs_op_adj_pdaf
    10. py__cvt_adj_pdaf
    11. py__cvt_adj_ens_pdaf
    12. core DA algorithm
    After the iterations: 
    13. py__cvt_pdaf
    14. py__cvt_ens_pdaf
    Perform LESTKF: 
    15. py__init_n_domains_p_pdaf
    16. py__init_dim_obs_pdaf
    17. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    18. py__init_dim_l_pdaf
    19. py__init_dim_obs_l_pdaf
    20. py__g2l_state_pdaf
    21. py__init_obs_l_pdaf
    22. py__prodRinvA_l_pdaf
    23. core DA algorithm
    24. py__l2g_state_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], A_p : ndarray[tuple[dim_obs_p, rank], np.float64], C_p : ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], v_p : ndarray[tuple[dim_cvec_ens], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_ens** : int

            * Ensemble size

        * **dim_cvec_ens** : int

            * Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_ens** : int

            * Ensemble size

        * **dim_cv_ens_p** : int

            * PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p : ndarray[tuple[dim_cvec], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], A_l : ndarray[tuple[dim_obs_l, rank], np.float64], C_l : ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A for analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p : ndarray[tuple[dim_p], np.float64], dim_l:int, state_l : ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l : ndarray[tuple[dim_l], np.float64], dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Init full state from local state

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.prodRinvA_pdaf = <void*>py__prodRinvA_pdaf
    c__PDAFcython.cvt_ens_pdaf = <void*>py__cvt_ens_pdaf
    c__PDAFcython.cvt_adj_ens_pdaf = <void*>py__cvt_adj_ens_pdaf
    c__PDAFcython.cvt_pdaf = <void*>py__cvt_pdaf
    c__PDAFcython.cvt_adj_pdaf = <void*>py__cvt_adj_pdaf
    c__PDAFcython.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    c__PDAFcython.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    c__PDAFcython.prodRinvA_l_pdaf = <void*>py__prodRinvA_l_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.g2l_state_pdaf = <void*>py__g2l_state_pdaf
    c__PDAFcython.l2g_state_pdaf = <void*>py__l2g_state_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf

    c__pdafomi_put_state_hyb3dvar_lestkf_nondiagr (c__PDAFcython.c__collect_state_pdaf,
                                                   c__PDAFcython.c__init_dim_obs_pdaf,
                                                   c__PDAFcython.c__obs_op_pdaf,
                                                   c__PDAFcython.c__prodRinvA_pdaf,
                                                   c__PDAFcython.c__cvt_ens_pdaf,
                                                   c__PDAFcython.c__cvt_adj_ens_pdaf,
                                                   c__PDAFcython.c__cvt_pdaf,
                                                   c__PDAFcython.c__cvt_adj_pdaf,
                                                   c__PDAFcython.c__obs_op_lin_pdaf,
                                                   c__PDAFcython.c__obs_op_adj_pdaf,
                                                   c__PDAFcython.c__prodRinvA_l_pdaf,
                                                   c__PDAFcython.c__init_n_domains_p_pdaf,
                                                   c__PDAFcython.c__init_dim_l_pdaf,
                                                   c__PDAFcython.c__init_dim_obs_l_pdaf,
                                                   c__PDAFcython.c__g2l_state_pdaf,
                                                   c__PDAFcython.c__l2g_state_pdaf,
                                                   c__PDAFcython.c__prepoststep_pdaf,
                                                   &outflag
                                                  )

    return outflag

def omi_put_state_lenkf_nondiagR (py__collect_state_pdaf,
                                  py__init_dim_obs_pdaf,
                                  py__obs_op_pdaf,
                                  py__prepoststep_pdaf,
                                  py__localize_covar_pdaf,
                                  py__add_obs_err_pdaf,
                                  py__init_obs_covar_pdaf
                                 ):
    """Using stochastic EnKF (ensemble Kalman filter) with covariance localisation for DA with non-diagonal observation error covariance matrix without post-processing and analysis distribution to forecsat without OMI. This is the only scheme for covariance localisation in PDAF. This function should be called at each model time step. 
    
    This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf (for each ensemble member
    5. py__localize_pdaf
    6. py__add_obs_err_pdaf
    7. py__init_obscovar_pdaf
    8. py__obs_op_pdaf (repeated to reduce storage
    9. core DA algorith
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__localize_covar_pdaf : Callable[dim_p:int, dim_obs:int, hp_p : ndarray[tuple[dim_obs, dim_p], np.float64], hph : ndarray[tuple[dim_obs, dim_obs], np.float64]]
        Apply localization to HP and HPH^T

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **dim_obs** : int

            * number of observations

        * **hp_p** : ndarray[tuple[dim_obs, dim_p], np.float64]

            * pe local part of matrix hp

        * **hph** : ndarray[tuple[dim_obs, dim_obs], np.float64]

            * matrix hph

        **Callback Returns**

        * **hp_p** : ndarray[tuple[dim_obs, dim_p], np.float64]

            * pe local part of matrix hp

        * **hph** : ndarray[tuple[dim_obs, dim_obs], np.float64]

            * matrix hph

    py__add_obs_err_pdaf : Callable[step:int, dim_obs_p:int, C_p : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]]
        Add obs error covariance R to HPH in EnKF

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Dimension of observation vector

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            * Matrix to that observation covariance R is added

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            * Matrix to that observation covariance R is added

    py__init_obs_covar_pdaf : Callable[step:int, dim_obs:int, dim_obs_p:int, covar:float, obs_p : ndarray[tuple[dim_obs_p], np.float64], isdiag:bool]
        Initialize obs. error cov. matrix R in EnKF

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs** : int

            * Global size of observation vector

        * **dim_obs_p** : int

            * Size of process-local observation vector

        * **covar** : float

            * Observation error covariance matrix

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Process-local vector of observations

        * **isdiag** : bool

            * 

        **Callback Returns**

        * **covar** : float

            * Observation error covariance matrix

        * **isdiag** : bool

            * 


    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.localize_covar_pdaf = <void*>py__localize_covar_pdaf
    c__PDAFcython.add_obs_err_pdaf = <void*>py__add_obs_err_pdaf
    c__PDAFcython.init_obs_covar_pdaf = <void*>py__init_obs_covar_pdaf

    cdef int outflag

    c__pdafomi_put_state_lenkf_nondiagr (c__PDAFcython.c__collect_state_pdaf,
                                         c__PDAFcython.c__init_dim_obs_pdaf,
                                         c__PDAFcython.c__obs_op_pdaf,
                                         c__PDAFcython.c__prepoststep_pdaf,
                                         c__PDAFcython.c__localize_covar_pdaf,
                                         c__PDAFcython.c__add_obs_err_pdaf,
                                         c__PDAFcython.c__init_obs_covar_pdaf,
                                         &outflag
                                        )

    return outflag

def omi_put_state_lknetf_nondiagR (py__collect_state_pdaf,
                                   py__init_dim_obs_pdaf,
                                   py__obs_op_pdaf,
                                   py__prepoststep_pdaf,
                                   py__init_n_domains_p_pdaf,
                                   py__init_dim_l_pdaf,
                                   py__init_dim_obs_l_pdaf,
                                   py__prodRinvA_l_pdaf,
                                   py__prodRinvA_hyb_l_pdaf,
                                   py__likelihood_l_pdaf,
                                   py__likelihood_hyb_l_pdaf,
                                   py__g2l_state_pdaf,
                                   py__l2g_state_pdaf
                                  ):
    """It is recommended to use local module for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_assimilate_lknetf_nondiagR`. 
    Using LKNETF for DA with non-diagonal observation error covariance matrix without post-processing and analysis distribution to forecsat without OMI. This function should be called at each model time step. 
    
    This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    6. py__init_dim_l_pdaf
    7. py__init_dim_obs_l_pdaf
    8. py__g2l_state_pdaf
    9. py__prodRinvA_pdaf
    10. py__likelihood_l_pdaf
    11. core DA algorithm
    12. py__l2g_state_pdaf
    13. py__obs_op_pdaf (only called with `HKN` and `HNK` options called for each ensemble member
    14. py__likelihood_hyb_l_pda
    15. py__prodRinvA_hyb_l_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], A_l : ndarray[tuple[dim_obs_l, rank], np.float64], C_l : ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

    py__prodRinvA_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, dim_ens:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], gamma:float, A_l : ndarray[tuple[dim_obs_l, dim_ens], np.float64], C_l : ndarray[tuple[dim_obs_l, dim_ens], np.float64]]
        Provide product R^-1 A on local analysis domain with hybrid weight

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **dim_ens** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **gamma** : float

            * Hybrid weight provided by PDAF

        * **A_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            * Output matrix

    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], resid_l : ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            * nput vector holding the local residual

        * **likely_l** : float

            * Output value of the local likelihood

        **Callback Returns**

        * **likely_l** : float

            * Output value of the local likelihood

    py__likelihood_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], resid_l : ndarray[tuple[dim_obs_l], np.float64], gamma:float, likely_l:float]
        Compute likelihood with hybrid weight

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Input vector holding the local residual

        * **gamma** : float

            * Hybrid weight provided by PDAF

        * **likely_l** : float

            * Output value of the local likelihood

        **Callback Returns**

        * **likely_l** : float

            * Output value of the local likelihood

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p : ndarray[tuple[dim_p], np.float64], dim_l:int, state_l : ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l : ndarray[tuple[dim_l], np.float64], dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector


    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.prodRinvA_l_pdaf = <void*>py__prodRinvA_l_pdaf
    c__PDAFcython.prodRinvA_hyb_l_pdaf = <void*>py__prodRinvA_hyb_l_pdaf
    c__PDAFcython.likelihood_l_pdaf = <void*>py__likelihood_l_pdaf
    c__PDAFcython.likelihood_hyb_l_pdaf = <void*>py__likelihood_hyb_l_pdaf
    c__PDAFcython.g2l_state_pdaf = <void*>py__g2l_state_pdaf
    c__PDAFcython.l2g_state_pdaf = <void*>py__l2g_state_pdaf

    cdef int outflag

    c__pdafomi_put_state_lknetf_nondiagr (c__PDAFcython.c__collect_state_pdaf,
                                          c__PDAFcython.c__init_dim_obs_pdaf,
                                          c__PDAFcython.c__obs_op_pdaf,
                                          c__PDAFcython.c__prepoststep_pdaf,
                                          c__PDAFcython.c__init_n_domains_p_pdaf,
                                          c__PDAFcython.c__init_dim_l_pdaf,
                                          c__PDAFcython.c__init_dim_obs_l_pdaf,
                                          c__PDAFcython.c__prodRinvA_l_pdaf,
                                          c__PDAFcython.c__prodRinvA_hyb_l_pdaf,
                                          c__PDAFcython.c__likelihood_l_pdaf,
                                          c__PDAFcython.c__likelihood_hyb_l_pdaf,
                                          c__PDAFcython.c__g2l_state_pdaf,
                                          c__PDAFcython.c__l2g_state_pdaf,
                                          &outflag
                                         )

    return outflag

def omi_put_state_lnetf_nondiagR (py__collect_state_pdaf,
                                  py__init_dim_obs_pdaf,
                                  py__obs_op_pdaf,
                                  py__prepoststep_pdaf,
                                  py__init_n_domains_p_pdaf,
                                  py__init_dim_l_pdaf,
                                  py__init_dim_obs_l_pdaf,
                                  py__likelihood_l_pdaf,
                                  py__g2l_state_pdaf,
                                  py__l2g_state_pdaf
                                 ):
    """It is recommended to use local module for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_assimilate_lnetf_nondiagR`. 
    Using LNETF for DA with non-diagonal observation error covariance matrix without post-processing and analysis distribution to forecsat without OMI. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.omi_put_state_lnetf_nondiagR` This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    6. py__init_dim_l_pdaf
    7. py__init_dim_obs_l_pdaf
    8. py__g2l_state_pdaf
    9. py__likelihood_l_pdaf
    10. core DA algorithm
    11. py__l2g_state_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], resid_l : ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            * nput vector holding the local residual

        * **likely_l** : float

            * Output value of the local likelihood

        **Callback Returns**

        * **likely_l** : float

            * Output value of the local likelihood

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p : ndarray[tuple[dim_p], np.float64], dim_l:int, state_l : ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l : ndarray[tuple[dim_l], np.float64], dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector


    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.likelihood_l_pdaf = <void*>py__likelihood_l_pdaf
    c__PDAFcython.g2l_state_pdaf = <void*>py__g2l_state_pdaf
    c__PDAFcython.l2g_state_pdaf = <void*>py__l2g_state_pdaf

    cdef int outflag

    c__pdafomi_put_state_lnetf_nondiagr (c__PDAFcython.c__collect_state_pdaf,
                                         c__PDAFcython.c__init_dim_obs_pdaf,
                                         c__PDAFcython.c__obs_op_pdaf,
                                         c__PDAFcython.c__prepoststep_pdaf,
                                         c__PDAFcython.c__init_n_domains_p_pdaf,
                                         c__PDAFcython.c__init_dim_l_pdaf,
                                         c__PDAFcython.c__init_dim_obs_l_pdaf,
                                         c__PDAFcython.c__likelihood_l_pdaf,
                                         c__PDAFcython.c__g2l_state_pdaf,
                                         c__PDAFcython.c__l2g_state_pdaf,
                                         &outflag
                                        )

    return outflag

def omi_put_state_local_nondiagR (py__collect_state_pdaf,
                                  py__init_dim_obs_pdaf,
                                  py__obs_op_pdaf,
                                  py__prepoststep_pdaf,
                                  py__init_n_domains_p_pdaf,
                                  py__init_dim_l_pdaf,
                                  py__init_dim_obs_l_pdaf,
                                  py__prodRinvA_l_pdaf,
                                  py__g2l_state_pdaf,
                                  py__l2g_state_pdaf
                                 ):
    """It is recommended to use local module for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_assimilate_nondiagR`. 
    Using domain localised filters for DA with non-diagonal observation error covariance matrix without post-processing and analysis distribution to forecsat without OMI. This function should be called at each model time step. 
    
    This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    6. py__init_dim_l_pdaf
    7. py__init_dim_obs_l_pdaf
    8. py__g2l_state_pdaf
    9. py__init_obs_l_pdaf
    10. py__prodRinvA_l_pdaf
    11. core DA algorithm
    12. py__l2g_state_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], A_l : ndarray[tuple[dim_obs_l, rank], np.float64], C_l : ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p : ndarray[tuple[dim_p], np.float64], dim_l:int, state_l : ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l : ndarray[tuple[dim_l], np.float64], dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * **dim_p** : int

            * pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector


    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.prodRinvA_l_pdaf = <void*>py__prodRinvA_l_pdaf
    c__PDAFcython.g2l_state_pdaf = <void*>py__g2l_state_pdaf
    c__PDAFcython.l2g_state_pdaf = <void*>py__l2g_state_pdaf

    cdef int outflag

    c__pdafomi_put_state_local_nondiagr (c__PDAFcython.c__collect_state_pdaf,
                                         c__PDAFcython.c__init_dim_obs_pdaf,
                                         c__PDAFcython.c__obs_op_pdaf,
                                         c__PDAFcython.c__prepoststep_pdaf,
                                         c__PDAFcython.c__init_n_domains_p_pdaf,
                                         c__PDAFcython.c__init_dim_l_pdaf,
                                         c__PDAFcython.c__init_dim_obs_l_pdaf,
                                         c__PDAFcython.c__prodRinvA_l_pdaf,
                                         c__PDAFcython.c__g2l_state_pdaf,
                                         c__PDAFcython.c__l2g_state_pdaf,
                                         &outflag
                                        )

    return outflag

def omi_put_state_nonlin_nondiagR (py__collect_state_pdaf,
                                   py__init_dim_obs_pdaf,
                                   py__obs_op_pdaf,
                                   py__likelihood_pdaf,
                                   py__prepoststep_pdaf
                                  ):
    """Using nonlinear filters (particle filter, NETF) for DA except for 3DVars with non-diagonal observation error covariance matrix
    without post-processing and analysis distribution to forecsat without OMI. This function should be called at each model time step. 
    
    This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf (for ensemble mean
    5. py__obs_op_pdaf (for each ensemble member
    6. py__likelihood_pdaf
    7. core DA algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__likelihood_pdaf : Callable[step:int, dim_obs_p:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], resid : ndarray[tuple[dim_obs_p], np.float64], likely:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **resid** : ndarray[tuple[dim_obs_p], np.float64]

            * Input vector holding the residual

        * **likely** : float

            * Output value of the likelihood

        **Callback Returns**

        * **likely** : float

            * Output value of the likelihood

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble


    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.likelihood_pdaf = <void*>py__likelihood_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf

    cdef int outflag

    c__pdafomi_put_state_nonlin_nondiagr (c__PDAFcython.c__collect_state_pdaf,
                                          c__PDAFcython.c__init_dim_obs_pdaf,
                                          c__PDAFcython.c__obs_op_pdaf,
                                          c__PDAFcython.c__likelihood_pdaf,
                                          c__PDAFcython.c__prepoststep_pdaf,
                                          &outflag
                                         )

    return outflag

def local_set_indices (int[::1] map
                      ):
    """Set index vector to map local state vector to global state vectors. This is called in the user-supplied function `py__init_dim_l_pdaf`.

    Parameters
    ----------
    map : ndarray[tuple[dim_l], np.intc]
        Index array for mapping between local and global state vector
    """

    cdef int dim_l
    dim_l = map.shape[0]

    c__pdaflocal_set_indices (&dim_l,
                              &map[0]
                             )

def local_set_increment_weights (double[::1] weights
                                ):
    """This function initialises a PDAF_internal local array of increment weights. The weights are applied in in PDAF_local_l2g_cb where the local state vector
    is weighted by given weights. These can e.g. be used to apply a vertical localisation.

    Parameters
    ----------
    weights : ndarray[tuple[dim_l], np.float64]
        Weights array
    """

    cdef int dim_l
    dim_l = weights.shape[0]

    c__pdaflocal_set_increment_weights (&dim_l,
                                        &weights[0]
                                       )

def local_clear_increment_weights ():
    """This function deallocates the local increment weight vector in `pyPDAF.PDAF.local_set_increment_weights` if it is allocated

    """

    c__pdaflocal_clear_increment_weights ()

def local_g2l_cb (int step,
                  int domain_p,
                  int dim_p,
                  double[::1] state_p,
                  int dim_l,
                  double[::1] state_l
                 ):
    """Project a global to a local state vector for the localized filters.
    This is the full callback function to be used internally. The mapping is done using the index vector id_lstate_in_pstate that is initialised in `pyPDAF.PDAF.local_set_indices`.

    Parameters
    ----------
    step : int
        Current time step
    domain_p : int
        Current local analysis domain
    dim_p : int
        PE-local full state dimension
    state_p : ndarray[tuple[dim_p], np.float64]
        PE-local full state vector
    dim_l : int
        Local state dimension
    state_l : ndarray[tuple[dim_l], np.float64]
        State vector on local analysis domain

    Returns
    -------
    state_l : ndarray[tuple[dim_l], np.float64]
         State vector on local analysis domain
    """

    c__pdaflocal_g2l_cb (&step,
                         &domain_p,
                         &dim_p,
                         &state_p[0],
                         &dim_l,
                         &state_l[0]
                        )

    return np.asarray(state_l).reshape((dim_l), order='F')

def local_l2g_cb (int step,
                  int domain_p,
                  int dim_l,
                  double[::1] state_l,
                  int dim_p,
                  double[::1] state_p
                 ):
    """Initialise elements of a global state vector from a local state vector.
    This is the full callback function to be used internally. The mapping is done using the index vector `id_lstate_in_pstate` that is initialised in `pyPDAF.PDAF.local_set_indices`. 
    
    To exclude any element of the local state vector from the initialisationone can set the corresponding index value to 0.

    Parameters
    ----------
    step : int
        Current time step
    domain_p : int
        Current local analysis domain
    dim_l : int
        Local state dimension
    state_l : ndarray[tuple[dim_l], np.float64]
        State vector on local analysis domain
    dim_p : int
        PE-local full state dimension
    state_p : ndarray[tuple[dim_p], np.float64]
        PE-local full state vector

    Returns
    -------
    state_p : ndarray[tuple[dim_p], np.float64]
         PE-local full state vector
    """

    c__pdaflocal_l2g_cb (&step,
                         &domain_p,
                         &dim_l,
                         &state_l[0],
                         &dim_p,
                         &state_p[0]
                        )

    return np.asarray(state_p).reshape((dim_p), order='F')

def localomi_assimilate (py__collect_state_pdaf,
                         py__distribute_state_pdaf,
                         py__init_dim_obs_pdaf,
                         py__obs_op_pdaf,
                         py__prepoststep_pdaf,
                         py__init_n_domains_p_pdaf,
                         py__init_dim_l_pdaf,
                         py__init_dim_obs_l_pdaf,
                         py__next_observation_pdaf,
                         int outflag
                        ):
    """Using domain localised filters for DA with diagonal observation error covariance matrix. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.localomi_put_state` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    6. py__init_dim_l_pdaf
    7. py__init_dim_obs_l_pdaf
    8. py__init_obs_l_pdaf
    9. core DA algorithm
    10. py__prepoststep_state_pdaf
    11. py__distribute_state_pdaf
    12. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    c__pdaflocalomi_assimilate (c__PDAFcython.c__collect_state_pdaf,
                                c__PDAFcython.c__distribute_state_pdaf,
                                c__PDAFcython.c__init_dim_obs_pdaf,
                                c__PDAFcython.c__obs_op_pdaf,
                                c__PDAFcython.c__prepoststep_pdaf,
                                c__PDAFcython.c__init_n_domains_p_pdaf,
                                c__PDAFcython.c__init_dim_l_pdaf,
                                c__PDAFcython.c__init_dim_obs_l_pdaf,
                                c__PDAFcython.c__next_observation_pdaf,
                                &outflag
                               )

    return outflag

def localomi_assimilate_en3dvar_lestkf (py__collect_state_pdaf,
                                        py__distribute_state_pdaf,
                                        py__init_dim_obs_pdaf,
                                        py__obs_op_f_pdaf,
                                        py__cvt_ens_pdaf,
                                        py__cvt_adj_ens_pdaf,
                                        py__obs_op_lin_pdaf,
                                        py__obs_op_adj_pdaf,
                                        py__init_n_domains_p_pdaf,
                                        py__init_dim_l_pdaf,
                                        py__init_dim_obs_l_pdaf,
                                        py__prepoststep_pdaf,
                                        py__next_observation_pdaf,
                                        int outflag
                                       ):
    """Using 3DEnVar for DA with diagonal observation error covariance matrix.
    The background error covariance matrix is estimated by ensemble. The 3DEnVar only calculates the analysis of the ensemble mean.
    An LESTKF is used to generate ensemble perturbations. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf`
    and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_ens_pdaf
    6. py__obs_op_lin_pdaf
    7. py__obs_op_adj_pdaf
    8. py__cvt_adj_ens_pdaf
    9. core DA algorithm
    After the iterations: 
    10. py__cvt_ens_pdaf
    Perform LESTKF: 
    11. py__init_n_domains_p_pdaf
    12. py__init_dim_obs_pdaf
    13. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    14. py__init_dim_l_pdaf
    15. py__init_dim_obs_l_pdaf (localise mean ensemble in observation space)
    16. core DA algorithm
    17. py__prepoststep_state_pdaf
    18. py__distribute_state_pdaf
    19. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], v_p : ndarray[tuple[dim_cvec_ens], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_ens** : int

            * Ensemble size

        * **dim_cvec_ens** : int

            * Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_ens** : int

            * Ensemble size

        * **dim_cv_ens_p** : int

            * PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_f_pdaf = <void*>py__obs_op_f_pdaf
    c__PDAFcython.cvt_ens_pdaf = <void*>py__cvt_ens_pdaf
    c__PDAFcython.cvt_adj_ens_pdaf = <void*>py__cvt_adj_ens_pdaf
    c__PDAFcython.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    c__PDAFcython.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    c__pdaflocalomi_assimilate_en3dvar_lestkf (c__PDAFcython.c__collect_state_pdaf,
                                               c__PDAFcython.c__distribute_state_pdaf,
                                               c__PDAFcython.c__init_dim_obs_pdaf,
                                               c__PDAFcython.c__obs_op_f_pdaf,
                                               c__PDAFcython.c__cvt_ens_pdaf,
                                               c__PDAFcython.c__cvt_adj_ens_pdaf,
                                               c__PDAFcython.c__obs_op_lin_pdaf,
                                               c__PDAFcython.c__obs_op_adj_pdaf,
                                               c__PDAFcython.c__init_n_domains_p_pdaf,
                                               c__PDAFcython.c__init_dim_l_pdaf,
                                               c__PDAFcython.c__init_dim_obs_l_pdaf,
                                               c__PDAFcython.c__prepoststep_pdaf,
                                               c__PDAFcython.c__next_observation_pdaf,
                                               &outflag
                                              )

    return outflag

def localomi_assimilate_en3dvar_lestkf_nondiagR (py__collect_state_pdaf,
                                                 py__distribute_state_pdaf,
                                                 py__init_dim_obs_pdaf,
                                                 py__obs_op_pdaf,
                                                 py__prodRinvA_pdaf,
                                                 py__cvt_ens_pdaf,
                                                 py__cvt_adj_ens_pdaf,
                                                 py__obs_op_lin_pdaf,
                                                 py__obs_op_adj_pdaf,
                                                 py__prodRinvA_l_pdaf,
                                                 py__init_n_domains_p_pdaf,
                                                 py__init_dim_l_pdaf,
                                                 py__init_dim_obs_l_pdaf,
                                                 py__prepoststep_pdaf,
                                                 py__next_observation_pdaf,
                                                 int outflag
                                                ):
    """Using 3DEnVar for DA with non-diagonal observation error covariance matrix.
    The background error covariance matrix is estimated by ensemble. The 3DEnVar only calculates the analysis of the ensemble mean.
    An LESTKF is used to generate ensemble perturbations. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf_nondiagR`
    and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_ens_pdaf
    6. py__obs_op_lin_pdaf
    7. py__prodRinvA_pdaf
    8. py__obs_op_adj_pdaf
    9. py__cvt_adj_ens_pdaf
    10. core DA algorithm
    After the iterations: 
    11. py__cvt_ens_pdaf
    Perform LESTKF: 
    12. py__init_n_domains_p_pdaf
    13. py__init_dim_obs_pdaf
    14. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    15. py__init_dim_l_pdaf
    16. py__init_dim_obs_l_pdaf (localise mean ensemble in observation space)
    17. py__prodRinvA_l_pdaf
    18. core DA algorithm
    19. py__prepoststep_state_pdaf
    20. py__distribute_state_pdaf
    21. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], A_p : ndarray[tuple[dim_obs_p, rank], np.float64], C_p : ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], v_p : ndarray[tuple[dim_cvec_ens], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_ens** : int

            * Ensemble size

        * **dim_cvec_ens** : int

            * Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_ens** : int

            * Ensemble size

        * **dim_cv_ens_p** : int

            * PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], A_l : ndarray[tuple[dim_obs_l, rank], np.float64], C_l : ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A with localization

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.prodRinvA_pdaf = <void*>py__prodRinvA_pdaf
    c__PDAFcython.cvt_ens_pdaf = <void*>py__cvt_ens_pdaf
    c__PDAFcython.cvt_adj_ens_pdaf = <void*>py__cvt_adj_ens_pdaf
    c__PDAFcython.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    c__PDAFcython.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    c__PDAFcython.prodRinvA_l_pdaf = <void*>py__prodRinvA_l_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    c__pdaflocalomi_assimilate_en3dvar_lestkf_nondiagr (c__PDAFcython.c__collect_state_pdaf,
                                                        c__PDAFcython.c__distribute_state_pdaf,
                                                        c__PDAFcython.c__init_dim_obs_pdaf,
                                                        c__PDAFcython.c__obs_op_pdaf,
                                                        c__PDAFcython.c__prodRinvA_pdaf,
                                                        c__PDAFcython.c__cvt_ens_pdaf,
                                                        c__PDAFcython.c__cvt_adj_ens_pdaf,
                                                        c__PDAFcython.c__obs_op_lin_pdaf,
                                                        c__PDAFcython.c__obs_op_adj_pdaf,
                                                        c__PDAFcython.c__prodRinvA_l_pdaf,
                                                        c__PDAFcython.c__init_n_domains_p_pdaf,
                                                        c__PDAFcython.c__init_dim_l_pdaf,
                                                        c__PDAFcython.c__init_dim_obs_l_pdaf,
                                                        c__PDAFcython.c__prepoststep_pdaf,
                                                        c__PDAFcython.c__next_observation_pdaf,
                                                        &outflag
                                                       )

    return outflag

def localomi_assimilate_hyb3dvar_lestkf (py__collect_state_pdaf,
                                         py__distribute_state_pdaf,
                                         py__init_dim_obs_pdaf,
                                         py__obs_op_pdaf,
                                         py__cvt_ens_pdaf,
                                         py__cvt_adj_ens_pdaf,
                                         py__cvt_pdaf,
                                         py__cvt_adj_pdaf,
                                         py__obs_op_lin_pdaf,
                                         py__obs_op_adj_pdaf,
                                         py__init_n_domains_p_pdaf,
                                         py__init_dim_l_pdaf,
                                         py__init_dim_obs_l_pdaf,
                                         py__prepoststep_pdaf,
                                         py__next_observation_pdaf,
                                         int outflag
                                        ):
    """Using Hybrid 3DEnVar for DA with diagonal observation error covariance matrix.
    Here, the background error covariance is hybridised by a static background error covariance, and a flow-dependent background error covariance estimated from ensemble. The 3DVar generates an ensemble mean and the ensemble perturbation is generated by
    LESTKF in this implementation. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf`
    and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_pdaf
    6. py__cvt_ens_pdaf
    7. py__obs_op_lin_pdaf
    8. py__obs_op_adj_pdaf
    9. py__cvt_adj_pdaf
    10. py__cvt_adj_ens_pdaf
    11. core DA algorithm
    After the iterations: 
    12. py__cvt_pdaf
    13. py__cvt_ens_pdaf
    Perform LESTKF: 
    14. py__init_n_domains_p_pdaf
    15. py__init_dim_obs_pdaf
    16. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    17. py__init_dim_l_pdaf
    18. py__init_dim_obs_l_pdaf
    19. py__init_obs_l_pdaf
    20. core DA algorithm
    21. py__prepoststep_state_pdaf
    22. py__distribute_state_pdaf
    23. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], v_p : ndarray[tuple[dim_cvec_ens], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_ens** : int

            * Ensemble size

        * **dim_cvec_ens** : int

            * Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_ens** : int

            * Ensemble size

        * **dim_cv_ens_p** : int

            * PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p : ndarray[tuple[dim_cvec], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.cvt_ens_pdaf = <void*>py__cvt_ens_pdaf
    c__PDAFcython.cvt_adj_ens_pdaf = <void*>py__cvt_adj_ens_pdaf
    c__PDAFcython.cvt_pdaf = <void*>py__cvt_pdaf
    c__PDAFcython.cvt_adj_pdaf = <void*>py__cvt_adj_pdaf
    c__PDAFcython.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    c__PDAFcython.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    c__pdaflocalomi_assimilate_hyb3dvar_lestkf (c__PDAFcython.c__collect_state_pdaf,
                                                c__PDAFcython.c__distribute_state_pdaf,
                                                c__PDAFcython.c__init_dim_obs_pdaf,
                                                c__PDAFcython.c__obs_op_pdaf,
                                                c__PDAFcython.c__cvt_ens_pdaf,
                                                c__PDAFcython.c__cvt_adj_ens_pdaf,
                                                c__PDAFcython.c__cvt_pdaf,
                                                c__PDAFcython.c__cvt_adj_pdaf,
                                                c__PDAFcython.c__obs_op_lin_pdaf,
                                                c__PDAFcython.c__obs_op_adj_pdaf,
                                                c__PDAFcython.c__init_n_domains_p_pdaf,
                                                c__PDAFcython.c__init_dim_l_pdaf,
                                                c__PDAFcython.c__init_dim_obs_l_pdaf,
                                                c__PDAFcython.c__prepoststep_pdaf,
                                                c__PDAFcython.c__next_observation_pdaf,
                                                &outflag
                                               )

    return outflag

def localomi_assimilate_hyb3dvar_lestkf_nondiagR (py__collect_state_pdaf,
                                                  py__distribute_state_pdaf,
                                                  py__init_dim_obs_pdaf,
                                                  py__obs_op_pdaf,
                                                  py__prodRinvA_pdaf,
                                                  py__cvt_ens_pdaf,
                                                  py__cvt_adj_ens_pdaf,
                                                  py__cvt_pdaf,
                                                  py__cvt_adj_pdaf,
                                                  py__obs_op_lin_pdaf,
                                                  py__obs_op_adj_pdaf,
                                                  py__prodRinvA_l_pdaf,
                                                  py__init_n_domains_p_pdaf,
                                                  py__init_dim_l_pdaf,
                                                  py__init_dim_obs_l_pdaf,
                                                  py__prepoststep_pdaf,
                                                  py__next_observation_pdaf,
                                                  int outflag
                                                 ):
    """Using Hybrid 3DEnVar for DA with non-diagonal observation error covariance matrix.
    Here, the background error covariance is hybridised by a static background error covariance, and a flow-dependent background error covariance estimated from ensemble. The 3DVar generates an ensemble mean and the ensemble perturbation is generated by
    LESTKF in this implementation. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf_nondiagR`
    and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_pdaf
    6. py__cvt_ens_pdaf
    7. py__obs_op_lin_pdaf
    8. py__prodRinvA_pdaf
    9. py__obs_op_adj_pdaf
    10. py__cvt_adj_pdaf
    11. py__cvt_adj_ens_pdaf
    12. core DA algorithm
    After the iterations: 
    13. py__cvt_pdaf
    14. py__cvt_ens_pdaf
    Perform LESTKF: 
    15. py__init_n_domains_p_pdaf
    16. py__init_dim_obs_pdaf
    17. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    18. py__init_dim_l_pdaf
    19. py__init_dim_obs_l_pdaf
    20. py__init_obs_l_pdaf
    21. py__prodRinvA_l_pdaf
    22. core DA algorithm
    23. py__prepoststep_state_pdaf
    24. py__distribute_state_pdaf
    25. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], A_p : ndarray[tuple[dim_obs_p, rank], np.float64], C_p : ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], v_p : ndarray[tuple[dim_cvec_ens], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_ens** : int

            * Ensemble size

        * **dim_cvec_ens** : int

            * Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_ens** : int

            * Ensemble size

        * **dim_cv_ens_p** : int

            * PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p : ndarray[tuple[dim_cvec], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], A_l : ndarray[tuple[dim_obs_l, rank], np.float64], C_l : ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.prodRinvA_pdaf = <void*>py__prodRinvA_pdaf
    c__PDAFcython.cvt_ens_pdaf = <void*>py__cvt_ens_pdaf
    c__PDAFcython.cvt_adj_ens_pdaf = <void*>py__cvt_adj_ens_pdaf
    c__PDAFcython.cvt_pdaf = <void*>py__cvt_pdaf
    c__PDAFcython.cvt_adj_pdaf = <void*>py__cvt_adj_pdaf
    c__PDAFcython.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    c__PDAFcython.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    c__PDAFcython.prodRinvA_l_pdaf = <void*>py__prodRinvA_l_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    c__pdaflocalomi_assimilate_hyb3dvar_lestkf_nondiagr (c__PDAFcython.c__collect_state_pdaf,
                                                         c__PDAFcython.c__distribute_state_pdaf,
                                                         c__PDAFcython.c__init_dim_obs_pdaf,
                                                         c__PDAFcython.c__obs_op_pdaf,
                                                         c__PDAFcython.c__prodRinvA_pdaf,
                                                         c__PDAFcython.c__cvt_ens_pdaf,
                                                         c__PDAFcython.c__cvt_adj_ens_pdaf,
                                                         c__PDAFcython.c__cvt_pdaf,
                                                         c__PDAFcython.c__cvt_adj_pdaf,
                                                         c__PDAFcython.c__obs_op_lin_pdaf,
                                                         c__PDAFcython.c__obs_op_adj_pdaf,
                                                         c__PDAFcython.c__prodRinvA_l_pdaf,
                                                         c__PDAFcython.c__init_n_domains_p_pdaf,
                                                         c__PDAFcython.c__init_dim_l_pdaf,
                                                         c__PDAFcython.c__init_dim_obs_l_pdaf,
                                                         c__PDAFcython.c__prepoststep_pdaf,
                                                         c__PDAFcython.c__next_observation_pdaf,
                                                         &outflag
                                                        )

    return outflag

def localomi_assimilate_lknetf_nondiagR (py__collect_state_pdaf,
                                         py__distribute_state_pdaf,
                                         py__init_dim_obs_pdaf,
                                         py__obs_op_pdaf,
                                         py__prepoststep_pdaf,
                                         py__init_n_domains_p_pdaf,
                                         py__init_dim_l_pdaf,
                                         py__init_dim_obs_l_pdaf,
                                         py__prodRinvA_l_pdaf,
                                         py__prodRinvA_hyb_l_pdaf,
                                         py__likelihood_l_pdaf,
                                         py__likelihood_hyb_l_pdaf,
                                         py__next_observation_pdaf,
                                         int outflag
                                        ):
    """Using LKNETF for DA with non-diagonal observation error covariance matrix. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.localomi_put_state_lknetf_nondiagR` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    6. py__init_dim_l_pdaf
    7. py__init_dim_obs_l_pdaf
    8. py__prodRinvA_pdaf
    9. py__likelihood_l_pdaf
    10. core DA algorithm
    11. py__obs_op_pdaf (only called with `HKN` and `HNK` options called for each ensemble member
    12. py__likelihood_hyb_l_pda
    13. py__prodRinvA_hyb_l_pdaf
    14. py__prepoststep_state_pdaf
    15. py__distribute_state_pdaf
    16. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], A_l : ndarray[tuple[dim_obs_l, rank], np.float64], C_l : ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

    py__prodRinvA_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, dim_ens:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], gamma:float, A_l : ndarray[tuple[dim_obs_l, dim_ens], np.float64], C_l : ndarray[tuple[dim_obs_l, dim_ens], np.float64]]
        Product R^-1 A on local analysis domain with hybrid weight

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **dim_ens** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **gamma** : float

            * Hybrid weight provided by PDAF

        * **A_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            * Output matrix

    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], resid_l : ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute likelihood and apply localization

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            * nput vector holding the local residual

        * **likely_l** : float

            * Output value of the local likelihood

        **Callback Returns**

        * **likely_l** : float

            * Output value of the local likelihood

    py__likelihood_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], resid_l : ndarray[tuple[dim_obs_l], np.float64], gamma:float, likely_l:float]
        Compute likelihood and apply localization with tempering

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Input vector holding the local residual

        * **gamma** : float

            * Hybrid weight provided by PDAF

        * **likely_l** : float

            * Output value of the local likelihood

        **Callback Returns**

        * **likely_l** : float

            * Output value of the local likelihood

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.prodRinvA_l_pdaf = <void*>py__prodRinvA_l_pdaf
    c__PDAFcython.prodRinvA_hyb_l_pdaf = <void*>py__prodRinvA_hyb_l_pdaf
    c__PDAFcython.likelihood_l_pdaf = <void*>py__likelihood_l_pdaf
    c__PDAFcython.likelihood_hyb_l_pdaf = <void*>py__likelihood_hyb_l_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    c__pdaflocalomi_assimilate_lknetf_nondiagr (c__PDAFcython.c__collect_state_pdaf,
                                                c__PDAFcython.c__distribute_state_pdaf,
                                                c__PDAFcython.c__init_dim_obs_pdaf,
                                                c__PDAFcython.c__obs_op_pdaf,
                                                c__PDAFcython.c__prepoststep_pdaf,
                                                c__PDAFcython.c__init_n_domains_p_pdaf,
                                                c__PDAFcython.c__init_dim_l_pdaf,
                                                c__PDAFcython.c__init_dim_obs_l_pdaf,
                                                c__PDAFcython.c__prodRinvA_l_pdaf,
                                                c__PDAFcython.c__prodRinvA_hyb_l_pdaf,
                                                c__PDAFcython.c__likelihood_l_pdaf,
                                                c__PDAFcython.c__likelihood_hyb_l_pdaf,
                                                c__PDAFcython.c__next_observation_pdaf,
                                                &outflag
                                               )

    return outflag

def localomi_assimilate_lnetf_nondiagR (py__collect_state_pdaf,
                                        py__distribute_state_pdaf,
                                        py__init_dim_obs_pdaf,
                                        py__obs_op_pdaf,
                                        py__prepoststep_pdaf,
                                        py__init_n_domains_p_pdaf,
                                        py__init_dim_l_pdaf,
                                        py__init_dim_obs_l_pdaf,
                                        py__likelihood_l_pdaf,
                                        py__next_observation_pdaf,
                                        int outflag
                                       ):
    """Using LNETF for DA with non-diagonal observation error covariance matrix. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.localomi_put_state_lnetf_nondiagR` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    6. py__init_dim_l_pdaf
    7. py__init_dim_obs_l_pdaf
    8. py__likelihood_l_pdaf
    9. core DA algorithm
    10. py__prepoststep_state_pdaf
    11. py__distribute_state_pdaf
    12. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], resid_l : ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute likelihood and apply localization

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            * nput vector holding the local residual

        * **likely_l** : float

            * Output value of the local likelihood

        **Callback Returns**

        * **likely_l** : float

            * Output value of the local likelihood

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.likelihood_l_pdaf = <void*>py__likelihood_l_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    c__pdaflocalomi_assimilate_lnetf_nondiagr (c__PDAFcython.c__collect_state_pdaf,
                                               c__PDAFcython.c__distribute_state_pdaf,
                                               c__PDAFcython.c__init_dim_obs_pdaf,
                                               c__PDAFcython.c__obs_op_pdaf,
                                               c__PDAFcython.c__prepoststep_pdaf,
                                               c__PDAFcython.c__init_n_domains_p_pdaf,
                                               c__PDAFcython.c__init_dim_l_pdaf,
                                               c__PDAFcython.c__init_dim_obs_l_pdaf,
                                               c__PDAFcython.c__likelihood_l_pdaf,
                                               c__PDAFcython.c__next_observation_pdaf,
                                               &outflag
                                              )

    return outflag

def localomi_assimilate_nondiagR (py__collect_state_pdaf,
                                  py__distribute_state_pdaf,
                                  py__init_dim_obs_pdaf,
                                  py__obs_op_pdaf,
                                  py__prepoststep_pdaf,
                                  py__init_n_domains_p_pdaf,
                                  py__init_dim_l_pdaf,
                                  py__init_dim_obs_l_pdaf,
                                  py__prodRinvA_l_pdaf,
                                  py__next_observation_pdaf,
                                  int outflag
                                 ):
    """Using domain localised filters for DA with non-diagonal observation error covariance matrix. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.localomi_put_state_local_nondiagR` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    6. py__init_dim_l_pdaf
    7. py__init_dim_obs_l_pdaf
    8. py__init_obs_l_pdaf
    9. py__prodRinvA_l_pdaf
    10. core DA algorithm
    11. py__prepoststep_state_pdaf
    12. py__distribute_state_pdaf
    13. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], A_l : ndarray[tuple[dim_obs_l, rank], np.float64], C_l : ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product of inverse of R with matrix A

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.prodRinvA_l_pdaf = <void*>py__prodRinvA_l_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    c__pdaflocalomi_assimilate_nondiagr (c__PDAFcython.c__collect_state_pdaf,
                                         c__PDAFcython.c__distribute_state_pdaf,
                                         c__PDAFcython.c__init_dim_obs_pdaf,
                                         c__PDAFcython.c__obs_op_pdaf,
                                         c__PDAFcython.c__prepoststep_pdaf,
                                         c__PDAFcython.c__init_n_domains_p_pdaf,
                                         c__PDAFcython.c__init_dim_l_pdaf,
                                         c__PDAFcython.c__init_dim_obs_l_pdaf,
                                         c__PDAFcython.c__prodRinvA_l_pdaf,
                                         c__PDAFcython.c__next_observation_pdaf,
                                         &outflag
                                        )

    return outflag

def localomi_put_state (py__collect_state_pdaf,
                        py__init_dim_obs_pdaf,
                        py__obs_op_pdaf,
                        py__prepoststep_pdaf,
                        py__init_n_domains_p_pdaf,
                        py__init_dim_l_pdaf,
                        py__init_dim_obs_l_pdaf,
                        int outflag
                       ):
    """Using domain localised filters for DA without post-processing and analysis distribution to forecsat with diagonal observation error covariance matrix. This is a domain localisation method. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. The LESTKF is a more efficient equivalent to the LETKF. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    6. py__init_dim_l_pdaf
    7. py__init_dim_obs_l_pdaf
    8. core DA algorithm
    9. py__prepoststep_state_pdaf
    10. py__distribute_state_pdaf
    11. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf

    c__pdaflocalomi_put_state (c__PDAFcython.c__collect_state_pdaf,
                               c__PDAFcython.c__init_dim_obs_pdaf,
                               c__PDAFcython.c__obs_op_pdaf,
                               c__PDAFcython.c__prepoststep_pdaf,
                               c__PDAFcython.c__init_n_domains_p_pdaf,
                               c__PDAFcython.c__init_dim_l_pdaf,
                               c__PDAFcython.c__init_dim_obs_l_pdaf,
                               &outflag
                              )

    return outflag

def localomi_put_state_en3dvar_lestkf (py__collect_state_pdaf,
                                       py__init_dim_obs_pdaf,
                                       py__obs_op_pdaf,
                                       py__cvt_ens_pdaf,
                                       py__cvt_adj_ens_pdaf,
                                       py__obs_op_lin_pdaf,
                                       py__obs_op_adj_pdaf,
                                       py__init_n_domains_p_pdaf,
                                       py__init_dim_l_pdaf,
                                       py__init_dim_obs_l_pdaf,
                                       py__prepoststep_pdaf,
                                       int outflag
                                      ):
    """Using 3DEnVar for DA without post-processing and analysis distribution to forecsat with diagonal observation error covariance matrix.
    The background error covariance matrix is estimated by ensemble. The 3DEnVar only calculates the analysis of the ensemble mean.
    An LESTKF is used to generate ensemble perturbations. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_ens_pdaf
    6. py__obs_op_lin_pdaf
    7. py__obs_op_adj_pdaf
    8. py__cvt_adj_ens_pdaf
    9. core DA algorithm
    After the iterations: 
    10. py__cvt_ens_pdaf
    Perform LESTKF: 
    11. py__init_n_domains_p_pdaf
    12. py__init_dim_obs_pdaf
    13. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    14. py__init_dim_l_pdaf
    15. py__init_dim_obs_l_pdaf
    16. core DA algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], v_p : ndarray[tuple[dim_cvec_ens], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_ens** : int

            * Ensemble size

        * **dim_cvec_ens** : int

            * Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_ens** : int

            * Ensemble size

        * **dim_cv_ens_p** : int

            * PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.cvt_ens_pdaf = <void*>py__cvt_ens_pdaf
    c__PDAFcython.cvt_adj_ens_pdaf = <void*>py__cvt_adj_ens_pdaf
    c__PDAFcython.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    c__PDAFcython.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf

    c__pdaflocalomi_put_state_en3dvar_lestkf (c__PDAFcython.c__collect_state_pdaf,
                                              c__PDAFcython.c__init_dim_obs_pdaf,
                                              c__PDAFcython.c__obs_op_pdaf,
                                              c__PDAFcython.c__cvt_ens_pdaf,
                                              c__PDAFcython.c__cvt_adj_ens_pdaf,
                                              c__PDAFcython.c__obs_op_lin_pdaf,
                                              c__PDAFcython.c__obs_op_adj_pdaf,
                                              c__PDAFcython.c__init_n_domains_p_pdaf,
                                              c__PDAFcython.c__init_dim_l_pdaf,
                                              c__PDAFcython.c__init_dim_obs_l_pdaf,
                                              c__PDAFcython.c__prepoststep_pdaf,
                                              &outflag
                                             )

    return outflag

def localomi_put_state_en3dvar_lestkf_nondiagR (py__collect_state_pdaf,
                                                py__init_dim_obs_pdaf,
                                                py__obs_op_pdaf,
                                                py__prodRinvA_pdaf,
                                                py__cvt_ens_pdaf,
                                                py__cvt_adj_ens_pdaf,
                                                py__obs_op_lin_pdaf,
                                                py__obs_op_adj_pdaf,
                                                py__prodRinvA_l_pdaf,
                                                py__init_n_domains_p_pdaf,
                                                py__init_dim_l_pdaf,
                                                py__init_dim_obs_l_pdaf,
                                                py__prepoststep_pdaf,
                                                int outflag
                                               ):
    """Using 3DEnVar for DA with non-diagonal observation error covariance matrix
    without post-processing and analysis distribution to forecsat without OMI. The background error covariance matrix is estimated by ensemble. The 3DEnVar only calculates the analysis of the ensemble mean.
    An LESTKF is used to generate ensemble perturbations. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_ens_pdaf
    6. py__obs_op_lin_pdaf
    7. py__prodRinvA_pdaf
    8. py__obs_op_adj_pdaf
    9. py__cvt_adj_ens_pdaf
    10. core DA algorithm
    After the iterations: 
    11. py__cvt_ens_pdaf
    Perform LESTKF: 
    12. py__init_n_domains_p_pdaf
    13. py__init_dim_obs_pdaf
    14. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    15. py__init_dim_l_pdaf
    16. py__init_dim_obs_l_pdaf (localise mean ensemble in observation space)
    17. py__prodRinvA_l_pdaf
    18. core DA algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], A_p : ndarray[tuple[dim_obs_p, rank], np.float64], C_p : ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], v_p : ndarray[tuple[dim_cvec_ens], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_ens** : int

            * Ensemble size

        * **dim_cvec_ens** : int

            * Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_ens** : int

            * Ensemble size

        * **dim_cv_ens_p** : int

            * PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], A_l : ndarray[tuple[dim_obs_l, rank], np.float64], C_l : ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.prodRinvA_pdaf = <void*>py__prodRinvA_pdaf
    c__PDAFcython.cvt_ens_pdaf = <void*>py__cvt_ens_pdaf
    c__PDAFcython.cvt_adj_ens_pdaf = <void*>py__cvt_adj_ens_pdaf
    c__PDAFcython.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    c__PDAFcython.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    c__PDAFcython.prodRinvA_l_pdaf = <void*>py__prodRinvA_l_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf

    c__pdaflocalomi_put_state_en3dvar_lestkf_nondiagr (c__PDAFcython.c__collect_state_pdaf,
                                                       c__PDAFcython.c__init_dim_obs_pdaf,
                                                       c__PDAFcython.c__obs_op_pdaf,
                                                       c__PDAFcython.c__prodRinvA_pdaf,
                                                       c__PDAFcython.c__cvt_ens_pdaf,
                                                       c__PDAFcython.c__cvt_adj_ens_pdaf,
                                                       c__PDAFcython.c__obs_op_lin_pdaf,
                                                       c__PDAFcython.c__obs_op_adj_pdaf,
                                                       c__PDAFcython.c__prodRinvA_l_pdaf,
                                                       c__PDAFcython.c__init_n_domains_p_pdaf,
                                                       c__PDAFcython.c__init_dim_l_pdaf,
                                                       c__PDAFcython.c__init_dim_obs_l_pdaf,
                                                       c__PDAFcython.c__prepoststep_pdaf,
                                                       &outflag
                                                      )

    return outflag

def localomi_put_state_hyb3dvar_lestkf (py__collect_state_pdaf,
                                        py__init_dim_obs_pdaf,
                                        py__obs_op_pdaf,
                                        py__cvt_ens_pdaf,
                                        py__cvt_adj_ens_pdaf,
                                        py__cvt_pdaf,
                                        py__cvt_adj_pdaf,
                                        py__obs_op_lin_pdaf,
                                        py__obs_op_adj_pdaf,
                                        py__init_n_domains_p_pdaf,
                                        py__init_dim_l_pdaf,
                                        py__init_dim_obs_l_pdaf,
                                        py__prepoststep_pdaf,
                                        int outflag
                                       ):
    """Using 3DEnVar for DA without post-processing and analysis distribution to forecsat with diagonal observation error covariance matrix.
    Here, the background error covariance is hybridised by a static background error covariance, and a flow-dependent background error covariance estimated from ensemble. The 3DVar generates an ensemble mean and the ensemble perturbation is generated by
    LESTKF in this implementation. 
    
    This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_ens_pdaf
    6. py__obs_op_lin_pdaf
    7. py__obs_op_adj_pdaf
    8. py__cvt_adj_ens_pdaf
    9. core DA algorithm
    After the iterations: 
    10. py__cvt_ens_pdaf
    Perform LESTKF: 
    11. py__init_n_domains_p_pdaf
    12. py__init_dim_obs_pdaf
    13. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    14. py__init_dim_l_pdaf
    15. py__init_dim_obs_l_pdaf (localise mean ensemble in observation space)
    16. core DA algorith
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], v_p : ndarray[tuple[dim_cvec_ens], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_ens** : int

            * Ensemble size

        * **dim_cvec_ens** : int

            * Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_ens** : int

            * Ensemble size

        * **dim_cv_ens_p** : int

            * PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p : ndarray[tuple[dim_cvec], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.cvt_ens_pdaf = <void*>py__cvt_ens_pdaf
    c__PDAFcython.cvt_adj_ens_pdaf = <void*>py__cvt_adj_ens_pdaf
    c__PDAFcython.cvt_pdaf = <void*>py__cvt_pdaf
    c__PDAFcython.cvt_adj_pdaf = <void*>py__cvt_adj_pdaf
    c__PDAFcython.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    c__PDAFcython.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf

    c__pdaflocalomi_put_state_hyb3dvar_lestkf (c__PDAFcython.c__collect_state_pdaf,
                                               c__PDAFcython.c__init_dim_obs_pdaf,
                                               c__PDAFcython.c__obs_op_pdaf,
                                               c__PDAFcython.c__cvt_ens_pdaf,
                                               c__PDAFcython.c__cvt_adj_ens_pdaf,
                                               c__PDAFcython.c__cvt_pdaf,
                                               c__PDAFcython.c__cvt_adj_pdaf,
                                               c__PDAFcython.c__obs_op_lin_pdaf,
                                               c__PDAFcython.c__obs_op_adj_pdaf,
                                               c__PDAFcython.c__init_n_domains_p_pdaf,
                                               c__PDAFcython.c__init_dim_l_pdaf,
                                               c__PDAFcython.c__init_dim_obs_l_pdaf,
                                               c__PDAFcython.c__prepoststep_pdaf,
                                               &outflag
                                              )

    return outflag

def localomi_put_state_hyb3dvar_lestkf_nondiagR (py__collect_state_pdaf,
                                                 py__init_dim_obs_pdaf,
                                                 py__obs_op_pdaf,
                                                 py__prodRinvA_pdaf,
                                                 py__cvt_ens_pdaf,
                                                 py__cvt_adj_ens_pdaf,
                                                 py__cvt_pdaf,
                                                 py__cvt_adj_pdaf,
                                                 py__obs_op_lin_pdaf,
                                                 py__obs_op_adj_pdaf,
                                                 py__prodRinvA_l_pdaf,
                                                 py__init_n_domains_p_pdaf,
                                                 py__init_dim_l_pdaf,
                                                 py__init_dim_obs_l_pdaf,
                                                 py__prepoststep_pdaf,
                                                 int outflag
                                                ):
    """Using Hybrid 3DEnVar for DA with non-diagonal observation error covariance matrix
    without post-processing and analysis distribution to forecsat without OMI. Here, the background error covariance is hybridised by a static background error covariance, and a flow-dependent background error covariance estimated from ensemble. The 3DVar generates an ensemble mean and the ensemble perturbation is generated by
    LESTKF in this implementation. This function should be called at each model time step. 
    
    This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_pdaf
    6. py__cvt_ens_pdaf
    7. py__obs_op_lin_pdaf
    8. py__prodRinvA_pdaf
    9. py__obs_op_adj_pdaf
    10. py__cvt_adj_pdaf
    11. py__cvt_adj_ens_pdaf
    12. core DA algorithm
    After the iterations: 
    13. py__cvt_pdaf
    14. py__cvt_ens_pdaf
    Perform LESTKF: 
    15. py__init_n_domains_p_pdaf
    16. py__init_dim_obs_pdaf
    17. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    18. py__init_dim_l_pdaf
    19. py__init_dim_obs_l_pdaf
    20. py__init_obs_l_pdaf
    21. py__prodRinvA_l_pdaf
    22. core DA algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], A_p : ndarray[tuple[dim_obs_p, rank], np.float64], C_p : ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], v_p : ndarray[tuple[dim_cvec_ens], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_ens** : int

            * Ensemble size

        * **dim_cvec_ens** : int

            * Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_ens** : int

            * Ensemble size

        * **dim_cv_ens_p** : int

            * PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p : ndarray[tuple[dim_cvec], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], A_l : ndarray[tuple[dim_obs_l, rank], np.float64], C_l : ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.prodRinvA_pdaf = <void*>py__prodRinvA_pdaf
    c__PDAFcython.cvt_ens_pdaf = <void*>py__cvt_ens_pdaf
    c__PDAFcython.cvt_adj_ens_pdaf = <void*>py__cvt_adj_ens_pdaf
    c__PDAFcython.cvt_pdaf = <void*>py__cvt_pdaf
    c__PDAFcython.cvt_adj_pdaf = <void*>py__cvt_adj_pdaf
    c__PDAFcython.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    c__PDAFcython.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    c__PDAFcython.prodRinvA_l_pdaf = <void*>py__prodRinvA_l_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf

    c__pdaflocalomi_put_state_hyb3dvar_lestkf_nondiagr (c__PDAFcython.c__collect_state_pdaf,
                                                        c__PDAFcython.c__init_dim_obs_pdaf,
                                                        c__PDAFcython.c__obs_op_pdaf,
                                                        c__PDAFcython.c__prodRinvA_pdaf,
                                                        c__PDAFcython.c__cvt_ens_pdaf,
                                                        c__PDAFcython.c__cvt_adj_ens_pdaf,
                                                        c__PDAFcython.c__cvt_pdaf,
                                                        c__PDAFcython.c__cvt_adj_pdaf,
                                                        c__PDAFcython.c__obs_op_lin_pdaf,
                                                        c__PDAFcython.c__obs_op_adj_pdaf,
                                                        c__PDAFcython.c__prodRinvA_l_pdaf,
                                                        c__PDAFcython.c__init_n_domains_p_pdaf,
                                                        c__PDAFcython.c__init_dim_l_pdaf,
                                                        c__PDAFcython.c__init_dim_obs_l_pdaf,
                                                        c__PDAFcython.c__prepoststep_pdaf,
                                                        &outflag
                                                       )

    return outflag

def localomi_put_state_lknetf_nondiagR (py__collect_state_pdaf,
                                        py__init_dim_obs_pdaf,
                                        py__obs_op_pdaf,
                                        py__prepoststep_pdaf,
                                        py__init_n_domains_p_pdaf,
                                        py__init_dim_l_pdaf,
                                        py__init_dim_obs_l_pdaf,
                                        py__prodRinvA_l_pdaf,
                                        py__prodRinvA_hyb_l_pdaf,
                                        py__likelihood_l_pdaf,
                                        py__likelihood_hyb_l_pdaf,
                                        int outflag
                                       ):
    """Using LKNETF for DA with non-diagonal observation error covariance matrix without post-processing and analysis distribution to forecsat without OMI. This function should be called at each model time step. 
    
    This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    6. py__init_dim_l_pdaf
    7. py__init_dim_obs_l_pdaf
    8. py__prodRinvA_pdaf
    9. py__likelihood_l_pdaf
    10. core DA algorithm
    11. py__obs_op_pdaf (only called with `HKN` and `HNK` options called for each ensemble member
    12. py__likelihood_hyb_l_pda
    13. py__prodRinvA_hyb_l_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], A_l : ndarray[tuple[dim_obs_l, rank], np.float64], C_l : ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

    py__prodRinvA_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, dim_ens:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], gamma:float, A_l : ndarray[tuple[dim_obs_l, dim_ens], np.float64], C_l : ndarray[tuple[dim_obs_l, dim_ens], np.float64]]
        Product R^-1 A on local analysis domain with hybrid weight

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **dim_ens** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **gamma** : float

            * Hybrid weight provided by PDAF

        * **A_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            * Output matrix

    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], resid_l : ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute likelihood and apply localization

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            * nput vector holding the local residual

        * **likely_l** : float

            * Output value of the local likelihood

        **Callback Returns**

        * **likely_l** : float

            * Output value of the local likelihood

    py__likelihood_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], resid_l : ndarray[tuple[dim_obs_l], np.float64], gamma:float, likely_l:float]
        Compute likelihood and apply localization with tempering

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Input vector holding the local residual

        * **gamma** : float

            * Hybrid weight provided by PDAF

        * **likely_l** : float

            * Output value of the local likelihood

        **Callback Returns**

        * **likely_l** : float

            * Output value of the local likelihood

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.prodRinvA_l_pdaf = <void*>py__prodRinvA_l_pdaf
    c__PDAFcython.prodRinvA_hyb_l_pdaf = <void*>py__prodRinvA_hyb_l_pdaf
    c__PDAFcython.likelihood_l_pdaf = <void*>py__likelihood_l_pdaf
    c__PDAFcython.likelihood_hyb_l_pdaf = <void*>py__likelihood_hyb_l_pdaf

    c__pdaflocalomi_put_state_lknetf_nondiagr (c__PDAFcython.c__collect_state_pdaf,
                                               c__PDAFcython.c__init_dim_obs_pdaf,
                                               c__PDAFcython.c__obs_op_pdaf,
                                               c__PDAFcython.c__prepoststep_pdaf,
                                               c__PDAFcython.c__init_n_domains_p_pdaf,
                                               c__PDAFcython.c__init_dim_l_pdaf,
                                               c__PDAFcython.c__init_dim_obs_l_pdaf,
                                               c__PDAFcython.c__prodRinvA_l_pdaf,
                                               c__PDAFcython.c__prodRinvA_hyb_l_pdaf,
                                               c__PDAFcython.c__likelihood_l_pdaf,
                                               c__PDAFcython.c__likelihood_hyb_l_pdaf,
                                               &outflag
                                              )

    return outflag

def localomi_put_state_lnetf_nondiagR (py__collect_state_pdaf,
                                       py__init_dim_obs_pdaf,
                                       py__obs_op_pdaf,
                                       py__prepoststep_pdaf,
                                       py__init_n_domains_p_pdaf,
                                       py__init_dim_l_pdaf,
                                       py__init_dim_obs_l_pdaf,
                                       py__likelihood_l_pdaf,
                                       int outflag
                                      ):
    """Using LNETF for DA with non-diagonal observation error covariance matrix without post-processing and analysis distribution to forecsat without OMI. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.omi_put_state_lnetf_nondiagR` This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    6. py__init_dim_l_pdaf
    7. py__init_dim_obs_l_pdaf
    8. py__likelihood_l_pdaf
    9. core DA algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], resid_l : ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute likelihood and apply localization

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            * nput vector holding the local residual

        * **likely_l** : float

            * Output value of the local likelihood

        **Callback Returns**

        * **likely_l** : float

            * Output value of the local likelihood

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.likelihood_l_pdaf = <void*>py__likelihood_l_pdaf

    c__pdaflocalomi_put_state_lnetf_nondiagr (c__PDAFcython.c__collect_state_pdaf,
                                              c__PDAFcython.c__init_dim_obs_pdaf,
                                              c__PDAFcython.c__obs_op_pdaf,
                                              c__PDAFcython.c__prepoststep_pdaf,
                                              c__PDAFcython.c__init_n_domains_p_pdaf,
                                              c__PDAFcython.c__init_dim_l_pdaf,
                                              c__PDAFcython.c__init_dim_obs_l_pdaf,
                                              c__PDAFcython.c__likelihood_l_pdaf,
                                              &outflag
                                             )

    return outflag

def localomi_put_state_nondiagR (py__collect_state_pdaf,
                                 py__init_dim_obs_pdaf,
                                 py__obs_op_pdaf,
                                 py__prepoststep_pdaf,
                                 py__init_n_domains_p_pdaf,
                                 py__init_dim_l_pdaf,
                                 py__init_dim_obs_l_pdaf,
                                 py__prodRinvA_l_pdaf,
                                 int outflag
                                ):
    """Using domain localised filters for DA with non-diagonal observation error covariance matrix without post-processing and analysis distribution to forecsat without OMI. This function should be called at each model time step. 
    
    This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    6. py__init_dim_l_pdaf
    7. py__init_dim_obs_l_pdaf
    9. py__init_obs_l_pdaf
    10. py__prodRinvA_l_pdaf
    11. core DA algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], A_l : ndarray[tuple[dim_obs_l, rank], np.float64], C_l : ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product of inverse of R with matrix A

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.prodRinvA_l_pdaf = <void*>py__prodRinvA_l_pdaf

    c__pdaflocalomi_put_state_nondiagr (c__PDAFcython.c__collect_state_pdaf,
                                        c__PDAFcython.c__init_dim_obs_pdaf,
                                        c__PDAFcython.c__obs_op_pdaf,
                                        c__PDAFcython.c__prepoststep_pdaf,
                                        c__PDAFcython.c__init_n_domains_p_pdaf,
                                        c__PDAFcython.c__init_dim_l_pdaf,
                                        c__PDAFcython.c__init_dim_obs_l_pdaf,
                                        c__PDAFcython.c__prodRinvA_l_pdaf,
                                        &outflag
                                       )

    return outflag

def local_assimilate_en3dvar_lestkf (py__collect_state_pdaf,
                                     py__distribute_state_pdaf,
                                     py__init_dim_obs_pdaf,
                                     py__obs_op_pdaf,
                                     py__init_obs_pdaf,
                                     py__prodRinvA_pdaf,
                                     py__cvt_ens_pdaf,
                                     py__cvt_adj_ens_pdaf,
                                     py__obs_op_lin_pdaf,
                                     py__obs_op_adj_pdaf,
                                     py__init_dim_obs_f_pdaf,
                                     py__obs_op_f_pdaf,
                                     py__init_obs_f_pdaf,
                                     py__init_obs_l_pdaf,
                                     py__prodRinvA_l_pdaf,
                                     py__init_n_domains_p_pdaf,
                                     py__init_dim_l_pdaf,
                                     py__init_dim_obs_l_pdaf,
                                     py__g2l_obs_pdaf,
                                     py__init_obsvar_pdaf,
                                     py__init_obsvar_l_pdaf,
                                     py__prepoststep_pdaf,
                                     py__next_observation_pdaf
                                    ):
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency.
    I.e., `pyPDAF.PDAF.localomi_assimilate_en3dvar_lestkf` or `pyPDAF.PDAF.localomi_assimilate_en3dvar_lestkf_nondiagR`. 
    
    
    Using 3DEnVar for DA without OMI.
    The background error covariance matrix is estimated by ensemble. The 3DEnVar only calculates the analysis of the ensemble mean.
    An LESTKF is used to generate ensemble perturbations. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.local_put_state_en3dvar_lestkf`
    and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    5. py__init_obs_pdaf
    Starting the iterative optimisation:
    6. py__cvt_ens_pdaf
    7. py__obs_op_lin_pdaf
    8. py__prodRinvA_pdaf
    9. py__obs_op_adj_pdaf
    10. py__cvt_adj_ens_pdaf
    11. core DA algorithm
    After the iterations: 
    12. py__cvt_ens_pdaf
    Perform LESTKF: 
    13. py__init_n_domains_p_pdaf
    14. py__init_dim_obs_pdaf
    15. py__obs_op_pdaf (for each ensemble member
    16. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init
    17. py__init_obsvar_pdaf (if global adaptive forgetting factor is used
    loop over each local domain:
    18. py__init_dim_l_pdaf
    19. py__init_dim_obs_l_pdaf
    20. py__g2l_obs_pdaf (localise mean ensemble in observation space)
    21. py__init_obs_l_pdaf
    22. py__g2l_obs_pdaf (localise each ensemble member in observation space
    23. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used
    24. py__prodRinvA_l_pdaf
    25. core DA algorithm
    26. py__prepoststep_state_pdaf
    27. py__distribute_state_pdaf
    28. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], A_p : ndarray[tuple[dim_obs_p, rank], np.float64], C_p : ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], v_p : ndarray[tuple[dim_cvec_ens], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_ens** : int

            * Ensemble size

        * **dim_cvec_ens** : int

            * Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_ens** : int

            * Ensemble size

        * **dim_cv_ens_p** : int

            * PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f : ndarray[tuple[dim_obs_f], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_f** : int

            * Size of the full observation vector

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of observations

        **Callback Returns**

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of observations

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l : ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], A_l : ndarray[tuple[dim_obs_l, rank], np.float64], C_l : ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f : ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l : ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_f** : int

            * Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            * Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * **dim_p** : int

            * Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * **dim_l** : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **meanvar** : float

            * Mean observation error variance

        **Callback Returns**

        * **meanvar** : float

            * Mean observation error variance

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * **dim_obs_p** : int

            * Dimension of local observation vector

        * **meanvar_l** : float

            * Mean local observation error variance

        **Callback Returns**

        * **meanvar_l** : float

            * Mean local observation error variance

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time


    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.prodRinvA_pdaf = <void*>py__prodRinvA_pdaf
    c__PDAFcython.cvt_ens_pdaf = <void*>py__cvt_ens_pdaf
    c__PDAFcython.cvt_adj_ens_pdaf = <void*>py__cvt_adj_ens_pdaf
    c__PDAFcython.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    c__PDAFcython.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    c__PDAFcython.init_dim_obs_f_pdaf = <void*>py__init_dim_obs_f_pdaf
    c__PDAFcython.obs_op_f_pdaf = <void*>py__obs_op_f_pdaf
    c__PDAFcython.init_obs_f_pdaf = <void*>py__init_obs_f_pdaf
    c__PDAFcython.init_obs_l_pdaf = <void*>py__init_obs_l_pdaf
    c__PDAFcython.prodRinvA_l_pdaf = <void*>py__prodRinvA_l_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.g2l_obs_pdaf = <void*>py__g2l_obs_pdaf
    c__PDAFcython.init_obsvar_pdaf = <void*>py__init_obsvar_pdaf
    c__PDAFcython.init_obsvar_l_pdaf = <void*>py__init_obsvar_l_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    cdef int outflag

    c__pdaflocal_assimilate_en3dvar_lestkf (c__PDAFcython.c__collect_state_pdaf,
                                            c__PDAFcython.c__distribute_state_pdaf,
                                            c__PDAFcython.c__init_dim_obs_pdaf,
                                            c__PDAFcython.c__obs_op_pdaf,
                                            c__PDAFcython.c__init_obs_pdaf,
                                            c__PDAFcython.c__prodRinvA_pdaf,
                                            c__PDAFcython.c__cvt_ens_pdaf,
                                            c__PDAFcython.c__cvt_adj_ens_pdaf,
                                            c__PDAFcython.c__obs_op_lin_pdaf,
                                            c__PDAFcython.c__obs_op_adj_pdaf,
                                            c__PDAFcython.c__init_dim_obs_f_pdaf,
                                            c__PDAFcython.c__obs_op_f_pdaf,
                                            c__PDAFcython.c__init_obs_f_pdaf,
                                            c__PDAFcython.c__init_obs_l_pdaf,
                                            c__PDAFcython.c__prodRinvA_l_pdaf,
                                            c__PDAFcython.c__init_n_domains_p_pdaf,
                                            c__PDAFcython.c__init_dim_l_pdaf,
                                            c__PDAFcython.c__init_dim_obs_l_pdaf,
                                            c__PDAFcython.c__g2l_obs_pdaf,
                                            c__PDAFcython.c__init_obsvar_pdaf,
                                            c__PDAFcython.c__init_obsvar_l_pdaf,
                                            c__PDAFcython.c__prepoststep_pdaf,
                                            c__PDAFcython.c__next_observation_pdaf,
                                            &outflag
                                           )

    return outflag

def local_assimilate_hyb3dvar_lestkf (py__collect_state_pdaf,
                                      py__distribute_state_pdaf,
                                      py__init_dim_obs_pdaf,
                                      py__obs_op_pdaf,
                                      py__init_obs_pdaf,
                                      py__prodRinvA_pdaf,
                                      py__cvt_ens_pdaf,
                                      py__cvt_adj_ens_pdaf,
                                      py__cvt_pdaf,
                                      py__cvt_adj_pdaf,
                                      py__obs_op_lin_pdaf,
                                      py__obs_op_adj_pdaf,
                                      py__init_dim_obs_f_pdaf,
                                      py__obs_op_f_pdaf,
                                      py__init_obs_f_pdaf,
                                      py__init_obs_l_pdaf,
                                      py__prodRinvA_l_pdaf,
                                      py__init_n_domains_p_pdaf,
                                      py__init_dim_l_pdaf,
                                      py__init_dim_obs_l_pdaf,
                                      py__g2l_obs_pdaf,
                                      py__init_obsvar_pdaf,
                                      py__init_obsvar_l_pdaf,
                                      py__prepoststep_pdaf,
                                      py__next_observation_pdaf
                                     ):
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency.
    I.e., `pyPDAF.PDAF.localomi_assimilate_hyb3dvar_lestkf` or `pyPDAF.PDAF.localomi_assimilate_hyb3dvar_lestkf_nondiagR`. 
    
    
    Using Hybrid 3DEnVar for DA without OMI.
    Here, the background error covariance is hybridised by a static background error covariance, and a flow-dependent background error covariance estimated from ensemble. The 3DVar generates an ensemble mean and the ensemble perturbation is generated by
    LESTKF in this implementation. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.local_put_state_hyb3dvar_lestkf`
    and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    5. py__init_obs_pdaf
    Starting the iterative optimisation:
    6. py__cvt_pdaf
    7. py__cvt_ens_pdaf
    8. py__obs_op_lin_pdaf
    9. py__prodRinvA_pdaf
    10. py__obs_op_adj_pdaf
    11. py__cvt_adj_pdaf
    12. py__cvt_adj_ens_pdaf
    13. core DA algorithm
    After the iterations: 
    14. py__cvt_pdaf
    15. py__cvt_ens_pdaf
    Perform LESTKF: 
    16. py__init_n_domains_p_pdaf
    17. py__init_dim_obs_pdaf
    18. py__obs_op_pdaf (for each ensemble member
    19. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in `pyPDAF.PDAF.init`))
    20. py__init_obsvar_pdaf (if global adaptive forgetting factor is used)
    loop over each local domain:
    21. py__init_dim_l_pdaf
    22. py__init_dim_obs_l_pdaf
    23. py__g2l_obs_pdaf (localise mean ensemble in observation space)
    24. py__init_obs_l_pdaf
    25. py__g2l_obs_pdaf (localise each ensemble member in observation space)
    26. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used)
    27. py__prodRinvA_l_pdaf
    28. core DA algorithm
    29. py__prepoststep_state_pdaf
    30. py__distribute_state_pdaf
    31. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], A_p : ndarray[tuple[dim_obs_p, rank], np.float64], C_p : ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], v_p : ndarray[tuple[dim_cvec_ens], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_ens** : int

            * Ensemble size

        * **dim_cvec_ens** : int

            * Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_ens** : int

            * Ensemble size

        * **dim_cv_ens_p** : int

            * PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p : ndarray[tuple[dim_cvec], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f : ndarray[tuple[dim_obs_f], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_f** : int

            * Size of the full observation vector

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of observations

        **Callback Returns**

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of observations

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l : ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], A_l : ndarray[tuple[dim_obs_l, rank], np.float64], C_l : ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f : ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l : ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_f** : int

            * Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            * Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * **dim_p** : int

            * Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * **dim_l** : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **meanvar** : float

            * Mean observation error variance

        **Callback Returns**

        * **meanvar** : float

            * Mean observation error variance

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * **dim_obs_p** : int

            * Dimension of local observation vector

        * **meanvar_l** : float

            * Mean local observation error variance

        **Callback Returns**

        * **meanvar_l** : float

            * Mean local observation error variance

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time


    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.prodRinvA_pdaf = <void*>py__prodRinvA_pdaf
    c__PDAFcython.cvt_ens_pdaf = <void*>py__cvt_ens_pdaf
    c__PDAFcython.cvt_adj_ens_pdaf = <void*>py__cvt_adj_ens_pdaf
    c__PDAFcython.cvt_pdaf = <void*>py__cvt_pdaf
    c__PDAFcython.cvt_adj_pdaf = <void*>py__cvt_adj_pdaf
    c__PDAFcython.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    c__PDAFcython.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    c__PDAFcython.init_dim_obs_f_pdaf = <void*>py__init_dim_obs_f_pdaf
    c__PDAFcython.obs_op_f_pdaf = <void*>py__obs_op_f_pdaf
    c__PDAFcython.init_obs_f_pdaf = <void*>py__init_obs_f_pdaf
    c__PDAFcython.init_obs_l_pdaf = <void*>py__init_obs_l_pdaf
    c__PDAFcython.prodRinvA_l_pdaf = <void*>py__prodRinvA_l_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.g2l_obs_pdaf = <void*>py__g2l_obs_pdaf
    c__PDAFcython.init_obsvar_pdaf = <void*>py__init_obsvar_pdaf
    c__PDAFcython.init_obsvar_l_pdaf = <void*>py__init_obsvar_l_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    cdef int outflag

    c__pdaflocal_assimilate_hyb3dvar_lestkf (c__PDAFcython.c__collect_state_pdaf,
                                             c__PDAFcython.c__distribute_state_pdaf,
                                             c__PDAFcython.c__init_dim_obs_pdaf,
                                             c__PDAFcython.c__obs_op_pdaf,
                                             c__PDAFcython.c__init_obs_pdaf,
                                             c__PDAFcython.c__prodRinvA_pdaf,
                                             c__PDAFcython.c__cvt_ens_pdaf,
                                             c__PDAFcython.c__cvt_adj_ens_pdaf,
                                             c__PDAFcython.c__cvt_pdaf,
                                             c__PDAFcython.c__cvt_adj_pdaf,
                                             c__PDAFcython.c__obs_op_lin_pdaf,
                                             c__PDAFcython.c__obs_op_adj_pdaf,
                                             c__PDAFcython.c__init_dim_obs_f_pdaf,
                                             c__PDAFcython.c__obs_op_f_pdaf,
                                             c__PDAFcython.c__init_obs_f_pdaf,
                                             c__PDAFcython.c__init_obs_l_pdaf,
                                             c__PDAFcython.c__prodRinvA_l_pdaf,
                                             c__PDAFcython.c__init_n_domains_p_pdaf,
                                             c__PDAFcython.c__init_dim_l_pdaf,
                                             c__PDAFcython.c__init_dim_obs_l_pdaf,
                                             c__PDAFcython.c__g2l_obs_pdaf,
                                             c__PDAFcython.c__init_obsvar_pdaf,
                                             c__PDAFcython.c__init_obsvar_l_pdaf,
                                             c__PDAFcython.c__prepoststep_pdaf,
                                             c__PDAFcython.c__next_observation_pdaf,
                                             &outflag
                                            )

    return outflag

def local_assimilate_lestkf (py__collect_state_pdaf,
                             py__distribute_state_pdaf,
                             py__init_dim_obs_pdaf,
                             py__obs_op_pdaf,
                             py__init_obs_pdaf,
                             py__init_obs_l_pdaf,
                             py__prepoststep_pdaf,
                             py__prodRinvA_l_pdaf,
                             py__init_n_domains_p_pdaf,
                             py__init_dim_l_pdaf,
                             py__init_dim_obs_l_pdaf,
                             py__g2l_obs_pdaf,
                             py__init_obsvar_pdaf,
                             py__init_obsvar_l_pdaf,
                             py__next_observation_pdaf
                            ):
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_assimilate` or `pyPDAF.PDAF.localomi_assimilate_nondiagR`. 
    Using Local ESTKF (error space transform Kalman filter) for DA without OMI. This is a domain localisation method. This function should be called at each model time step. The LESTKF is a more efficient equivalent to the LETKF. 
    
    The function is a combination of `pyPDAF.PDAF.local_put_state_lestkf` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    6. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init
    7. py__init_obsvar_pdaf (if global adaptive forgetting factor is used
    loop over each local domain:
    8. py__init_dim_l_pdaf
    9. py__init_dim_obs_l_pdaf
    10. py__g2l_obs_pdaf (localise mean ensemble in observation space)
    11. py__init_obs_l_pdaf
    12. py__g2l_obs_pdaf (localise each ensemble member in observation space
    13. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used
    14. py__prodRinvA_l_pdaf
    15. core DA algorithm
    16. py__prepoststep_state_pdaf
    17. py__distribute_state_pdaf (18. py__next_observation_pdaf 
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l : ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], A_l : ndarray[tuple[dim_obs_l, rank], np.float64], C_l : ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f : ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l : ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_f** : int

            * Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            * Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * **dim_p** : int

            * Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * **dim_l** : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **meanvar** : float

            * Mean observation error variance

        **Callback Returns**

        * **meanvar** : float

            * Mean observation error variance

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * **dim_obs_p** : int

            * Dimension of local observation vector

        * **meanvar_l** : float

            * Mean local observation error variance

        **Callback Returns**

        * **meanvar_l** : float

            * Mean local observation error variance

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time


    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.init_obs_l_pdaf = <void*>py__init_obs_l_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.prodRinvA_l_pdaf = <void*>py__prodRinvA_l_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.g2l_obs_pdaf = <void*>py__g2l_obs_pdaf
    c__PDAFcython.init_obsvar_pdaf = <void*>py__init_obsvar_pdaf
    c__PDAFcython.init_obsvar_l_pdaf = <void*>py__init_obsvar_l_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    cdef int outflag

    c__pdaflocal_assimilate_lestkf (c__PDAFcython.c__collect_state_pdaf,
                                    c__PDAFcython.c__distribute_state_pdaf,
                                    c__PDAFcython.c__init_dim_obs_pdaf,
                                    c__PDAFcython.c__obs_op_pdaf,
                                    c__PDAFcython.c__init_obs_pdaf,
                                    c__PDAFcython.c__init_obs_l_pdaf,
                                    c__PDAFcython.c__prepoststep_pdaf,
                                    c__PDAFcython.c__prodRinvA_l_pdaf,
                                    c__PDAFcython.c__init_n_domains_p_pdaf,
                                    c__PDAFcython.c__init_dim_l_pdaf,
                                    c__PDAFcython.c__init_dim_obs_l_pdaf,
                                    c__PDAFcython.c__g2l_obs_pdaf,
                                    c__PDAFcython.c__init_obsvar_pdaf,
                                    c__PDAFcython.c__init_obsvar_l_pdaf,
                                    c__PDAFcython.c__next_observation_pdaf,
                                    &outflag
                                   )

    return outflag

def local_assimilate_letkf (py__collect_state_pdaf,
                            py__distribute_state_pdaf,
                            py__init_dim_obs_pdaf,
                            py__obs_op_pdaf,
                            py__init_obs_pdaf,
                            py__init_obs_l_pdaf,
                            py__prepoststep_pdaf,
                            py__prodRinvA_l_pdaf,
                            py__init_n_domains_p_pdaf,
                            py__init_dim_l_pdaf,
                            py__init_dim_obs_l_pdaf,
                            py__g2l_obs_pdaf,
                            py__init_obsvar_pdaf,
                            py__init_obsvar_l_pdaf,
                            py__next_observation_pdaf
                           ):
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_assimilate` or `pyPDAF.PDAF.localomi_assimilate_nondiagR`. 
    Using local ensemble transform Kalman filter for DA without OMI. This is a domain localisation method. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.local_put_state_letkf` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    6. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init
    7. py__init_obsvar_pdaf (if global adaptive forgetting factor is used
    loop over each local domain:
    8. py__init_dim_l_pdaf
    9. py__init_dim_obs_l_pdaf
    10. py__g2l_obs_pdaf (localise mean ensemble in observation space)
    11. py__init_obs_l_pdaf
    12. py__g2l_obs_pdaf (localise each ensemble member in observation space
    13. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used
    14. py__prodRinvA_l_pdaf
    15. core DA algorithm
    16. py__prepoststep_state_pdaf
    17. py__distribute_state_pdaf
    18. py__next_observation_pdaf 
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l : ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], A_l : ndarray[tuple[dim_obs_l, rank], np.float64], C_l : ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f : ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l : ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_f** : int

            * Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            * Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * **dim_p** : int

            * Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * **dim_l** : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **meanvar** : float

            * Mean observation error variance

        **Callback Returns**

        * **meanvar** : float

            * Mean observation error variance

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * **dim_obs_p** : int

            * Dimension of local observation vector

        * **meanvar_l** : float

            * Mean local observation error variance

        **Callback Returns**

        * **meanvar_l** : float

            * Mean local observation error variance

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time


    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.init_obs_l_pdaf = <void*>py__init_obs_l_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.prodRinvA_l_pdaf = <void*>py__prodRinvA_l_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.g2l_obs_pdaf = <void*>py__g2l_obs_pdaf
    c__PDAFcython.init_obsvar_pdaf = <void*>py__init_obsvar_pdaf
    c__PDAFcython.init_obsvar_l_pdaf = <void*>py__init_obsvar_l_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    cdef int outflag

    c__pdaflocal_assimilate_letkf (c__PDAFcython.c__collect_state_pdaf,
                                   c__PDAFcython.c__distribute_state_pdaf,
                                   c__PDAFcython.c__init_dim_obs_pdaf,
                                   c__PDAFcython.c__obs_op_pdaf,
                                   c__PDAFcython.c__init_obs_pdaf,
                                   c__PDAFcython.c__init_obs_l_pdaf,
                                   c__PDAFcython.c__prepoststep_pdaf,
                                   c__PDAFcython.c__prodRinvA_l_pdaf,
                                   c__PDAFcython.c__init_n_domains_p_pdaf,
                                   c__PDAFcython.c__init_dim_l_pdaf,
                                   c__PDAFcython.c__init_dim_obs_l_pdaf,
                                   c__PDAFcython.c__g2l_obs_pdaf,
                                   c__PDAFcython.c__init_obsvar_pdaf,
                                   c__PDAFcython.c__init_obsvar_l_pdaf,
                                   c__PDAFcython.c__next_observation_pdaf,
                                   &outflag
                                  )

    return outflag

def local_assimilate_lknetf (py__collect_state_pdaf,
                             py__distribute_state_pdaf,
                             py__init_dim_obs_pdaf,
                             py__obs_op_pdaf,
                             py__init_obs_pdaf,
                             py__init_obs_l_pdaf,
                             py__prepoststep_pdaf,
                             py__prodRinvA_l_pdaf,
                             py__prodRinvA_hyb_l_pdaf,
                             py__init_n_domains_p_pdaf,
                             py__init_dim_l_pdaf,
                             py__init_dim_obs_l_pdaf,
                             py__g2l_obs_pdaf,
                             py__init_obsvar_pdaf,
                             py__init_obsvar_l_pdaf,
                             py__likelihood_l_pdaf,
                             py__likelihood_hyb_l_pdaf,
                             py__next_observation_pdaf
                            ):
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_assimilate` or `pyPDAF.PDAF.localomi_assimilate_lknetf_nondiagR`. 
    This function will is a hybridised LETKF and LNETF for DA without OMI. The LNETF computes the distribution up to the second moment similar to KF but using a nonlinear weighting similar to particle filter. This leads to an equal weights assumption for prior ensemble. The hybridisation with LETKF is expected to lead to improved performance for quasi-Gaussian problems. The function should be called at each model step. 
    
    The function is a combination of `pyPDAF.PDAF.local_put_state_lknetf` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf 
    2. py__prepoststep_state_pdaf 
    3. py__init_n_domains_p_pdaf 
    4. py__init_dim_obs_pdaf 
    5. py__obs_op_pdaf (for each ensemble member)
    6. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in `pyPDAF.PDAF.init`
    7. py__init_obsvar_pdaf (if global adaptive forgetting factor is used
    loop over each local domain:
    8. py__init_dim_l_pdaf 
    9. py__init_dim_obs_l_pdaf 
    10. py__g2l_obs_pdaf (localise each ensemble member in observation space
    11. py__init_obs_l_pdaf 
    12. py__init_obsvar_l_pdaf 
(only called if local adaptive forgetting factor (type_forget=2) is used
    13. py__prodRinvA_pdaf 
    14. py__likelihood_l_pdaf 
    15. core DA algorithm 
    16. py__obs_op_pdaf (only called with `HKN` and `HNK` options called for each ensemble member)
    17. py__likelihood_hyb_l_pdaf
    18. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used
    19. py__prodRinvA_hyb_l_pdaf 
    20. py__prepoststep_state_pdaf 
    21. py__distribute_state_pdaf 
    22. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l : ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], A_l : ndarray[tuple[dim_obs_l, rank], np.float64], C_l : ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

    py__prodRinvA_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, dim_ens:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], gamma:float, A_l : ndarray[tuple[dim_obs_l, dim_ens], np.float64], C_l : ndarray[tuple[dim_obs_l, dim_ens], np.float64]]
        Provide product R^-1 A on local analysis domain with hybrid weight

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **dim_ens** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **gamma** : float

            * Hybrid weight provided by PDAF

        * **A_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            * Output matrix

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f : ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l : ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_f** : int

            * Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            * Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * **dim_p** : int

            * Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * **dim_l** : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **meanvar** : float

            * Mean observation error variance

        **Callback Returns**

        * **meanvar** : float

            * Mean observation error variance

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * **dim_obs_p** : int

            * Dimension of local observation vector

        * **meanvar_l** : float

            * Mean local observation error variance

        **Callback Returns**

        * **meanvar_l** : float

            * Mean local observation error variance

    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], resid_l : ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute likelihood

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            * nput vector holding the local residual

        * **likely_l** : float

            * Output value of the local likelihood

        **Callback Returns**

        * **likely_l** : float

            * Output value of the local likelihood

    py__likelihood_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], resid_l : ndarray[tuple[dim_obs_l], np.float64], gamma:float, likely_l:float]
        Compute likelihood with hybrid weight

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Input vector holding the local residual

        * **gamma** : float

            * Hybrid weight provided by PDAF

        * **likely_l** : float

            * Output value of the local likelihood

        **Callback Returns**

        * **likely_l** : float

            * Output value of the local likelihood

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time


    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.init_obs_l_pdaf = <void*>py__init_obs_l_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.prodRinvA_l_pdaf = <void*>py__prodRinvA_l_pdaf
    c__PDAFcython.prodRinvA_hyb_l_pdaf = <void*>py__prodRinvA_hyb_l_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.g2l_obs_pdaf = <void*>py__g2l_obs_pdaf
    c__PDAFcython.init_obsvar_pdaf = <void*>py__init_obsvar_pdaf
    c__PDAFcython.init_obsvar_l_pdaf = <void*>py__init_obsvar_l_pdaf
    c__PDAFcython.likelihood_l_pdaf = <void*>py__likelihood_l_pdaf
    c__PDAFcython.likelihood_hyb_l_pdaf = <void*>py__likelihood_hyb_l_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    cdef int outflag

    c__pdaflocal_assimilate_lknetf (c__PDAFcython.c__collect_state_pdaf,
                                    c__PDAFcython.c__distribute_state_pdaf,
                                    c__PDAFcython.c__init_dim_obs_pdaf,
                                    c__PDAFcython.c__obs_op_pdaf,
                                    c__PDAFcython.c__init_obs_pdaf,
                                    c__PDAFcython.c__init_obs_l_pdaf,
                                    c__PDAFcython.c__prepoststep_pdaf,
                                    c__PDAFcython.c__prodRinvA_l_pdaf,
                                    c__PDAFcython.c__prodRinvA_hyb_l_pdaf,
                                    c__PDAFcython.c__init_n_domains_p_pdaf,
                                    c__PDAFcython.c__init_dim_l_pdaf,
                                    c__PDAFcython.c__init_dim_obs_l_pdaf,
                                    c__PDAFcython.c__g2l_obs_pdaf,
                                    c__PDAFcython.c__init_obsvar_pdaf,
                                    c__PDAFcython.c__init_obsvar_l_pdaf,
                                    c__PDAFcython.c__likelihood_l_pdaf,
                                    c__PDAFcython.c__likelihood_hyb_l_pdaf,
                                    c__PDAFcython.c__next_observation_pdaf,
                                    &outflag
                                   )

    return outflag

def local_assimilate_lnetf (py__collect_state_pdaf,
                            py__distribute_state_pdaf,
                            py__init_dim_obs_pdaf,
                            py__obs_op_pdaf,
                            py__init_obs_l_pdaf,
                            py__prepoststep_pdaf,
                            py__likelihood_l_pdaf,
                            py__init_n_domains_p_pdaf,
                            py__init_dim_l_pdaf,
                            py__init_dim_obs_l_pdaf,
                            py__g2l_obs_pdaf,
                            py__next_observation_pdaf
                           ):
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_assimilate` or `pyPDAF.PDAF.localomi_assimilate_lnetf_nondiagR`. 
    This function will use Local Nonlinear Ensemble Transform Filter (LNETF) for DA without OMI. The nonlinear filter computes the distribution up to the second moment similar to KF but using a nonlinear weighting similar to particle filter. This leads to an equal weights assumption for prior ensemble. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.local_put_state_lnetf` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    6. py__init_dim_l_pdaf
    7. py__init_dim_obs_l_pdaf
    8. py__init_obs_l_pdaf
    9. py__g2l_obs_pdaf (localise each ensemble member in observation space)
    10. py__likelihood_l_pdaf
    11. core DA algorithm
    12. py__prepoststep_state_pdaf
    13. py__distribute_state_pdaf
    14. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l : ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], resid_l : ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            * nput vector holding the local residual

        * **likely_l** : float

            * Output value of the local likelihood

        **Callback Returns**

        * **likely_l** : float

            * Output value of the local likelihood

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f : ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l : ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_f** : int

            * Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            * Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * **dim_p** : int

            * Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * **dim_l** : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time


    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_l_pdaf = <void*>py__init_obs_l_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.likelihood_l_pdaf = <void*>py__likelihood_l_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.g2l_obs_pdaf = <void*>py__g2l_obs_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    cdef int outflag

    c__pdaflocal_assimilate_lnetf (c__PDAFcython.c__collect_state_pdaf,
                                   c__PDAFcython.c__distribute_state_pdaf,
                                   c__PDAFcython.c__init_dim_obs_pdaf,
                                   c__PDAFcython.c__obs_op_pdaf,
                                   c__PDAFcython.c__init_obs_l_pdaf,
                                   c__PDAFcython.c__prepoststep_pdaf,
                                   c__PDAFcython.c__likelihood_l_pdaf,
                                   c__PDAFcython.c__init_n_domains_p_pdaf,
                                   c__PDAFcython.c__init_dim_l_pdaf,
                                   c__PDAFcython.c__init_dim_obs_l_pdaf,
                                   c__PDAFcython.c__g2l_obs_pdaf,
                                   c__PDAFcython.c__next_observation_pdaf,
                                   &outflag
                                  )

    return outflag

def local_assimilate_lseik (py__collect_state_pdaf,
                            py__distribute_state_pdaf,
                            py__init_dim_obs_pdaf,
                            py__obs_op_pdaf,
                            py__init_obs_pdaf,
                            py__init_obs_l_pdaf,
                            py__prepoststep_pdaf,
                            py__prodRinvA_l_pdaf,
                            py__init_n_domains_p_pdaf,
                            py__init_dim_l_pdaf,
                            py__init_dim_obs_l_pdaf,
                            py__g2l_obs_pdaf,
                            py__init_obsvar_pdaf,
                            py__init_obsvar_l_pdaf,
                            py__next_observation_pdaf
                           ):
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_assimilate` or `pyPDAF.PDAF.localomi_assimilate_nondiagR`. 
    Using local singular evolutive interpolated Kalman filter for DA without OMI. This is a domain localisation method. This function should be called at each model time step.
    
    The function is a combination of `pyPDAF.PDAF.local_put_state_lseik` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    6. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init
    7. py__init_obsvar_pdaf (if global adaptive forgetting factor is used
    loop over each local domain:
    8. py__init_dim_l_pdaf
    9. py__init_dim_obs_l_pdaf
    10. py__g2l_obs_pdaf (localise mean ensemble in observation space)
    11. py__init_obs_l_pdaf
    12. py__g2l_obs_pdaf (localise each ensemble member in observation space
    13. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used
    14. py__prodRinvA_l_pdaf
    15. core DA algorithm
    16. py__prepoststep_state_pdaf
    17. py__distribute_state_pdaf
    18. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__distribute_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l : ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], A_l : ndarray[tuple[dim_obs_l, rank], np.float64], C_l : ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f : ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l : ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_f** : int

            * Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            * Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * **dim_p** : int

            * Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * **dim_l** : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **meanvar** : float

            * Mean observation error variance

        **Callback Returns**

        * **meanvar** : float

            * Mean observation error variance

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * **dim_obs_p** : int

            * Dimension of local observation vector

        * **meanvar_l** : float

            * Mean local observation error variance

        **Callback Returns**

        * **meanvar_l** : float

            * Mean local observation error variance

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            * number of the current time step

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time

        **Callback Returns**

        * **nsteps** : int

            * number of time steps until next obs

        * **doexit** : int

            * whether to exit forecasting (1 for exit)

        * **time** : float

            * current model (physical) time


    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.init_obs_l_pdaf = <void*>py__init_obs_l_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.prodRinvA_l_pdaf = <void*>py__prodRinvA_l_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.g2l_obs_pdaf = <void*>py__g2l_obs_pdaf
    c__PDAFcython.init_obsvar_pdaf = <void*>py__init_obsvar_pdaf
    c__PDAFcython.init_obsvar_l_pdaf = <void*>py__init_obsvar_l_pdaf
    c__PDAFcython.next_observation_pdaf = <void*>py__next_observation_pdaf

    cdef int outflag

    c__pdaflocal_assimilate_lseik (c__PDAFcython.c__collect_state_pdaf,
                                   c__PDAFcython.c__distribute_state_pdaf,
                                   c__PDAFcython.c__init_dim_obs_pdaf,
                                   c__PDAFcython.c__obs_op_pdaf,
                                   c__PDAFcython.c__init_obs_pdaf,
                                   c__PDAFcython.c__init_obs_l_pdaf,
                                   c__PDAFcython.c__prepoststep_pdaf,
                                   c__PDAFcython.c__prodRinvA_l_pdaf,
                                   c__PDAFcython.c__init_n_domains_p_pdaf,
                                   c__PDAFcython.c__init_dim_l_pdaf,
                                   c__PDAFcython.c__init_dim_obs_l_pdaf,
                                   c__PDAFcython.c__g2l_obs_pdaf,
                                   c__PDAFcython.c__init_obsvar_pdaf,
                                   c__PDAFcython.c__init_obsvar_l_pdaf,
                                   c__PDAFcython.c__next_observation_pdaf,
                                   &outflag
                                  )

    return outflag

def local_put_state_en3dvar_lestkf (py__collect_state_pdaf,
                                    py__init_dim_obs_pdaf,
                                    py__obs_op_pdaf,
                                    py__init_obs_pdaf,
                                    py__prodRinvA_pdaf,
                                    py__cvt_ens_pdaf,
                                    py__cvt_adj_ens_pdaf,
                                    py__obs_op_lin_pdaf,
                                    py__obs_op_adj_pdaf,
                                    py__init_dim_obs_f_pdaf,
                                    py__obs_op_f_pdaf,
                                    py__init_obs_f_pdaf,
                                    py__init_obs_l_pdaf,
                                    py__prodRinvA_l_pdaf,
                                    py__init_n_domains_p_pdaf,
                                    py__init_dim_l_pdaf,
                                    py__init_dim_obs_l_pdaf,
                                    py__g2l_obs_pdaf,
                                    py__init_obsvar_pdaf,
                                    py__init_obsvar_l_pdaf,
                                    py__prepoststep_pdaf
                                   ):
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency.
    I.e., `pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf` or `pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf_nondiagR`. 
    
    
    Using 3DEnVar for DA without post-processing and analysis distribution to forecsat without OMI.
    The background error covariance matrix is estimated by ensemble. The 3DEnVar only calculates the analysis of the ensemble mean.
    An LESTKF is used to generate ensemble perturbations. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    5. py__init_obs_pdaf
    Starting the iterative optimisation:
    6. py__cvt_ens_pdaf
    7. py__obs_op_lin_pdaf
    8. py__prodRinvA_pdaf
    9. py__obs_op_adj_pdaf
    10. py__cvt_adj_ens_pdaf
    11. core DA algorithm
    After the iterations: 
    12. py__cvt_ens_pdaf
    Perform LESTKF: 
    13. py__init_n_domains_p_pdaf
    14. py__init_dim_obs_pdaf
    15. py__obs_op_pdaf (for each ensemble member
    16. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init
    17. py__init_obsvar_pdaf (if global adaptive forgetting factor is used
    loop over each local domain:
    18. py__init_dim_l_pdaf
    19. py__init_dim_obs_l_pdaf
    20. py__g2l_obs_pdaf (localise mean ensemble in observation space)
    21. py__init_obs_l_pdaf
    22. py__g2l_obs_pdaf (localise each ensemble member in observation space
    23. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used
    24. py__prodRinvA_pdaf
    25. core DA algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], A_p : ndarray[tuple[dim_obs_p, rank], np.float64], C_p : ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], v_p : ndarray[tuple[dim_cvec_ens], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_ens** : int

            * Ensemble size

        * **dim_cvec_ens** : int

            * Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_ens** : int

            * Ensemble size

        * **dim_cv_ens_p** : int

            * PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f : ndarray[tuple[dim_obs_f], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_f** : int

            * Size of the full observation vector

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of observations

        **Callback Returns**

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of observations

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l : ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], A_l : ndarray[tuple[dim_obs_l, rank], np.float64], C_l : ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f : ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l : ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_f** : int

            * Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            * Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * **dim_p** : int

            * Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * **dim_l** : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **meanvar** : float

            * Mean observation error variance

        **Callback Returns**

        * **meanvar** : float

            * Mean observation error variance

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * **dim_obs_p** : int

            * Dimension of local observation vector

        * **meanvar_l** : float

            * Mean local observation error variance

        **Callback Returns**

        * **meanvar_l** : float

            * Mean local observation error variance

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble


    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.prodRinvA_pdaf = <void*>py__prodRinvA_pdaf
    c__PDAFcython.cvt_ens_pdaf = <void*>py__cvt_ens_pdaf
    c__PDAFcython.cvt_adj_ens_pdaf = <void*>py__cvt_adj_ens_pdaf
    c__PDAFcython.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    c__PDAFcython.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    c__PDAFcython.init_dim_obs_f_pdaf = <void*>py__init_dim_obs_f_pdaf
    c__PDAFcython.obs_op_f_pdaf = <void*>py__obs_op_f_pdaf
    c__PDAFcython.init_obs_f_pdaf = <void*>py__init_obs_f_pdaf
    c__PDAFcython.init_obs_l_pdaf = <void*>py__init_obs_l_pdaf
    c__PDAFcython.prodRinvA_l_pdaf = <void*>py__prodRinvA_l_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.g2l_obs_pdaf = <void*>py__g2l_obs_pdaf
    c__PDAFcython.init_obsvar_pdaf = <void*>py__init_obsvar_pdaf
    c__PDAFcython.init_obsvar_l_pdaf = <void*>py__init_obsvar_l_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf

    cdef int outflag

    c__pdaflocal_put_state_en3dvar_lestkf (c__PDAFcython.c__collect_state_pdaf,
                                           c__PDAFcython.c__init_dim_obs_pdaf,
                                           c__PDAFcython.c__obs_op_pdaf,
                                           c__PDAFcython.c__init_obs_pdaf,
                                           c__PDAFcython.c__prodRinvA_pdaf,
                                           c__PDAFcython.c__cvt_ens_pdaf,
                                           c__PDAFcython.c__cvt_adj_ens_pdaf,
                                           c__PDAFcython.c__obs_op_lin_pdaf,
                                           c__PDAFcython.c__obs_op_adj_pdaf,
                                           c__PDAFcython.c__init_dim_obs_f_pdaf,
                                           c__PDAFcython.c__obs_op_f_pdaf,
                                           c__PDAFcython.c__init_obs_f_pdaf,
                                           c__PDAFcython.c__init_obs_l_pdaf,
                                           c__PDAFcython.c__prodRinvA_l_pdaf,
                                           c__PDAFcython.c__init_n_domains_p_pdaf,
                                           c__PDAFcython.c__init_dim_l_pdaf,
                                           c__PDAFcython.c__init_dim_obs_l_pdaf,
                                           c__PDAFcython.c__g2l_obs_pdaf,
                                           c__PDAFcython.c__init_obsvar_pdaf,
                                           c__PDAFcython.c__init_obsvar_l_pdaf,
                                           c__PDAFcython.c__prepoststep_pdaf,
                                           &outflag
                                          )

    return outflag

def local_put_state_hyb3dvar_lestkf (py__collect_state_pdaf,
                                     py__init_dim_obs_pdaf,
                                     py__obs_op_pdaf,
                                     py__init_obs_pdaf,
                                     py__prodRinvA_pdaf,
                                     py__cvt_ens_pdaf,
                                     py__cvt_adj_ens_pdaf,
                                     py__cvt_pdaf,
                                     py__cvt_adj_pdaf,
                                     py__obs_op_lin_pdaf,
                                     py__obs_op_adj_pdaf,
                                     py__init_dim_obs_f_pdaf,
                                     py__obs_op_f_pdaf,
                                     py__init_obs_f_pdaf,
                                     py__init_obs_l_pdaf,
                                     py__prodRinvA_l_pdaf,
                                     py__init_n_domains_p_pdaf,
                                     py__init_dim_l_pdaf,
                                     py__init_dim_obs_l_pdaf,
                                     py__g2l_obs_pdaf,
                                     py__init_obsvar_pdaf,
                                     py__init_obsvar_l_pdaf,
                                     py__prepoststep_pdaf
                                    ):
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency.
    I.e., `pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf` or `pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf_nondiagR`. 
    
    
    Using Hybrid 3DEnVar for DA without post-processing and analysis distribution to forecsat without OMI.
    Here, the background error covariance is hybridised by a static background error covariance, and a flow-dependent background error covariance estimated from ensemble. The 3DVar generates an ensemble mean and the ensemble perturbation is generated by
    LESTKF in this implementation. 
    
    This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    5. py__init_obs_pdaf
    Starting the iterative optimisation:
    6. py__cvt_pdaf
    7. py__cvt_ens_pdaf
    8. py__obs_op_lin_pdaf
    9. py__prodRinvA_pdaf
    10. py__obs_op_adj_pdaf
    11. py__cvt_adj_pdaf
    12. py__cvt_adj_ens_pdaf
    13. core DA algorithm
    After the iterations: 
    14. py__cvt_pdaf
    15. py__cvt_ens_pdaf
    Perform LESTKF: 
    16. py__init_n_domains_p_pdaf
    17. py__init_dim_obs_pdaf
    18. py__obs_op_pdaf (for each ensemble member
    19. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in `pyPDAF.PDAF.init`))
    20. py__init_obsvar_pdaf (if global adaptive forgetting factor is used)
    loop over each local domain:
    21. py__init_dim_l_pdaf
    22. py__init_dim_obs_l_pdaf
    23. py__g2l_obs_pdaf (localise mean ensemble in observation space)
    24. py__init_obs_l_pdaf
    25. py__g2l_obs_pdaf (localise each ensemble member in observation space)
    26. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used)
    27. py__prodRinvA_pdaf
    28. core DA algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], A_p : ndarray[tuple[dim_obs_p, rank], np.float64], C_p : ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], v_p : ndarray[tuple[dim_cvec_ens], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_ens** : int

            * Ensemble size

        * **dim_cvec_ens** : int

            * Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_ens** : int

            * Ensemble size

        * **dim_cv_ens_p** : int

            * PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p : ndarray[tuple[dim_cvec], np.float64], Vv_p : ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p : ndarray[tuple[dim_p], np.float64], cv_p : ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            * Iteration of optimization

        * **dim_p** : int

            * PE-local observation dimension

        * **dim_cvec** : int

            * Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * PE-local dimension of state

        * **dim_obs_p** : int

            * Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f : ndarray[tuple[dim_obs_f], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_f** : int

            * Size of the full observation vector

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of observations

        **Callback Returns**

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of observations

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l : ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], A_l : ndarray[tuple[dim_obs_l, rank], np.float64], C_l : ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f : ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l : ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_f** : int

            * Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            * Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * **dim_p** : int

            * Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * **dim_l** : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **meanvar** : float

            * Mean observation error variance

        **Callback Returns**

        * **meanvar** : float

            * Mean observation error variance

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * **dim_obs_p** : int

            * Dimension of local observation vector

        * **meanvar_l** : float

            * Mean local observation error variance

        **Callback Returns**

        * **meanvar_l** : float

            * Mean local observation error variance

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble


    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.prodRinvA_pdaf = <void*>py__prodRinvA_pdaf
    c__PDAFcython.cvt_ens_pdaf = <void*>py__cvt_ens_pdaf
    c__PDAFcython.cvt_adj_ens_pdaf = <void*>py__cvt_adj_ens_pdaf
    c__PDAFcython.cvt_pdaf = <void*>py__cvt_pdaf
    c__PDAFcython.cvt_adj_pdaf = <void*>py__cvt_adj_pdaf
    c__PDAFcython.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    c__PDAFcython.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    c__PDAFcython.init_dim_obs_f_pdaf = <void*>py__init_dim_obs_f_pdaf
    c__PDAFcython.obs_op_f_pdaf = <void*>py__obs_op_f_pdaf
    c__PDAFcython.init_obs_f_pdaf = <void*>py__init_obs_f_pdaf
    c__PDAFcython.init_obs_l_pdaf = <void*>py__init_obs_l_pdaf
    c__PDAFcython.prodRinvA_l_pdaf = <void*>py__prodRinvA_l_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.g2l_obs_pdaf = <void*>py__g2l_obs_pdaf
    c__PDAFcython.init_obsvar_pdaf = <void*>py__init_obsvar_pdaf
    c__PDAFcython.init_obsvar_l_pdaf = <void*>py__init_obsvar_l_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf

    cdef int outflag

    c__pdaflocal_put_state_hyb3dvar_lestkf (c__PDAFcython.c__collect_state_pdaf,
                                            c__PDAFcython.c__init_dim_obs_pdaf,
                                            c__PDAFcython.c__obs_op_pdaf,
                                            c__PDAFcython.c__init_obs_pdaf,
                                            c__PDAFcython.c__prodRinvA_pdaf,
                                            c__PDAFcython.c__cvt_ens_pdaf,
                                            c__PDAFcython.c__cvt_adj_ens_pdaf,
                                            c__PDAFcython.c__cvt_pdaf,
                                            c__PDAFcython.c__cvt_adj_pdaf,
                                            c__PDAFcython.c__obs_op_lin_pdaf,
                                            c__PDAFcython.c__obs_op_adj_pdaf,
                                            c__PDAFcython.c__init_dim_obs_f_pdaf,
                                            c__PDAFcython.c__obs_op_f_pdaf,
                                            c__PDAFcython.c__init_obs_f_pdaf,
                                            c__PDAFcython.c__init_obs_l_pdaf,
                                            c__PDAFcython.c__prodRinvA_l_pdaf,
                                            c__PDAFcython.c__init_n_domains_p_pdaf,
                                            c__PDAFcython.c__init_dim_l_pdaf,
                                            c__PDAFcython.c__init_dim_obs_l_pdaf,
                                            c__PDAFcython.c__g2l_obs_pdaf,
                                            c__PDAFcython.c__init_obsvar_pdaf,
                                            c__PDAFcython.c__init_obsvar_l_pdaf,
                                            c__PDAFcython.c__prepoststep_pdaf,
                                            &outflag
                                           )

    return outflag

def local_put_state_lestkf (py__collect_state_pdaf,
                            py__init_dim_obs_pdaf,
                            py__obs_op_pdaf,
                            py__init_obs_pdaf,
                            py__init_obs_l_pdaf,
                            py__prepoststep_pdaf,
                            py__prodRinvA_l_pdaf,
                            py__init_n_domains_p_pdaf,
                            py__init_dim_l_pdaf,
                            py__init_dim_obs_l_pdaf,
                            py__g2l_obs_pdaf,
                            py__init_obsvar_pdaf,
                            py__init_obsvar_l_pdaf
                           ):
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_put_state` or `pyPDAF.PDAF.localomi_put_state_nondiagR`. 
    Using Local ESTKF (error space transform Kalman filter) for DA without post-processing and analysis distribution to forecsat without OMI. This is a domain localisation method. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. The LESTKF is a more efficient equivalent to the LETKF. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    6. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init
    7. py__init_obsvar_pdaf (if global adaptive forgetting factor is used
    loop over each local domain:
    8. py__init_dim_l_pdaf
    9. py__init_dim_obs_l_pdaf
    10. py__g2l_obs_pdaf (localise mean ensemble in observation space)
    11. py__init_obs_l_pdaf
    12. py__g2l_obs_pdaf (localise each ensemble member in observation space
    13. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used
    14. py__prodRinvA_l_pdaf
    15. core DA algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l : ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], A_l : ndarray[tuple[dim_obs_l, rank], np.float64], C_l : ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f : ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l : ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_f** : int

            * Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            * Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * **dim_p** : int

            * Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * **dim_l** : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **meanvar** : float

            * Mean observation error variance

        **Callback Returns**

        * **meanvar** : float

            * Mean observation error variance

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * **dim_obs_p** : int

            * Dimension of local observation vector

        * **meanvar_l** : float

            * Mean local observation error variance

        **Callback Returns**

        * **meanvar_l** : float

            * Mean local observation error variance


    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.init_obs_l_pdaf = <void*>py__init_obs_l_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.prodRinvA_l_pdaf = <void*>py__prodRinvA_l_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.g2l_obs_pdaf = <void*>py__g2l_obs_pdaf
    c__PDAFcython.init_obsvar_pdaf = <void*>py__init_obsvar_pdaf
    c__PDAFcython.init_obsvar_l_pdaf = <void*>py__init_obsvar_l_pdaf

    cdef int outflag

    c__pdaflocal_put_state_lestkf (c__PDAFcython.c__collect_state_pdaf,
                                   c__PDAFcython.c__init_dim_obs_pdaf,
                                   c__PDAFcython.c__obs_op_pdaf,
                                   c__PDAFcython.c__init_obs_pdaf,
                                   c__PDAFcython.c__init_obs_l_pdaf,
                                   c__PDAFcython.c__prepoststep_pdaf,
                                   c__PDAFcython.c__prodRinvA_l_pdaf,
                                   c__PDAFcython.c__init_n_domains_p_pdaf,
                                   c__PDAFcython.c__init_dim_l_pdaf,
                                   c__PDAFcython.c__init_dim_obs_l_pdaf,
                                   c__PDAFcython.c__g2l_obs_pdaf,
                                   c__PDAFcython.c__init_obsvar_pdaf,
                                   c__PDAFcython.c__init_obsvar_l_pdaf,
                                   &outflag
                                  )

    return outflag

def local_put_state_letkf (py__collect_state_pdaf,
                           py__init_dim_obs_pdaf,
                           py__obs_op_pdaf,
                           py__init_obs_pdaf,
                           py__init_obs_l_pdaf,
                           py__prepoststep_pdaf,
                           py__prodRinvA_l_pdaf,
                           py__init_n_domains_p_pdaf,
                           py__init_dim_l_pdaf,
                           py__init_dim_obs_l_pdaf,
                           py__g2l_obs_pdaf,
                           py__init_obsvar_pdaf,
                           py__init_obsvar_l_pdaf
                          ):
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_put_state` or `pyPDAF.PDAF.localomi_put_state_nondiagR`. 
    Using local ensemble transform Kalman filter for DA without post-processing and analysis distribution to forecsat without OMI. This is a domain localisation method. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    6. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init
    7. py__init_obsvar_pdaf (if global adaptive forgetting factor is used
    loop over each local domain:
    8. py__init_dim_l_pdaf
    9. py__init_dim_obs_l_pdaf
    10. py__g2l_obs_pdaf (localise mean ensemble in observation space)
    11. py__init_obs_l_pdaf
    12. py__g2l_obs_pdaf (localise each ensemble member in observation space
    13. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used
    14. py__prodRinvA_l_pdaf
    15. core DA algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l : ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], A_l : ndarray[tuple[dim_obs_l, rank], np.float64], C_l : ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f : ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l : ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_f** : int

            * Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            * Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * **dim_p** : int

            * Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * **dim_l** : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **meanvar** : float

            * Mean observation error variance

        **Callback Returns**

        * **meanvar** : float

            * Mean observation error variance

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * **dim_obs_p** : int

            * Dimension of local observation vector

        * **meanvar_l** : float

            * Mean local observation error variance

        **Callback Returns**

        * **meanvar_l** : float

            * Mean local observation error variance


    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.init_obs_l_pdaf = <void*>py__init_obs_l_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.prodRinvA_l_pdaf = <void*>py__prodRinvA_l_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.g2l_obs_pdaf = <void*>py__g2l_obs_pdaf
    c__PDAFcython.init_obsvar_pdaf = <void*>py__init_obsvar_pdaf
    c__PDAFcython.init_obsvar_l_pdaf = <void*>py__init_obsvar_l_pdaf

    cdef int outflag

    c__pdaflocal_put_state_letkf (c__PDAFcython.c__collect_state_pdaf,
                                  c__PDAFcython.c__init_dim_obs_pdaf,
                                  c__PDAFcython.c__obs_op_pdaf,
                                  c__PDAFcython.c__init_obs_pdaf,
                                  c__PDAFcython.c__init_obs_l_pdaf,
                                  c__PDAFcython.c__prepoststep_pdaf,
                                  c__PDAFcython.c__prodRinvA_l_pdaf,
                                  c__PDAFcython.c__init_n_domains_p_pdaf,
                                  c__PDAFcython.c__init_dim_l_pdaf,
                                  c__PDAFcython.c__init_dim_obs_l_pdaf,
                                  c__PDAFcython.c__g2l_obs_pdaf,
                                  c__PDAFcython.c__init_obsvar_pdaf,
                                  c__PDAFcython.c__init_obsvar_l_pdaf,
                                  &outflag
                                 )

    return outflag

def local_put_state_lknetf (py__collect_state_pdaf,
                            py__init_dim_obs_pdaf,
                            py__obs_op_pdaf,
                            py__init_obs_pdaf,
                            py__init_obs_l_pdaf,
                            py__prepoststep_pdaf,
                            py__prodRinvA_l_pdaf,
                            py__prodRinvA_hyb_l_pdaf,
                            py__init_n_domains_p_pdaf,
                            py__init_dim_l_pdaf,
                            py__init_dim_obs_l_pdaf,
                            py__g2l_obs_pdaf,
                            py__init_obsvar_pdaf,
                            py__init_obsvar_l_pdaf,
                            py__likelihood_l_pdaf,
                            py__likelihood_hyb_l_pdaf
                           ):
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_put_state` or `pyPDAF.PDAF.localomi_put_state_lknetf_nondiagR`. 
    This function will is a hybridised LETKF and LNETF for DA without post-processing and analysis distribution to forecsat without OMI. The LNETF computes the distribution up to the second moment similar to KF but using a nonlinear weighting similar to particle filter. This leads to an equal weights assumption for prior ensemble. The hybridisation with LETKF is expected to lead to improved performance for quasi-Gaussian problems.  
    
    This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    6. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init
    7. py__init_obsvar_pdaf (if global adaptive forgetting factor is used
    loop over each local domain:
    8. py__init_dim_l_pdaf
    9. py__init_dim_obs_l_pdaf
    10. py__g2l_obs_pdaf (localise each ensemble member in observation space)
    11. py__init_obs_l_pdaf
    12. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used
    13. py__prodRinvA_pdaf
    14. py__likelihood_l_pdaf
    15. core DA algorithm
    16. py__obs_op_pdaf (only called with `HKN` and `HNK` options called for each ensemble member
    17. py__likelihood_hyb_l_pda
    18. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used
    19. py__prodRinvA_hyb_l_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l : ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], A_l : ndarray[tuple[dim_obs_l, rank], np.float64], C_l : ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

    py__prodRinvA_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, dim_ens:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], gamma:float, A_l : ndarray[tuple[dim_obs_l, dim_ens], np.float64], C_l : ndarray[tuple[dim_obs_l, dim_ens], np.float64]]
        Provide product R^-1 A on local analysis domain with hybrid weight

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **dim_ens** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **gamma** : float

            * Hybrid weight provided by PDAF

        * **A_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            * Output matrix

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f : ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l : ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_f** : int

            * Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            * Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * **dim_p** : int

            * Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * **dim_l** : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **meanvar** : float

            * Mean observation error variance

        **Callback Returns**

        * **meanvar** : float

            * Mean observation error variance

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * **dim_obs_p** : int

            * Dimension of local observation vector

        * **meanvar_l** : float

            * Mean local observation error variance

        **Callback Returns**

        * **meanvar_l** : float

            * Mean local observation error variance

    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], resid_l : ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute likelihood

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            * nput vector holding the local residual

        * **likely_l** : float

            * Output value of the local likelihood

        **Callback Returns**

        * **likely_l** : float

            * Output value of the local likelihood

    py__likelihood_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], resid_l : ndarray[tuple[dim_obs_l], np.float64], gamma:float, likely_l:float]
        Compute likelihood with hybrid weight

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Input vector holding the local residual

        * **gamma** : float

            * Hybrid weight provided by PDAF

        * **likely_l** : float

            * Output value of the local likelihood

        **Callback Returns**

        * **likely_l** : float

            * Output value of the local likelihood


    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.init_obs_l_pdaf = <void*>py__init_obs_l_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.prodRinvA_l_pdaf = <void*>py__prodRinvA_l_pdaf
    c__PDAFcython.prodRinvA_hyb_l_pdaf = <void*>py__prodRinvA_hyb_l_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.g2l_obs_pdaf = <void*>py__g2l_obs_pdaf
    c__PDAFcython.init_obsvar_pdaf = <void*>py__init_obsvar_pdaf
    c__PDAFcython.init_obsvar_l_pdaf = <void*>py__init_obsvar_l_pdaf
    c__PDAFcython.likelihood_l_pdaf = <void*>py__likelihood_l_pdaf
    c__PDAFcython.likelihood_hyb_l_pdaf = <void*>py__likelihood_hyb_l_pdaf

    cdef int outflag

    c__pdaflocal_put_state_lknetf (c__PDAFcython.c__collect_state_pdaf,
                                   c__PDAFcython.c__init_dim_obs_pdaf,
                                   c__PDAFcython.c__obs_op_pdaf,
                                   c__PDAFcython.c__init_obs_pdaf,
                                   c__PDAFcython.c__init_obs_l_pdaf,
                                   c__PDAFcython.c__prepoststep_pdaf,
                                   c__PDAFcython.c__prodRinvA_l_pdaf,
                                   c__PDAFcython.c__prodRinvA_hyb_l_pdaf,
                                   c__PDAFcython.c__init_n_domains_p_pdaf,
                                   c__PDAFcython.c__init_dim_l_pdaf,
                                   c__PDAFcython.c__init_dim_obs_l_pdaf,
                                   c__PDAFcython.c__g2l_obs_pdaf,
                                   c__PDAFcython.c__init_obsvar_pdaf,
                                   c__PDAFcython.c__init_obsvar_l_pdaf,
                                   c__PDAFcython.c__likelihood_l_pdaf,
                                   c__PDAFcython.c__likelihood_hyb_l_pdaf,
                                   &outflag
                                  )

    return outflag

def local_put_state_lnetf (py__collect_state_pdaf,
                           py__init_dim_obs_pdaf,
                           py__obs_op_pdaf,
                           py__init_obs_l_pdaf,
                           py__prepoststep_pdaf,
                           py__likelihood_l_pdaf,
                           py__init_n_domains_p_pdaf,
                           py__init_dim_l_pdaf,
                           py__init_dim_obs_l_pdaf,
                           py__g2l_obs_pdaf
                          ):
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_put_state` or `pyPDAF.PDAF.localomi_put_state_lnetf_nondiagR`. 
    This function will use Local Nonlinear Ensemble Transform Filter (LNETF) for DA without post-processing and analysis distribution to forecsat without OMI. The nonlinear filter computes the distribution up to the second moment similar to KF but using a nonlinear weighting similar to particle filter. This leads to an equal weights assumption for prior ensemble. 
    
    This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    6. py__init_dim_l_pdaf
    7. py__init_dim_obs_l_pdaf
    8. py__init_obs_l_pdaf
    9. py__g2l_obs_pdaf (localise each ensemble member in observation space)
    10. py__likelihood_l_pdaf
    11. core DA algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l : ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], resid_l : ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            * nput vector holding the local residual

        * **likely_l** : float

            * Output value of the local likelihood

        **Callback Returns**

        * **likely_l** : float

            * Output value of the local likelihood

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f : ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l : ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_f** : int

            * Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            * Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * **dim_p** : int

            * Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * **dim_l** : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain


    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_l_pdaf = <void*>py__init_obs_l_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.likelihood_l_pdaf = <void*>py__likelihood_l_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.g2l_obs_pdaf = <void*>py__g2l_obs_pdaf

    cdef int outflag

    c__pdaflocal_put_state_lnetf (c__PDAFcython.c__collect_state_pdaf,
                                  c__PDAFcython.c__init_dim_obs_pdaf,
                                  c__PDAFcython.c__obs_op_pdaf,
                                  c__PDAFcython.c__init_obs_l_pdaf,
                                  c__PDAFcython.c__prepoststep_pdaf,
                                  c__PDAFcython.c__likelihood_l_pdaf,
                                  c__PDAFcython.c__init_n_domains_p_pdaf,
                                  c__PDAFcython.c__init_dim_l_pdaf,
                                  c__PDAFcython.c__init_dim_obs_l_pdaf,
                                  c__PDAFcython.c__g2l_obs_pdaf,
                                  &outflag
                                 )

    return outflag

def local_put_state_lseik (py__collect_state_pdaf,
                           py__init_dim_obs_pdaf,
                           py__obs_op_pdaf,
                           py__init_obs_pdaf,
                           py__init_obs_l_pdaf,
                           py__prepoststep_pdaf,
                           py__prodRinvA_l_pdaf,
                           py__init_n_domains_p_pdaf,
                           py__init_dim_l_pdaf,
                           py__init_dim_obs_l_pdaf,
                           py__g2l_obs_pdaf,
                           py__init_obsvar_pdaf,
                           py__init_obsvar_l_pdaf
                          ):
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_put_state` or `pyPDAF.PDAF.localomi_put_state_nondiagR`. 
    Using local singular evolutive interpolated Kalman filter for DA without post-processing and analysis distribution to forecsat without OMI. This is a domain localisation method. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    6. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init
    7. py__init_obsvar_pdaf (if global adaptive forgetting factor is used
    loop over each local domain:
    8. py__init_dim_l_pdaf
    9. py__init_dim_obs_l_pdaf
    10. py__g2l_obs_pdaf (localise mean ensemble in observation space)
    11. py__init_obs_l_pdaf
    12. py__g2l_obs_pdaf (localise each ensemble member in observation space
    13. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used
    14. py__prodRinvA_l_pdaf
    15. core DA algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p : ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            * pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * local state vector

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            * current time step

        * **dim_obs_p** : int

            * dimension of observation vector

        **Callback Returns**

        * **dim_obs_p** : int

            * dimension of observation vector

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], m_state_p : ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_p** : int

            * Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            * Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p : ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l : ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p : ndarray[tuple[dim_p], np.float64], uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p : ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            * current time step (negative for call after forecast)

        * **dim_p** : int

            * pe-local state dimension

        * **dim_ens** : int

            * size of state ensemble

        * **dim_ens_p** : int

            * pe-local size of ensemble

        * **dim_obs_p** : int

            * pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * **flag** : int

            * pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l : ndarray[tuple[dim_obs_l], np.float64], A_l : ndarray[tuple[dim_obs_l, rank], np.float64], C_l : ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            * current time step

        * **n_domains_p** : int

            * pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p** : int

            * pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            * current time step

        * **domain_p** : int

            * current local analysis domain

        * **dim_l** : int

            * local state dimension

        **Callback Returns**

        * **dim_l** : int

            * local state dimension

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            * index of current local analysis domain

        * **step** : int

            * current time step

        * **dim_obs_f** : int

            * full dimension of observation vector

        * **dim_obs_l** : int

            * local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l** : int

            * local dimension of observation vector

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f : ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l : ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_f** : int

            * Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            * Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * **dim_p** : int

            * Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * **dim_l** : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p : ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            * Current time step

        * **dim_obs_p** : int

            * Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * **meanvar** : float

            * Mean observation error variance

        **Callback Returns**

        * **meanvar** : float

            * Mean observation error variance

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l : ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            * Index of current local analysis domain

        * **step** : int

            * Current time step

        * **dim_obs_l** : int

            * Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * **dim_obs_p** : int

            * Dimension of local observation vector

        * **meanvar_l** : float

            * Mean local observation error variance

        **Callback Returns**

        * **meanvar_l** : float

            * Mean local observation error variance


    Returns
    -------
    outflag : int
        Status flag
    """

    c__PDAFcython.collect_state_pdaf = <void*>py__collect_state_pdaf
    c__PDAFcython.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    c__PDAFcython.obs_op_pdaf = <void*>py__obs_op_pdaf
    c__PDAFcython.init_obs_pdaf = <void*>py__init_obs_pdaf
    c__PDAFcython.init_obs_l_pdaf = <void*>py__init_obs_l_pdaf
    c__PDAFcython.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    c__PDAFcython.prodRinvA_l_pdaf = <void*>py__prodRinvA_l_pdaf
    c__PDAFcython.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    c__PDAFcython.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    c__PDAFcython.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    c__PDAFcython.g2l_obs_pdaf = <void*>py__g2l_obs_pdaf
    c__PDAFcython.init_obsvar_pdaf = <void*>py__init_obsvar_pdaf
    c__PDAFcython.init_obsvar_l_pdaf = <void*>py__init_obsvar_l_pdaf

    cdef int outflag

    c__pdaflocal_put_state_lseik (c__PDAFcython.c__collect_state_pdaf,
                                  c__PDAFcython.c__init_dim_obs_pdaf,
                                  c__PDAFcython.c__obs_op_pdaf,
                                  c__PDAFcython.c__init_obs_pdaf,
                                  c__PDAFcython.c__init_obs_l_pdaf,
                                  c__PDAFcython.c__prepoststep_pdaf,
                                  c__PDAFcython.c__prodRinvA_l_pdaf,
                                  c__PDAFcython.c__init_n_domains_p_pdaf,
                                  c__PDAFcython.c__init_dim_l_pdaf,
                                  c__PDAFcython.c__init_dim_obs_l_pdaf,
                                  c__PDAFcython.c__g2l_obs_pdaf,
                                  c__PDAFcython.c__init_obsvar_pdaf,
                                  c__PDAFcython.c__init_obsvar_l_pdaf,
                                  &outflag
                                 )

    return outflag

