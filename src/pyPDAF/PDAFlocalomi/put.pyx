import sys
import numpy as np
cimport numpy as cnp
from pyPDAF cimport pdaf_c_cb_interface as pdaf_cb
from pyPDAF.cfi_binding cimport CFI_cdesc_t, CFI_address, CFI_index_t, CFI_establish
from pyPDAF.cfi_binding cimport CFI_attribute_other, CFI_type_double, CFI_type_int
from pyPDAF.cfi_binding cimport CFI_cdesc_rank1, CFI_cdesc_rank2, CFI_cdesc_rank3

try:
    import mpi4py
    mpi4py.rc.initialize = False
except ImportError:
    pass

# Global error handler
def global_except_hook(exctype, value, traceback):
    from traceback import print_exception
    try:
        import mpi4py.MPI

        if mpi4py.MPI.Is_initialized():
            try:
                sys.stderr.write('Uncaught exception was ''detected on rank {}.\n'.format(
                    mpi4py.MPI.COMM_WORLD.Get_rank()))
                print_exception(exctype, value, traceback)
                sys.stderr.write("\n")
                sys.stderr.flush()
            finally:
                try:
                    mpi4py.MPI.COMM_WORLD.Abort(1)
                except Exception as e:
                    sys.stderr.write('MPI Abort failed, this process will hang.\n')
                    sys.stderr.flush()
                    raise e
        else:
            sys.__excepthook__(exctype, value, traceback)
    except ImportError:
        sys.__excepthook__(exctype, value, traceback)

sys.excepthook = global_except_hook

def put_state_en3dvar_lestkf(py__collect_state_pdaf,
    py__init_dim_obs_f_pdaf, py__obs_op_f_pdaf, py__cvt_ens_pdaf,
    py__cvt_adj_ens_pdaf, py__obs_op_lin_pdaf, py__obs_op_adj_pdaf,
    py__init_n_domains_p_pdaf, py__init_dim_l_pdaf,
    py__init_dim_obs_l_pdaf, py__prepoststep_pdaf):
    """It is recommended to use
    :func:`pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf`
    or :func:`pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions
    and improved efficiency.

    3DEnVar for a single DA step without post-processing,
    distributing analysis, and setting next observation step,
    where the ensemble anomaly is generated by LESTKF.

    Compared to :func:`pyPDAF.PDAF.assimilate_en3dvar_lestkf`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    The background error covariance matrix is estimated by ensemble.
    The 3DEnVar only calculates the analysis of the ensemble mean.
    An LESTKF is used to generate ensemble perturbations.
    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. py__init_obs_pdaf
        6. Starting the iterative optimisation:
            1. py__cvt_ens_pdaf
            2. py__obs_op_lin_pdaf
            3. py__prodRinvA_pdaf
            4. py__obs_op_adj_pdaf
            5. py__cvt_adj_ens_pdaf
            6. core DA algorithm
        7. py__cvt_ens_pdaf
        8. Perform LESTKF:
            1. py__init_n_domains_p_pdaf
            2. py__init_dim_obs_pdaf
            3. py__obs_op_pdaf
               (for each ensemble member)
            4. py__init_obs_pdaf
               (if global adaptive forgetting factor is used
               `type_forget=1` in :func:`pyPDAF.PDAF.init`)
            5. py__init_obsvar_pdaf
               (if global adaptive forgetting factor is used)
            6. loop over each local domain:
                1. py__init_dim_l_pdaf
                2. py__init_dim_obs_l_pdaf
                3. py__g2l_state_pdaf
                4. py__g2l_obs_pdaf
                   (localise mean ensemble in observation space)
                5. py__init_obs_l_pdaf
                6. py__g2l_obs_pdaf
                   (localise each ensemble member in observation space)
                7. py__init_obsvar_l_pdaf
                   (only called if local adaptive forgetting factor
                   `type_forget=2` is used)
                8. py__prodRinvA_l_pdaf
                9. core DA algorithm
                10. py__l2g_state_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf`
       and :func:`pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf_nondiagR`

    Parameters
    ----------
    py__collect_state_pdaf : Callable
        Routine to collect a state vector

        Callback Parameters
        -------------------
        dim_p : int
                pe-local state dimension
        state_p : ndarray[np.float64, ndim=1]
                local state vector
                Array shape: (dim_p)

        Callback Returns
        ----------------
        state_p : ndarray[np.float64, ndim=1]
                local state vector
                Array shape: (dim_p)

    py__init_dim_obs_f_pdaf : Callable
        Initialize dimension of full observation vector

        Callback Parameters
        -------------------
        step : int
                current time step

        Callback Returns
        ----------------
        dim_obs_p : int
                dimension of observation vector

    py__obs_op_f_pdaf : Callable
        Full observation operator

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_p : int
                Size of state vector (local part in case of parallel decomposed state)
        dim_obs_p : int
                Size of observation vector
        state_p : ndarray[np.float64, ndim=1]
                Model state vector
                Array shape: (dim_p)

        Callback Returns
        ----------------
        m_state_p : ndarray[np.float64, ndim=1]
                Observed state vector (i.e. the result after applying the observation operator to state_p)
                Array shape: (dim_obs_p)

    py__cvt_ens_pdaf : Callable
        Apply control vector transform matrix to control vector

        Callback Parameters
        -------------------
        iter : int
                Iteration of optimization
        dim_p : int
                PE-local dimension of state
        dim_ens : int
                Ensemble size
        dim_cvec_ens : int
                Dimension of control vector
        ens_p : ndarray[np.float64, ndim=2]
                PE-local ensemble
                Array shape: (dim_p, dim_ens)
        v_p : ndarray[np.float64, ndim=1]
                PE-local control vector
                Array shape: (dim_cvec_ens)
        vv_p : ndarray[np.float64, ndim=1]
                PE-local state increment
                Array shape: (dim_p)

        Callback Returns
        ----------------
        vv_p : ndarray[np.float64, ndim=1]
                PE-local state increment
                Array shape: (dim_p)

    py__cvt_adj_ens_pdaf : Callable
        Apply adjoint control vector transform matrix

        Callback Parameters
        -------------------
        iter : int
                Iteration of optimization
        dim_p : int
                PE-local observation dimension
        dim_ens : int
                Ensemble size
        dim_cv_ens_p : int
                PE-local dimension of control vector
        ens_p : ndarray[np.float64, ndim=2]
                PE-local ensemble
                Array shape: (dim_p, dim_ens)
        vcv_p : ndarray[np.float64, ndim=1]
                PE-local input vector
                Array shape: (dim_p)
        cv_p : ndarray[np.float64, ndim=1]
                PE-local result vector
                Array shape: (dim_cv_ens_p)

        Callback Returns
        ----------------
        cv_p : ndarray[np.float64, ndim=1]
                PE-local result vector
                Array shape: (dim_cv_ens_p)

    py__obs_op_lin_pdaf : Callable
        Linearized observation operator

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_p : int
                PE-local dimension of state
        dim_obs_p : int
                Dimension of observed state
        state_p : ndarray[np.float64, ndim=1]
                PE-local model state
                Array shape: (dim_p)
        m_state_p : ndarray[np.float64, ndim=1]
                PE-local observed state
                Array shape: (dim_obs_p)

        Callback Returns
        ----------------
        m_state_p : ndarray[np.float64, ndim=1]
                PE-local observed state
                Array shape: (dim_obs_p)

    py__obs_op_adj_pdaf : Callable
        Adjoint observation operator

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_p : int
                PE-local dimension of state
        dim_obs_p : int
                Dimension of observed state
        m_state_p : ndarray[np.float64, ndim=1]
                PE-local observed state
                Array shape: (dim_obs_p)
        state_p : ndarray[np.float64, ndim=1]
                PE-local model state
                Array shape: (dim_p)

        Callback Returns
        ----------------
        state_p : ndarray[np.float64, ndim=1]
                PE-local model state
                Array shape: (dim_p)

    py__init_n_domains_p_pdaf : Callable
        Provide number of local analysis domains

        Callback Parameters
        -------------------
        step : int
                current time step

        Callback Returns
        ----------------
        n_domains_p : int
                pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable
        Init state dimension for local ana. domain

        Callback Parameters
        -------------------
        step : int
                current time step
        domain_p : int
                current local analysis domain

        Callback Returns
        ----------------
        dim_l : int
                local state dimension

    py__init_dim_obs_l_pdaf : Callable
        Initialize local dimimension of obs. vector

        Callback Parameters
        -------------------
        domain_p : int
                index of current local analysis domain
        step : int
                current time step
        dim_obs_f : int
                full dimension of observation vector

        Callback Returns
        ----------------
        dim_obs_l : int
                local dimension of observation vector

    py__prepoststep_pdaf : Callable
        User supplied pre/poststep routine

        Callback Parameters
        -------------------
        step : int
                current time step
                (negative for call before analysis/preprocessing)
        dim_p : int
                PE-local state vector dimension
        dim_ens : int
                number of ensemble members
        dim_ens_l : int
                number of ensemble members run serially
                on each model task
        dim_obs_p : int
                PE-local dimension of observation vector
        state_p : ndarray[np.float64, ndim=1]
                pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)
                Array shape: (dim_p)
        uinv : ndarray[np.float64, ndim=2]
                Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.
                Array shape: (dim_ens-1, dim_ens-1)
        ens_p : ndarray[np.float64, ndim=2]
                PE-local ensemble
                Array shape: (dim_p, dim_ens)
        flag : int
                pdaf status flag

        Callback Returns
        ----------------
        state_p : ndarray[np.float64, ndim=1]
                pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)
                Array shape: (dim_p)
        uinv : ndarray[np.float64, ndim=2]
                Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.
                Array shape: (dim_ens-1, dim_ens-1)
        ens_p : ndarray[np.float64, ndim=2]
                PE-local ensemble
                Array shape: (dim_p, dim_ens)


    Returns
    -------
    outflag : int
        Status flag
    """
    pdaf_cb.collect_state_pdaf = <void*>py__collect_state_pdaf
    pdaf_cb.init_dim_obs_f_pdaf = <void*>py__init_dim_obs_f_pdaf
    pdaf_cb.obs_op_f_pdaf = <void*>py__obs_op_f_pdaf
    pdaf_cb.cvt_ens_pdaf = <void*>py__cvt_ens_pdaf
    pdaf_cb.cvt_adj_ens_pdaf = <void*>py__cvt_adj_ens_pdaf
    pdaf_cb.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    pdaf_cb.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    pdaf_cb.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    pdaf_cb.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    pdaf_cb.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    pdaf_cb.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    cdef int  outflag
    with nogil:
        c__pdaflocalomi_put_state_en3dvar_lestkf(
                                                 pdaf_cb.c__collect_state_pdaf,
                                                 pdaf_cb.c__init_dim_obs_f_pdaf,
                                                 pdaf_cb.c__obs_op_f_pdaf,
                                                 pdaf_cb.c__cvt_ens_pdaf,
                                                 pdaf_cb.c__cvt_adj_ens_pdaf,
                                                 pdaf_cb.c__obs_op_lin_pdaf,
                                                 pdaf_cb.c__obs_op_adj_pdaf,
                                                 pdaf_cb.c__init_n_domains_p_pdaf,
                                                 pdaf_cb.c__init_dim_l_pdaf,
                                                 pdaf_cb.c__init_dim_obs_l_pdaf,
                                                 pdaf_cb.c__prepoststep_pdaf,
                                                 &outflag)

    return outflag


def put_state_hyb3dvar_lestkf(py__collect_state_pdaf,
    py__init_dim_obs_f_pdaf, py__obs_op_f_pdaf, py__cvt_ens_pdaf,
    py__cvt_adj_ens_pdaf, py__cvt_pdaf, py__cvt_adj_pdaf,
    py__obs_op_lin_pdaf, py__obs_op_adj_pdaf, py__init_n_domains_p_pdaf,
    py__init_dim_l_pdaf, py__init_dim_obs_l_pdaf, py__prepoststep_pdaf):
    """It is recommended to use
    :func:`pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf`
    or :func:`pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions
    and improved efficiency.

    Hybrid 3DEnVar for a single DA step using
    non-diagnoal observation error covariance matrix
    without post-processing, distributing analysis,
    and setting next observation step, where
    the background error covariance is hybridised by
    a static background error covariance,
    and a flow-dependent background error covariance
    estimated from ensemble.

    Compared to :func:`pyPDAF.PDAF.assimilate_hyb3dvar_lestkf`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    The 3DVar generates an ensemble mean and
    the ensemble perturbation is generated by
    LESTKF in this implementation.
    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. py__init_obs_pdaf
        6. The iterative optimisation:
            1. py__cvt_pdaf
            2. py__cvt_ens_pdaf
            3. py__obs_op_lin_pdaf
            4. py__prodRinvA_pdaf
            5. py__obs_op_adj_pdaf
            6. py__cvt_adj_pdaf
            7. py__cvt_adj_ens_pdaf
            8. core DA algorithm
        7. py__cvt_pdaf
        8. py__cvt_ens_pdaf
        9. Perform LESTKF:
            1. py__init_n_domains_p_pdaf
            2. py__init_dim_obs_pdaf
            3. py__obs_op_pdaf
               (for each ensemble member)
            4. py__init_obs_pdaf
               (if global adaptive forgetting factor
               `type_forget=1` in :func:`pyPDAF.PDAF.init`)
            5. py__init_obsvar_pdaf
               (if global adaptive forgetting factor is used)
            6. loop over each local domain:
                1. py__init_dim_l_pdaf
                2. py__init_dim_obs_l_pdaf
                3. py__g2l_state_pdaf
                4. py__g2l_obs_pdaf
                   (localise mean ensemble in observation space)
                5. py__init_obs_l_pdaf
                6. py__g2l_obs_pdaf
                   (localise each ensemble member
                   in observation space)
                7. py__init_obsvar_l_pdaf
                   (only called if local adaptive forgetting
                   factor `type_forget=2` is used)
                8. py__prodRinvA_l_pdaf
                9. core DA algorithm
                10. py__l2g_state_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf`
       and :func:`pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf_nondiagR`

    Parameters
    ----------
    py__collect_state_pdaf : Callable
        Routine to collect a state vector

        Callback Parameters
        -------------------
        dim_p : int
                pe-local state dimension
        state_p : ndarray[np.float64, ndim=1]
                local state vector
                Array shape: (dim_p)

        Callback Returns
        ----------------
        state_p : ndarray[np.float64, ndim=1]
                local state vector
                Array shape: (dim_p)

    py__init_dim_obs_f_pdaf : Callable
        Initialize dimension of full observation vector

        Callback Parameters
        -------------------
        step : int
                current time step

        Callback Returns
        ----------------
        dim_obs_p : int
                dimension of observation vector

    py__obs_op_f_pdaf : Callable
        Full observation operator

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_p : int
                Size of state vector (local part in case of parallel decomposed state)
        dim_obs_p : int
                Size of observation vector
        state_p : ndarray[np.float64, ndim=1]
                Model state vector
                Array shape: (dim_p)

        Callback Returns
        ----------------
        m_state_p : ndarray[np.float64, ndim=1]
                Observed state vector (i.e. the result after applying the observation operator to state_p)
                Array shape: (dim_obs_p)

    py__cvt_ens_pdaf : Callable
        Apply control vector transform matrix to control vector

        Callback Parameters
        -------------------
        iter : int
                Iteration of optimization
        dim_p : int
                PE-local dimension of state
        dim_ens : int
                Ensemble size
        dim_cvec_ens : int
                Dimension of control vector
        ens_p : ndarray[np.float64, ndim=2]
                PE-local ensemble
                Array shape: (dim_p, dim_ens)
        v_p : ndarray[np.float64, ndim=1]
                PE-local control vector
                Array shape: (dim_cvec_ens)
        vv_p : ndarray[np.float64, ndim=1]
                PE-local state increment
                Array shape: (dim_p)

        Callback Returns
        ----------------
        vv_p : ndarray[np.float64, ndim=1]
                PE-local state increment
                Array shape: (dim_p)

    py__cvt_adj_ens_pdaf : Callable
        Apply adjoint control vector transform matrix

        Callback Parameters
        -------------------
        iter : int
                Iteration of optimization
        dim_p : int
                PE-local observation dimension
        dim_ens : int
                Ensemble size
        dim_cv_ens_p : int
                PE-local dimension of control vector
        ens_p : ndarray[np.float64, ndim=2]
                PE-local ensemble
                Array shape: (dim_p, dim_ens)
        vcv_p : ndarray[np.float64, ndim=1]
                PE-local input vector
                Array shape: (dim_p)
        cv_p : ndarray[np.float64, ndim=1]
                PE-local result vector
                Array shape: (dim_cv_ens_p)

        Callback Returns
        ----------------
        cv_p : ndarray[np.float64, ndim=1]
                PE-local result vector
                Array shape: (dim_cv_ens_p)

    py__cvt_pdaf : Callable
        Apply control vector transform matrix to control vector

        Callback Parameters
        -------------------
        iter : int
                Iteration of optimization
        dim_p : int
                PE-local observation dimension
        dim_cvec : int
                Dimension of control vector
        cv_p : ndarray[np.float64, ndim=1]
                PE-local control vector
                Array shape: (dim_cvec)
        vv_p : ndarray[np.float64, ndim=1]
                PE-local result vector (state vector increment)
                Array shape: (dim_p)

        Callback Returns
        ----------------
        vv_p : ndarray[np.float64, ndim=1]
                PE-local result vector (state vector increment)
                Array shape: (dim_p)

    py__cvt_adj_pdaf : Callable
        Apply adjoint control vector transform matrix

        Callback Parameters
        -------------------
        iter : int
                Iteration of optimization
        dim_p : int
                PE-local observation dimension
        dim_cvec : int
                Dimension of control vector
        vcv_p : ndarray[np.float64, ndim=1]
                PE-local result vector (state vector increment)
                Array shape: (dim_p)
        cv_p : ndarray[np.float64, ndim=1]
                PE-local control vector
                Array shape: (dim_cvec)

        Callback Returns
        ----------------
        cv_p : ndarray[np.float64, ndim=1]
                PE-local control vector
                Array shape: (dim_cvec)

    py__obs_op_lin_pdaf : Callable
        Linearized observation operator

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_p : int
                PE-local dimension of state
        dim_obs_p : int
                Dimension of observed state
        state_p : ndarray[np.float64, ndim=1]
                PE-local model state
                Array shape: (dim_p)
        m_state_p : ndarray[np.float64, ndim=1]
                PE-local observed state
                Array shape: (dim_obs_p)

        Callback Returns
        ----------------
        m_state_p : ndarray[np.float64, ndim=1]
                PE-local observed state
                Array shape: (dim_obs_p)

    py__obs_op_adj_pdaf : Callable
        Adjoint observation operator

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_p : int
                PE-local dimension of state
        dim_obs_p : int
                Dimension of observed state
        m_state_p : ndarray[np.float64, ndim=1]
                PE-local observed state
                Array shape: (dim_obs_p)
        state_p : ndarray[np.float64, ndim=1]
                PE-local model state
                Array shape: (dim_p)

        Callback Returns
        ----------------
        state_p : ndarray[np.float64, ndim=1]
                PE-local model state
                Array shape: (dim_p)

    py__init_n_domains_p_pdaf : Callable
        Provide number of local analysis domains

        Callback Parameters
        -------------------
        step : int
                current time step

        Callback Returns
        ----------------
        n_domains_p : int
                pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable
        Init state dimension for local ana. domain

        Callback Parameters
        -------------------
        step : int
                current time step
        domain_p : int
                current local analysis domain

        Callback Returns
        ----------------
        dim_l : int
                local state dimension

    py__init_dim_obs_l_pdaf : Callable
        Initialize local dimimension of obs. vector

        Callback Parameters
        -------------------
        domain_p : int
                index of current local analysis domain
        step : int
                current time step
        dim_obs_f : int
                full dimension of observation vector

        Callback Returns
        ----------------
        dim_obs_l : int
                local dimension of observation vector

    py__prepoststep_pdaf : Callable
        User supplied pre/poststep routine

        Callback Parameters
        -------------------
        step : int
                current time step
                (negative for call before analysis/preprocessing)
        dim_p : int
                PE-local state vector dimension
        dim_ens : int
                number of ensemble members
        dim_ens_l : int
                number of ensemble members run serially
                on each model task
        dim_obs_p : int
                PE-local dimension of observation vector
        state_p : ndarray[np.float64, ndim=1]
                pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)
                Array shape: (dim_p)
        uinv : ndarray[np.float64, ndim=2]
                Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.
                Array shape: (dim_ens-1, dim_ens-1)
        ens_p : ndarray[np.float64, ndim=2]
                PE-local ensemble
                Array shape: (dim_p, dim_ens)
        flag : int
                pdaf status flag

        Callback Returns
        ----------------
        state_p : ndarray[np.float64, ndim=1]
                pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)
                Array shape: (dim_p)
        uinv : ndarray[np.float64, ndim=2]
                Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.
                Array shape: (dim_ens-1, dim_ens-1)
        ens_p : ndarray[np.float64, ndim=2]
                PE-local ensemble
                Array shape: (dim_p, dim_ens)


    Returns
    -------
    outflag : int
        Status flag
    """
    pdaf_cb.collect_state_pdaf = <void*>py__collect_state_pdaf
    pdaf_cb.init_dim_obs_f_pdaf = <void*>py__init_dim_obs_f_pdaf
    pdaf_cb.obs_op_f_pdaf = <void*>py__obs_op_f_pdaf
    pdaf_cb.cvt_ens_pdaf = <void*>py__cvt_ens_pdaf
    pdaf_cb.cvt_adj_ens_pdaf = <void*>py__cvt_adj_ens_pdaf
    pdaf_cb.cvt_pdaf = <void*>py__cvt_pdaf
    pdaf_cb.cvt_adj_pdaf = <void*>py__cvt_adj_pdaf
    pdaf_cb.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    pdaf_cb.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    pdaf_cb.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    pdaf_cb.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    pdaf_cb.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    pdaf_cb.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    cdef int  outflag
    with nogil:
        c__pdaflocalomi_put_state_hyb3dvar_lestkf(
                                                  pdaf_cb.c__collect_state_pdaf,
                                                  pdaf_cb.c__init_dim_obs_f_pdaf,
                                                  pdaf_cb.c__obs_op_f_pdaf,
                                                  pdaf_cb.c__cvt_ens_pdaf,
                                                  pdaf_cb.c__cvt_adj_ens_pdaf,
                                                  pdaf_cb.c__cvt_pdaf,
                                                  pdaf_cb.c__cvt_adj_pdaf,
                                                  pdaf_cb.c__obs_op_lin_pdaf,
                                                  pdaf_cb.c__obs_op_adj_pdaf,
                                                  pdaf_cb.c__init_n_domains_p_pdaf,
                                                  pdaf_cb.c__init_dim_l_pdaf,
                                                  pdaf_cb.c__init_dim_obs_l_pdaf,
                                                  pdaf_cb.c__prepoststep_pdaf,
                                                  &outflag)

    return outflag


def put_state_en3dvar_lestkf_nondiagr(py__collect_state_pdaf,
    py__init_dim_obs_pdaf, py__obs_op_pdaf, py__prodrinva_pdaf,
    py__cvt_ens_pdaf, py__cvt_adj_ens_pdaf, py__obs_op_lin_pdaf,
    py__obs_op_adj_pdaf, py__prodrinva_l_pdaf, py__init_n_domains_p_pdaf,
    py__init_dim_l_pdaf, py__init_dim_obs_l_pdaf, py__prepoststep_pdaf):
    """Checking the corresponding PDAF documentation in https://pdaf.awi.de
    For internal subroutines checking corresponding PDAF comments.

    Parameters
    ----------
    py__collect_state_pdaf : Callable
        Routine to collect a state vector

        Callback Parameters
        -------------------
        dim_p : int
                pe-local state dimension
        state_p : ndarray[np.float64, ndim=1]
                local state vector
                Array shape: (dim_p)

        Callback Returns
        ----------------
        state_p : ndarray[np.float64, ndim=1]
                local state vector
                Array shape: (dim_p)

    py__init_dim_obs_pdaf : Callable
        Initialize dimension of full observation vector

        Callback Parameters
        -------------------
        step : int
                current time step

        Callback Returns
        ----------------
        dim_obs_p : int
                dimension of observation vector

    py__obs_op_pdaf : Callable
        Full observation operator

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_p : int
                Size of state vector
                (local part in case of parallel decomposed state)
        dim_obs_p : int
                Size of PE-local observation vector
        state_p : ndarray[np.float64, ndim=1]
                Model state vector
                Array shape: (dim_p)
        m_state_p : ndarray[np.float64, ndim=1]
                Observed state vector
                (i.e. the result after applying the observation operator to state_p)
                Array shape: (dim_obs_p)

        Callback Returns
        ----------------
        m_state_p : ndarray[np.float64, ndim=1]
                Observed state vector
                (i.e. the result after applying the observation operator to state_p)
                Array shape: (dim_obs_p)

    py__prodrinva_pdaf : Callable
        Provide product R^-1 A

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_obs_p : int
                Number of observations at current time step (i.e. the size of the observation vector)
        rank : int
                Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one
                (or the rank of the initial covariance matrix)
        obs_p : ndarray[np.float64, ndim=1]
                Vector of observations
                Array shape: (dim_obs_p)
        a_p : ndarray[np.float64, ndim=2]
                Input matrix provided by PDAF
                Array shape: (dim_obs_p, rank)

        Callback Returns
        ----------------
        c_p : ndarray[np.float64, ndim=2]
                Output matrix
                Array shape: (dim_obs_p, rank)

    py__cvt_ens_pdaf : Callable
        Apply control vector transform matrix to control vector

        Callback Parameters
        -------------------
        iter : int
                Iteration of optimization
        dim_p : int
                PE-local dimension of state
        dim_ens : int
                Ensemble size
        dim_cvec_ens : int
                Dimension of control vector
        ens_p : ndarray[np.float64, ndim=2]
                PE-local ensemble
                Array shape: (dim_p, dim_ens)
        v_p : ndarray[np.float64, ndim=1]
                PE-local control vector
                Array shape: (dim_cvec_ens)
        vv_p : ndarray[np.float64, ndim=1]
                PE-local state increment
                Array shape: (dim_p)

        Callback Returns
        ----------------
        vv_p : ndarray[np.float64, ndim=1]
                PE-local state increment
                Array shape: (dim_p)

    py__cvt_adj_ens_pdaf : Callable
        Apply adjoint control vector transform matrix

        Callback Parameters
        -------------------
        iter : int
                Iteration of optimization
        dim_p : int
                PE-local observation dimension
        dim_ens : int
                Ensemble size
        dim_cv_ens_p : int
                PE-local dimension of control vector
        ens_p : ndarray[np.float64, ndim=2]
                PE-local ensemble
                Array shape: (dim_p, dim_ens)
        vcv_p : ndarray[np.float64, ndim=1]
                PE-local input vector
                Array shape: (dim_p)
        cv_p : ndarray[np.float64, ndim=1]
                PE-local result vector
                Array shape: (dim_cv_ens_p)

        Callback Returns
        ----------------
        cv_p : ndarray[np.float64, ndim=1]
                PE-local result vector
                Array shape: (dim_cv_ens_p)

    py__obs_op_lin_pdaf : Callable
        Linearized observation operator

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_p : int
                PE-local dimension of state
        dim_obs_p : int
                Dimension of observed state
        state_p : ndarray[np.float64, ndim=1]
                PE-local model state
                Array shape: (dim_p)
        m_state_p : ndarray[np.float64, ndim=1]
                PE-local observed state
                Array shape: (dim_obs_p)

        Callback Returns
        ----------------
        m_state_p : ndarray[np.float64, ndim=1]
                PE-local observed state
                Array shape: (dim_obs_p)

    py__obs_op_adj_pdaf : Callable
        Adjoint observation operator

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_p : int
                PE-local dimension of state
        dim_obs_p : int
                Dimension of observed state
        m_state_p : ndarray[np.float64, ndim=1]
                PE-local observed state
                Array shape: (dim_obs_p)
        state_p : ndarray[np.float64, ndim=1]
                PE-local model state
                Array shape: (dim_p)

        Callback Returns
        ----------------
        state_p : ndarray[np.float64, ndim=1]
                PE-local model state
                Array shape: (dim_p)

    py__prodrinva_l_pdaf : Callable
        Provide product R^-1 A

        Callback Parameters
        -------------------
        domain_p : int
                Index of current local analysis domain
        step : int
                Current time step
        dim_obs_l : int
                Number of local observations at current time step (i.e. the size of the local observation vector)
        rank : int
                Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)
        obs_l : ndarray[np.float64, ndim=1]
                Local vector of observations
                Array shape: (dim_obs_l)
        a_l : ndarray[np.float64, ndim=2]
                Input matrix provided by PDAF
                Array shape: (dim_obs_l, rank)

        Callback Returns
        ----------------
        a_l : ndarray[np.float64, ndim=2]
                Input matrix provided by PDAF
                Array shape: (dim_obs_l, rank)
        c_l : ndarray[np.float64, ndim=2]
                Output matrix
                Array shape: (dim_obs_l, rank)

    py__init_n_domains_p_pdaf : Callable
        Provide number of local analysis domains

        Callback Parameters
        -------------------
        step : int
                current time step

        Callback Returns
        ----------------
        n_domains_p : int
                pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable
        Init state dimension for local ana. domain

        Callback Parameters
        -------------------
        step : int
                current time step
        domain_p : int
                current local analysis domain

        Callback Returns
        ----------------
        dim_l : int
                local state dimension

    py__init_dim_obs_l_pdaf : Callable
        Initialize local dimimension of obs. vector

        Callback Parameters
        -------------------
        domain_p : int
                index of current local analysis domain
        step : int
                current time step
        dim_obs_f : int
                full dimension of observation vector

        Callback Returns
        ----------------
        dim_obs_l : int
                local dimension of observation vector

    py__prepoststep_pdaf : Callable
        User supplied pre/poststep routine

        Callback Parameters
        -------------------
        step : int
                current time step
                (negative for call before analysis/preprocessing)
        dim_p : int
                PE-local state vector dimension
        dim_ens : int
                number of ensemble members
        dim_ens_l : int
                number of ensemble members run serially
                on each model task
        dim_obs_p : int
                PE-local dimension of observation vector
        state_p : ndarray[np.float64, ndim=1]
                pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)
                Array shape: (dim_p)
        uinv : ndarray[np.float64, ndim=2]
                Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.
                Array shape: (dim_ens-1, dim_ens-1)
        ens_p : ndarray[np.float64, ndim=2]
                PE-local ensemble
                Array shape: (dim_p, dim_ens)
        flag : int
                pdaf status flag

        Callback Returns
        ----------------
        state_p : ndarray[np.float64, ndim=1]
                pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)
                Array shape: (dim_p)
        uinv : ndarray[np.float64, ndim=2]
                Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.
                Array shape: (dim_ens-1, dim_ens-1)
        ens_p : ndarray[np.float64, ndim=2]
                PE-local ensemble
                Array shape: (dim_p, dim_ens)


    Returns
    -------
    outflag : int
        Status flag
    """
    pdaf_cb.collect_state_pdaf = <void*>py__collect_state_pdaf
    pdaf_cb.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    pdaf_cb.obs_op_pdaf = <void*>py__obs_op_pdaf
    pdaf_cb.prodrinva_pdaf = <void*>py__prodrinva_pdaf
    pdaf_cb.cvt_ens_pdaf = <void*>py__cvt_ens_pdaf
    pdaf_cb.cvt_adj_ens_pdaf = <void*>py__cvt_adj_ens_pdaf
    pdaf_cb.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    pdaf_cb.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    pdaf_cb.prodrinva_l_pdaf = <void*>py__prodrinva_l_pdaf
    pdaf_cb.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    pdaf_cb.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    pdaf_cb.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    pdaf_cb.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    cdef int  outflag
    with nogil:
        c__pdaflocalomi_put_state_en3dvar_lestkf_nondiagr(
                                                          pdaf_cb.c__collect_state_pdaf,
                                                          pdaf_cb.c__init_dim_obs_pdaf,
                                                          pdaf_cb.c__obs_op_pdaf,
                                                          pdaf_cb.c__prodrinva_pdaf,
                                                          pdaf_cb.c__cvt_ens_pdaf,
                                                          pdaf_cb.c__cvt_adj_ens_pdaf,
                                                          pdaf_cb.c__obs_op_lin_pdaf,
                                                          pdaf_cb.c__obs_op_adj_pdaf,
                                                          pdaf_cb.c__prodrinva_l_pdaf,
                                                          pdaf_cb.c__init_n_domains_p_pdaf,
                                                          pdaf_cb.c__init_dim_l_pdaf,
                                                          pdaf_cb.c__init_dim_obs_l_pdaf,
                                                          pdaf_cb.c__prepoststep_pdaf,
                                                          &outflag)

    return outflag


def put_state_hyb3dvar_lestkf_nondiagr(py__collect_state_pdaf,
    py__init_dim_obs_pdaf, py__obs_op_pdaf, py__prodrinva_pdaf,
    py__cvt_ens_pdaf, py__cvt_adj_ens_pdaf, py__cvt_pdaf, py__cvt_adj_pdaf,
    py__obs_op_lin_pdaf, py__obs_op_adj_pdaf, py__prodrinva_l_pdaf,
    py__init_n_domains_p_pdaf, py__init_dim_l_pdaf,
    py__init_dim_obs_l_pdaf, py__prepoststep_pdaf):
    """Checking the corresponding PDAF documentation in https://pdaf.awi.de
    For internal subroutines checking corresponding PDAF comments.

    Parameters
    ----------
    py__collect_state_pdaf : Callable
        Routine to collect a state vector

        Callback Parameters
        -------------------
        dim_p : int
                pe-local state dimension
        state_p : ndarray[np.float64, ndim=1]
                local state vector
                Array shape: (dim_p)

        Callback Returns
        ----------------
        state_p : ndarray[np.float64, ndim=1]
                local state vector
                Array shape: (dim_p)

    py__init_dim_obs_pdaf : Callable
        Initialize dimension of full observation vector

        Callback Parameters
        -------------------
        step : int
                current time step

        Callback Returns
        ----------------
        dim_obs_p : int
                dimension of observation vector

    py__obs_op_pdaf : Callable
        Full observation operator

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_p : int
                Size of state vector
                (local part in case of parallel decomposed state)
        dim_obs_p : int
                Size of PE-local observation vector
        state_p : ndarray[np.float64, ndim=1]
                Model state vector
                Array shape: (dim_p)
        m_state_p : ndarray[np.float64, ndim=1]
                Observed state vector
                (i.e. the result after applying the observation operator to state_p)
                Array shape: (dim_obs_p)

        Callback Returns
        ----------------
        m_state_p : ndarray[np.float64, ndim=1]
                Observed state vector
                (i.e. the result after applying the observation operator to state_p)
                Array shape: (dim_obs_p)

    py__prodrinva_pdaf : Callable
        Provide product R^-1 A

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_obs_p : int
                Number of observations at current time step (i.e. the size of the observation vector)
        rank : int
                Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one
                (or the rank of the initial covariance matrix)
        obs_p : ndarray[np.float64, ndim=1]
                Vector of observations
                Array shape: (dim_obs_p)
        a_p : ndarray[np.float64, ndim=2]
                Input matrix provided by PDAF
                Array shape: (dim_obs_p, rank)

        Callback Returns
        ----------------
        c_p : ndarray[np.float64, ndim=2]
                Output matrix
                Array shape: (dim_obs_p, rank)

    py__cvt_ens_pdaf : Callable
        Apply control vector transform matrix to control vector

        Callback Parameters
        -------------------
        iter : int
                Iteration of optimization
        dim_p : int
                PE-local dimension of state
        dim_ens : int
                Ensemble size
        dim_cvec_ens : int
                Dimension of control vector
        ens_p : ndarray[np.float64, ndim=2]
                PE-local ensemble
                Array shape: (dim_p, dim_ens)
        v_p : ndarray[np.float64, ndim=1]
                PE-local control vector
                Array shape: (dim_cvec_ens)
        vv_p : ndarray[np.float64, ndim=1]
                PE-local state increment
                Array shape: (dim_p)

        Callback Returns
        ----------------
        vv_p : ndarray[np.float64, ndim=1]
                PE-local state increment
                Array shape: (dim_p)

    py__cvt_adj_ens_pdaf : Callable
        Apply adjoint control vector transform matrix

        Callback Parameters
        -------------------
        iter : int
                Iteration of optimization
        dim_p : int
                PE-local observation dimension
        dim_ens : int
                Ensemble size
        dim_cv_ens_p : int
                PE-local dimension of control vector
        ens_p : ndarray[np.float64, ndim=2]
                PE-local ensemble
                Array shape: (dim_p, dim_ens)
        vcv_p : ndarray[np.float64, ndim=1]
                PE-local input vector
                Array shape: (dim_p)
        cv_p : ndarray[np.float64, ndim=1]
                PE-local result vector
                Array shape: (dim_cv_ens_p)

        Callback Returns
        ----------------
        cv_p : ndarray[np.float64, ndim=1]
                PE-local result vector
                Array shape: (dim_cv_ens_p)

    py__cvt_pdaf : Callable
        Apply control vector transform matrix to control vector

        Callback Parameters
        -------------------
        iter : int
                Iteration of optimization
        dim_p : int
                PE-local observation dimension
        dim_cvec : int
                Dimension of control vector
        cv_p : ndarray[np.float64, ndim=1]
                PE-local control vector
                Array shape: (dim_cvec)
        vv_p : ndarray[np.float64, ndim=1]
                PE-local result vector (state vector increment)
                Array shape: (dim_p)

        Callback Returns
        ----------------
        vv_p : ndarray[np.float64, ndim=1]
                PE-local result vector (state vector increment)
                Array shape: (dim_p)

    py__cvt_adj_pdaf : Callable
        Apply adjoint control vector transform matrix

        Callback Parameters
        -------------------
        iter : int
                Iteration of optimization
        dim_p : int
                PE-local observation dimension
        dim_cvec : int
                Dimension of control vector
        vcv_p : ndarray[np.float64, ndim=1]
                PE-local result vector (state vector increment)
                Array shape: (dim_p)
        cv_p : ndarray[np.float64, ndim=1]
                PE-local control vector
                Array shape: (dim_cvec)

        Callback Returns
        ----------------
        cv_p : ndarray[np.float64, ndim=1]
                PE-local control vector
                Array shape: (dim_cvec)

    py__obs_op_lin_pdaf : Callable
        Linearized observation operator

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_p : int
                PE-local dimension of state
        dim_obs_p : int
                Dimension of observed state
        state_p : ndarray[np.float64, ndim=1]
                PE-local model state
                Array shape: (dim_p)
        m_state_p : ndarray[np.float64, ndim=1]
                PE-local observed state
                Array shape: (dim_obs_p)

        Callback Returns
        ----------------
        m_state_p : ndarray[np.float64, ndim=1]
                PE-local observed state
                Array shape: (dim_obs_p)

    py__obs_op_adj_pdaf : Callable
        Adjoint observation operator

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_p : int
                PE-local dimension of state
        dim_obs_p : int
                Dimension of observed state
        m_state_p : ndarray[np.float64, ndim=1]
                PE-local observed state
                Array shape: (dim_obs_p)
        state_p : ndarray[np.float64, ndim=1]
                PE-local model state
                Array shape: (dim_p)

        Callback Returns
        ----------------
        state_p : ndarray[np.float64, ndim=1]
                PE-local model state
                Array shape: (dim_p)

    py__prodrinva_l_pdaf : Callable
        Provide product R^-1 A

        Callback Parameters
        -------------------
        domain_p : int
                Index of current local analysis domain
        step : int
                Current time step
        dim_obs_l : int
                Number of local observations at current time step (i.e. the size of the local observation vector)
        rank : int
                Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)
        obs_l : ndarray[np.float64, ndim=1]
                Local vector of observations
                Array shape: (dim_obs_l)
        a_l : ndarray[np.float64, ndim=2]
                Input matrix provided by PDAF
                Array shape: (dim_obs_l, rank)

        Callback Returns
        ----------------
        a_l : ndarray[np.float64, ndim=2]
                Input matrix provided by PDAF
                Array shape: (dim_obs_l, rank)
        c_l : ndarray[np.float64, ndim=2]
                Output matrix
                Array shape: (dim_obs_l, rank)

    py__init_n_domains_p_pdaf : Callable
        Provide number of local analysis domains

        Callback Parameters
        -------------------
        step : int
                current time step

        Callback Returns
        ----------------
        n_domains_p : int
                pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable
        Init state dimension for local ana. domain

        Callback Parameters
        -------------------
        step : int
                current time step
        domain_p : int
                current local analysis domain

        Callback Returns
        ----------------
        dim_l : int
                local state dimension

    py__init_dim_obs_l_pdaf : Callable
        Initialize local dimimension of obs. vector

        Callback Parameters
        -------------------
        domain_p : int
                index of current local analysis domain
        step : int
                current time step
        dim_obs_f : int
                full dimension of observation vector

        Callback Returns
        ----------------
        dim_obs_l : int
                local dimension of observation vector

    py__prepoststep_pdaf : Callable
        User supplied pre/poststep routine

        Callback Parameters
        -------------------
        step : int
                current time step
                (negative for call before analysis/preprocessing)
        dim_p : int
                PE-local state vector dimension
        dim_ens : int
                number of ensemble members
        dim_ens_l : int
                number of ensemble members run serially
                on each model task
        dim_obs_p : int
                PE-local dimension of observation vector
        state_p : ndarray[np.float64, ndim=1]
                pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)
                Array shape: (dim_p)
        uinv : ndarray[np.float64, ndim=2]
                Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.
                Array shape: (dim_ens-1, dim_ens-1)
        ens_p : ndarray[np.float64, ndim=2]
                PE-local ensemble
                Array shape: (dim_p, dim_ens)
        flag : int
                pdaf status flag

        Callback Returns
        ----------------
        state_p : ndarray[np.float64, ndim=1]
                pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)
                Array shape: (dim_p)
        uinv : ndarray[np.float64, ndim=2]
                Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.
                Array shape: (dim_ens-1, dim_ens-1)
        ens_p : ndarray[np.float64, ndim=2]
                PE-local ensemble
                Array shape: (dim_p, dim_ens)


    Returns
    -------
    outflag : int
        Status flag
    """
    pdaf_cb.collect_state_pdaf = <void*>py__collect_state_pdaf
    pdaf_cb.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    pdaf_cb.obs_op_pdaf = <void*>py__obs_op_pdaf
    pdaf_cb.prodrinva_pdaf = <void*>py__prodrinva_pdaf
    pdaf_cb.cvt_ens_pdaf = <void*>py__cvt_ens_pdaf
    pdaf_cb.cvt_adj_ens_pdaf = <void*>py__cvt_adj_ens_pdaf
    pdaf_cb.cvt_pdaf = <void*>py__cvt_pdaf
    pdaf_cb.cvt_adj_pdaf = <void*>py__cvt_adj_pdaf
    pdaf_cb.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    pdaf_cb.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    pdaf_cb.prodrinva_l_pdaf = <void*>py__prodrinva_l_pdaf
    pdaf_cb.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    pdaf_cb.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    pdaf_cb.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    pdaf_cb.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    cdef int  outflag
    with nogil:
        c__pdaflocalomi_put_state_hyb3dvar_lestkf_nondiagr(
                                                           pdaf_cb.c__collect_state_pdaf,
                                                           pdaf_cb.c__init_dim_obs_pdaf,
                                                           pdaf_cb.c__obs_op_pdaf,
                                                           pdaf_cb.c__prodrinva_pdaf,
                                                           pdaf_cb.c__cvt_ens_pdaf,
                                                           pdaf_cb.c__cvt_adj_ens_pdaf,
                                                           pdaf_cb.c__cvt_pdaf,
                                                           pdaf_cb.c__cvt_adj_pdaf,
                                                           pdaf_cb.c__obs_op_lin_pdaf,
                                                           pdaf_cb.c__obs_op_adj_pdaf,
                                                           pdaf_cb.c__prodrinva_l_pdaf,
                                                           pdaf_cb.c__init_n_domains_p_pdaf,
                                                           pdaf_cb.c__init_dim_l_pdaf,
                                                           pdaf_cb.c__init_dim_obs_l_pdaf,
                                                           pdaf_cb.c__prepoststep_pdaf,
                                                           &outflag)

    return outflag


def put_state(py__collect_state_pdaf, py__init_dim_obs_f_pdaf,
    py__obs_op_f_pdaf, py__prepoststep_pdaf, py__init_n_domains_p_pdaf,
    py__init_dim_l_pdaf, py__init_dim_obs_l_pdaf, int  outflag):
    """Checking the corresponding PDAF documentation in https://pdaf.awi.de
    For internal subroutines checking corresponding PDAF comments.

    Parameters
    ----------
    py__collect_state_pdaf : Callable
        Routine to collect a state vector

        Callback Parameters
        -------------------
        dim_p : int
                pe-local state dimension
        state_p : ndarray[np.float64, ndim=1]
                local state vector
                Array shape: (dim_p)

        Callback Returns
        ----------------
        state_p : ndarray[np.float64, ndim=1]
                local state vector
                Array shape: (dim_p)

    py__init_dim_obs_f_pdaf : Callable
        Initialize dimension of full observation vector

        Callback Parameters
        -------------------
        step : int
                current time step

        Callback Returns
        ----------------
        dim_obs_p : int
                dimension of observation vector

    py__obs_op_f_pdaf : Callable
        Full observation operator

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_p : int
                Size of state vector (local part in case of parallel decomposed state)
        dim_obs_p : int
                Size of observation vector
        state_p : ndarray[np.float64, ndim=1]
                Model state vector
                Array shape: (dim_p)

        Callback Returns
        ----------------
        m_state_p : ndarray[np.float64, ndim=1]
                Observed state vector (i.e. the result after applying the observation operator to state_p)
                Array shape: (dim_obs_p)

    py__prepoststep_pdaf : Callable
        User supplied pre/poststep routine

        Callback Parameters
        -------------------
        step : int
                current time step
                (negative for call before analysis/preprocessing)
        dim_p : int
                PE-local state vector dimension
        dim_ens : int
                number of ensemble members
        dim_ens_l : int
                number of ensemble members run serially
                on each model task
        dim_obs_p : int
                PE-local dimension of observation vector
        state_p : ndarray[np.float64, ndim=1]
                pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)
                Array shape: (dim_p)
        uinv : ndarray[np.float64, ndim=2]
                Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.
                Array shape: (dim_ens-1, dim_ens-1)
        ens_p : ndarray[np.float64, ndim=2]
                PE-local ensemble
                Array shape: (dim_p, dim_ens)
        flag : int
                pdaf status flag

        Callback Returns
        ----------------
        state_p : ndarray[np.float64, ndim=1]
                pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)
                Array shape: (dim_p)
        uinv : ndarray[np.float64, ndim=2]
                Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.
                Array shape: (dim_ens-1, dim_ens-1)
        ens_p : ndarray[np.float64, ndim=2]
                PE-local ensemble
                Array shape: (dim_p, dim_ens)

    py__init_n_domains_p_pdaf : Callable
        Provide number of local analysis domains

        Callback Parameters
        -------------------
        step : int
                current time step

        Callback Returns
        ----------------
        n_domains_p : int
                pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable
        Init state dimension for local ana. domain

        Callback Parameters
        -------------------
        step : int
                current time step
        domain_p : int
                current local analysis domain

        Callback Returns
        ----------------
        dim_l : int
                local state dimension

    py__init_dim_obs_l_pdaf : Callable
        Initialize local dimimension of obs. vector

        Callback Parameters
        -------------------
        domain_p : int
                index of current local analysis domain
        step : int
                current time step
        dim_obs_f : int
                full dimension of observation vector

        Callback Returns
        ----------------
        dim_obs_l : int
                local dimension of observation vector

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    pdaf_cb.collect_state_pdaf = <void*>py__collect_state_pdaf
    pdaf_cb.init_dim_obs_f_pdaf = <void*>py__init_dim_obs_f_pdaf
    pdaf_cb.obs_op_f_pdaf = <void*>py__obs_op_f_pdaf
    pdaf_cb.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    pdaf_cb.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    pdaf_cb.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    pdaf_cb.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    with nogil:
        c__pdaflocalomi_put_state(pdaf_cb.c__collect_state_pdaf,
                                  pdaf_cb.c__init_dim_obs_f_pdaf,
                                  pdaf_cb.c__obs_op_f_pdaf,
                                  pdaf_cb.c__prepoststep_pdaf,
                                  pdaf_cb.c__init_n_domains_p_pdaf,
                                  pdaf_cb.c__init_dim_l_pdaf,
                                  pdaf_cb.c__init_dim_obs_l_pdaf, &outflag)

    return outflag


def put_state_nondiagr(py__collect_state_pdaf, py__init_dim_obs_pdaf,
    py__obs_op_pdaf, py__prepoststep_pdaf, py__init_n_domains_p_pdaf,
    py__init_dim_l_pdaf, py__init_dim_obs_l_pdaf, py__prodrinva_l_pdaf):
    """Checking the corresponding PDAF documentation in https://pdaf.awi.de
    For internal subroutines checking corresponding PDAF comments.

    Parameters
    ----------
    py__collect_state_pdaf : Callable
        Routine to collect a state vector

        Callback Parameters
        -------------------
        dim_p : int
                pe-local state dimension
        state_p : ndarray[np.float64, ndim=1]
                local state vector
                Array shape: (dim_p)

        Callback Returns
        ----------------
        state_p : ndarray[np.float64, ndim=1]
                local state vector
                Array shape: (dim_p)

    py__init_dim_obs_pdaf : Callable
        Initialize dimension of full observation vector

        Callback Parameters
        -------------------
        step : int
                current time step

        Callback Returns
        ----------------
        dim_obs_p : int
                dimension of observation vector

    py__obs_op_pdaf : Callable
        Full observation operator

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_p : int
                Size of state vector
                (local part in case of parallel decomposed state)
        dim_obs_p : int
                Size of PE-local observation vector
        state_p : ndarray[np.float64, ndim=1]
                Model state vector
                Array shape: (dim_p)
        m_state_p : ndarray[np.float64, ndim=1]
                Observed state vector
                (i.e. the result after applying the observation operator to state_p)
                Array shape: (dim_obs_p)

        Callback Returns
        ----------------
        m_state_p : ndarray[np.float64, ndim=1]
                Observed state vector
                (i.e. the result after applying the observation operator to state_p)
                Array shape: (dim_obs_p)

    py__prepoststep_pdaf : Callable
        User supplied pre/poststep routine

        Callback Parameters
        -------------------
        step : int
                current time step
                (negative for call before analysis/preprocessing)
        dim_p : int
                PE-local state vector dimension
        dim_ens : int
                number of ensemble members
        dim_ens_l : int
                number of ensemble members run serially
                on each model task
        dim_obs_p : int
                PE-local dimension of observation vector
        state_p : ndarray[np.float64, ndim=1]
                pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)
                Array shape: (dim_p)
        uinv : ndarray[np.float64, ndim=2]
                Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.
                Array shape: (dim_ens-1, dim_ens-1)
        ens_p : ndarray[np.float64, ndim=2]
                PE-local ensemble
                Array shape: (dim_p, dim_ens)
        flag : int
                pdaf status flag

        Callback Returns
        ----------------
        state_p : ndarray[np.float64, ndim=1]
                pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)
                Array shape: (dim_p)
        uinv : ndarray[np.float64, ndim=2]
                Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.
                Array shape: (dim_ens-1, dim_ens-1)
        ens_p : ndarray[np.float64, ndim=2]
                PE-local ensemble
                Array shape: (dim_p, dim_ens)

    py__init_n_domains_p_pdaf : Callable
        Provide number of local analysis domains

        Callback Parameters
        -------------------
        step : int
                current time step

        Callback Returns
        ----------------
        n_domains_p : int
                pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable
        Init state dimension for local ana. domain

        Callback Parameters
        -------------------
        step : int
                current time step
        domain_p : int
                current local analysis domain

        Callback Returns
        ----------------
        dim_l : int
                local state dimension

    py__init_dim_obs_l_pdaf : Callable
        Initialize local dimimension of obs. vector

        Callback Parameters
        -------------------
        domain_p : int
                index of current local analysis domain
        step : int
                current time step
        dim_obs_f : int
                full dimension of observation vector

        Callback Returns
        ----------------
        dim_obs_l : int
                local dimension of observation vector

    py__prodrinva_l_pdaf : Callable
        Provide product of inverse of R with matrix A

        Callback Parameters
        -------------------
        domain_p : int
                Index of current local analysis domain
        step : int
                Current time step
        dim_obs_l : int
                Number of local observations at current time step (i.e. the size of the local observation vector)
        rank : int
                Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)
        obs_l : ndarray[np.float64, ndim=1]
                Local vector of observations
                Array shape: (dim_obs_l)
        a_l : ndarray[np.float64, ndim=2]
                Input matrix provided by PDAF
                Array shape: (dim_obs_l, rank)

        Callback Returns
        ----------------
        a_l : ndarray[np.float64, ndim=2]
                Input matrix provided by PDAF
                Array shape: (dim_obs_l, rank)
        c_l : ndarray[np.float64, ndim=2]
                Output matrix
                Array shape: (dim_obs_l, rank)


    Returns
    -------
    outflag : int
        Status flag
    """
    pdaf_cb.collect_state_pdaf = <void*>py__collect_state_pdaf
    pdaf_cb.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    pdaf_cb.obs_op_pdaf = <void*>py__obs_op_pdaf
    pdaf_cb.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    pdaf_cb.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    pdaf_cb.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    pdaf_cb.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    pdaf_cb.prodrinva_l_pdaf = <void*>py__prodrinva_l_pdaf
    cdef int  outflag
    with nogil:
        c__pdaflocalomi_put_state_nondiagr(pdaf_cb.c__collect_state_pdaf,
                                           pdaf_cb.c__init_dim_obs_pdaf,
                                           pdaf_cb.c__obs_op_pdaf,
                                           pdaf_cb.c__prepoststep_pdaf,
                                           pdaf_cb.c__init_n_domains_p_pdaf,
                                           pdaf_cb.c__init_dim_l_pdaf,
                                           pdaf_cb.c__init_dim_obs_l_pdaf,
                                           pdaf_cb.c__prodrinva_l_pdaf,
                                           &outflag)

    return outflag


def put_state_lnetf_nondiagr(py__collect_state_pdaf, py__init_dim_obs_pdaf,
    py__obs_op_pdaf, py__prepoststep_pdaf, py__init_n_domains_p_pdaf,
    py__init_dim_l_pdaf, py__init_dim_obs_l_pdaf, py__likelihood_l_pdaf):
    """Checking the corresponding PDAF documentation in https://pdaf.awi.de
    For internal subroutines checking corresponding PDAF comments.

    Parameters
    ----------
    py__collect_state_pdaf : Callable
        Routine to collect a state vector

        Callback Parameters
        -------------------
        dim_p : int
                pe-local state dimension
        state_p : ndarray[np.float64, ndim=1]
                local state vector
                Array shape: (dim_p)

        Callback Returns
        ----------------
        state_p : ndarray[np.float64, ndim=1]
                local state vector
                Array shape: (dim_p)

    py__init_dim_obs_pdaf : Callable
        Initialize dimension of full observation vector

        Callback Parameters
        -------------------
        step : int
                current time step

        Callback Returns
        ----------------
        dim_obs_p : int
                dimension of observation vector

    py__obs_op_pdaf : Callable
        Full observation operator

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_p : int
                Size of state vector
                (local part in case of parallel decomposed state)
        dim_obs_p : int
                Size of PE-local observation vector
        state_p : ndarray[np.float64, ndim=1]
                Model state vector
                Array shape: (dim_p)
        m_state_p : ndarray[np.float64, ndim=1]
                Observed state vector
                (i.e. the result after applying the observation operator to state_p)
                Array shape: (dim_obs_p)

        Callback Returns
        ----------------
        m_state_p : ndarray[np.float64, ndim=1]
                Observed state vector
                (i.e. the result after applying the observation operator to state_p)
                Array shape: (dim_obs_p)

    py__prepoststep_pdaf : Callable
        User supplied pre/poststep routine

        Callback Parameters
        -------------------
        step : int
                current time step
                (negative for call before analysis/preprocessing)
        dim_p : int
                PE-local state vector dimension
        dim_ens : int
                number of ensemble members
        dim_ens_l : int
                number of ensemble members run serially
                on each model task
        dim_obs_p : int
                PE-local dimension of observation vector
        state_p : ndarray[np.float64, ndim=1]
                pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)
                Array shape: (dim_p)
        uinv : ndarray[np.float64, ndim=2]
                Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.
                Array shape: (dim_ens-1, dim_ens-1)
        ens_p : ndarray[np.float64, ndim=2]
                PE-local ensemble
                Array shape: (dim_p, dim_ens)
        flag : int
                pdaf status flag

        Callback Returns
        ----------------
        state_p : ndarray[np.float64, ndim=1]
                pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)
                Array shape: (dim_p)
        uinv : ndarray[np.float64, ndim=2]
                Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.
                Array shape: (dim_ens-1, dim_ens-1)
        ens_p : ndarray[np.float64, ndim=2]
                PE-local ensemble
                Array shape: (dim_p, dim_ens)

    py__init_n_domains_p_pdaf : Callable
        Provide number of local analysis domains

        Callback Parameters
        -------------------
        step : int
                current time step

        Callback Returns
        ----------------
        n_domains_p : int
                pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable
        Init state dimension for local ana. domain

        Callback Parameters
        -------------------
        step : int
                current time step
        domain_p : int
                current local analysis domain

        Callback Returns
        ----------------
        dim_l : int
                local state dimension

    py__init_dim_obs_l_pdaf : Callable
        Initialize local dimimension of obs. vector

        Callback Parameters
        -------------------
        domain_p : int
                index of current local analysis domain
        step : int
                current time step
        dim_obs_f : int
                full dimension of observation vector

        Callback Returns
        ----------------
        dim_obs_l : int
                local dimension of observation vector

    py__likelihood_l_pdaf : Callable
        Compute likelihood and apply localization

        Callback Parameters
        -------------------
        domain_p : int
                Index of current local analysis domain
        step : int
                Current time step
        dim_obs_l : int
                Number of local observations at current time step (i.e. the size of the local observation vector)
        obs_l : ndarray[np.float64, ndim=1]
                Local vector of observations
                Array shape: (dim_obs_l)
        resid_l : ndarray[np.float64, ndim=1]
                nput vector holding the local residual
                Array shape: (dim_obs_l)

        Callback Returns
        ----------------
        resid_l : ndarray[np.float64, ndim=1]
                nput vector holding the local residual
                Array shape: (dim_obs_l)
        likely_l : double
                Output value of the local likelihood


    Returns
    -------
    outflag : int
        Status flag
    """
    pdaf_cb.collect_state_pdaf = <void*>py__collect_state_pdaf
    pdaf_cb.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    pdaf_cb.obs_op_pdaf = <void*>py__obs_op_pdaf
    pdaf_cb.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    pdaf_cb.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    pdaf_cb.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    pdaf_cb.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    pdaf_cb.likelihood_l_pdaf = <void*>py__likelihood_l_pdaf
    cdef int  outflag
    with nogil:
        c__pdaflocalomi_put_state_lnetf_nondiagr(
                                                 pdaf_cb.c__collect_state_pdaf,
                                                 pdaf_cb.c__init_dim_obs_pdaf,
                                                 pdaf_cb.c__obs_op_pdaf,
                                                 pdaf_cb.c__prepoststep_pdaf,
                                                 pdaf_cb.c__init_n_domains_p_pdaf,
                                                 pdaf_cb.c__init_dim_l_pdaf,
                                                 pdaf_cb.c__init_dim_obs_l_pdaf,
                                                 pdaf_cb.c__likelihood_l_pdaf,
                                                 &outflag)

    return outflag


def put_state_lknetf_nondiagr(py__collect_state_pdaf,
    py__init_dim_obs_pdaf, py__obs_op_pdaf, py__prepoststep_pdaf,
    py__init_n_domains_p_pdaf, py__init_dim_l_pdaf,
    py__init_dim_obs_l_pdaf, py__prodrinva_l_pdaf,
    py__prodrinva_hyb_l_pdaf, py__likelihood_l_pdaf, py__likelihood_hyb_l_pdaf):
    """Checking the corresponding PDAF documentation in https://pdaf.awi.de
    For internal subroutines checking corresponding PDAF comments.

    Parameters
    ----------
    py__collect_state_pdaf : Callable
        Routine to collect a state vector

        Callback Parameters
        -------------------
        dim_p : int
                pe-local state dimension
        state_p : ndarray[np.float64, ndim=1]
                local state vector
                Array shape: (dim_p)

        Callback Returns
        ----------------
        state_p : ndarray[np.float64, ndim=1]
                local state vector
                Array shape: (dim_p)

    py__init_dim_obs_pdaf : Callable
        Initialize dimension of full observation vector

        Callback Parameters
        -------------------
        step : int
                current time step

        Callback Returns
        ----------------
        dim_obs_p : int
                dimension of observation vector

    py__obs_op_pdaf : Callable
        Full observation operator

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_p : int
                Size of state vector
                (local part in case of parallel decomposed state)
        dim_obs_p : int
                Size of PE-local observation vector
        state_p : ndarray[np.float64, ndim=1]
                Model state vector
                Array shape: (dim_p)
        m_state_p : ndarray[np.float64, ndim=1]
                Observed state vector
                (i.e. the result after applying the observation operator to state_p)
                Array shape: (dim_obs_p)

        Callback Returns
        ----------------
        m_state_p : ndarray[np.float64, ndim=1]
                Observed state vector
                (i.e. the result after applying the observation operator to state_p)
                Array shape: (dim_obs_p)

    py__prepoststep_pdaf : Callable
        User supplied pre/poststep routine

        Callback Parameters
        -------------------
        step : int
                current time step
                (negative for call before analysis/preprocessing)
        dim_p : int
                PE-local state vector dimension
        dim_ens : int
                number of ensemble members
        dim_ens_l : int
                number of ensemble members run serially
                on each model task
        dim_obs_p : int
                PE-local dimension of observation vector
        state_p : ndarray[np.float64, ndim=1]
                pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)
                Array shape: (dim_p)
        uinv : ndarray[np.float64, ndim=2]
                Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.
                Array shape: (dim_ens-1, dim_ens-1)
        ens_p : ndarray[np.float64, ndim=2]
                PE-local ensemble
                Array shape: (dim_p, dim_ens)
        flag : int
                pdaf status flag

        Callback Returns
        ----------------
        state_p : ndarray[np.float64, ndim=1]
                pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)
                Array shape: (dim_p)
        uinv : ndarray[np.float64, ndim=2]
                Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.
                Array shape: (dim_ens-1, dim_ens-1)
        ens_p : ndarray[np.float64, ndim=2]
                PE-local ensemble
                Array shape: (dim_p, dim_ens)

    py__init_n_domains_p_pdaf : Callable
        Provide number of local analysis domains

        Callback Parameters
        -------------------
        step : int
                current time step

        Callback Returns
        ----------------
        n_domains_p : int
                pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable
        Init state dimension for local ana. domain

        Callback Parameters
        -------------------
        step : int
                current time step
        domain_p : int
                current local analysis domain

        Callback Returns
        ----------------
        dim_l : int
                local state dimension

    py__init_dim_obs_l_pdaf : Callable
        Initialize local dimimension of obs. vector

        Callback Parameters
        -------------------
        domain_p : int
                index of current local analysis domain
        step : int
                current time step
        dim_obs_f : int
                full dimension of observation vector

        Callback Returns
        ----------------
        dim_obs_l : int
                local dimension of observation vector

    py__prodrinva_l_pdaf : Callable
        Provide product R^-1 A on local analysis domain

        Callback Parameters
        -------------------
        domain_p : int
                Index of current local analysis domain
        step : int
                Current time step
        dim_obs_l : int
                Number of local observations at current time step (i.e. the size of the local observation vector)
        rank : int
                Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)
        obs_l : ndarray[np.float64, ndim=1]
                Local vector of observations
                Array shape: (dim_obs_l)
        a_l : ndarray[np.float64, ndim=2]
                Input matrix provided by PDAF
                Array shape: (dim_obs_l, rank)

        Callback Returns
        ----------------
        a_l : ndarray[np.float64, ndim=2]
                Input matrix provided by PDAF
                Array shape: (dim_obs_l, rank)
        c_l : ndarray[np.float64, ndim=2]
                Output matrix
                Array shape: (dim_obs_l, rank)

    py__prodrinva_hyb_l_pdaf : Callable
        Product R^-1 A on local analysis domain with hybrid weight

        Callback Parameters
        -------------------
        domain_p : int
                Index of current local analysis domain
        step : int
                Current time step
        dim_obs_l : int
                Number of local observations at current time step (i.e. the size of the local observation vector)
        dim_ens : int
                Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)
        obs_l : ndarray[np.float64, ndim=1]
                Local vector of observations
                Array shape: (dim_obs_l)
        gamma : double
                Hybrid weight provided by PDAF
        a_l : ndarray[np.float64, ndim=2]
                Input matrix provided by PDAF
                Array shape: (dim_obs_l, dim_ens)

        Callback Returns
        ----------------
        a_l : ndarray[np.float64, ndim=2]
                Input matrix provided by PDAF
                Array shape: (dim_obs_l, dim_ens)
        c_l : ndarray[np.float64, ndim=2]
                Output matrix
                Array shape: (dim_obs_l, dim_ens)

    py__likelihood_l_pdaf : Callable
        Compute likelihood and apply localization

        Callback Parameters
        -------------------
        domain_p : int
                Index of current local analysis domain
        step : int
                Current time step
        dim_obs_l : int
                Number of local observations at current time step (i.e. the size of the local observation vector)
        obs_l : ndarray[np.float64, ndim=1]
                Local vector of observations
                Array shape: (dim_obs_l)
        resid_l : ndarray[np.float64, ndim=1]
                nput vector holding the local residual
                Array shape: (dim_obs_l)

        Callback Returns
        ----------------
        resid_l : ndarray[np.float64, ndim=1]
                nput vector holding the local residual
                Array shape: (dim_obs_l)
        likely_l : double
                Output value of the local likelihood

    py__likelihood_hyb_l_pdaf : Callable
        Compute likelihood and apply localization with tempering

        Callback Parameters
        -------------------
        domain_p : int
                Index of current local analysis domain
        step : int
                Current time step
        dim_obs_l : int
                Number of local observations at current time step (i.e. the size of the local observation vector)
        obs_l : ndarray[np.float64, ndim=1]
                Local vector of observations
                Array shape: (dim_obs_l)
        resid_l : ndarray[np.float64, ndim=1]
                Input vector holding the local residual
                Array shape: (dim_obs_l)
        gamma : double
                Hybrid weight provided by PDAF

        Callback Returns
        ----------------
        resid_l : ndarray[np.float64, ndim=1]
                Input vector holding the local residual
                Array shape: (dim_obs_l)
        likely_l : double
                Output value of the local likelihood


    Returns
    -------
    outflag : int
        Status flag
    """
    pdaf_cb.collect_state_pdaf = <void*>py__collect_state_pdaf
    pdaf_cb.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    pdaf_cb.obs_op_pdaf = <void*>py__obs_op_pdaf
    pdaf_cb.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    pdaf_cb.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    pdaf_cb.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    pdaf_cb.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    pdaf_cb.prodrinva_l_pdaf = <void*>py__prodrinva_l_pdaf
    pdaf_cb.prodrinva_hyb_l_pdaf = <void*>py__prodrinva_hyb_l_pdaf
    pdaf_cb.likelihood_l_pdaf = <void*>py__likelihood_l_pdaf
    pdaf_cb.likelihood_hyb_l_pdaf = <void*>py__likelihood_hyb_l_pdaf
    cdef int  outflag
    with nogil:
        c__pdaflocalomi_put_state_lknetf_nondiagr(
                                                  pdaf_cb.c__collect_state_pdaf,
                                                  pdaf_cb.c__init_dim_obs_pdaf,
                                                  pdaf_cb.c__obs_op_pdaf,
                                                  pdaf_cb.c__prepoststep_pdaf,
                                                  pdaf_cb.c__init_n_domains_p_pdaf,
                                                  pdaf_cb.c__init_dim_l_pdaf,
                                                  pdaf_cb.c__init_dim_obs_l_pdaf,
                                                  pdaf_cb.c__prodrinva_l_pdaf,
                                                  pdaf_cb.c__prodrinva_hyb_l_pdaf,
                                                  pdaf_cb.c__likelihood_l_pdaf,
                                                  pdaf_cb.c__likelihood_hyb_l_pdaf,
                                                  &outflag)

    return outflag


