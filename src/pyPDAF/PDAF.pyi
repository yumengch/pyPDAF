import numpy as np
from typing import Callable

def assimilate_3dvar (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_dim_obs_pdaf : Callable[[int, int], int],
                      py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__prodRinvA_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                      py__cvt_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__cvt_adj_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__obs_op_lin_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__obs_op_adj_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                       int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                      py__next_observation_pdaf : Callable[[int, int, int, 
                                                            float], tuple[int, 
                                                            int, float]]
                     ) -> int:
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency.I.e., `pyPDAF.PDAF.omi_assimilate_3dvar` or `pyPDAF.PDAF.omi_assimilate_3dvar_nondiagR`. 
    Using 3DVar for DA without OMI. This is a deterministic filtering scheme. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.put_state_3dvar` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    5. py__init_obs_pdaf
    Starting the iterative optimisation:
    6. py__cvt_pdaf
    7. py__obs_op_lin_pdaf
    8. py__prodRinvA_pdaf
    9. py__obs_op_adj_pdaf
    10. py__cvt_adj_pdaf
    11. core DA algorithm
    After the iterations: 
    12. py__cvt_pdaf
    13. py__prepoststep_state_pdaf
    14. py__distribute_state_pdaf
    15. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def assimilate_en3dvar_estkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__distribute_state_pdaf : Callable[[int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__init_dim_obs_pdaf : Callable[[int, int], int],
                              py__obs_op_pdaf : Callable[[int, int, int, 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__prodRinvA_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                              py__cvt_ens_pdaf : Callable[[int, int, int, 
                                                           int, np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__cvt_adj_ens_pdaf : Callable[[int, int, 
                                                               int, int, 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__obs_op_lin_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__obs_op_adj_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__init_obsvar_pdaf : Callable[[int, int, 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               float], float],
                              py__prepoststep_pdaf : Callable[[int, int, 
                                                               int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                              py__next_observation_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    float], tuple[int, 
                                                                    int, 
                                                                    float]]
                             ) -> int:
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.omi_assimilate_en3dvar_estkf` or `pyPDAF.PDAF.omi_assimilate_en3dvar_estkf_nondiagR`. 
    Using 3DEnVar for DA without OMI. The background error covariance matrix is estimated by ensemble. The 3DEnVar only calculates the analysis of the ensemble mean. An ESTKF is used to generate ensemble perturbations. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.put_state_en3dvar_estkf` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    5. py__init_obs_pdaf
    Starting the iterative optimisation:
    6. py__cvt_ens_pdaf
    7. py__obs_op_lin_pdaf
    8. py__prodRinvA_pdaf
    9. py__obs_op_adj_pdaf
    10. py__cvt_adj_ens_pdaf
    11. core 3DEnVar algorithm
    After the iterations: 
    12. py__cvt_ens_pdaf
    Perform ESTKF: 13. py__init_dim_obs_pdaf
    14. py__obs_op_pdaf (for ensemble mean)
    15. py__init_obs_pdaf
    16. py__obs_op_pdaf (for each ensemble member)
    17. py__init_obsvar_pdaf (only relevant for adaptive forgetting factor schemes)
    18. py__prodRinvA_pdaf
    19. core ESTKF algorithm
    20. py__prepoststep_state_pdaf
    21. py__distribute_state_pdaf
    22. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def assimilate_en3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__distribute_state_pdaf : Callable[[int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__init_dim_obs_pdaf : Callable[[int, int], int],
                               py__obs_op_pdaf : Callable[[int, int, int, 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__init_obs_pdaf : Callable[[int, int, 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__prodRinvA_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                               py__cvt_ens_pdaf : Callable[[int, int, int, 
                                                            int, np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__cvt_adj_ens_pdaf : Callable[[int, int, 
                                                                int, int, 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__obs_op_lin_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__obs_op_adj_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__init_dim_obs_f_pdaf : Callable[[int, 
                                                                   int], int],
                               py__obs_op_f_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__init_obs_f_pdaf : Callable[[int, int, 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__init_obs_l_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__prodRinvA_l_pdaf : Callable[[int, int, 
                                                                int, int, 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                               py__init_n_domains_p_pdaf : Callable[[int, 
                                                                     int], int],
                               py__init_dim_l_pdaf : Callable[[int, int, 
                                                               int], int],
                               py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int], int],
                               py__g2l_state_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__l2g_state_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__g2l_obs_pdaf : Callable[[int, int, int, 
                                                            int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                            int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                            int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                               py__init_obsvar_pdaf : Callable[[int, int, 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                float], float],
                               py__init_obsvar_l_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  int, 
                                                                  float], float],
                               py__prepoststep_pdaf : Callable[[int, int, 
                                                                int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                               py__next_observation_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     float], tuple[int, 
                                                                     int, 
                                                                     float]],
                               outflag: int) -> int:
    """It is recommended to use local module with OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_assimilate_en3dvar_lestkf` or `pyPDAF.PDAF.localomi_assimilate_en3dvar_lestkf_nondiagR`. 
    Using 3DEnVar for DA without OMI. The background error covariance matrix is estimated by ensemble. The 3DEnVar only calculates the analysis of the ensemble mean. An LESTKF is used to generate ensemble perturbations. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.put_state_en3dvar_lestkf` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    5. py__init_obs_pdaf
    Starting the iterative optimisation:
    6. py__cvt_ens_pdaf
    7. py__obs_op_lin_pdaf
    8. py__prodRinvA_pdaf
    9. py__obs_op_adj_pdaf
    10. py__cvt_adj_ens_pdaf
    11. core DA algorithm
    After the iterations: 
    12. py__cvt_ens_pdaf
    Perform LESTKF: 
    13. py__init_n_domains_p_pdaf
    14. py__init_dim_obs_pdaf
    15. py__obs_op_pdaf (for each ensemble member
    16. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init))(if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init)(if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init))(if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init))(if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init)(if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init
    17. py__init_obsvar_pdaf (if global adaptive forgetting factor is used)
    loop over each local domain:
    18. py__init_dim_l_pdaf
    19. py__init_dim_obs_l_pdaf
    20. py__g2l_state_pdaf
    21. py__g2l_obs_pdaf (localise mean ensemble in observation space)
    22. py__init_obs_l_pdaf
    23. py__g2l_obs_pdaf (localise each ensemble member in observation space)
    24. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used)(only called if local adaptive forgetting factor (type_forget=2
    25. py__prodRinvA_l_pdaf
    26. core DA algorithm
    27. py__l2g_state_pdaf
    28. py__prepoststep_state_pdaf
    29. py__distribute_state_pdaf
    30. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Acts as the full observation operator on some state vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f:ndarray[tuple[dim_obs_f], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of the full observation vector

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of observations

        **Callback Returns**

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def assimilate_enkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_dim_obs_pdaf : Callable[[int, int], int],
                     py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                     py__add_obs_err_pdaf : Callable[[int, int, np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                     py__init_obs_covar_pdaf : Callable[[int, int, int, 
                                                         float, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         bool], tuple[float, 
                                                         bool]],
                     py__next_observation_pdaf : Callable[[int, int, int, 
                                                           float], tuple[int, 
                                                           int, float]]
                    ) -> int:
    """It is recommended to use :func:`pyPDAF.PDAF.omi_assimilate_global`
    or :func:`pyPDAF.PDAF.omi_assimilate_enkf_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions and improved efficiency.

    Using stochastic EnKF (ensemble Kalman filter) [1]_ for DA without OMI. This function should be called at each model time step. 

    The function is a combination of :func:`pyPDAF.PDAF.put_state_enkf` and :func:`pyPDAF.PDAF.get_state`.

    This function executes the user-supplied functions in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf (for ensemble mean)
        5. py__add_obs_err_pdaf
        6. py__init_obs_pdaf
        7. py__init_obscovar_pdaf
        8. py__obs_op_pdaf (for each ensemble member)
        9. core DA algorithm
        10. py__prepoststep_state_pdaf
        11. py__distribute_state_pdaf
        12. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by :func:`pyPDAF.PDAF.omi_assimilate_global`
       and :func:`pyPDAF.PDAF.omi_assimilate_enkf_nondiagR`

    References
    ----------
    .. [1] Evensen, G. (1994), 
           Sequential data assimilation with a nonlinear quasi-geostrophic model
           using Monte Carlo methods to forecast error statistics,
           J. Geophys. Res., 99(C5), 1014310162, doi:10.1029/94JC00572.

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__add_obs_err_pdaf : Callable[step:int, dim_obs_p:int, C_p:ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]]
        Add obs error covariance R to HPH in EnKF

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Dimension of observation vector

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            --- Matrix to that observation covariance R is added

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            --- Matrix to that observation covariance R is added


    py__init_obs_covar_pdaf : Callable[step:int, dim_obs:int, dim_obs_p:int, covar:float, obs_p:ndarray[tuple[dim_obs_p], np.float64], isdiag:bool]
        Initialize obs. error cov. matrix R in EnKF

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs** : int

            --- Global size of observation vector

        * **dim_obs_p** : int

            --- Size of process-local observation vector

        * **covar** : float

            --- Observation error covariance matrix

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Process-local vector of observations

        * **isdiag** : bool

            --- 

        **Callback Returns**

        * **covar**:float

            --- Observation error covariance matrix

        * **isdiag**:bool

            --- 


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def assimilate_estkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_dim_obs_pdaf : Callable[[int, int], int],
                      py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                       int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                      py__prodRinvA_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                      py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       float], float],
                      py__next_observation_pdaf : Callable[[int, int, int, 
                                                            float], tuple[int, 
                                                            int, float]]
                     ) -> int:
    """It is recommended to use :func:`pyPDAF.PDAF.omi_assimilate_global`
    or :func:`pyPDAF.PDAF.omi_assimilate_global_nondiagR` instead of this function.

    OMI functions need fewer user-supplied functions and improve DA efficiency.

    This function calls ESTKF (error space transform Kalman filter) [1]_.
    The ESTKF is a more efficient equivalent to the ETKF.

    The function should be called at each model time step.
    The function is a combination of :func:`pyPDAF.PDAF.put_state_estkf`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf (for ensemble mean)
        5. py__init_obs_pdaf
        6. py__obs_op_pdaf (for each ensemble member)
        7. py__init_obsvar_pdaf (only relevant for adaptive forgetting factor schemes)
        8. py__prodRinvA_pdaf
        9. core DA algorithm
        10. py__prepoststep_state_pdaf
        11. py__distribute_state_pdaf
        12. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by :func:`pyPDAF.PDAF.omi_assimilate_global`
       and :func:`pyPDAF.PDAF.omi_assimilate_global_nondiagR`

    References
    ----------
    .. [1] Nerger, L., Janji, T., Schrter, J., Hiller, W. (2012). 
           A unification of ensemble square root Kalman filters. 
           Monthly Weather Review, 140, 2335-2345. doi:10.1175/MWR-D-11-00102.1

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 HV

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def assimilate_etkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_dim_obs_pdaf : Callable[[int, int], int],
                     py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                     py__prodRinvA_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                     py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      float], float],
                     py__next_observation_pdaf : Callable[[int, int, int, 
                                                           float], tuple[int, 
                                                           int, float]]
                    ) -> int:
    """It is recommended to use :func:`pyPDAF.PDAF.omi_assimilate_global`
    or :func:`pyPDAF.PDAF.omi_assimilate_global_nondiagR`.

    PDAFlocal-OMI modules require fewer user-supplied functions and improved efficiency.

    Using ETKF (ensemble transform Kalman filter) [1]_ for DA without OMI. The implementation is baed on [2]_.

    This function should be called at each model time step.
    The function is a combination of :func:`pyPDAF.PDAF.put_state_etkf` :func:and `pyPDAF.PDAF.get_state`.

    This function executes the user-supplied function in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf (for ensemble mean)
        5. py__init_obs_pdaf
        6. py__obs_op_pdaf (for each ensemble member)
        7. py__init_obsvar_pdaf (only relevant for adaptive forgetting factor schemes)
        8. py__prodRinvA_pdaf
        9. core DA algorithm
        10. py__prepoststep_state_pdaf
        11. py__distribute_state_pdaf
        12. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by :func:`pyPDAF.PDAF.omi_assimilate_global`
       and :func:`pyPDAF.PDAF.omi_assimilate_global_nondiagR`

    References
    ----------
    .. [1] Bishop, C. H., B. J. Etherton, and S. J. Majumdar (2001)
           Adaptive Sampling with the Ensemble Transform Kalman Filter.
           Part I: Theoretical Aspects. Mon. Wea. Rev., 129, 420436,
           doi: 10.1175/1520-0493(2001)129<0420:ASWTET>2.0.CO;2. 
    .. [2] Nerger, L., Janji, T., Schrter, J., Hiller, W. (2012). 
           A unification of ensemble square root Kalman filters. 
           Monthly Weather Review, 140, 2335-2345. doi:10.1175/MWR-D-11-00102.1

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 HV

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def assimilate_hyb3dvar_estkf (py__collect_state_pdaf : Callable[[int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__distribute_state_pdaf : Callable[[int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__init_dim_obs_pdaf : Callable[[int, int], int],
                               py__obs_op_pdaf : Callable[[int, int, int, 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__init_obs_pdaf : Callable[[int, int, 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__prodRinvA_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                               py__cvt_ens_pdaf : Callable[[int, int, int, 
                                                            int, np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__cvt_adj_ens_pdaf : Callable[[int, int, 
                                                                int, int, 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__cvt_pdaf : Callable[[int, int, int, 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__cvt_adj_pdaf : Callable[[int, int, int, 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__obs_op_lin_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__obs_op_adj_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__init_obsvar_pdaf : Callable[[int, int, 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                float], float],
                               py__prepoststep_pdaf : Callable[[int, int, 
                                                                int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                               py__next_observation_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     float], tuple[int, 
                                                                     int, 
                                                                     float]]
                              ) -> int:
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.omi_assimilate_hyb3dvar_estkf` or `pyPDAF.PDAF.omi_assimilate_hyb3dvar_estkf_nondiagR`. 
    Using Hybrid 3DEnVar for DA without OMI. Here, the background error covariance is hybridised by a static background error covariance, and a flow-dependent background error covariance estimated from ensemble. The 3DVar generates an ensemble mean and the ensemble perturbation is generated by ESTKF in this implementation. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.put_state_hyb3dvar_estkf` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    5. py__init_obs_pdaf
    Starting the iterative optimisation:
    6. py__cvt_pdaf
    7. py__cvt_ens_pdaf
    8. py__obs_op_lin_pdaf
    9. py__prodRinvA_pdaf
    10. py__obs_op_adj_pdaf
    11. py__cvt_adj_pdaf
    12. py__cvt_adj_ens_pdaf
    13. core 3DEnVar algorithm
    After the iterations: 
    14. py__cvt_pdaf
    15. py__cvt_ens_pdaf
    Perform ESTKF: 16. py__init_dim_obs_pdaf
    17. py__obs_op_pdaf (for ensemble mean
    18. py__init_obs_pdaf
    19. py__obs_op_pdaf (for each ensemble member
    20. py__init_obsvar_pdaf (only relevant for adaptive forgetting factor schemes)
    21. py__prodRinvA_pdaf
    22. core ESTKF algorithm
    23. py__prepoststep_state_pdaf
    24. py__distribute_state_pdaf
    25. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def assimilate_hyb3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__distribute_state_pdaf : Callable[[int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__init_dim_obs_pdaf : Callable[[int, 
                                                                  int], int],
                                py__obs_op_pdaf : Callable[[int, int, int, 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__init_obs_pdaf : Callable[[int, int, 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__prodRinvA_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                py__cvt_ens_pdaf : Callable[[int, int, 
                                                             int, int, 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__cvt_adj_ens_pdaf : Callable[[int, int, 
                                                                 int, int, 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__cvt_pdaf : Callable[[int, int, int, 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__cvt_adj_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__obs_op_lin_pdaf : Callable[[int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__obs_op_adj_pdaf : Callable[[int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__init_dim_obs_f_pdaf : Callable[[int, 
                                                                    int], int],
                                py__obs_op_f_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__init_obs_f_pdaf : Callable[[int, int, 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__init_obs_l_pdaf : Callable[[int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__prodRinvA_l_pdaf : Callable[[int, int, 
                                                                 int, int, 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                py__init_n_domains_p_pdaf : Callable[[int, 
                                                                      int], int],
                                py__init_dim_l_pdaf : Callable[[int, int, 
                                                                int], int],
                                py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    int], int],
                                py__g2l_state_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__l2g_state_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__g2l_obs_pdaf : Callable[[int, int, 
                                                             int, int, 
                                                             np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                             int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                             int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                                py__init_obsvar_pdaf : Callable[[int, int, 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 float], float],
                                py__init_obsvar_l_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   int, 
                                                                   float], float],
                                py__prepoststep_pdaf : Callable[[int, int, 
                                                                 int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                 int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                py__next_observation_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      float], tuple[int, 
                                                                      int, 
                                                                      float]]
                               ) -> int:
    """It is recommended to use local module with OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_assimilate_hyb3dvar_lestkf` or `pyPDAF.PDAF.localomi_assimilate_hyb3dvar_lestkf_nondiagR`. 
    Using Hybrid 3DEnVar for DA without OMI. Here, the background error covariance is hybridised by a static background error covariance, and a flow-dependent background error covariance estimated from ensemble. The 3DVar generates an ensemble mean and the ensemble perturbation is generated by LESTKF in this implementation. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.put_state_hyb3dvar_lestkf` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    5. py__init_obs_pdaf
    Starting the iterative optimisation:
    6. py__cvt_pdaf
    7. py__cvt_ens_pdaf
    8. py__obs_op_lin_pdaf
    9. py__prodRinvA_pdaf
    10. py__obs_op_adj_pdaf
    11. py__cvt_adj_pdaf
    12. py__cvt_adj_ens_pdaf
    13. core DA algorithm
    After the iterations: 
    14. py__cvt_pdaf
    15. py__cvt_ens_pdaf
    Perform LESTKF: 
    16. py__init_n_domains_p_pdaf
    17. py__init_dim_obs_pdaf
    18. py__obs_op_pdaf (for each ensemble member
    19. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in `pyPDAF.PDAF.init`))
    20. py__init_obsvar_pdaf (if global adaptive forgetting factor is used)
    loop over each local domain:
    21. py__init_dim_l_pdaf
    22. py__init_dim_obs_l_pdaf
    23. py__g2l_state_pdaf
    24. py__g2l_obs_pdaf (localise mean ensemble in observation space)
    25. py__init_obs_l_pdaf
    26. py__g2l_obs_pdaf (localise each ensemble member in observation space)
    27. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used)
    28. py__prodRinvA_l_pdaf
    29. core DA algorithm
    30. py__l2g_state_pdaf
    31. py__prepoststep_state_pdaf
    32. py__distribute_state_pdaf
    33. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f:ndarray[tuple[dim_obs_f], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of the full observation vector

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of observations

        **Callback Returns**

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def assimilate_lenkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_dim_obs_pdaf : Callable[[int, int], int],
                      py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                       int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                      py__localize_covar_pdaf : Callable[[int, int, np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]]], tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                      py__add_obs_err_pdaf : Callable[[int, int, np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                      py__init_obs_covar_pdaf : Callable[[int, int, int, 
                                                          float, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          bool], tuple[float, 
                                                          bool]],
                      py__next_observation_pdaf : Callable[[int, int, int, 
                                                            float], tuple[int, 
                                                            int, float]]
                     ) -> int:
    """It is recommended to use :func:`pyPDAF.PDAF.omi_assimilate_lenkf`
    or :func:`pyPDAF.PDAF.omi_assimilate_lenkf_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions and improved efficiency.

    Using stochastic EnKF (ensemble Kalman filter) with covariance localisation [1]_
    for DA without OMI.

    This is the only scheme for covariance localisation in PDAF.

    This function should be called at each model time step.
    The function is a combination of :func:`pyPDAF.PDAF.put_state_lenkf`
    and :func:`pyPDAF.PDAF.get_state`.

    The user-supplied function is executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf (for each ensemble member)
        5. py__localize_pdaf
        6. py__add_obs_err_pdaf
        7. py__init_obs_pdaf
        8. py__init_obscovar_pdaf
        9. py__obs_op_pdaf (repeated to reduce storage)
        10. core DA algorith
        11. py__prepoststep_state_pdaf
        12. py__distribute_state_pdaf
        13. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by :func:`pyPDAF.PDAF.omi_assimilate_lenkf`
       and :func:`pyPDAF.PDAF.omi_assimilate_lenkf_nondiagR`

    References
    ----------
    .. [1] Houtekamer, P. L., and H. L. Mitchell (1998): 
           Data Assimilation Using an Ensemble Kalman Filter Technique.
           Mon. Wea. Rev., 126, 796811,
           doi: 10.1175/1520-0493(1998)126<0796:DAUAEK>2.0.CO;2.

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__localize_covar_pdaf : Callable[dim_p:int, dim_obs:int, hp_p:ndarray[tuple[dim_obs, dim_p], np.float64], hph:ndarray[tuple[dim_obs, dim_obs], np.float64]]
        Apply localization to HP and HPH^T

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_obs** : int

            --- number of observations

        * **hp_p** : ndarray[tuple[dim_obs, dim_p], np.float64]

            --- pe local part of matrix hp

        * **hph** : ndarray[tuple[dim_obs, dim_obs], np.float64]

            --- matrix hph

        **Callback Returns**

        * **hp_p** : ndarray[tuple[dim_obs, dim_p], np.float64]

            --- pe local part of matrix hp

        * **hph** : ndarray[tuple[dim_obs, dim_obs], np.float64]

            --- matrix hph


    py__add_obs_err_pdaf : Callable[step:int, dim_obs_p:int, C_p:ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]]
        Add obs error covariance R to HPH in EnKF

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Dimension of observation vector

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            --- Matrix to that observation covariance R is added

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            --- Matrix to that observation covariance R is added


    py__init_obs_covar_pdaf : Callable[step:int, dim_obs:int, dim_obs_p:int, covar:float, obs_p:ndarray[tuple[dim_obs_p], np.float64], isdiag:bool]
        Initialize obs. error cov. matrix R in EnKF

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs** : int

            --- Global size of observation vector

        * **dim_obs_p** : int

            --- Size of process-local observation vector

        * **covar** : float

            --- Observation error covariance matrix

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Process-local vector of observations

        * **isdiag** : bool

            --- 

        **Callback Returns**

        * **covar**:float

            --- Observation error covariance matrix

        * **isdiag**:bool

            --- 


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def assimilate_lestkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__init_dim_obs_pdaf : Callable[[int, int], int],
                       py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__init_obs_l_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__prepoststep_pdaf : Callable[[int, int, int, 
                                                        int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                        int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                       py__prodRinvA_l_pdaf : Callable[[int, int, int, 
                                                        int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                       py__init_n_domains_p_pdaf : Callable[[int, int], int],
                       py__init_dim_l_pdaf : Callable[[int, int, int], int],
                       py__init_dim_obs_l_pdaf : Callable[[int, int, int, 
                                                           int], int],
                       py__g2l_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__l2g_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__g2l_obs_pdaf : Callable[[int, int, int, int, 
                                                    np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                    int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                    int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                       py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        float], float],
                       py__init_obsvar_l_pdaf : Callable[[int, int, int, 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          int, float], float],
                       py__next_observation_pdaf : Callable[[int, int, 
                                                             int, float], tuple[int, 
                                                             int, float]]
                      ) -> int:
    """It is recommended to use :func:`pyPDAF.PDAF.localomi_assimilate`
    or :func:`pyPDAF.PDAF.localomi_assimilate_nondiagR`.

    PDAFlocal-OMI modules require fewer user-supplied functions and improved efficiency.

    Local ESTKF (error space transform Kalman filter) [1]_ for DA without OMI.
    The LESTKF is a more efficient equivalent to the LETKF.

    This function should be called at each model time step.
    The function is a combination of :func:`pyPDAF.PDAF.put_state_lestkf`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. py__init_obs_pdaf
           (if global adaptive forgetting factor `type_forget=1` is used
           in :func:`pyPDAF.PDAF.init`)
        7. py__init_obsvar_pdaf (if global adaptive forgetting factor is used)
        8. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. py__g2l_state_pdaf
            4. py__g2l_obs_pdaf (localise mean ensemble in observation space)
            5. py__init_obs_l_pdaf
            6. py__g2l_obs_pdaf
               (localise each ensemble member in observation space)
            7. py__init_obsvar_l_pdaf
               (only called if local adaptive forgetting factor `type_forget=2` is used)
            8. py__prodRinvA_l_pdaf
            9. core DA algorithm
            10. py__l2g_state_pdaf
        9. py__prepoststep_state_pdaf
        10. py__distribute_state_pdaf
        11. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by :func:`pyPDAF.PDAF.omi_assimilate_global`
       and :func:`pyPDAF.PDAF.localomi_assimilate`

    References
    ----------
    .. [1] Nerger, L., Janji, T., Schrter, J., Hiller, W. (2012). 
           A unification of ensemble square root Kalman filters. 
           Monthly Weather Review, 140, 2335-2345. doi:10.1175/MWR-D-11-00102.1

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def assimilate_letkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_dim_obs_pdaf : Callable[[int, int], int],
                      py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_obs_l_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                       int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                      py__prodRinvA_l_pdaf : Callable[[int, int, int, int, 
                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                      py__init_n_domains_p_pdaf : Callable[[int, int], int],
                      py__init_dim_l_pdaf : Callable[[int, int, int], int],
                      py__init_dim_obs_l_pdaf : Callable[[int, int, int, 
                                                          int], int],
                      py__g2l_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__l2g_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__g2l_obs_pdaf : Callable[[int, int, int, int, 
                                                   np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                   int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                   int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                      py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       float], float],
                      py__init_obsvar_l_pdaf : Callable[[int, int, int, 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         int, float], float],
                      py__next_observation_pdaf : Callable[[int, int, int, 
                                                            float], tuple[int, 
                                                            int, float]]
                     ) -> int:
    """It is recommended to use :func:`pyPDAF.PDAF.localomi_assimilate`
    or :func:`pyPDAF.PDAF.localomi_assimilate_nondiagR`.

    PDAFlocal-OMI modules require fewer user-supplied functions and improved efficiency.

    Local ensemble transform Kalman filter (LETKF) [1]_ for DA without OMI. Implementation is based on [2]_.
    Note that the LESTKF is a more efficient equivalent to the LETKF.

    This function should be called at each model time step.
    The function is a combination of :func:`pyPDAF.PDAF.put_state_letkf`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. py__init_obs_pdaf
           (if global adaptive forgetting factor `type_forget=1` is used
           in :func:`pyPDAF.PDAF.init`)
        7. py__init_obsvar_pdaf (if global adaptive forgetting factor is used)
        8. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. py__g2l_state_pdaf
            4. py__g2l_obs_pdaf (localise mean ensemble in observation space)
            5. py__init_obs_l_pdaf
            6. py__g2l_obs_pdaf (localise each ensemble member in observation space)
            7. py__init_obsvar_l_pdaf
               (only called if local adaptive forgetting factor `type_forget=2` is used)
            8. py__prodRinvA_l_pdaf
            9. core DA algorithm
            10. py__l2g_state_pdaf
        9. py__prepoststep_state_pdaf
        10. py__distribute_state_pdaf
        11. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by :func:`pyPDAF.PDAF.localomi_assimilate`
       and :func:`pyPDAF.PDAF.localomi_assimilate_nondiagR`

    References
    ----------
    .. [1] Hunt, B. R., Kostelich, E. J., & Szunyogh, I. (2007).
           Efficient data assimilation for spatiotemporal chaos:
           A local ensemble transform Kalman filter. 
           Physica D: Nonlinear Phenomena, 230(1-2), 112-126.
    .. [2] Nerger, L., Janji, T., Schrter, J., Hiller, W. (2012). 
           A unification of ensemble square root Kalman filters. 
           Monthly Weather Review, 140, 2335-2345. doi:10.1175/MWR-D-11-00102.1

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def assimilate_lnetf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_dim_obs_pdaf : Callable[[int, int], int],
                      py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_obs_l_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                       int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                      py__likelihood_l_pdaf : Callable[[int, int, int, 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        float], float],
                      py__init_n_domains_p_pdaf : Callable[[int, int], int],
                      py__init_dim_l_pdaf : Callable[[int, int, int], int],
                      py__init_dim_obs_l_pdaf : Callable[[int, int, int, 
                                                          int], int],
                      py__g2l_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__l2g_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__g2l_obs_pdaf : Callable[[int, int, int, int, 
                                                   np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                   int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                   int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                      py__next_observation_pdaf : Callable[[int, int, int, 
                                                            float], tuple[int, 
                                                            int, float]]
                     ) -> int:
    """It is recommended to use local module with OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_assimilate` or `pyPDAF.PDAF.localomi_assimilate_lnetf_nondiagR`. 
    This function will use Local Nonlinear Ensemble Transform Filter (LNETF) for DA without OMI. The nonlinear filter computes the distribution up to the second moment similar to KF but using a nonlinear weighting similar to particle filter. This leads to an equal weights assumption for prior ensemble. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.put_state_lnetf` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    6. py__init_dim_l_pdaf
    7. py__init_dim_obs_l_pdaf
    8. py__g2l_state_pdaf
    9. py__init_obs_l_pdaf
    10. py__g2l_obs_pdaf(localise each ensemble member in observation space)
    11. py__likelihood_l_pdaf
    12. core DA algorithm
    13. py__l2g_state_pdaf
    14. py__prepoststep_state_pdaf
    15. py__distribute_state_pdaf
    16. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- nput vector holding the local residual

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def assimilate_lknetf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__init_dim_obs_pdaf : Callable[[int, int], int],
                       py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__init_obs_l_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__prepoststep_pdaf : Callable[[int, int, int, 
                                                        int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                        int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                       py__prodRinvA_l_pdaf : Callable[[int, int, int, 
                                                        int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                       py__prodRinvA_hyb_l_pdaf : Callable[[int, int, int, 
                                                            int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            float, np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                       py__init_n_domains_p_pdaf : Callable[[int, int], int],
                       py__init_dim_l_pdaf : Callable[[int, int, int], int],
                       py__init_dim_obs_l_pdaf : Callable[[int, int, int, 
                                                           int], int],
                       py__g2l_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__l2g_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__g2l_obs_pdaf : Callable[[int, int, int, int, 
                                                    np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                    int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                    int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                       py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        float], float],
                       py__init_obsvar_l_pdaf : Callable[[int, int, int, 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          int, float], float],
                       py__likelihood_l_pdaf : Callable[[int, int, int, 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         float], float],
                       py__likelihood_hyb_l_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             float, float], float],
                       py__next_observation_pdaf : Callable[[int, int, 
                                                             int, float], tuple[int, 
                                                             int, float]]
                      ) -> int:
    """It is recommended to use local module with OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_assimilate` or `pyPDAF.PDAF.localomi_assimilate_lknetf_nondiagR`. 
    This function will is a hybridised LETKF and LNETF for DA without OMI. The LNETF computes the distribution up to the second moment similar to KF but using a nonlinear weighting similar to particle filter. This leads to an equal weights assumption for prior ensemble. The hybridisation with LETKF is expected to lead to improved performance for quasi-Gaussian problems. The function should be called at each model step. 
    
    The function is a combination of `pyPDAF.PDAF.put_state_lknetf` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    6. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init
    7. py__init_obsvar_pdaf (if global adaptive forgetting factor is used
    loop over each local domain:
    8. py__init_dim_l_pdaf
    9. py__init_dim_obs_l_pdaf
    10. py__g2l_state_pdaf
    11. py__g2l_obs_pdaf (localise each ensemble member in observation space)
    12. py__init_obs_l_pdaf
    13. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used
    14. py__prodRinvA_pdaf
    15. py__likelihood_l_pdaf
    16. core DA algorithm
    17. py__l2g_state_pdaf
    18. py__obs_op_pdaf (only called with `HKN` and `HNK` options called for each ensemble member
    19. py__likelihood_hyb_l_pda
    20. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used
    21. py__prodRinvA_hyb_l_pdaf
    22. py__prepoststep_state_pdaf
    23. py__distribute_state_pdaf
    24. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__prodRinvA_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, dim_ens:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, A_l:ndarray[tuple[dim_obs_l, dim_ens], np.float64], C_l:ndarray[tuple[dim_obs_l, dim_ens], np.float64]]
        Provide product R^-1 A on local analysis domain with hybrid weight

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **dim_ens** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **gamma** : float

            --- Hybrid weight provided by PDAF

        * **A_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance


    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute likelihood

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- nput vector holding the local residual

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    py__likelihood_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, likely_l:float]
        Compute likelihood with hybrid weight

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Input vector holding the local residual

        * **gamma** : float

            --- Hybrid weight provided by PDAF

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def assimilate_lseik (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_dim_obs_pdaf : Callable[[int, int], int],
                      py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_obs_l_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                       int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                      py__prodRinvA_l_pdaf : Callable[[int, int, int, int, 
                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                      py__init_n_domains_p_pdaf : Callable[[int, int], int],
                      py__init_dim_l_pdaf : Callable[[int, int, int], int],
                      py__init_dim_obs_l_pdaf : Callable[[int, int, int, 
                                                          int], int],
                      py__g2l_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__l2g_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__g2l_obs_pdaf : Callable[[int, int, int, int, 
                                                   np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                   int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                   int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                      py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       float], float],
                      py__init_obsvar_l_pdaf : Callable[[int, int, int, 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         int, float], float],
                      py__next_observation_pdaf : Callable[[int, int, int, 
                                                            float], tuple[int, 
                                                            int, float]]
                     ) -> int:
    """It is recommended to use local module with OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_assimilate` or `pyPDAF.PDAF.localomi_assimilate_nondiagR`. 
    Using local singular evolutive interpolated Kalman filter for DA without OMI. This is a domain localisation method. This function should be called at each model time step.
    
    The function is a combination of `pyPDAF.PDAF.put_state_lseik` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    6. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init
    7. py__init_obsvar_pdaf (if global adaptive forgetting factor is used
    loop over each local domain:
    8. py__init_dim_l_pdaf
    9. py__init_dim_obs_l_pdaf
    10. py__g2l_state_pdaf
    11. py__g2l_obs_pdaf (localise mean ensemble in observation space)
    12. py__init_obs_l_pdaf
    13. py__g2l_obs_pdaf (localise each ensemble member in observation space
    14. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used
    15. py__prodRinvA_l_pdaf
    16. core DA algorithm
    17. py__l2g_state_pdaf
    18. py__prepoststep_state_pdaf
    19. py__distribute_state_pdaf
    20. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def assimilate_netf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_dim_obs_pdaf : Callable[[int, int], int],
                     py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                     py__likelihood_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     float], float],
                     py__next_observation_pdaf : Callable[[int, int, int, 
                                                           float], tuple[int, 
                                                           int, float]]
                    ) -> int:
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.omi_assimilate_global` or `pyPDAF.PDAF.omi_assimilate_nonlin_nondiagR`. 
    This function will use Nonlinear Ensemble Transform Filter (NETF) for DA without OMI. The nonlinear filter computes the distribution up to the second moment similar to KF but using a nonlinear weighting similar to particle filter. This leads to an equal weights assumption for prior ensemble. The function should be called at each model step. 
    
    The function is a combination of `pyPDAF.PDAF.put_state_netf` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__init_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    6. py__likelihood_pdaf
    7. core DA algorithm
    8. py__prepoststep_state_pdaf
    9. py__distribute_state_pdaf
    10. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__likelihood_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], resid:ndarray[tuple[dim_obs_p], np.float64], likely:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **resid** : ndarray[tuple[dim_obs_p], np.float64]

            --- Input vector holding the residual

        * **likely** : float

            --- Output value of the likelihood

        **Callback Returns**

        * **likely**:float

            --- Output value of the likelihood


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def assimilate_pf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                   py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                   py__init_dim_obs_pdaf : Callable[[int, int], int],
                   py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                   py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                   py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                    int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                    int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                   py__likelihood_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                   float], float],
                   py__next_observation_pdaf : Callable[[int, int, int, 
                                                         float], tuple[int, 
                                                         int, float]]
                  ) -> int:
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.omi_assimilate_global` or `pyPDAF.PDAF.omi_assimilate_nonlin_nondiagR`. 
    This function will use particle filter for DA without OMI. This is a fully nonlinear filter. The function should be called at each model step. 
    
    The function is a combination of `pyPDAF.PDAF.put_state_pf` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__init_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    6. py__likelihood_pdaf
    7. core DA algorithm
    8. py__prepoststep_state_pdaf
    9. py__distribute_state_pdaf
    10. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__likelihood_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], resid:ndarray[tuple[dim_obs_p], np.float64], likely:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **resid** : ndarray[tuple[dim_obs_p], np.float64]

            --- Input vector holding the residual

        * **likely** : float

            --- Output value of the likelihood

        **Callback Returns**

        * **likely**:float

            --- Output value of the likelihood


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def assimilate_seek (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_dim_obs_pdaf : Callable[[int, int], int],
                     py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                     py__prodRinvA_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                     py__next_observation_pdaf : Callable[[int, int, int, 
                                                           float], tuple[int, 
                                                           int, float]]
                    ) -> int:
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.omi_assimilate_global` or `pyPDAF.PDAF.omi_assimilate_global_nondiagR`. 
    This function will use singular evolutive extended Kalman filter for DA without OMI. This is a deterministic Kalman filter. The function should be called at each model step.
    
    The function is a combination of `pyPDAF.PDAF.put_state_seek` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf (for ensemble mean
    5. py__init_obs_pdaf
    6. py__obs_op_pdaf (for each ensemble member
    7. py__prodRinvA_pdaf
    8. core DA algorithm
    9. py__prepoststep_state_pdaf
    10. py__distribute_state_pdaf
    11. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 HV

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def assimilate_seik (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_dim_obs_pdaf : Callable[[int, int], int],
                     py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                     py__prodRinvA_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                     py__next_observation_pdaf : Callable[[int, int, int, 
                                                           float], tuple[int, 
                                                           int, float]]
                    ) -> int:
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.omi_assimilate_global` or `pyPDAF.PDAF.omi_assimilate_nonlin_nondiagR`. 
    This function will use singular evolutive interpolated Kalman filter for DA without OMI. The function should be called at each model step.
    
    The function is a combination of `pyPDAF.PDAF.put_state_seik` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf (for ensemble mean
    5. py__init_obs_pdaf
    6. py__obs_op_pdaf (for each ensemble member
    7. py__init_obsvar_pdaf (only relevant for adaptive forgetting factor schemes)
    8. py__prodRinvA_pdaf
    9. core DA algorithm
    10. py__prepoststep_state_pdaf
    11. py__distribute_state_pdaf
    12. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 HV

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def assimilate_prepost (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                        py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                        py__prepoststep_pdaf : Callable[[int, int, int, 
                                                         int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                         int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                        py__next_observation_pdaf : Callable[[int, int, 
                                                              int, float], tuple[int, 
                                                              int, float]]
                       ) -> int:
    """This function does not perform any DA. It is used to perform a preprocess and postprocess of the ensemble. Compared to `pyPDAF.PDAF.prepost`, this function sets assimilation flag.
    The function is a combination of `pyPDAF.PDAF.put_state_prepost` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf (preprocess, step < 0)
    3. py__prepoststep_state_pdaf (postprocess, step > 0
    4. py__distribute_state_pdaf
    5. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def deallocate () -> None:
    """This function finalise the PDAF systems including deaclloating all arrays in PDAF.

    """
    ...

def diag_effsample (weights: np.ndarray[tuple[int], np.dtype[np.float64]]
                   ) -> float:
    """This function calculates the effective sample size of a particle filter as defined in Doucet et al. 2001 p. 333.
    It is defined as the inverse of the sum of the squared particle filter weights. If the `n_eff=dim_sample`, all weights are identical, the filter has no influence. If `n_eff=0`, the filter is collapsed. This is typically called during the analysis step of a particle filter, e.g. in the analysis step of NETF and LNETF.

    Parameters
    ----------
    weights : ndarray[tuple[dim_sample], np.float64]
        weights of the samples

    Returns
    -------
    effSample : float
        effecfive sample size
    """
    ...

def diag_ensstats (element: int,state: np.ndarray[tuple[int], np.dtype[np.float64]],
                   ens: np.ndarray[tuple[int, int], np.dtype[np.float64]]
                  ) -> tuple[float, float, int]:
    """This function returns the skewness and kurtosis of the ensemble of a given element of the state vector. The definition used for kurtosis follows that used by Lawson and Hansen, Mon. Wea. Rev. 132 (2004) 1966
    

    Parameters
    ----------
    element : int
        Index of state vector/ensemble element to be used. If element=0, mean values over all elements are computed
    state : ndarray[tuple[dim], np.float64]
        State vector (typically ensemble mean)
    ens : ndarray[tuple[dim, dim_ens], np.float64]
        State ensemble

    Returns
    -------
    skewness : float
        Skewness of ensemble
    kurtosis : float
        Kurtosis of ensemble
    status : int
        Status flag (0=success)
    """
    ...

def diag_histogram (ncall: int,element: int,state: np.ndarray[tuple[int], np.dtype[np.float64]],
                    ens: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                    hist: np.ndarray[tuple[int], np.dtype[np.intc]]) -> tuple[np.ndarray[tuple[int], np.dtype[np.intc]], float, int]:
    """This function returns a rank histogram of the ensemble. A rank histogram is used to diagnose the reliability of the ensemble. A perfectly reliable ensemble should have a uniform rank histogram. The function can be called in the pre/poststep routine of PDAF both before and after the analysis step to collect the histogram information.

    Parameters
    ----------
    ncall : int
        The number of calls used to increment the histogram and is needed to compute the delta-measure that describes the deviation from the ideal histogram.
    element : int
        Element of vector used for histogram. If element=0, all elements are used
    state : ndarray[tuple[dim], np.float64]
        Assumed truth
    ens : ndarray[tuple[dim, dim_ens], np.float64]
        Ensemble
    hist : ndarray[tuple[dim_ens+1], np.intc]
        Histogram about the state

    Returns
    -------
    hist : ndarray[tuple[dim_ens+1], np.intc]
         Histogram about the state
    delta : float
        deviation measure from flat histogram. It must be initialised to be 0
    status : int
        Status flag (0=success)
    """
    ...

def eofcovar (dim_fields: np.ndarray[tuple[int], np.dtype[np.intc]],offsets: np.ndarray[tuple[int], np.dtype[np.intc]],
              remove_mstate: int,do_mv: int,states: np.ndarray[tuple[int, int], np.dtype[np.float64]],
              meanstate: np.ndarray[tuple[int], np.dtype[np.float64]],verbose: int
             ) -> tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], np.ndarray[tuple[int], np.dtype[np.float64]], 
              np.ndarray[tuple[int], np.dtype[np.float64]], np.ndarray[tuple[int, int], np.dtype[np.float64]], 
              np.ndarray[tuple[int], np.dtype[np.float64]], int]:
    """EOF analysis of a state vectors at multiple time steps by singular value decomposition.

    Typically, this function is used with :func:`pyPDAF.PDAF.sampleens`
    to generate an ensemble of a chosen size 
    (up to the number of EOFs plus one).

    Here, the function performs a singular value decomposition of the ensemble anomaly of the input matrix,
    which is an ensemble formed by state vectors at multiple time steps.
    The singular values and corresponding singular vectors can be used to
    construct an error covariance matrix.
    This can be used as the initial error covariance for the initial ensemble.

    A multivariate scaling can be performed to ensure that all fields in the state vectors have unit variance.

    It can be useful to store more EOFs than one finally
    might want to use to have the flexibility to cary the ensemble size.

    See also `PDAF webpage <https://pdaf.awi.de/trac/wiki/EnsembleGeneration>`_

    Parameters
    ----------
    dim_fields : ndarray[tuple[nfields], np.intc]
        Size of each field, only used when `do_mv = 1`. Each field could be 2D or 3D so can have different sizes.
    offsets : ndarray[tuple[nfields], np.intc]
        Start position of each field.\n This variable is used only used when `do_mv = 1`.\n For example, if the state vector contains temperature and humidity, this array specifies the starting index of the two physical fields.\n The offset values start from 1.
    remove_mstate : int
        Subtract mean state from states (average over nstates dimension) before computing EOFs (`remove_mstate = 1`) or don't remove (`remove_mstate = 0`)
    do_mv : int
        Do multivariate scaling (`do_mv = 1`) or no scaling (`do_mv = 0`). Variable `nfields`, `dim_fields` and `offsets` are only used if `do_mv=1`.
    states : ndarray[tuple[dim_state, nstates], np.float64]
        State perturbations or an ensemble of state vectors
    meanstate : ndarray[tuple[dim_state], np.float64]
        Mean state (only changed if `remove_mstate=1`)
    verbose : int
        Verbosity flag

    Returns
    -------
    states : ndarray[tuple[dim_state, nstates], np.float64]
         State perturbations or an ensemble of state vectors
    stddev : ndarray[tuple[nfields], np.float64]
         Standard deviation of field variability. Without multivariate scaling (`do_mv=0`), it is `stddev = 1.0`.
    svals : ndarray[tuple[nstates], np.float64]
         Singular values scaled by `1/sqrt(nstates-1)`.
    svec : ndarray[tuple[dim_state, nstates], np.float64]
         Singular vectors
    meanstate : ndarray[tuple[dim_state], np.float64]
         Mean state (only changed if `remove_mstate=1`)
    status : int
        Status flag
    """
    ...

def gather_dim_obs_f (dim_obs_p: int) -> int:
    """In the local filters (LESKTF, LETKF, LSEIK, LNETF) this function returns the total observation dimension from process-local observation dimensions. The function has to be called once before using any of the functions `pyPDAF.PDAF.gather_obs_f` or `pyPDAF.PDAF.gather_obs_f2`.
    This is because it stores the information on the process-local observation dimensions to allocate actual observation vectors. The routine is typically used in the routine `py__init_dim_obs_f_pdaf` if the analysis step of the local filters is parallelized.

    Parameters
    ----------
    dim_obs_p : int
        PE-local observation dimension

    Returns
    -------
    dim_obs_f : int
        Full observation dimension
    """
    ...

def gather_obs_f (obs_p: np.ndarray[tuple[int], np.dtype[np.float64]],dimobs_f: int
                 ) -> tuple[np.ndarray[tuple[int], np.dtype[np.float64]], int]:
    """In the local filters (LESKTF, LETKF, LSEIK, LNETF) this function returns the total observation vector from process-local observations. The function depends on `pyPDAF.PDAF.gather_dim_obs_f` which defines the process-local observation dimensions. Further, the related routine `pyPDAF.PDAF.gather_obs_f2` is used to
    gather the associated 2D observation coordinates
    

    Parameters
    ----------
    obs_p : ndarray[tuple[dimobs_p], np.float64]
        PE-local vector
    dimobs_f : int
        dimension of full gathered obs

    Returns
    -------
    obs_f : ndarray[tuple[dimobs_f], np.float64]
         Full gathered vector
    status : int
        Status flag: (0) no error; (1) when PDAF_gather_dim_obs_f not executed before
    """
    ...

def gather_obs_f2 (coords_p: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                   dimobs_f: int) -> tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], int]:
    """In the local filters (LESKTF, LETKF, LSEIK, LNETF)
    this function returns the full observation coordinates from process-local observation coordinates. The function depends on `pyPDAF.PDAF.gather_dim_obs_f` which defines the process-local observation dimensions. Further, the related routine `pyPDAF.PDAF.gather_obs_f` is used to gather the associated observation vectors. 
    
    The routine is typically used in the routines `py__init_dim_obs_f_pdaf` if the analysis step of the local filters is parallelized.

    Parameters
    ----------
    coords_p : ndarray[tuple[nrows, dimobs_p], np.float64]
        PE-local array
    dimobs_f : int
        dimension of full gathered obs

    Returns
    -------
    coords_f : ndarray[tuple[nrows, dimobs_f], np.float64]
         Full gathered array
    status : int
        Status flag: (0) no error; (1) when PDAF_gather dim_obs_f not executed before
    """
    ...

def generate_obs (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                  py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                  py__init_dim_obs_pdaf : Callable[[int, int], int],
                  py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                  py__get_obs_f_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                  py__init_obserr_f_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                  py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                   int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                   int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                  py__next_observation_pdaf : Callable[[int, int, int, 
                                                        float], tuple[int, 
                                                        int, float]]
                 ) -> int:
    """When diagonal observation error covariance matrix is used, it is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.omi_generate_obs`. 
    This function generates synthetic observations based on each member of model forecast. This is based on the usual implementation strategy for PDAF.
    
    The function is a combination of `pyPDAF.PDAF.put_state_generate_obs` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pda
    5. py__init_obserr_f_pdaf
    6. py__get_obs_f_pdaf
    7. py__prepoststep_state_pdaf
    8. py__distribute_state_pdaf
    9. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__get_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f:ndarray[tuple[dim_obs_f], np.float64]]
        Provide observation vector to user

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of the full observation vector

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of synthetic observations (process-local)

        **Callback Returns**

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of synthetic observations (process-local)


    py__init_obserr_f_pdaf : Callable[step:int, dim_obs_f:int, obs_f:ndarray[tuple[dim_obs_f], np.float64], obserr_f:ndarray[tuple[dim_obs_f], np.float64]]
        Initialize vector of observation error standard deviations

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Full dimension of observation vector

        * **obs_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full observation vector

        * **obserr_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full observation error stddev

        **Callback Returns**

        * **obserr_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full observation error stddev


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def get_assim_flag () -> int:
    """This function returns the flag that indicates if the DA is performed in the last time step. It only works for online DA systems. 


    Returns
    -------
    did_assim : int
        Flag: (1) for assimilation; (0) else
    """
    ...

def get_ensstats () -> tuple[np.ndarray[tuple[int, ], np.dtype[float]], np.ndarray[tuple[int, ], np.dtype[float]], 
                   int]:
    """This is a diagnotics function for LKNETF which returns the skewness and kutosis used there. 


    Returns
    -------
    dims : ndarray[tuple[1], np.intc]
         dimension of pointer
    c_skew_ptr : ndarray[float]
        Skewness array
    c_kurt_ptr : ndarray[float]
        kurtosis array
    status : int
        Status flag
    """
    ...

def get_localfilter () -> int:
    """This function returns whether a local filter is used. 


    Returns
    -------
    lfilter : int
        Whether the filter is domain-localized (1) or not (0)
    """
    ...

def get_memberid (memberid: int) -> int:
    """This function returns the ensemble member id on the current process. 
    For example, it can be called during the ensemble integration if ensemble-specific forcing is applied. It can also be used in the user-supplied functions such as `py__collect_state_pdaf` and `py__distribute_state_pdaf`.

    Parameters
    ----------
    memberid : int
        Index in the local ensemble

    Returns
    -------
    memberid : int
        Index in the local ensemble
    """
    ...

def get_obsmemberid (memberid: int) -> int:
    """This function returns the ensemble member id when observation operator is being applied. 
    This function is used specifically for user-supplied function `py__obs_op_pdaf`.

    Parameters
    ----------
    memberid : int
        Index in the local observed ensemble

    Returns
    -------
    memberid : int
        Index in the local observed ensemble
    """
    ...

def get_smootherens () -> tuple[np.ndarray[tuple[int, ], np.dtype[float]], int, int]:
    """This function returns the smoothed ensemble in earlier time steps. It is only used when the smoother options is used .


    Returns
    -------
    c_sens_point : ndarray[float]
        A smoother array
    maxlag : int
        Number of past timesteps processed in sens
    dims : ndarray[tuple[3], np.intc]
         dimension of pointer
    status : int
        Status flag
    """
    ...

def get_state (steps: int,doexit: int,py__next_observation_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            float], tuple[int, 
                                                                            int, 
                                                                            float]],
               py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
               py__prepoststep_pdaf : Callable[[int, int, int, int, int, 
                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
               flag: int) -> tuple[int, float, int, int]:
    """Post-processing the analysis and distributing state vector back to the model.

    This function also sets the next model step for assimilation, or end the entire assimilation.

    The function executes the user-supplied function in the following sequence:

    1. py__prepoststep_state_pdaf

    2. py__distribute_state_pdaf

    3. py__next_observation_pdaf

    Parameters
    ----------
    steps : int
        Flag and number of time steps
    doexit : int
        Whether to exit from forecasts
    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    flag : int
        Status flag

    Returns
    -------
    steps : int
        Flag and number of time steps
    time : float
        current model time
    doexit : int
        Whether to exit from forecasts
    flag : int
        Status flag
    """
    ...

def init (filtertype: int,subtype: int,stepnull: int,param_int: np.ndarray[tuple[int], np.dtype[np.intc]],
          param_real: np.ndarray[tuple[int], np.dtype[np.float64]],COMM_model: int,
          COMM_filter: int,COMM_couple: int,task_id: int,n_modeltasks: int,
          in_filterpe: bool,py__init_ens_pdaf : Callable[[int, int, int, 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          int]],
          in_screen: int) -> tuple[np.ndarray[tuple[int], np.dtype[np.intc]], np.ndarray[tuple[int], np.dtype[np.float64]], 
                         int]:
    """This function initialises the PDAF system. It is called once at the beginning of the assimilation. The function specifies the type of DA methods, parameters of the filters, the MPI communicators, and other parallel options.The function also provides an initial ensemble to the PDAF system by the user-supplied function which can be distribute to the model by `pyPDAF.PDAF.get_state`. 
    For the options and parameters of DA methods, check the `PDAF introduction page <https://pdaf.awi.de/trac/wiki/AvailableOptionsforInitPDAF.>` 
    The parallisation module in the repository example can be used directly for most cases. Explanation of the parallelisation strategy in PDAF can be found in https://pdaf.awi.de/trac/wiki/ImplementationConceptOnline#Parallelizationofthedataassimilationprogram and https://pdaf.awi.de/trac/wiki/AdaptParallelization

    Parameters
    ----------
    filtertype : int
        Type of filter
    subtype : int
        Sub-type of filter
    stepnull : int
        Initial time step of assimilation
    param_int : ndarray[tuple[dim_pint], np.intc]
        Integer parameter array
    param_real : ndarray[tuple[dim_preal], np.float64]
        Real parameter array
    COMM_model : int
        Model communicator
    COMM_filter : int
        Filter communicator
    COMM_couple : int
        Coupling communicator
    task_id : int
        Id of my ensemble task
    n_modeltasks : int
        Number of parallel model tasks
    in_filterpe : bool
        Is my PE a filter-PE?
    py__init_ens_pdaf : Callable[filtertype:int, dim_p:int, dim_ens:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User-supplied routine for ensemble initialization

        **Callback Parameters**

        * **filtertype** : int

            --- type of filter to initialize

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of ensemble

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local model state

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- array not referenced for ensemble filters

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local model state

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- array not referenced for ensemble filters

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag**:int

            --- pdaf status flag


    in_screen : int
        Control screen output:

    Returns
    -------
    param_int : ndarray[tuple[dim_pint], np.intc]
         Integer parameter array
    param_real : ndarray[tuple[dim_preal], np.float64]
         Real parameter array
    flag : int
        Status flag, 0: no error, error codes:
    """
    ...

def local_weight (wtype: int,rtype: int,cradius: float,sradius: float,distance: float,
                  A: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                  var_obs: float,verbose: int) -> float:
    """The function is used for localisation in the analysis step of a filter and computes a weight according to the specified distance and the settings for the localising function. Typically the function is called in `py__prodRinvA_l_pdaf` in the domain-localised filters. Also, the function is typically called for the LEnKF in the `py__localize_covar_pdaf`. 
    This function is usually only used in user-codes that do not use PDAF-OMI.

    Parameters
    ----------
    wtype : int
        Type of weight function
    rtype : int
        Type of regulated weighting
    cradius : float
        Cut-off radius (check `PDAF-OMI wiki <https://pdaf.awi.de/trac/wiki/OMI_observation_modules#init_dim_obs_l_OBSTYPE>`_)
    sradius : float
        Support radius (check `PDAF-OMI wiki <https://pdaf.awi.de/trac/wiki/OMI_observation_modules#init_dim_obs_l_OBSTYPE>`_)
    distance : float
        Distance to observation
    A : ndarray[tuple[nrows, ncols], np.float64]
        Input matrix
    var_obs : float
        Observation variance
    verbose : int
        Verbosity flag

    Returns
    -------
    weight : float
        Weights
    """
    ...

def print_info (printtype: int) -> None:
    """This function prints the wallclock time and memory measured by PDAF. This is called at the end of the DA program. 
    The function displays the following information: 
    - Memory required for the ensemble array, state vector, and transform matrix- Memory required by the analysis step- Memory required to perform the ensemble transformation

    Parameters
    ----------
    printtype : int
        - X=1: Basic timers - X=3: Timers showing the time spent int he different call-back routines (this variant was added with PDAF 1.15) - X=4: More detailed timers about parts of the filter algorithm (before PDAF 1.15, this was timer level 3) - X=5: Very detailed timers about various operations in the filter algorithm (before PDAF 1.15, this was timer level 4)
    """
    ...

def put_state_3dvar (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_dim_obs_pdaf : Callable[[int, int], int],
                     py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__prodRinvA_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                     py__cvt_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__cvt_adj_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__obs_op_lin_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__obs_op_adj_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]]]
                    ) -> int:
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency.
    I.e., `pyPDAF.PDAF.omi_put_state_global` or `pyPDAF.PDAF.omi_put_state_global_nondiagR`. 
    Using 3DVar for DA without post-processing and analysis distribution to forecsat without OMI.
    This is a deterministic filtering scheme. This function is usually used in 'flexible' parallelisation, but 3dvar is deterministic and does not require ensemble.
    A `pyPDAF.PDAF.get_state` function should be used to post-process the state vector and distribute the state vector to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    5. py__init_obs_pdaf
    Starting the iterative optimisation:
    6. py__cvt_pdaf
    7. py__obs_op_lin_pdaf
    8. py__prodRinvA_pdaf
    9. py__obs_op_adj_pdaf
    10. py__cvt_adj_pdaf
    11. core DA algorithm
    After the iterations: 
    12. py__cvt_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def put_state_en3dvar_estkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__init_dim_obs_pdaf : Callable[[int, int], int],
                             py__obs_op_pdaf : Callable[[int, int, int, 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__prodRinvA_pdaf : Callable[[int, int, int, 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                             py__cvt_ens_pdaf : Callable[[int, int, int, 
                                                          int, np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__cvt_adj_ens_pdaf : Callable[[int, int, 
                                                              int, int, 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__obs_op_lin_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__obs_op_adj_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__init_obsvar_pdaf : Callable[[int, int, 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              float], float],
                             py__prepoststep_pdaf : Callable[[int, int, 
                                                              int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]]]]
                            ) -> int:
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency.
    I.e., `pyPDAF.PDAF.omi_put_state_en3dvar_estkf` or `pyPDAF.PDAF.omi_put_state_en3dvar_estkf_nondiagR`. 
    
    
    Using 3DEnVar for DA without post-processing and analysis distribution to forecsat without OMI.
    The background error covariance matrix is estimated by ensemble. The 3DEnVar only calculates the analysis of the ensemble mean.
    An ESTKF is used to generate ensemble perturbations. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    5. py__init_obs_pdaf
    Starting the iterative optimisation:
    6. py__cvt_ens_pdaf
    7. py__obs_op_lin_pdaf
    8. py__prodRinvA_pdaf
    9. py__obs_op_adj_pdaf
    10. py__cvt_adj_ens_pdaf
    11. core 3DEnVar algorithm
    After the iterations: 
    12. py__cvt_ens_pdaf
    Perform ESTKF: 13. py__init_dim_obs_pdaf
    14. py__obs_op_pdaf (for ensemble mean
    15. py__init_obs_pdaf
    16. py__obs_op_pdaf (for each ensemble member
    17. py__init_obsvar_pdaf (only relevant for adaptive forgetting factor schemes)
    18. py__prodRinvA_pdaf
    19. core ESTKF algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def put_state_en3dvar_lestkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__init_dim_obs_pdaf : Callable[[int, int], int],
                              py__obs_op_pdaf : Callable[[int, int, int, 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__prodRinvA_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                              py__cvt_ens_pdaf : Callable[[int, int, int, 
                                                           int, np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__cvt_adj_ens_pdaf : Callable[[int, int, 
                                                               int, int, 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__obs_op_lin_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__obs_op_adj_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__init_dim_obs_f_pdaf : Callable[[int, 
                                                                  int], int],
                              py__obs_op_f_pdaf : Callable[[int, int, int, 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__init_obs_f_pdaf : Callable[[int, int, 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__init_obs_l_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__prodRinvA_l_pdaf : Callable[[int, int, 
                                                               int, int, 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                              py__init_n_domains_p_pdaf : Callable[[int, 
                                                                    int], int],
                              py__init_dim_l_pdaf : Callable[[int, int, 
                                                              int], int],
                              py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  int], int],
                              py__g2l_state_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__l2g_state_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__g2l_obs_pdaf : Callable[[int, int, int, 
                                                           int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                           int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                           int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                              py__init_obsvar_pdaf : Callable[[int, int, 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               float], float],
                              py__init_obsvar_l_pdaf : Callable[[int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 int, float], float],
                              py__prepoststep_pdaf : Callable[[int, int, 
                                                               int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]]]]
                             ) -> int:
    """It is recommended to use local module with OMI functionalities for fewer user-supplied functions and improved efficiency.
    I.e., `pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf` or `pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf_nondiagR`. 
    
    
    Using 3DEnVar for DA without post-processing and analysis distribution to forecsat without OMI.
    The background error covariance matrix is estimated by ensemble. The 3DEnVar only calculates the analysis of the ensemble mean.
    An LESTKF is used to generate ensemble perturbations. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    5. py__init_obs_pdaf
    Starting the iterative optimisation:
    6. py__cvt_ens_pdaf
    7. py__obs_op_lin_pdaf
    8. py__prodRinvA_pdaf
    9. py__obs_op_adj_pdaf
    10. py__cvt_adj_ens_pdaf
    11. core DA algorithm
    After the iterations: 
    12. py__cvt_ens_pdaf
    Perform LESTKF: 
    13. py__init_n_domains_p_pdaf
    14. py__init_dim_obs_pdaf
    15. py__obs_op_pdaf (for each ensemble member
    16. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init
    17. py__init_obsvar_pdaf (if global adaptive forgetting factor is used
    loop over each local domain:
    18. py__init_dim_l_pdaf
    19. py__init_dim_obs_l_pdaf
    20. py__g2l_state_pdaf
    21. py__g2l_obs_pdaf (localise mean ensemble in observation space)
    22. py__init_obs_l_pdaf
    23. py__g2l_obs_pdaf (localise each ensemble member in observation space
    24. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used
    25. py__prodRinvA_pdaf
    26. core DA algorithm
    27. py__l2g_state_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f:ndarray[tuple[dim_obs_f], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of the full observation vector

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of observations

        **Callback Returns**

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def put_state_enkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__init_dim_obs_pdaf : Callable[[int, int], int],
                    py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                    py__add_obs_err_pdaf : Callable[[int, int, np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                    py__init_obs_covar_pdaf : Callable[[int, int, int, 
                                                        float, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        bool], tuple[float, 
                                                        bool]]
                   ) -> int:
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.put_state_global` or `pyPDAF.PDAF.put_state_enkf_nondiagR`. 
    Using stochastic EnKF (ensemble Kalman filter) for DA without post-processing and analysis distribution to forecsat without OMI. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf (for ensemble mean
    5. py__add_obs_err_pdaf
    6. py__init_obs_pdaf
    7. py__init_obscovar_pdaf
    8. py__obs_op_pdaf (for each ensemble member
    9. core DA algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__add_obs_err_pdaf : Callable[step:int, dim_obs_p:int, C_p:ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]]
        Add obs error covariance R to HPH in EnKF

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Dimension of observation vector

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            --- Matrix to that observation covariance R is added

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            --- Matrix to that observation covariance R is added


    py__init_obs_covar_pdaf : Callable[step:int, dim_obs:int, dim_obs_p:int, covar:float, obs_p:ndarray[tuple[dim_obs_p], np.float64], isdiag:bool]
        Initialize obs. error cov. matrix R in EnKF

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs** : int

            --- Global size of observation vector

        * **dim_obs_p** : int

            --- Size of process-local observation vector

        * **covar** : float

            --- Observation error covariance matrix

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Process-local vector of observations

        * **isdiag** : bool

            --- 

        **Callback Returns**

        * **covar**:float

            --- Observation error covariance matrix

        * **isdiag**:bool

            --- 



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def put_state_estkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_dim_obs_pdaf : Callable[[int, int], int],
                     py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                     py__prodRinvA_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                     py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      float], float]
                    ) -> int:
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.put_state_global` or `pyPDAF.PDAF.put_state_global_nondiagR`. 
    Using ESTKF (error space transform Kalman filter) for DA without post-processing and analysis distribution to forecsat without OMI. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. The ESTKF is a more efficient equivalent to the ETKF. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf (for ensemble mean
    5. py__init_obs_pdaf
    6. py__obs_op_pdaf (for each ensemble member
    7. py__init_obsvar_pdaf (only relevant for adaptive forgetting factor schemes)
    8. py__prodRinvA_pdaf
    9. core DA algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def put_state_etkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__init_dim_obs_pdaf : Callable[[int, int], int],
                    py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                    py__prodRinvA_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                    py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     float], float]
                   ) -> int:
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.put_state_global` or `pyPDAF.PDAF.put_state_global_nondiagR`. 
    Using ETKF (ensemble transform Kalman filter) for DA without post-processing and analysis distribution to forecsat without OMI. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf (for ensemble mean
    5. py__init_obs_pdaf
    6. py__obs_op_pdaf (for each ensemble member
    7. py__init_obsvar_pdaf (only relevant for adaptive forgetting factor schemes)
    8. py__prodRinvA_pdaf
    9. core DA algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def put_state_generate_obs (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_dim_obs_pdaf : Callable[[int, int], int],
                            py__obs_op_pdaf : Callable[[int, int, int, 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__get_obs_f_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_obserr_f_pdaf : Callable[[int, int, 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__prepoststep_pdaf : Callable[[int, int, 
                                                             int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]]]
                           ) -> int:
    """When diagonal observation error covariance matrix is used, it is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.omi_put_state_generate_obs`. 
    This function generates synthetic observations based on each member of model forecast. This function is for the case where the ensemble size is larger than the number of processors. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pda
    5. py__init_obserr_f_pdaf
    6. py__get_obs_f_pdaf
    7. py__prepoststep_state_pdaf
    8. py__distribute_state_pdaf
    9. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__get_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f:ndarray[tuple[dim_obs_f], np.float64]]
        Provide observation vector to user

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of the full observation vector

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of synthetic observations (process-local)

        **Callback Returns**

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of synthetic observations (process-local)


    py__init_obserr_f_pdaf : Callable[step:int, dim_obs_f:int, obs_f:ndarray[tuple[dim_obs_f], np.float64], obserr_f:ndarray[tuple[dim_obs_f], np.float64]]
        Initialize vector of observation errors

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Full dimension of observation vector

        * **obs_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full observation vector

        * **obserr_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full observation error stddev

        **Callback Returns**

        * **obserr_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full observation error stddev


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def put_state_hyb3dvar_estkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__init_dim_obs_pdaf : Callable[[int, int], int],
                              py__obs_op_pdaf : Callable[[int, int, int, 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__prodRinvA_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                              py__cvt_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__cvt_adj_pdaf : Callable[[int, int, int, 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__cvt_ens_pdaf : Callable[[int, int, int, 
                                                           int, np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__cvt_adj_ens_pdaf : Callable[[int, int, 
                                                               int, int, 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__obs_op_lin_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__obs_op_adj_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__init_obsvar_pdaf : Callable[[int, int, 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               float], float],
                              py__prepoststep_pdaf : Callable[[int, int, 
                                                               int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]]]]
                             ) -> int:
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency.
    I.e., `pyPDAF.PDAF.omi_put_state_hyb3dvar_estkf` or `pyPDAF.PDAF.omi_put_state_hyb3dvar_estkf_nondiagR`. 
    
    
    Using Hybrid 3DEnVar for DA without post-processing and analysis distribution to forecsat without OMI.
    Here, the background error covariance is hybridised by a static background error covariance, and a flow-dependent background error covariance estimated from ensemble. The 3DVar generates an ensemble mean and the ensemble perturbation is generated by
    ESTKF in this implementation. 
    
    This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    5. py__init_obs_pdaf
    Starting the iterative optimisation:
    6. py__cvt_pdaf
    7. py__cvt_ens_pdaf
    8. py__obs_op_lin_pdaf
    9. py__prodRinvA_pdaf
    10. py__obs_op_adj_pdaf
    11. py__cvt_adj_pdaf
    12. py__cvt_adj_ens_pdaf
    13. core 3DEnVar algorithm
    After the iterations: 
    14. py__cvt_pdaf
    15. py__cvt_ens_pdaf
    Perform ESTKF: 16. py__init_dim_obs_pdaf
    17. py__obs_op_pdaf (for ensemble mean
    18. py__init_obs_pdaf
    19. py__obs_op_pdaf (for each ensemble member
    20. py__init_obsvar_pdaf (only relevant for adaptive forgetting factor schemes)
    21. py__prodRinvA_pdaf
    22. core ESTKF algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def put_state_hyb3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__init_dim_obs_pdaf : Callable[[int, int], int],
                               py__obs_op_pdaf : Callable[[int, int, int, 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__init_obs_pdaf : Callable[[int, int, 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__prodRinvA_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                               py__cvt_ens_pdaf : Callable[[int, int, int, 
                                                            int, np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__cvt_adj_ens_pdaf : Callable[[int, int, 
                                                                int, int, 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__cvt_pdaf : Callable[[int, int, int, 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__cvt_adj_pdaf : Callable[[int, int, int, 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__obs_op_lin_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__obs_op_adj_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__init_dim_obs_f_pdaf : Callable[[int, 
                                                                   int], int],
                               py__obs_op_f_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__init_obs_f_pdaf : Callable[[int, int, 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__init_obs_l_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__prodRinvA_l_pdaf : Callable[[int, int, 
                                                                int, int, 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                               py__init_n_domains_p_pdaf : Callable[[int, 
                                                                     int], int],
                               py__init_dim_l_pdaf : Callable[[int, int, 
                                                               int], int],
                               py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int], int],
                               py__g2l_state_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__l2g_state_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__g2l_obs_pdaf : Callable[[int, int, int, 
                                                            int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                            int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                            int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                               py__init_obsvar_pdaf : Callable[[int, int, 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                float], float],
                               py__init_obsvar_l_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  int, 
                                                                  float], float],
                               py__prepoststep_pdaf : Callable[[int, int, 
                                                                int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]]]]
                              ) -> int:
    """It is recommended to use local module with OMI functionalities for fewer user-supplied functions and improved efficiency.
    I.e., `pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf` or `pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf_nondiagR`. 
    
    
    Using Hybrid 3DEnVar for DA without post-processing and analysis distribution to forecsat without OMI.
    Here, the background error covariance is hybridised by a static background error covariance, and a flow-dependent background error covariance estimated from ensemble. The 3DVar generates an ensemble mean and the ensemble perturbation is generated by
    LESTKF in this implementation. 
    
    This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    5. py__init_obs_pdaf
    Starting the iterative optimisation:
    6. py__cvt_pdaf
    7. py__cvt_ens_pdaf
    8. py__obs_op_lin_pdaf
    9. py__prodRinvA_pdaf
    10. py__obs_op_adj_pdaf
    11. py__cvt_adj_pdaf
    12. py__cvt_adj_ens_pdaf
    13. core DA algorithm
    After the iterations: 
    14. py__cvt_pdaf
    15. py__cvt_ens_pdaf
    Perform LESTKF: 
    16. py__init_n_domains_p_pdaf
    17. py__init_dim_obs_pdaf
    18. py__obs_op_pdaf (for each ensemble member
    19. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in `pyPDAF.PDAF.init`))
    20. py__init_obsvar_pdaf (if global adaptive forgetting factor is used)
    loop over each local domain:
    21. py__init_dim_l_pdaf
    22. py__init_dim_obs_l_pdaf
    23. py__g2l_state_pdaf
    24. py__g2l_obs_pdaf (localise mean ensemble in observation space)
    25. py__init_obs_l_pdaf
    26. py__g2l_obs_pdaf (localise each ensemble member in observation space)
    27. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used)
    28. py__prodRinvA_pdaf
    29. core DA algorithm
    30. py__l2g_state_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f:ndarray[tuple[dim_obs_f], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of the full observation vector

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of observations

        **Callback Returns**

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def put_state_lenkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_dim_obs_pdaf : Callable[[int, int], int],
                     py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                     py__localize_covar_pdaf : Callable[[int, int, np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]]], tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                     py__add_obs_err_pdaf : Callable[[int, int, np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                     py__init_obs_covar_pdaf : Callable[[int, int, int, 
                                                         float, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         bool], tuple[float, 
                                                         bool]]
                    ) -> int:
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.omi_put_state_lenkf` or `pyPDAF.PDAF.omi_put_state_lenkf_nondiagR`. 
    Using stochastic EnKF (ensemble Kalman filter) with covariance localisation for DA without post-processing and analysis distribution to forecsat without OMI. This is the only scheme for covariance localisation in PDAF. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf (for each ensemble member
    5. py__localize_pdaf
    6. py__add_obs_err_pdaf
    7. py__init_obs_pdaf
    8. py__init_obscovar_pdaf
    9. py__obs_op_pdaf (repeated to reduce storage
    10. core DA algorith
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__localize_covar_pdaf : Callable[dim_p:int, dim_obs:int, hp_p:ndarray[tuple[dim_obs, dim_p], np.float64], hph:ndarray[tuple[dim_obs, dim_obs], np.float64]]
        Apply localization to HP and HPH^T

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_obs** : int

            --- number of observations

        * **hp_p** : ndarray[tuple[dim_obs, dim_p], np.float64]

            --- pe local part of matrix hp

        * **hph** : ndarray[tuple[dim_obs, dim_obs], np.float64]

            --- matrix hph

        **Callback Returns**

        * **hp_p** : ndarray[tuple[dim_obs, dim_p], np.float64]

            --- pe local part of matrix hp

        * **hph** : ndarray[tuple[dim_obs, dim_obs], np.float64]

            --- matrix hph


    py__add_obs_err_pdaf : Callable[step:int, dim_obs_p:int, C_p:ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]]
        Add obs error covariance R to HPH in EnKF

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Dimension of observation vector

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            --- Matrix to that observation covariance R is added

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            --- Matrix to that observation covariance R is added


    py__init_obs_covar_pdaf : Callable[step:int, dim_obs:int, dim_obs_p:int, covar:float, obs_p:ndarray[tuple[dim_obs_p], np.float64], isdiag:bool]
        Initialize obs. error cov. matrix R in EnKF

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs** : int

            --- Global size of observation vector

        * **dim_obs_p** : int

            --- Size of process-local observation vector

        * **covar** : float

            --- Observation error covariance matrix

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Process-local vector of observations

        * **isdiag** : bool

            --- 

        **Callback Returns**

        * **covar**:float

            --- Observation error covariance matrix

        * **isdiag**:bool

            --- 



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def put_state_lestkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_dim_obs_pdaf : Callable[[int, int], int],
                      py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_obs_l_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                       int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                      py__prodRinvA_l_pdaf : Callable[[int, int, int, int, 
                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                      py__init_n_domains_p_pdaf : Callable[[int, int], int],
                      py__init_dim_l_pdaf : Callable[[int, int, int], int],
                      py__init_dim_obs_l_pdaf : Callable[[int, int, int, 
                                                          int], int],
                      py__g2l_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__l2g_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__g2l_obs_pdaf : Callable[[int, int, int, int, 
                                                   np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                   int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                   int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                      py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       float], float],
                      py__init_obsvar_l_pdaf : Callable[[int, int, int, 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         int, float], float]
                     ) -> int:
    """It is recommended to use local module with OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_put_state` or `pyPDAF.PDAF.localomi_put_state_nondiagR`. 
    Using Local ESTKF (error space transform Kalman filter) for DA without post-processing and analysis distribution to forecsat without OMI. This is a domain localisation method. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. The LESTKF is a more efficient equivalent to the LETKF. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    6. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init
    7. py__init_obsvar_pdaf (if global adaptive forgetting factor is used
    loop over each local domain:
    8. py__init_dim_l_pdaf
    9. py__init_dim_obs_l_pdaf
    10. py__g2l_state_pdaf
    11. py__g2l_obs_pdaf (localise mean ensemble in observation space)
    12. py__init_obs_l_pdaf
    13. py__g2l_obs_pdaf (localise each ensemble member in observation space
    14. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used
    15. py__prodRinvA_l_pdaf
    16. core DA algorithm
    17. py__l2g_state_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def put_state_letkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_dim_obs_pdaf : Callable[[int, int], int],
                     py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_obs_l_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                     py__prodRinvA_l_pdaf : Callable[[int, int, int, int, 
                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                     py__init_n_domains_p_pdaf : Callable[[int, int], int],
                     py__init_dim_l_pdaf : Callable[[int, int, int], int],
                     py__init_dim_obs_l_pdaf : Callable[[int, int, int, 
                                                         int], int],
                     py__g2l_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__l2g_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__g2l_obs_pdaf : Callable[[int, int, int, int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                  int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                  int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                     py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      float], float],
                     py__init_obsvar_l_pdaf : Callable[[int, int, int, 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        int, float], float]
                    ) -> int:
    """It is recommended to use local module with OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_put_state` or `pyPDAF.PDAF.localomi_put_state_nondiagR`. 
    Using local ensemble transform Kalman filter for DA without post-processing and analysis distribution to forecsat without OMI. This is a domain localisation method. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    6. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init
    7. py__init_obsvar_pdaf (if global adaptive forgetting factor is used
    loop over each local domain:
    8. py__init_dim_l_pdaf
    9. py__init_dim_obs_l_pdaf
    10. py__g2l_state_pdaf
    11. py__g2l_obs_pdaf (localise mean ensemble in observation space)
    12. py__init_obs_l_pdaf
    13. py__g2l_obs_pdaf (localise each ensemble member in observation space
    14. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used
    15. py__prodRinvA_l_pdaf
    16. core DA algorithm
    17. py__l2g_state_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def put_state_lnetf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_dim_obs_pdaf : Callable[[int, int], int],
                     py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_obs_l_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                     py__likelihood_l_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       float], float],
                     py__init_n_domains_p_pdaf : Callable[[int, int], int],
                     py__init_dim_l_pdaf : Callable[[int, int, int], int],
                     py__init_dim_obs_l_pdaf : Callable[[int, int, int, 
                                                         int], int],
                     py__g2l_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__l2g_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__g2l_obs_pdaf : Callable[[int, int, int, int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                  int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                  int], np.ndarray[tuple[int], np.dtype[np.intc]]]
                    ) -> int:
    """It is recommended to use local module with OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_put_state` or `pyPDAF.PDAF.localomi_put_state_lnetf_nondiagR`. 
    This function will use Local Nonlinear Ensemble Transform Filter (LNETF) for DA without post-processing and analysis distribution to forecsat without OMI. The nonlinear filter computes the distribution up to the second moment similar to KF but using a nonlinear weighting similar to particle filter. This leads to an equal weights assumption for prior ensemble. 
    
    This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    6. py__init_dim_l_pdaf
    7. py__init_dim_obs_l_pdaf
    8. py__g2l_state_pdaf
    9. py__init_obs_l_pdaf
    10. py__g2l_obs_pdaf (localise each ensemble member in observation space)
    11. py__likelihood_l_pdaf
    12. core DA algorithm
    13. py__l2g_state_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- nput vector holding the local residual

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def put_state_lknetf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_dim_obs_pdaf : Callable[[int, int], int],
                      py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_obs_l_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                       int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                      py__prodRinvA_l_pdaf : Callable[[int, int, int, int, 
                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                      py__prodRinvA_hyb_l_pdaf : Callable[[int, int, int, 
                                                           int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           float, np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                      py__init_n_domains_p_pdaf : Callable[[int, int], int],
                      py__init_dim_l_pdaf : Callable[[int, int, int], int],
                      py__init_dim_obs_l_pdaf : Callable[[int, int, int, 
                                                          int], int],
                      py__g2l_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__l2g_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__g2l_obs_pdaf : Callable[[int, int, int, int, 
                                                   np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                   int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                   int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                      py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       float], float],
                      py__init_obsvar_l_pdaf : Callable[[int, int, int, 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         int, float], float],
                      py__likelihood_l_pdaf : Callable[[int, int, int, 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        float], float],
                      py__likelihood_hyb_l_pdaf : Callable[[int, int, int, 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            float, float], float]
                     ) -> int:
    """It is recommended to use local module with OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_put_state` or `pyPDAF.PDAF.localomi_put_state_lknetf_nondiagR`. 
    This function will is a hybridised LETKF and LNETF for DA without post-processing and analysis distribution to forecsat without OMI. The LNETF computes the distribution up to the second moment similar to KF but using a nonlinear weighting similar to particle filter. This leads to an equal weights assumption for prior ensemble. The hybridisation with LETKF is expected to lead to improved performance for quasi-Gaussian problems.  
    
    This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    6. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init
    7. py__init_obsvar_pdaf (if global adaptive forgetting factor is used
    loop over each local domain:
    8. py__init_dim_l_pdaf
    9. py__init_dim_obs_l_pdaf
    10. py__g2l_state_pdaf
    11. py__g2l_obs_pdaf (localise each ensemble member in observation space)
    12. py__init_obs_l_pdaf
    13. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used
    14. py__prodRinvA_pdaf
    15. py__likelihood_l_pdaf
    16. core DA algorithm
    17. py__l2g_state_pdaf
    18. py__obs_op_pdaf (only called with `HKN` and `HNK` options called for each ensemble member
    19. py__likelihood_hyb_l_pda
    20. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used
    21. py__prodRinvA_hyb_l_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__prodRinvA_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, dim_ens:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, A_l:ndarray[tuple[dim_obs_l, dim_ens], np.float64], C_l:ndarray[tuple[dim_obs_l, dim_ens], np.float64]]
        Provide product R^-1 A on local analysis domain with hybrid weight

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **dim_ens** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **gamma** : float

            --- Hybrid weight provided by PDAF

        * **A_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance


    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute likelihood

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- nput vector holding the local residual

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    py__likelihood_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, likely_l:float]
        Compute likelihood with hybrid weight

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Input vector holding the local residual

        * **gamma** : float

            --- Hybrid weight provided by PDAF

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def put_state_lseik (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_dim_obs_pdaf : Callable[[int, int], int],
                     py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_obs_l_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                     py__prodRinvA_l_pdaf : Callable[[int, int, int, int, 
                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                     py__init_n_domains_p_pdaf : Callable[[int, int], int],
                     py__init_dim_l_pdaf : Callable[[int, int, int], int],
                     py__init_dim_obs_l_pdaf : Callable[[int, int, int, 
                                                         int], int],
                     py__g2l_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__l2g_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__g2l_obs_pdaf : Callable[[int, int, int, int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                  int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                  int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                     py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      float], float],
                     py__init_obsvar_l_pdaf : Callable[[int, int, int, 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        int, float], float]
                    ) -> int:
    """It is recommended to use local module with OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_put_state` or `pyPDAF.PDAF.localomi_put_state_nondiagR`. 
    Using local singular evolutive interpolated Kalman filter for DA without post-processing and analysis distribution to forecsat without OMI. This is a domain localisation method. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    6. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init
    7. py__init_obsvar_pdaf (if global adaptive forgetting factor is used
    loop over each local domain:
    8. py__init_dim_l_pdaf
    9. py__init_dim_obs_l_pdaf
    10. py__g2l_state_pdaf
    11. py__g2l_obs_pdaf (localise mean ensemble in observation space)
    12. py__init_obs_l_pdaf
    13. py__g2l_obs_pdaf (localise each ensemble member in observation space
    14. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used
    15. py__prodRinvA_l_pdaf
    16. core DA algorithm
    17. py__l2g_state_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def put_state_netf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__init_dim_obs_pdaf : Callable[[int, int], int],
                    py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                    py__likelihood_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    float], float]
                   ) -> int:
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.put_state_global` or `pyPDAF.PDAF.omi_put_state_nonlin_nondiagR`. 
    This function will use Nonlinear Ensemble Transform Filter (NETF) for DA without post-processing and analysis distribution to forecsat without OMI. The nonlinear filter computes the distribution up to the second moment similar to KF but using a nonlinear weighting similar to particle filter. This leads to an equal weights assumption for prior ensemble. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__init_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    6. py__likelihood_pdaf
    7. core DA algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__likelihood_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], resid:ndarray[tuple[dim_obs_p], np.float64], likely:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **resid** : ndarray[tuple[dim_obs_p], np.float64]

            --- Input vector holding the residual

        * **likely** : float

            --- Output value of the likelihood

        **Callback Returns**

        * **likely**:float

            --- Output value of the likelihood



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def put_state_pf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                  py__init_dim_obs_pdaf : Callable[[int, int], int],
                  py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                  py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                  py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                   int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                   int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                  py__likelihood_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                  float], float]
                 ) -> int:
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.put_state_global` or `pyPDAF.PDAF.omi_put_state_nonlin_nondiagR`. 
    This function will use particle filter for DA without post-processing and analysis distribution to forecsat without OMI. This is a fully nonlinear filter. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__init_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    6. py__likelihood_pdaf
    7. core DA algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__likelihood_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], resid:ndarray[tuple[dim_obs_p], np.float64], likely:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **resid** : ndarray[tuple[dim_obs_p], np.float64]

            --- Input vector holding the residual

        * **likely** : float

            --- Output value of the likelihood

        **Callback Returns**

        * **likely**:float

            --- Output value of the likelihood



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def put_state_prepost (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__prepoststep_pdaf : Callable[[int, int, int, 
                                                        int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                        int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]]]]
                      ) -> int:
    """This function does not perform any DA. It is used to preprocess the ensemble. To distribute the ensemble back to the model with post-processing, `pyPDAF.PDAF.get_state` function should be used afterwards.
    The sequence of the user-supplied functions is: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def put_state_seek (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__init_dim_obs_pdaf : Callable[[int, int], int],
                    py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                    py__prodRinvA_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]]
                   ) -> int:
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.put_state_global` or `pyPDAF.PDAF.put_state_global_nondiagR`. 
    This function will use singular evolutive extended Kalman filter for DA without post-processing and analysis distribution to forecsat without OMI. This function is usually used in 'flexible' parallelisation, but SEEK is deterministic and does not require ensemble. A `pyPDAF.PDAF.get_state` function should be used to post-process the state vector and distribute the state vector to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf (for ensemble mean
    5. py__init_obs_pdaf
    6. py__obs_op_pdaf (for each ensemble member
    7. py__prodRinvA_pdaf
    8. core DA algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 HV

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def put_state_seik (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__init_dim_obs_pdaf : Callable[[int, int], int],
                    py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                    py__prodRinvA_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                    py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     float], float]
                   ) -> int:
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.put_state_global` or `pyPDAF.PDAF.put_state_global_nondiagR`. 
    This function will use singular evolutive interpolated Kalman filter for DA without post-processing and analysis distribution to forecsat without OMI. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf (for ensemble mean
    5. py__init_obs_pdaf
    6. py__obs_op_pdaf (for each ensemble member
    7. py__init_obsvar_pdaf (only relevant for adaptive forgetting factor schemes)
    8. py__prodRinvA_pdaf
    9. core DA algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def reset_forget (forget_in: float) -> None:
    """This function allows a user to reset the forgetting factor manually during the assimilation process. For the local ensemble Kalman filters the forgetting factor can be set either globally of differently for each local analysis domain. For the LNETF and the global filters only a global setting of the forgeting factor is possible. In addition, the implementation of adaptive choices for the forgetting factor (beyond what is implemented in PDAF) are possible.

    Parameters
    ----------
    forget_in : float
        New value of forgetting factor
    """
    ...

def SampleEns (modes: np.ndarray[tuple[int, int], np.dtype[np.float64]],
               svals: np.ndarray[tuple[int], np.dtype[np.float64]],state: np.ndarray[tuple[int], np.dtype[np.float64]],
               verbose: int,flag: int) -> tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], np.ndarray[tuple[int], np.dtype[np.float64]], 
                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                      int]:
    """This function generates an ensemble from singular values and their vectors (EOF modes) centred on given mean state. The singular values and vectors are derived from the ensemble anomalies which can be obtained from a long model trajectory using `pyPDAF.PDAF.eofcovar`.

    Parameters
    ----------
    modes : ndarray[tuple[dim, dim_ens-1], np.float64]
        Array of EOF modes
    svals : ndarray[tuple[dim_ens-1], np.float64]
        Vector of singular values
    state : ndarray[tuple[dim], np.float64]
        PE-local model mean state
    verbose : int
        Verbosity flag
    flag : int
        Status flag

    Returns
    -------
    modes : ndarray[tuple[dim, dim_ens-1], np.float64]
         Array of EOF modes
    state : ndarray[tuple[dim], np.float64]
         PE-local model mean state
    ens : ndarray[tuple[dim, dim_ens], np.float64]
         State ensemble
    flag : int
        Status flag
    """
    ...

def set_debug_flag (debugval: int) -> None:
    """This function activates the debug output of the PDAF. Starting from the use of this function, the debug infomation is sent to screen output.  The screen output end when the debug flag is set to 0. We recommend using debugging output for single local domain, e.g. `if domain_p = 1: pyPDAF.PDAF.set_debug_flag(1)`.
    

    Parameters
    ----------
    debugval : int
        Value of debugging flag; print debug information for >0
    """
    ...

def set_ens_pointer () -> tuple[np.ndarray[tuple[int, ], np.dtype[float]], int]:
    """This function returns the ensemble array in a numpy array where the internal array data has the same memoery address as PDAF ensemble array.


    Returns
    -------
    c_ens_point : ndarray[float]
        Pointer to smoother array
    dims : ndarray[tuple[2], np.intc]
         dimension of the pointer
    status : int
        Status flag
    """
    ...

def set_smootherens (maxlag: int) -> tuple[np.ndarray[tuple[int, ], np.dtype[float]], int]:
    """This function can be used in the offline implementation when a smoother is used. It is typically called in `py__init_ens_pdaf` in the call to `pyPDAF.PDAF.PDAF_init`. The function `pyPDAF.PDAF.set_smootherens` is used when the smoother extension of a filter is used. In this case, the smoothed ensemble states at earlier times are stored in an internal array of PDAF. To be able to smooth post times, the smoother algorithm must have access to the past ensembles. In the offline mode the user has to manually fill the smoother ensemble array from ensembles read in from files. In the online mode, the smoother array is filled automatically during the cycles of forecast phases and analysis steps. 

    Parameters
    ----------
    maxlag : int
        Number of past timesteps processed in sens

    Returns
    -------
    c_sens_point : ndarray[float]
        Pointer to smoother array
    dims : ndarray[tuple[3], np.intc]
         dimension of the pointer
    status : int
        Status flag
    """
    ...

def seik_TtimesA (A: np.ndarray[tuple[int, int], np.dtype[np.float64]]
                 ) -> np.ndarray[tuple[int, int], np.dtype[np.float64]]:
    """This is an internal function in PDAF where it perform matrix calculation of B = TA. This allows for two types of T matrix. The resulting matrix B is the transformation matrix act on the full forecast ensemble. Mathematical description of the function is the second term of Eq. (23) and the T matrix is defined in Eq. (13) in
    Nerger, L., Janji, T., Schrter, J., Hiller, W. (2012). A unification of ensemble square root Kalman filters. Monthly Weather Review, 140, 2335-2345. doi:10.1175/MWR-D-11-00102.1
    

    Parameters
    ----------
    A : ndarray[tuple[rank, dim_col], np.float64]
        Input matrix

    Returns
    -------
    B : ndarray[tuple[rank+1, dim_col], np.float64]
         Output matrix (TA)
    """
    ...

def etkf_Tleft (A: np.ndarray[tuple[int, int], np.dtype[np.float64]]) -> np.ndarray[tuple[int, int], np.dtype[np.float64]]:
    """This is an internal function in PDAF where it perform matrix calculation of B = TA. This function performs the second term of Eq. (34) i
    Nerger, L., Janji, T., Schrter, J., Hiller, W. (2012). A unification of ensemble square root Kalman filters. Monthly Weather Review, 140, 2335-2345. doi:10.1175/MWR-D-11-00102.1
    

    Parameters
    ----------
    A : ndarray[tuple[dim_ens, dim], np.float64]
        Input/output matrix

    Returns
    -------
    A : ndarray[tuple[dim_ens, dim], np.float64]
         Input/output matrix
    """
    ...

def estkf_OmegaA (A: np.ndarray[tuple[int, int], np.dtype[np.float64]]
                 ) -> np.ndarray[tuple[int, int], np.dtype[np.float64]]:
    """This function is an internal function in PDAF. This function performs the second term of Eq. (29) i
    Nerger, L., Janji, T., Schrter, J., Hiller, W. (2012). A unification of ensemble square root Kalman filters. Monthly Weather Review, 140, 2335-2345. doi:10.1175/MWR-D-11-00102.1
    

    Parameters
    ----------
    A : ndarray[tuple[rank, dim_col], np.float64]
        Input matrix

    Returns
    -------
    B : ndarray[tuple[rank+1, dim_col], np.float64]
         Output matrix (TA)
    """
    ...

def enkf_omega (seed: np.ndarray[tuple[int], np.dtype[np.intc]],omega: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                norm: float,otype: int,screen: int) -> tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], float]:
    """Generation of a random matrix with orthogonal basis following SEEK approach for EnKF with given properties.

    Parameters
    ----------
    seed : ndarray[tuple[4], np.intc]
        Seed for random number generation
    omega : ndarray[tuple[dim_ens, r], np.float64]
        Random matrix
    norm : float
        Norm for ensemble transformation
    otype : int
        Type of Omega: (1) Simple Gaussian random matrix (2) Columns of unit norm (3) Columns of norm dim_ens^(-1/2) (4) Projection orthogonal (1,..,1)^T (6) Combination of 2 and 4 (7) Combination of 3 and 4 (8) Rows of sum 0 and variance 1
    screen : int
        Verbosity flag

    Returns
    -------
    omega : ndarray[tuple[dim_ens, r], np.float64]
         Random matrix
    norm : float
        Norm for ensemble transformation
    """
    ...

def seik_omega (omega: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                omegatype: int,screen: int) -> np.ndarray[tuple[int, int], np.dtype[np.float64]]:
    """Generation of a random matrix with orthogonal basis following SEIK approach.

    Parameters
    ----------
    omega : ndarray[tuple[rank+1, rank], np.float64]
        Matrix Omega
    omegatype : int
        Select type of Omega: (1) generated from random vectors (0) generated from deterministic vectors (Householder)
    screen : int
        Verbosity flag

    Returns
    -------
    omega : ndarray[tuple[rank+1, rank], np.float64]
         Matrix Omega
    """
    ...

def incremental (steps: int,py__dist_stateinc_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               int, int], None]
                ) -> None:
    """This is a helper function to apply analysis increment to model state in model forecast phase. It simply calls the user-supplied function. 

    Parameters
    ----------
    steps : int
        Time steps over which increment is distributed
    py__dist_stateinc_pdaf : Callable[dim_p:int, state_inc_p:ndarray[tuple[dim_p], np.float64], first:int, steps:int]
        Add state increment during integration

        **Callback Parameters**

        * **dim_p** : int

            --- Dimension of PE-local state

        * **state_inc_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        * **first** : int

            --- Flag for first call of each forecast

        * **steps** : int

            --- number of time steps in forecast

        **Callback Returns**


    """
    ...

def add_increment (state_p: np.ndarray[tuple[int], np.dtype[np.float64]]
                  ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    """This function directly adds analysis increment to given state vector without the need for user-supplied functions.

    Parameters
    ----------
    state_p : ndarray[tuple[dim_p], np.float64]
        State vector

    Returns
    -------
    state_p : ndarray[tuple[dim_p], np.float64]
         State vector
    """
    ...

def local_weights (wtype: int,cradius: float,sradius: float,distance: np.ndarray[tuple[int], np.dtype[np.float64]],
                   verbose: int) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    """This function returns a vector of the localisation weights based on distance and localisation functions and radii. This function is particularly useful for mannually apply covariance localisations for state or observation errors.

    Parameters
    ----------
    wtype : int
        Type of weight function (0): unit weight (=1 up to distance=cradius) (1): exponential decrease (1/e at distance=sradius; 0 for distance>cradius) (2): 5th order polynomial (Gaspari&Cohn 1999; 0 for distance>cradius)
    cradius : float
        Parameter for cut-off
    sradius : float
        Support radius
    distance : ndarray[tuple[dim], np.float64]
        Array holding distances
    verbose : int
        Verbosity flag

    Returns
    -------
    weight : ndarray[tuple[dim], np.float64]
         Array for weights
    """
    ...

def diag_CRPS (element: int,oens: np.ndarray[tuple[int, int], np.dtype[np.float64]],
               obs: np.ndarray[tuple[int], np.dtype[np.float64]]) -> tuple[float, float, float, float, int]:
    """Obtain a continuous rank probability score for an ensemble. The implementation is based on This function follows follows Hersbach, H., 2000: Decomposition of the Continuous Ranked Probability Score for Ensemble Prediction Systems. Wea. Forecasting, 15, 559570, https://doi.org/10.1175/1520-0434(2000)015<0559:DOTCRP>2.0.CO;2
    

    Parameters
    ----------
    element : int
        ID of element to be used. If element=0, mean values over all elements are computed
    oens : ndarray[tuple[dim, dim_ens], np.float64]
        State ensemble
    obs : ndarray[tuple[dim], np.float64]
        State ensemble

    Returns
    -------
    CRPS : float
        CRPS
    reli : float
        Reliability
    resol : float
        resolution
    uncert : float
        uncertainty
    status : int
        Status flag (0=success)
    """
    ...

def force_analysis () -> None:
    """This function overwrite member index of the ensemble state by local_dim_ens (number of ensembles for current process, in full parallel setup, this is 1.) and the counter cnt_steps by nsteps-1.
    This forces that the analysis step is executed at the next call to PDAF assimilation functions.

    """
    ...

def gather_obs_f2_flex (dim_obs_f: int,coords_p: np.ndarray[tuple[int, int], np.dtype[np.float64]]
                       ) -> tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], int]:
    """In the local filters (LESKTF, LETKF, LSEIK, LNETF)
    this function returns the full observation coordinates from process-local observation coordinates. `pyPDAF.PDAF.gather_obs_f_flex` is used to get corresponding observations. Unlike `pyPDAF.PDAF.gather_obs_f2`, the function does not use depends on
    `pyPDAF.PDAF.gather_dim_obs_f`

    Parameters
    ----------
    dim_obs_f : int
        Full observation dimension
    coords_p : ndarray[tuple[nrows, dim_obs_p], np.float64]
        PE-local array

    Returns
    -------
    coords_f : ndarray[tuple[nrows, dim_obs_f], np.float64]
         Full gathered array
    status : int
        Status flag: (0) no error
    """
    ...

def gather_obs_f_flex (dim_obs_f: int,obs_p: np.ndarray[tuple[int], np.dtype[np.float64]]
                      ) -> tuple[np.ndarray[tuple[int], np.dtype[np.float64]], int]:
    """In the local filters (LESKTF, LETKF, LSEIK, LNETF) this function returns the total observation vector from process-local observations. `pyPDAF.PDAF.gather_obs_f2_flex` is used to get corresponding coordinates.
    Unlike `pyPDAF.PDAF.gather_obs_f`, the function does not use depends on `pyPDAF.PDAF.gather_dim_obs_f`

    Parameters
    ----------
    dim_obs_f : int
        Full observation dimension
    obs_p : ndarray[tuple[dim_obs_p], np.float64]
        PE-local vector

    Returns
    -------
    obs_f : ndarray[tuple[dim_obs_f], np.float64]
         Full gathered vector
    status : int
        Status flag: (0) no error
    """
    ...

def prepost (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
             py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
             py__prepoststep_pdaf : Callable[[int, int, int, int, int, 
                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                              int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                              np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
             py__next_observation_pdaf : Callable[[int, int, int, float], tuple[int, 
                                                   int, float]]
            ) -> int:
    """This function does not perform any DA. It is used to perform a preprocess and postprocess of the ensemble. Compared to `pyPDAF.PDAF.assimilate_prepost`, this function does not set assimilation flag.
    The function is a combination of `pyPDAF.PDAF.put_state_prepost` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__prepoststep_state_pdaf
    4. py__distribute_state_pdaf
    5. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def set_memberid (memberid: int) -> int:
    """This function sets the ensemble member index to given value.

    Parameters
    ----------
    memberid : int
        Index in the local ensemble

    Returns
    -------
    memberid : int
        Index in the local ensemble
    """
    ...

def set_comm_pdaf (in_COMM_pdaf: int) -> None:
    """This function sets the MPI communicator of PDAF. This is by default `MPI_COMM_WORLD`. 

    Parameters
    ----------
    in_COMM_pdaf : int
        MPI communicator for PDAF
    """
    ...

def set_offline_mode (screen: int) -> None:
    """This function activates offline mode.

    Parameters
    ----------
    screen : int
        Verbosity flag
    """
    ...

def print_domain_stats (n_domains_p: int) -> None:
    """This function make screen output of statistics of the local domains on current process.

    Parameters
    ----------
    n_domains_p : int
        Number of PE-local analysis domains
    """
    ...

def init_local_obsstats () -> None:
    """This function initialise the observation statistics of local domain. This statistics can be updated by `pyPDAF.PDAF.incr_local_obsstats`, and can be viewed by `pyPDAF.PDAF.print_local_obsstats`.

    """
    ...

def incr_local_obsstats (dim_obs_l: int) -> None:
    """This function update the observation statistics of local domain. This statistics should be initialised by `pyPDAF.PDAF.init_local_obsstats`, and can be viewed by `pyPDAF.PDAF.print_local_obsstats`.

    Parameters
    ----------
    dim_obs_l : int
        Number of locally assimilated observations
    """
    ...

def print_local_obsstats (screen: int) -> int:
    """This function print the observation statistics of local domain on screen. This statistics should be initialised by `pyPDAF.PDAF.init_local_obsstats`, and can be updated by `pyPDAF.PDAF.incr_local_obsstats`.

    Parameters
    ----------
    screen : int
        Verbosity flag

    Returns
    -------
    n_domains_with_obs : int
        number of domains with observations
    """
    ...

def omit_obs_omi (state_p: np.ndarray[tuple[int], np.dtype[np.float64]],
                  ens_p: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                  obs_p: np.ndarray[tuple[int], np.dtype[np.float64]],py__init_obs_pdaf : Callable[[int, 
                                                                                                    int, 
                                                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                  py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                  compute_mean: int,screen: int) -> tuple[np.ndarray[tuple[int], np.dtype[np.float64]], np.ndarray[tuple[int], np.dtype[np.float64]], 
                                              ]:
    """This function computes innovation and omit corresponding observations in assimilation if the innovation is too large. This function is used by some of the global filters, e.g. EnKF, LEnKF, PF, NETF, with OMI.

    Parameters
    ----------
    state_p : ndarray[tuple[dim_p], np.float64]
        on exit: PE-local forecast mean state
    ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]
        PE-local state ensemble
    obs_p : ndarray[tuple[dim_obs_p], np.float64]
        PE-local observation vector
    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    compute_mean : int
        (1) compute mean; (0) state_p holds mean
    screen : int
        Verbosity flag

    Returns
    -------
    state_p : ndarray[tuple[dim_p], np.float64]
         on exit: PE-local forecast mean state
    obs_p : ndarray[tuple[dim_obs_p], np.float64]
         PE-local observation vector
    """
    ...

def diag_CRPS_nompi (element: int,oens: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                     obs: np.ndarray[tuple[int], np.dtype[np.float64]]
                    ) -> tuple[float, float, float, float, int]:
    """Obtain a continuous rank probability score for an ensemble without using MPI parallelisation. The implementation is based on This function follows follows Hersbach, H., 2000: Decomposition of the Continuous Ranked Probability Score for Ensemble Prediction Systems. Wea. Forecasting, 15, 559570, https://doi.org/10.1175/1520-0434(2000)015<0559:DOTCRP>2.0.CO;2
    

    Parameters
    ----------
    element : int
        ID of element to be used If element=0, mean values over all elements are computed
    oens : ndarray[tuple[dim, dim_ens], np.float64]
        State ensemble
    obs : ndarray[tuple[dim], np.float64]
        State ensemble

    Returns
    -------
    CRPS : float
        CRPS
    reli : float
        Reliability
    resol : float
        resolution
    uncert : float
        uncertainty
    status : int
        Status flag (0=success)
    """
    ...

def omi_init (n_obs: int) -> None:
    """This function initialise the number of observation types in OMI by allocating an array of `obs_f` derived types instances. This should be called before any other OMI functions.

    Parameters
    ----------
    n_obs : int
        number of observations
    """
    ...

def omi_set_doassim (i_obs: int,doassim: int) -> None:
    """This function sets the `doassim` attribute of `obs_f` typically used in user-supplied function `py__init_dim_obs_pdaf`. If `doassim` is set to 0, the observation is not assimilated in the DA system. See https://pdaf.awi.de/trac/wiki/OMI_observation_modules#thisobsdoassim

    Parameters
    ----------
    i_obs : int
        index of observation types
    doassim : int
        0) do not assimilate; 1) assimilate the observation type
    """
    ...

def omi_set_disttype (i_obs: int,disttype: int) -> None:
    """This function sets the `disttype` attribute of `obs_f` typically used in user-supplied function `py__init_dim_obs_pdaf`. `disttype` determines the way the distance between observation and model grid is calculated in OMI. See https://pdaf.awi.de/trac/wiki/OMI_observation_modules#thisobsdisttype

    Parameters
    ----------
    i_obs : int
        index of observations
    disttype : int
        0) Cartesian; 1) Cartesian periodic 2) Approximation to geographic distance in metres using latitude and longitude expressed in radians 3) Using Haversine formula to compute distance in metres between two points on the surface of a sphere 10) 3D Cartesian distance for 2D+1D factorised localisation where horizontal and vertical distances are treated separately 11) 3D Cartesian periodic distance for 2D+1D factorised localisation where horizontal and vertical distances are treated separately 12) Same as 2) for horizontal distance but vertical distance is in units chosen by users 13) Same as 3) for horizontal distance but vertical distance is in units chosen by users
    """
    ...

def omi_set_ncoord (i_obs: int,ncoord: int) -> None:
    """This function sets the `ncoord` attribute of `obs_f` typically used in user-supplied function `py__init_dim_obs_pdaf`. This is the dimension of coordinates of the observation. 

    Parameters
    ----------
    i_obs : int
        index of observations
    ncoord : int
        Dimension of the observation coordinate
    """
    ...

def omi_set_id_obs_p (i_obs: int,id_obs_p: np.ndarray[tuple[int, int], np.dtype[np.intc]]
                     ) -> None:
    """Setting the `id_obs_p` attribute of `obs_f`.

    The function is typically used in user-supplied function `py__init_dim_obs_pdaf`.

    Here, `id_obs_p(nrows, dim_obs_p)` is a 2D array of integers.
    The value of `nrows` depends on the observation operator used for an observation.

    Examples:

    - `nrows=1`: observations are located on model grid point.
      In this case, `id_obs_p` stores the index of the state vector (starting from 1) corresponds to the observations,
      e.g. `id_obs_p[0, j] = i` means that the location and variable of the `i`-th element of the state vector
      is the same as the `j`-th observation.

    - `nrows=4`: each observation corresponds to 4 indices of elements in the state vector.
       In this case,
       the location of these elements is used to perform bi-linear interpolation
       from model grid to observation location.
       This information is used in the :func:`pyPDAF.PDAF.omi_obs_op_gridavg`
       and :func:`pyPDAF.PDAF.omi_obs_op_interp_lin` functions.
       When interpolation is needed,
       the weighting of the interpolation is done
       in the :func:`pyPDAF.PDAF.omi_get_interp_coeff_lin`,
       :func:`pyPDAF.PDAF.omi_get_interp_coeff_lin1D`,
       and :func:`pyPDAF.PDAF.omi_get_interp_coeff_tri` functions.
       The details of interpolation setup can be found at
       `PDAF wiki page <https://pdaf.awi.de/trac/wiki/OMI_observation_operators#Initializinginterpolationcoefficients>`_.


    Parameters
    ----------
    i_obs : int
        index of observations
    id_obs_p : ndarray[tuple[nrows, dim_obs_p], np.intc]
        indice corresponds to observations in the state vector
    """
    ...

def omi_set_icoeff_p (i_obs: int,icoeff_p: np.ndarray[tuple[int, int], np.dtype[np.float64]]
                     ) -> None:
    """This function sets the `icoeff_p` attribute of `obs_f` typically used in user-supplied function `py__init_dim_obs_pdaf`. `icoeff_p(nrows, dim_obs_p)` is a 2D array of real number used to implement
    interpolations. This is used in tandem with `id_obs_p`. Checking the documentation of `pyPDAF.PDAF.omi_set_id_obs_p` for some details. Also, see https://pdaf.awi.de/trac/wiki/OMI_observation_operators#Initializinginterpolationcoefficients for setting these values.

    Parameters
    ----------
    i_obs : int
        index of observations
    icoeff_p : ndarray[tuple[nrows, dim_obs_p], np.float64]
        weighting coefficients for interpolations
    """
    ...

def omi_set_domainsize (i_obs: int,domainsize: np.ndarray[tuple[int], np.dtype[np.float64]]
                       ) -> None:
    """This function sets the `domainsize` attribute of `obs_f` typically used in user-supplied function `py__init_dim_obs_pdaf`. `domainsize(ncoord)` is the size of the domain in each spatial dimension. This information is used to compute the Cartesian disance with periodic boundary. If the value of one dimension is `<=0`, no periodicity is assumed in that dimension. 

    Parameters
    ----------
    i_obs : int
        index of observations
    domainsize : ndarray[tuple[ncoord], np.float64]
        Size of the domain in each dimension
    """
    ...

def omi_set_obs_err_type (i_obs: int,obs_err_type: int) -> None:
    """This function sets the `obs_err_type` attribute of `obs_f` typically used in user-supplied function `py__init_dim_obs_pdaf`. `obs_err_type` is an integer that specifies the type of observation error. 

    Parameters
    ----------
    i_obs : int
        index of observations
    obs_err_type : int
        0) Gaussian (default); 1) double exponential (Laplacian)
    """
    ...

def omi_set_use_global_obs (i_obs: int,use_global_obs: int) -> None:
    """This function sets the `use_global_obs` attribute of `obs_f` typically used in user-supplied function `py__init_dim_obs_pdaf`. In the domain-localized filters (LESTK, LETKF, LSEIK, LNETF) observations are assimilated that are located within the localization around some grid point. When a model uses parallelisation with domain-decomposition some of these observations might belong to a different process-domain. In the default mode (use_global_obs=1) PDAF-OMI gathers all globally available observations so that each process has access to all observations.
    It can be more efficient to limit the observations on a process-domain to those observations that are located inside the domain or within the localization radius around it. Then, in the local analyses less observations have to be checked for their distance. Setting use_global_obs=0 activates this feature. However, it needs additional preparations to make PDAF-OMI aware of the limiting coordinates of a process sub-domain. See https://pdaf.awi.de/trac/wiki/OMI_use_global_obs for the use of `pyPDAF.PDAF.omi_set_domain_limits`.

    Parameters
    ----------
    i_obs : int
        index of observations
    use_global_obs : int
        0) Using process-local observations; 1) using cross-process observations (default)
    """
    ...

def omi_set_inno_omit (i_obs: int,inno_omit: float) -> None:
    """This function sets the `inno_omit` attribute of `obs_f` typically used in user-supplied function `py__init_dim_obs_pdaf`. Setting this variable to a value > 0.0 activates the functionality that observations are omitted (made irrelevant) from the analysis update if the difference of their value and the ensemble mean to too large. If inno_omit=2.0, an observation would be omitted if the squared difference between the observed ensemble mean state and the observation value is larger than 2 times the observation error variance
    See https://pdaf.awi.de/trac/wiki/PDAFomi_additional_functionality#Omittingobservationsthatarepotentialoutliers

    Parameters
    ----------
    i_obs : int
        index of observations
    inno_omit : float
        Threshold of innovation to be omitted
    """
    ...

def omi_set_inno_omit_ivar (i_obs: int,inno_omit_ivar: float) -> None:
    """This function sets the `inno_omit_ivar` attribute of `obs_f` typically used in user-supplied function `py__init_dim_obs_pdaf`. This is used to specify the inverse of the observations variance to omit the observation. By default it is `1e-12` for a large observation error, but users can adjust this value to ensure that the observation is omitted based on applications
    

    Parameters
    ----------
    i_obs : int
        index of observations
    inno_omit_ivar : float
        Inverse of observation variance for omiited observations
    """
    ...

def omi_gather_obs (i_obs: int,obs_p: np.ndarray[tuple[int], np.dtype[np.float64]],
                    ivar_obs_p: np.ndarray[tuple[int], np.dtype[np.float64]],
                    ocoord_p: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                    cradius: float) -> int:
    """This function is typically called in the user-supplied function `py__init_dim_obs_pdaf`. This function returns the full observation dimensioin from process-local observations. It also sets the observation vector, its coordinates, and the inverse of the observation variance. This function furtuer sets the localisation radius in OMI.

    Parameters
    ----------
    i_obs : int
        index of observations
    obs_p : ndarray[tuple[dim_obs_p], np.float64]
        pe-local observation vector
    ivar_obs_p : ndarray[tuple[dim_obs_p], np.float64]
        pe-local inverse observation error variance
    ocoord_p : ndarray[tuple[thisobs(i_obs)%ncoord, dim_obs_p], np.float64]
        pe-local observation coordinates
    cradius : float
        localization radius

    Returns
    -------
    dim_obs : int
        Full number of observations
    """
    ...

def omi_gather_obsstate (i_obs: int,obsstate_p: np.ndarray[tuple[int], np.dtype[np.float64]],
                         obsstate_f: np.ndarray[tuple[int], np.dtype[np.float64]]
                        ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    """This function is used to implement custom observation operators. See https://pdaf.awi.de/trac/wiki/OMI_observation_operators#Implementingyourownobservationoperator

    Parameters
    ----------
    i_obs : int
        index of observations
    obsstate_p : ndarray[tuple[thisobs(i_obs)%dim_obs_p], np.float64]
        Vector of process-local observed state
    obsstate_f : ndarray[tuple[nobs_f_all], np.float64]
        Full observed vector for all types

    Returns
    -------
    obsstate_f : ndarray[tuple[nobs_f_all], np.float64]
         Full observed vector for all types
    """
    ...

def omi_set_domain_limits (lim_coords: np.ndarray[tuple[int, int], np.dtype[np.float64]]
                          ) -> None:
    """This is used to set the domain limits for the use of `pyPDAF.PDAF.omi_set_use_global_obs`.Currently, it only supports 2D limitations. See https://pdaf.awi.de/trac/wiki/PDAFomi_additional_functionality#PDAFomi_set_domain_limit
    

    Parameters
    ----------
    lim_coords : ndarray[tuple[2, 2], np.float64]
        geographic coordinate array (1: longitude, 2: latitude)
    """
    ...

def omi_set_debug_flag (debugval: int) -> None:
    """This sets the debug flag for OMI. If set to 1, debug information is printed to the screen.
    The debug flag can be set to 0 to stop the debugging. See https://pdaf.awi.de/trac/wiki/OMI_debugging

    Parameters
    ----------
    debugval : int
        Value for debugging flag
    """
    ...

def omi_deallocate_obs (i_obs: int) -> None:
    """It deallocates teh OMI-internal obsrevation arrays but this should not be called as it is called internally in PDAF.

    Parameters
    ----------
    i_obs : int
        index of observations
    """
    ...

def omi_obs_op_gridpoint (i_obs: int,state_p: np.ndarray[tuple[int], np.dtype[np.float64]],
                          obs_f_all: np.ndarray[tuple[int], np.dtype[np.float64]]
                         ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    """A (partial) identity observation operator

    This observation operator is used when observations and model use the same grid. 

    The observations operator selects state vectors where observations are present. 

    The function is used in the user-supplied function `py__obs_op_pdaf`. 

    

    Parameters
    ----------
    i_obs : int
        index of observations
    state_p : ndarray[tuple[dim_p], np.float64]
        PE-local model state (dim_p)
    obs_f_all : ndarray[tuple[nobs_f_all], np.float64]
        Full observed state for all observation types (nobs_f_all)

    Returns
    -------
    obs_f_all : ndarray[tuple[nobs_f_all], np.float64]
         Full observed state for all observation types (nobs_f_all)
    """
    ...

def omi_obs_op_gridavg (i_obs: int,nrows: int,state_p: np.ndarray[tuple[int], np.dtype[np.float64]],
                        obs_f_all: np.ndarray[tuple[int], np.dtype[np.float64]]
                       ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    """Observation operator that average values on given model grid points.

    The averaged model grid points are specified in `id_obs_p` property of `obs_f`,
    which can be set in :func:`pyPDAF.PDAF.omi_set_id_obs_p`.

    The function is used in the user-supplied function `py__obs_op_pdaf`. 

    Parameters
    ----------
    i_obs : int
        index of observations
    nrows : int
        Number of values to be averaged
    state_p : ndarray[tuple[dim_p], np.float64]
        PE-local model state (dim_p)
    obs_f_all : ndarray[tuple[nobs_f_all], np.float64]
        Full observed state for all observation types (nobs_f_all)

    Returns
    -------
    obs_f_all : ndarray[tuple[nobs_f_all], np.float64]
         Full observed state for all observation types (nobs_f_all)
    """
    ...

def omi_obs_op_interp_lin (i_obs: int,nrows: int,state_p: np.ndarray[tuple[int], np.dtype[np.float64]],
                           obs_f_all: np.ndarray[tuple[int], np.dtype[np.float64]]
                          ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    """Observation operator that linearly interpolates model grid values to observation location.

    The grid points used by linear interpolation is specified in `id_obs_p` of `obs_f`,
    which can be set by :func:`pyPDAF.PDAF.omi_set_id_obs_p`.

    The function also requires `icoeff_p` attribute of `obs_f`,
    which can be set by :func:`pyPDAF.PDAF.omi_set_icoeff_p`

    The interpolation coefficient can be obtained by :func:`pyPDAF.PDAF.omi_get_interp_coeff_lin1D`,
    :func:`pyPDAF.PDAF.omi_get_interp_coeff_lin`, and
    :func:`pyPDAF.PDAF.omi_get_interp_coeff_tri`

    The details of interpolation setup can be found at
    `PDAF wiki page <https://pdaf.awi.de/trac/wiki/OMI_observation_operators#Initializinginterpolationcoefficients>`_

    The function is used in the user-supplied function `py__obs_op_pdaf`. 

    Parameters
    ----------
    i_obs : int
        index of observations
    nrows : int
        Number of values to be averaged
    state_p : ndarray[tuple[dim_p], np.float64]
        PE-local model state (dim_p)
    obs_f_all : ndarray[tuple[nobs_f_all], np.float64]
        Full observed state for all observation types (nobs_f_all)

    Returns
    -------
    obs_f_all : ndarray[tuple[nobs_f_all], np.float64]
         Full observed state for all observation types (nobs_f_all)
    """
    ...

def omi_obs_op_adj_gridavg (i_obs: int,nrows: int,state_p: np.ndarray[tuple[int], np.dtype[np.float64]],
                            obs_f_all: np.ndarray[tuple[int], np.dtype[np.float64]]
                           ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    """The adjoint observation operator of :func:`pyPDAF.PDAF.omi_obs_op_gridavg`.

    Parameters
    ----------
    i_obs : int
        index of observations
    nrows : int
        Number of values to be averaged
    state_p : ndarray[tuple[dim_p], np.float64]
        PE-local model state (dim_p)
    obs_f_all : ndarray[tuple[nobs_f_all], np.float64]
        Full observed state for all observation types (nobs_f_all)

    Returns
    -------
    state_p : ndarray[tuple[dim_p], np.float64]
         PE-local model state (dim_p)
    """
    ...

def omi_obs_op_adj_gridpoint (i_obs: int,state_p: np.ndarray[tuple[int], np.dtype[np.float64]],
                              obs_f_all: np.ndarray[tuple[int], np.dtype[np.float64]]
                             ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    """The adjoint observation operator of :func:`pyPDAF.PDAF.omi_obs_op_gridpoint`.

    Parameters
    ----------
    i_obs : int
        index of observations
    state_p : ndarray[tuple[dim_p], np.float64]
        PE-local model state (dim_p)
    obs_f_all : ndarray[tuple[nobs_f_all], np.float64]
        Full observed state for all observation types (nobs_f_all)

    Returns
    -------
    state_p : ndarray[tuple[dim_p], np.float64]
         PE-local model state (dim_p)
    """
    ...

def omi_obs_op_adj_interp_lin (i_obs: int,nrows: int,state_p: np.ndarray[tuple[int], np.dtype[np.float64]],
                               obs_f_all: np.ndarray[tuple[int], np.dtype[np.float64]]
                              ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    """The adjoint observation operator of :func:`pyPDAF.PDAF.omi_obs_op_interp_lin`.

    Parameters
    ----------
    i_obs : int
        index of observations
    nrows : int
        Number of values to be averaged
    state_p : ndarray[tuple[dim_p], np.float64]
        PE-local model state (dim_p)
    obs_f_all : ndarray[tuple[nobs_f_all], np.float64]
        Full observed state for all observation types (nobs_f_all)

    Returns
    -------
    state_p : ndarray[tuple[dim_p], np.float64]
         PE-local model state (dim_p)
    """
    ...

def omi_get_interp_coeff_tri (gpc: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                              oc: np.ndarray[tuple[int], np.dtype[np.float64]],
                              icoeff: np.ndarray[tuple[int], np.dtype[np.float64]]
                             ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    """The coefficient for linear interpolation in 2D on unstructure triangular grid.

    The resulting coefficient is used in :func:`omi_obs_op_interp_lin`.

    This function is for triangular model grid interpolation coefficients determined as barycentric coordinates.

    Parameters
    ----------
    gpc : ndarray[tuple[3, 2], np.float64]
        Coordinates of grid points with dimension of (3, 2). 3 grid points surrounding the observation; each containing lon and lat coordinates. The order of the grid points in gcoords has to be consistent with the order of the indices specified in `id_obs_p` of `obs_f`.
    oc : ndarray[tuple[2], np.float64]
        Coordinates of observation (targeted location); dim(2)
    icoeff : ndarray[tuple[3], np.float64]
        Interpolation coefficients; dim(3)

    Returns
    -------
    icoeff : ndarray[tuple[3], np.float64]
         Interpolation coefficients; dim(3)
    """
    ...

def omi_get_interp_coeff_lin1D (gpc: np.ndarray[tuple[int], np.dtype[np.float64]],
                                oc: float,icoeff: np.ndarray[tuple[int], np.dtype[np.float64]]
                               ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    """The coefficient for linear interpolation in 1D.

    The resulting coefficient is used in :func:`omi_obs_op_interp_lin`.

    

    Parameters
    ----------
    gpc : ndarray[tuple[2], np.float64]
        Coordinates of grid points surrounding the observations (dim=2)
    oc : float
        Coordinates of observation (targeted location)
    icoeff : ndarray[tuple[2], np.float64]
        Interpolation coefficients (dim=2)

    Returns
    -------
    icoeff : ndarray[tuple[2], np.float64]
         Interpolation coefficients (dim=2)
    """
    ...

def omi_get_interp_coeff_lin (gpc: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                              oc: np.ndarray[tuple[int], np.dtype[np.float64]],
                              icoeff: np.ndarray[tuple[int], np.dtype[np.float64]]
                             ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    """The coefficient for linear interpolation up to 3D.

    The resulting coefficient is used in :func:`omi_obs_op_interp_lin`.

    See introduction in `PDAF-OMI wiki page 
    <https://pdaf.awi.de/trac/wiki/OMI_observation_operators#PDAFomi_get_interp_coeff_lin>`_

    Parameters
    ----------
    gpc : ndarray[tuple[num_gp, n_dim], np.float64]
        Coordinates of grid points The order of the grid points in gcoords has to be consistent with the order of the indices specified in `id_obs_p` of `obs_f`.
    oc : ndarray[tuple[n_dim], np.float64]
        Coordinates of observation
    icoeff : ndarray[tuple[num_gp], np.float64]
        Interpolation coefficients (num_gp)

    Returns
    -------
    icoeff : ndarray[tuple[num_gp], np.float64]
         Interpolation coefficients (num_gp)
    """
    ...

def omi_assimilate_3dvar (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__init_dim_obs_pdaf : Callable[[int, int], int],
                          py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__cvt_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__cvt_adj_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__obs_op_lin_pdaf : Callable[[int, int, int, 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__obs_op_adj_pdaf : Callable[[int, int, int, 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__prepoststep_pdaf : Callable[[int, int, int, 
                                                           int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                          py__next_observation_pdaf : Callable[[int, int, 
                                                                int, float], tuple[int, 
                                                                int, float]],
                          outflag: int) -> int:
    """Using 3DVar for DA with diagonal observation error covariance matrix.
    This is a deterministic filtering scheme. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.omi_put_state_3dvar`
    and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_pdaf
    6. py__obs_op_lin_pdaf
    7. py__obs_op_adj_pdaf
    8. py__cvt_adj_pdaf
    9. core DA algorithm
    After the iterations: 
    10. py__cvt_pdaf
    11. py__prepoststep_state_pdaf
    12. py__distribute_state_pdaf
    13. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_assimilate_en3dvar_estkf (py__collect_state_pdaf : Callable[[int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__distribute_state_pdaf : Callable[[int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__init_dim_obs_pdaf : Callable[[int, 
                                                                    int], int],
                                  py__obs_op_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__cvt_ens_pdaf : Callable[[int, int, 
                                                               int, int, 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__obs_op_lin_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__obs_op_adj_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__prepoststep_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                  py__next_observation_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        float], tuple[int, 
                                                                        int, 
                                                                        float]],
                                  outflag: int) -> int:
    """Using 3DEnVar for DA with diagonal observation error covariance matrix.
    The background error covariance matrix is estimated by ensemble. The 3DEnVar only calculates the analysis of the ensemble mean.
    An ESTKF is used to generate ensemble perturbations. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.omi_put_state_en3dvar_estkf`
    and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_ens_pdaf
    6. py__obs_op_lin_pdaf
    7. py__obs_op_adj_pdaf
    8. py__cvt_adj_ens_pdaf
    9. core 3DEnVar algorithm
    After the iterations: 
    10. py__cvt_ens_pdaf
    Perform ESTKF: 11. py__init_dim_obs_pdaf
    12. py__obs_op_pdaf (for ensemble mean
    13. py__obs_op_pdaf (for each ensemble member
    14. core ESTKF algorithm
    15. py__prepoststep_state_pdaf
    16. py__distribute_state_pdaf
    17. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_assimilate_en3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__distribute_state_pdaf : Callable[[int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__init_dim_obs_pdaf : Callable[[int, 
                                                                     int], int],
                                   py__obs_op_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__cvt_ens_pdaf : Callable[[int, int, 
                                                                int, int, 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__obs_op_lin_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__obs_op_adj_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__init_n_domains_p_pdaf : Callable[[int, 
                                                                         int], int],
                                   py__init_dim_l_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int], int],
                                   py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int, 
                                                                       int], int],
                                   py__g2l_state_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__l2g_state_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__prepoststep_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                   py__next_observation_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         float], tuple[int, 
                                                                         int, 
                                                                         float]],
                                   outflag: int) -> int:
    """It is recommended to use `pyPDAF.PDAF.localomi_assimilate_en3dvar_lestkf` for better efficiency. 
    
   
    Using 3DEnVar for DA with diagonal observation error covariance matrix.
    The background error covariance matrix is estimated by ensemble. The 3DEnVar only calculates the analysis of the ensemble mean.
    An LESTKF is used to generate ensemble perturbations. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.omi_put_state_en3dvar_lestkf`
    and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_ens_pdaf
    6. py__obs_op_lin_pdaf
    7. py__obs_op_adj_pdaf
    8. py__cvt_adj_ens_pdaf
    9. core DA algorithm
    After the iterations: 
    10. py__cvt_ens_pdaf
    Perform LESTKF: 
    11. py__init_n_domains_p_pdaf
    12. py__init_dim_obs_pdaf
    13. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    14. py__init_dim_l_pdaf
    15. py__init_dim_obs_l_pdaf
    16. py__g2l_state_pdaf (localise mean ensemble in observation space)
    17. core DA algorithm
    18. py__l2g_state_pdaf
    19. py__prepoststep_state_pdaf
    20. py__distribute_state_pdaf
    21. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from local state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_assimilate_global (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                           py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                           py__init_dim_obs_pdaf : Callable[[int, int], int],
                           py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                           py__prepoststep_pdaf : Callable[[int, int, int, 
                                                            int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                           py__next_observation_pdaf : Callable[[int, int, 
                                                                 int, float], tuple[int, 
                                                                 int, float]]
                          ) -> int:
    """Global filters for DA except for 3DVars with diagonal observation error covariance matrix.

    The function is a combination of :func:`pyPDAF.PDAF.omi_put_state_global`
    and :func:`pyPDAF.PDAF.get_state`.

    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence:

    1. py__collect_state_pdaf

    2. py__prepoststep_state_pdaf

    3. py__init_dim_obs_pdaf

    4. py__obs_op_pdaf (for ensemble mean

    5. py__obs_op_pdaf (for each ensemble member

    6. core DA algorithm

    7. py__prepoststep_state_pdaf

    8. py__distribute_state_pdaf

    9. py__next_observation_pdaf

    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def omi_assimilate_hyb3dvar_estkf (py__collect_state_pdaf : Callable[[int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__distribute_state_pdaf : Callable[[int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__init_dim_obs_pdaf : Callable[[int, 
                                                                     int], int],
                                   py__obs_op_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__cvt_ens_pdaf : Callable[[int, int, 
                                                                int, int, 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__cvt_pdaf : Callable[[int, int, int, 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__cvt_adj_pdaf : Callable[[int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__obs_op_lin_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__obs_op_adj_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__prepoststep_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                   py__next_observation_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         float], tuple[int, 
                                                                         int, 
                                                                         float]],
                                   outflag: int) -> int:
    """Using Hybrid 3DEnVar for DA with diagonal observation error covariance matrix.
    Here, the background error covariance is hybridised by a static background error covariance, and a flow-dependent background error covariance estimated from ensemble. The 3DVar generates an ensemble mean and the ensemble perturbation is generated by
    ESTKF in this implementation. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.omi_put_state_hyb3dvar_estkf`
    and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_pdaf
    6. py__cvt_ens_pdaf
    7. py__obs_op_lin_pdaf
    8. py__obs_op_adj_pdaf
    9. py__cvt_adj_pdaf
    10. py__cvt_adj_ens_pdaf
    11. core 3DEnVar algorithm
    After the iterations: 
    12. py__cvt_pdaf
    13. py__cvt_ens_pdaf
    Perform ESTKF: 14. py__init_dim_obs_pdaf
    15. py__obs_op_pdaf (for ensemble mean
    16. py__obs_op_pdaf (for each ensemble member
    17. core ESTKF algorithm
    18. py__prepoststep_state_pdaf
    19. py__distribute_state_pdaf
    20. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply ensemble control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint ensemble control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_assimilate_hyb3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__distribute_state_pdaf : Callable[[int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__init_dim_obs_pdaf : Callable[[int, 
                                                                      int], int],
                                    py__obs_op_pdaf : Callable[[int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__cvt_ens_pdaf : Callable[[int, int, 
                                                                 int, int, 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__cvt_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__cvt_adj_pdaf : Callable[[int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__obs_op_lin_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__obs_op_adj_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__init_n_domains_p_pdaf : Callable[[int, 
                                                                          int], int],
                                    py__init_dim_l_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int], int],
                                    py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        int], int],
                                    py__g2l_state_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__l2g_state_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__prepoststep_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                    py__next_observation_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          float], tuple[int, 
                                                                          int, 
                                                                          float]],
                                    outflag: int) -> int:
    """It is recommended to use `pyPDAF.PDAF.localomi_assimilate_hyb3dvar_lestkf` for better efficiency. 
    
   
    Using Hybrid 3DEnVar for DA with diagonal observation error covariance matrix.
    Here, the background error covariance is hybridised by a static background error covariance, and a flow-dependent background error covariance estimated from ensemble. The 3DVar generates an ensemble mean and the ensemble perturbation is generated by
    LESTKF in this implementation. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.omi_put_state_hyb3dvar_lestkf`
    and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_pdaf
    6. py__cvt_ens_pdaf
    7. py__obs_op_lin_pdaf
    8. py__obs_op_adj_pdaf
    9. py__cvt_adj_pdaf
    10. py__cvt_adj_ens_pdaf
    11. core DA algorithm
    After the iterations: 
    12. py__cvt_pdaf
    13. py__cvt_ens_pdaf
    Perform LESTKF: 
    14. py__init_n_domains_p_pdaf
    15. py__init_dim_obs_pdaf
    16. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    17. py__init_dim_l_pdaf
    18. py__init_dim_obs_l_pdaf
    19. py__g2l_state_pdaf
    20. py__init_obs_l_pdaf
    21. core DA algorithm
    22. py__l2g_state_pdaf
    23. py__prepoststep_state_pdaf
    24. py__distribute_state_pdaf
    25. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from local state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_assimilate_lenkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__init_dim_obs_pdaf : Callable[[int, int], int],
                          py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__prepoststep_pdaf : Callable[[int, int, int, 
                                                           int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                          py__localize_covar_pdaf : Callable[[int, int, 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]]], tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                          py__next_observation_pdaf : Callable[[int, int, 
                                                                int, float], tuple[int, 
                                                                int, float]]
                         ) -> int:
    """Using stochastic EnKF (ensemble Kalman filter) with covariance localisation for DA  with diagonal observation error covariance matrix. This is the only scheme for covariance localisation in PDAF. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.omi_put_state_lenkf` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf (for each ensemble member
    5. py__localize_pdaf
    6. py__obs_op_pdaf (repeated to reduce storage
    7. core DA algorith
    8. py__prepoststep_state_pdaf
    9. py__distribute_state_pdaf
    10. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__localize_covar_pdaf : Callable[dim_p:int, dim_obs:int, hp_p:ndarray[tuple[dim_obs, dim_p], np.float64], hph:ndarray[tuple[dim_obs, dim_obs], np.float64]]
        Apply localization to HP and HPH^T

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_obs** : int

            --- number of observations

        * **hp_p** : ndarray[tuple[dim_obs, dim_p], np.float64]

            --- pe local part of matrix hp

        * **hph** : ndarray[tuple[dim_obs, dim_obs], np.float64]

            --- matrix hph

        **Callback Returns**

        * **hp_p** : ndarray[tuple[dim_obs, dim_p], np.float64]

            --- pe local part of matrix hp

        * **hph** : ndarray[tuple[dim_obs, dim_obs], np.float64]

            --- matrix hph


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def omi_assimilate_local (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__init_dim_obs_pdaf : Callable[[int, int], int],
                          py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__prepoststep_pdaf : Callable[[int, int, int, 
                                                           int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                          py__init_n_domains_p_pdaf : Callable[[int, int], int],
                          py__init_dim_l_pdaf : Callable[[int, int, int], int],
                          py__init_dim_obs_l_pdaf : Callable[[int, int, 
                                                              int, int], int],
                          py__g2l_state_pdaf : Callable[[int, int, int, 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__l2g_state_pdaf : Callable[[int, int, int, 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__next_observation_pdaf : Callable[[int, int, 
                                                                int, float], tuple[int, 
                                                                int, float]]
                         ) -> int:
    """It is recommended to use `pyPDAF.PDAF.localomi_assimilate` for better efficiency.Using domain localised filters for DA with diagonal observation error covariance matrix. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.omi_put_state_local` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    6. py__init_dim_l_pdaf
    7. py__init_dim_obs_l_pdaf
    8. py__g2l_state_pdaf
    9. py__init_obs_l_pdaf
    10. core DA algorithm
    11. py__l2g_state_pdaf
    12. py__prepoststep_state_pdaf
    13. py__distribute_state_pdaf
    14. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def omi_generate_obs (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_dim_obs_pdaf : Callable[[int, int], int],
                      py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__get_obs_f_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                       int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                      py__next_observation_pdaf : Callable[[int, int, int, 
                                                            float], tuple[int, 
                                                            int, float]]
                     ) -> int:
    """This function generates synthetic observations based on each member of model forecast with diagonal observation error covariance matrix. This is based on the usual implementation strategy for PDAF.
    
    The function calls `pyPDAF.PDAF.generate_obs`  and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pda
    5. py__get_obs_f_pdaf
    6. py__prepoststep_state_pdaf
    7. py__distribute_state_pdaf
    8. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__get_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f:ndarray[tuple[dim_obs_f], np.float64]]
        Provide observation vector to user

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of the full observation vector

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of synthetic observations (process-local)

        **Callback Returns**

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of synthetic observations (process-local)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def omi_put_state_3dvar (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                         py__init_dim_obs_pdaf : Callable[[int, int], int],
                         py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                         py__cvt_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                         py__cvt_adj_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                         py__obs_op_lin_pdaf : Callable[[int, int, int, 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                         py__obs_op_adj_pdaf : Callable[[int, int, int, 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                         py__prepoststep_pdaf : Callable[[int, int, int, 
                                                          int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                         outflag: int) -> int:
    """Using 3DVar for DA without post-processing and analysis distribution to forecsat with diagonal observation error covariance matrix.
    This is a deterministic filtering scheme. This function is usually used in 'flexible' parallelisation, but 3dvar is deterministic and does not require ensemble.
    A `pyPDAF.PDAF.get_state` function should be used to post-process the state vector and distribute the state vector to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_pdaf
    6. py__obs_op_lin_pdaf
    7. py__obs_op_adj_pdaf
    8. py__cvt_adj_pdaf
    9. core DA algorithm
    After the iterations: 
    10. py__cvt_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_put_state_en3dvar_estkf (py__collect_state_pdaf : Callable[[int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                 py__init_dim_obs_pdaf : Callable[[int, 
                                                                   int], int],
                                 py__obs_op_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                 py__cvt_ens_pdaf : Callable[[int, int, 
                                                              int, int, 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                 py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                 py__obs_op_lin_pdaf : Callable[[int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                 py__obs_op_adj_pdaf : Callable[[int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                 py__prepoststep_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                  int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                 outflag: int) -> int:
    """Using 3DEnVar for DA without post-processing and analysis distribution to forecsat with diagonal observation error covariance matrix.
    The background error covariance matrix is estimated by ensemble. The 3DEnVar only calculates the analysis of the ensemble mean.
    An ESTKF is used to generate ensemble perturbations. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_ens_pdaf
    6. py__obs_op_lin_pdaf
    7. py__obs_op_adj_pdaf
    8. py__cvt_adj_ens_pdaf
    9. core 3DEnVar algorithm
    After the iterations: 
    10. py__cvt_ens_pdaf
    Perform ESTKF: 11. py__init_dim_obs_pdaf
    12. py__obs_op_pdaf (for ensemble mean
    13. py__obs_op_pdaf (for each ensemble member (only relevant for adaptive forgetting factor schemes)
    14. core ESTKF algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_put_state_en3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__init_dim_obs_pdaf : Callable[[int, 
                                                                    int], int],
                                  py__obs_op_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__cvt_ens_pdaf : Callable[[int, int, 
                                                               int, int, 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__obs_op_lin_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__obs_op_adj_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__init_n_domains_p_pdaf : Callable[[int, 
                                                                        int], int],
                                  py__init_dim_l_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int], int],
                                  py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      int], int],
                                  py__g2l_state_pdaf : Callable[[int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__l2g_state_pdaf : Callable[[int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__prepoststep_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                  outflag: int) -> int:
    """It is recommended to use `pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf` for better efficiency. 
    
   
    Using 3DEnVar for DA without post-processing and analysis distribution to forecsat with diagonal observation error covariance matrix.
    The background error covariance matrix is estimated by ensemble. The 3DEnVar only calculates the analysis of the ensemble mean.
    An LESTKF is used to generate ensemble perturbations. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_ens_pdaf
    6. py__obs_op_lin_pdaf
    7. py__obs_op_adj_pdaf
    8. py__cvt_adj_ens_pdaf
    9. core DA algorithm
    After the iterations: 
    10. py__cvt_ens_pdaf
    Perform LESTKF: 
    11. py__init_n_domains_p_pdaf
    12. py__init_dim_obs_pdaf
    13. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    14. py__init_dim_l_pdaf
    15. py__init_dim_obs_l_pdaf
    16. py__g2l_state_pdaf
    17. core DA algorithm
    18. py__l2g_state_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from local state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_put_state_generate_obs (py__collect_state_pdaf : Callable[[int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__init_dim_obs_pdaf : Callable[[int, 
                                                                  int], int],
                                py__obs_op_pdaf : Callable[[int, int, int, 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__get_obs_f_pdaf : Callable[[int, int, 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__prepoststep_pdaf : Callable[[int, int, 
                                                                 int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                 int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]]]]
                               ) -> int:
    """This function generates synthetic observations based on each member of model forecast with diagonal observation error covariance matrix. This function is for the case where the ensemble size is larger than the number of processors. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pda
    5. py__get_obs_f_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__get_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f:ndarray[tuple[dim_obs_f], np.float64]]
        Provide observation vector to user

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of the full observation vector

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of synthetic observations (process-local)

        **Callback Returns**

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of synthetic observations (process-local)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def omi_put_state_global (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__init_dim_obs_pdaf : Callable[[int, int], int],
                          py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__prepoststep_pdaf : Callable[[int, int, int, 
                                                           int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]]]]
                         ) -> int:
    """Global filters for DA except for 3DVars
    without post-processing and analysis distribution to forecsat
    with diagonal observation error covariance matrix.

    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence: 
    1. py__collect_state_pdaf

    2. py__prepoststep_state_pdaf

    3. py__init_dim_obs_pdaf

    4. py__obs_op_pdaf (for ensemble mean)

    5. py__obs_op_pdaf (for each ensemble member)

    6. core DA algorithm

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def omi_put_state_hyb3dvar_estkf (py__collect_state_pdaf : Callable[[int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__init_dim_obs_pdaf : Callable[[int, 
                                                                    int], int],
                                  py__obs_op_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__cvt_ens_pdaf : Callable[[int, int, 
                                                               int, int, 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__cvt_pdaf : Callable[[int, int, int, 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__cvt_adj_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__obs_op_lin_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__obs_op_adj_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__prepoststep_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                  outflag: int) -> int:
    """Using 3DEnVar for DA without post-processing and analysis distribution to forecsat with diagonal observation error covariance matrix.
    Here, the background error covariance is hybridised by a static background error covariance, and a flow-dependent background error covariance estimated from ensemble. The 3DVar generates an ensemble mean and the ensemble perturbation is generated by
    ESTKF in this implementation. 
    
    This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_ens_pdaf
    6. py__obs_op_lin_pdaf
    7. py__obs_op_adj_pdaf
    8. py__cvt_adj_ens_pdaf
    9. core 3DEnVar algorithm
    After the iterations: 
    10. py__cvt_ens_pdaf
    Perform ESTKF: 11. py__init_dim_obs_pdaf
    12. py__obs_op_pdaf (for ensemble mean
    13. py__obs_op_pdaf (for each ensemble member
    14. core ESTKF algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply ensemble control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint ensemble control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_put_state_hyb3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__init_dim_obs_pdaf : Callable[[int, 
                                                                     int], int],
                                   py__obs_op_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__cvt_ens_pdaf : Callable[[int, int, 
                                                                int, int, 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__cvt_pdaf : Callable[[int, int, int, 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__cvt_adj_pdaf : Callable[[int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__obs_op_lin_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__obs_op_adj_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__init_n_domains_p_pdaf : Callable[[int, 
                                                                         int], int],
                                   py__init_dim_l_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int], int],
                                   py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int, 
                                                                       int], int],
                                   py__g2l_state_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__l2g_state_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__prepoststep_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                   outflag: int) -> int:
    """It is recommended to use `pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf` for better efficiency. 
    
   
    Using 3DEnVar for DA without post-processing and analysis distribution to forecsat with diagonal observation error covariance matrix.
    Here, the background error covariance is hybridised by a static background error covariance, and a flow-dependent background error covariance estimated from ensemble. The 3DVar generates an ensemble mean and the ensemble perturbation is generated by
    LESTKF in this implementation. 
    
    This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_ens_pdaf
    6. py__obs_op_lin_pdaf
    7. py__obs_op_adj_pdaf
    8. py__cvt_adj_ens_pdaf
    9. core DA algorithm
    After the iterations: 
    10. py__cvt_ens_pdaf
    Perform LESTKF: 
    11. py__init_n_domains_p_pdaf
    12. py__init_dim_obs_pdaf
    13. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    14. py__init_dim_l_pdaf
    15. py__init_dim_obs_l_pdaf
    16. py__g2l_state_pdaf (localise mean ensemble in observation space)
    17. core DA algorithm
    18. py__l2g_state_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from local state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_put_state_lenkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                         py__init_dim_obs_pdaf : Callable[[int, int], int],
                         py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                         py__prepoststep_pdaf : Callable[[int, int, int, 
                                                          int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                         py__localize_covar_pdaf : Callable[[int, int, 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]], tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]]]
                        ) -> int:
    """Using stochastic EnKF (ensemble Kalman filter) with covariance localisation for DA without post-processing and analysis distribution to forecsat with diagonal observation error covariance matrix. This is the only scheme for covariance localisation in PDAF. This is the only scheme for covariance localisation in PDAF. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf (for each ensemble member
    5. py__localize_pdaf
    6. py__obs_op_pdaf (repeated to reduce storage
    7. core DA algorith
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__localize_covar_pdaf : Callable[dim_p:int, dim_obs:int, hp_p:ndarray[tuple[dim_obs, dim_p], np.float64], hph:ndarray[tuple[dim_obs, dim_obs], np.float64]]
        Apply localization to HP and HPH^T

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_obs** : int

            --- number of observations

        * **hp_p** : ndarray[tuple[dim_obs, dim_p], np.float64]

            --- pe local part of matrix hp

        * **hph** : ndarray[tuple[dim_obs, dim_obs], np.float64]

            --- matrix hph

        **Callback Returns**

        * **hp_p** : ndarray[tuple[dim_obs, dim_p], np.float64]

            --- pe local part of matrix hp

        * **hph** : ndarray[tuple[dim_obs, dim_obs], np.float64]

            --- matrix hph



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def omi_put_state_local (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                         py__init_dim_obs_pdaf : Callable[[int, int], int],
                         py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                         py__prepoststep_pdaf : Callable[[int, int, int, 
                                                          int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                         py__init_n_domains_p_pdaf : Callable[[int, int], int],
                         py__init_dim_l_pdaf : Callable[[int, int, int], int],
                         py__init_dim_obs_l_pdaf : Callable[[int, int, 
                                                             int, int], int],
                         py__g2l_state_pdaf : Callable[[int, int, int, 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                         py__l2g_state_pdaf : Callable[[int, int, int, 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]]
                        ) -> int:
    """It is recommended to use `pyPDAF.PDAF.localomi_put_state` for better efficiency. 
    
    Using domain localised filters for DA without post-processing and analysis distribution to forecsat with diagonal observation error covariance matrix. This is a domain localisation method. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. The LESTKF is a more efficient equivalent to the LETKF. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    6. py__init_dim_l_pdaf
    7. py__init_dim_obs_l_pdaf
    8. py__g2l_state_pdaf
    9. core DA algorithm
    10. py__l2g_state_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def omi_init_obs_f_cb (step: int,dim_obs_f: int,observation_f: np.ndarray[tuple[int], np.dtype[np.float64]]
                      ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    """This function is an internal PDAF-OMI function that is used as a call-back function to initialise the observation vector. This could be used to modify the observation vector when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`.

    Parameters
    ----------
    step : int
        Current time step
    dim_obs_f : int
        Dimension of full observation vector
    observation_f : ndarray[tuple[dim_obs_f], np.float64]
        Full observation vector

    Returns
    -------
    observation_f : ndarray[tuple[dim_obs_f], np.float64]
         Full observation vector
    """
    ...

def omi_init_obsvar_cb (step: int,dim_obs_p: int,obs_p: np.ndarray[tuple[int], np.dtype[np.float64]],
                        meanvar: float) -> float:
    """This function is an internal PDAF function that is used as a call-back function to initialise the observation error variance. This could be used to modify the observation variance when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`.

    Parameters
    ----------
    step : int
        Current time step
    dim_obs_p : int
        PE-local dimension of observation vector
    obs_p : ndarray[tuple[dim_obs_p], np.float64]
        PE-local observation vector
    meanvar : float
        Mean observation error variance

    Returns
    -------
    meanvar : float
        Mean observation error variance
    """
    ...

def omi_g2l_obs_cb (domain_p: int,step: int,dim_obs_f: int,dim_obs_l: int,
                    ostate_f: np.ndarray[tuple[int], np.dtype[np.float64]],
                    ostate_l: np.ndarray[tuple[int], np.dtype[np.float64]]
                   ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    """This function is an internal PDAF-OMI function that is used as a call-back function to convert between global and local observation vectors in domain localisation.
    

    Parameters
    ----------
    domain_p : int
        Index of current local analysis domain
    step : int
        Current time step
    dim_obs_f : int
        Dimension of full PE-local observation vector
    dim_obs_l : int
        Dimension of local observation vector
    ostate_f : ndarray[tuple[dim_obs_f], np.float64]
        Full PE-local obs.ervation vector
    ostate_l : ndarray[tuple[dim_obs_l], np.float64]
        Observation vector on local domain

    Returns
    -------
    ostate_l : ndarray[tuple[dim_obs_l], np.float64]
         Observation vector on local domain
    """
    ...

def omi_init_obs_l_cb (domain_p: int,step: int,dim_obs_l: int,observation_l: np.ndarray[tuple[int], np.dtype[np.float64]]
                      ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    """This function is an internal PDAF-OMI function that is used as a call-back function to initialise local observation vector in domain localisation. This could be used to modify the observation variance when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`.

    Parameters
    ----------
    domain_p : int
        Index of current local analysis domain index
    step : int
        Current time step
    dim_obs_l : int
        Local dimension of observation vector
    observation_l : ndarray[tuple[dim_obs_l], np.float64]
        Local observation vector

    Returns
    -------
    observation_l : ndarray[tuple[dim_obs_l], np.float64]
         Local observation vector
    """
    ...

def omi_init_obsvar_l_cb (domain_p: int,step: int,dim_obs_l: int,obs_l: np.ndarray[tuple[int], np.dtype[np.float64]],
                          meanvar_l: float) -> float:
    """This function is an internal PDAF-OMI function that is used as a call-back function to initialise local observation vector in domain localisation. This could be used to modify the observation variance when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`.

    Parameters
    ----------
    domain_p : int
        Index of current local analysis domain
    step : int
        Current time step
    dim_obs_l : int
        Local dimension of observation vector
    obs_l : ndarray[tuple[dim_obs_l], np.float64]
        Local observation vector
    meanvar_l : float
        Mean local observation error variance

    Returns
    -------
    meanvar_l : float
        Mean local observation error variance
    """
    ...

def omi_prodRinvA_l_cb (domain_p: int,step: int,dim_obs_l: int,rank: int,
                        obs_l: np.ndarray[tuple[int], np.dtype[np.float64]],
                        A_l: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                        C_l: np.ndarray[tuple[int, int], np.dtype[np.float64]]
                       ) -> tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                      ]:
    """This function is an internal PDAF-OMI function that is used as a call-back function to perform the matrix multiplication inverse of local observation error covariance and a matrix A in domain localisation. This could be used to modify the observation variance when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`.

    Parameters
    ----------
    domain_p : int
        Index of current local analysis domain
    step : int
        Current time step
    dim_obs_l : int
        Dimension of local observation vector
    rank : int
        Rank of initial covariance matrix
    obs_l : ndarray[tuple[dim_obs_l], np.float64]
        Local vector of observations
    A_l : ndarray[tuple[dim_obs_l, rank], np.float64]
        Input matrix
    C_l : ndarray[tuple[dim_obs_l, rank], np.float64]
        Output matrix

    Returns
    -------
    A_l : ndarray[tuple[dim_obs_l, rank], np.float64]
         Input matrix
    C_l : ndarray[tuple[dim_obs_l, rank], np.float64]
         Output matrix
    """
    ...

def omi_likelihood_l_cb (domain_p: int,step: int,dim_obs_l: int,obs_l: np.ndarray[tuple[int], np.dtype[np.float64]],
                         resid_l: np.ndarray[tuple[int], np.dtype[np.float64]],
                         lhood_l: float) -> tuple[np.ndarray[tuple[int], np.dtype[np.float64]], float]:
    """This is an internal PDAF-OMI function that is used as a call-back function to compute the likelihood of the observation for a given ensemble member according to the observations used for the local analysis in the localized LNETF. This could be used to modify the observation variance when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`. See https://pdaf.awi.de/trac/wiki/U_likelihood_l

    Parameters
    ----------
    domain_p : int
        Current local analysis domain
    step : int
        Current time step
    dim_obs_l : int
        PE-local dimension of obs. vector
    obs_l : ndarray[tuple[dim_obs_l], np.float64]
        PE-local vector of observations
    resid_l : ndarray[tuple[dim_obs_l], np.float64]
        Input vector of residuum
    lhood_l : float
        Output vector - log likelihood

    Returns
    -------
    resid_l : ndarray[tuple[dim_obs_l], np.float64]
         Input vector of residuum
    lhood_l : float
        Output vector - log likelihood
    """
    ...

def omi_prodRinvA_cb (step: int,dim_obs_p: int,ncol: int,obs_p: np.ndarray[tuple[int], np.dtype[np.float64]],
                      A_p: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                      C_p: np.ndarray[tuple[int, int], np.dtype[np.float64]]
                     ) -> np.ndarray[tuple[int, int], np.dtype[np.float64]]:
    """This function is an internal PDAF-OMI function that is used as a call-back function to perform the matrix multiplication inverse of observation errro covariance and a matrix A. This could be used to modify the observation variance when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`.

    Parameters
    ----------
    step : int
        Current time step
    dim_obs_p : int
        Dimension of PE-local observation vector
    ncol : int
        Number of columns in A_p and C_p
    obs_p : ndarray[tuple[dim_obs_p], np.float64]
        PE-local vector of observations
    A_p : ndarray[tuple[dim_obs_p, ncol], np.float64]
        Input matrix
    C_p : ndarray[tuple[dim_obs_p, ncol], np.float64]
        Output matrix

    Returns
    -------
    C_p : ndarray[tuple[dim_obs_p, ncol], np.float64]
         Output matrix
    """
    ...

def omi_likelihood_cb (step: int,dim_obs: int,obs: np.ndarray[tuple[int], np.dtype[np.float64]],
                       resid: np.ndarray[tuple[int], np.dtype[np.float64]],
                       lhood: float) -> float:
    """This is an internal PDAF-OMI function that is used as a call-back function to compute the likelihood of the observation for a given ensemble member according to the observations used for the local analysis for NETF or particle filter. This could be used to modify the observation variance when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`. See https://pdaf.awi.de/trac/wiki/U_likelihood_l

    Parameters
    ----------
    step : int
        Current time step
    dim_obs : int
        PE-local dimension of obs. vector
    obs : ndarray[tuple[dim_obs], np.float64]
        PE-local vector of observations
    resid : ndarray[tuple[dim_obs], np.float64]
        Input vector of residuum
    lhood : float
        Output vector - log likelihood

    Returns
    -------
    lhood : float
        Output vector - log likelihood
    """
    ...

def omi_add_obs_error_cb (step: int,dim_obs_p: int,C_p: np.ndarray[tuple[int, int], np.dtype[np.float64]]
                         ) -> np.ndarray[tuple[int, int], np.dtype[np.float64]]:
    """This is an internal PDAF-OMI function that is used as a call-back function to add random observation error to stochastic EnKF. This could be used to modify the observation variance when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`. See https://pdaf.awi.de/trac/wiki/U_likelihood_l

    Parameters
    ----------
    step : int
        Current time step
    dim_obs_p : int
        Dimension of PE-local observation vector
    C_p : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]
        Matrix to which R is added

    Returns
    -------
    C_p : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]
         Matrix to which R is added
    """
    ...

def omi_init_obscovar_cb (step: int,dim_obs: int,dim_obs_p: int,covar: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                          m_state_p: np.ndarray[tuple[int], np.dtype[np.float64]],
                          isdiag: bool) -> tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], bool]:
    """This is an internal PDAF-OMI function that is used as a call-back function to construct a full observation error covariance matrix used only in stochastic EnKF. This could be used to modify the observation variance when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`.

    Parameters
    ----------
    step : int
        Current time step
    dim_obs : int
        Dimension of observation vector
    dim_obs_p : int
        PE-local dimension of obs. vector
    covar : ndarray[tuple[dim_obs, dim_obs], np.float64]
        Observation error covar. matrix
    m_state_p : ndarray[tuple[dim_obs_p], np.float64]
        Observation vector
    isdiag : bool
        Whether matrix R is diagonal

    Returns
    -------
    covar : ndarray[tuple[dim_obs, dim_obs], np.float64]
         Observation error covar. matrix
    isdiag : bool
        Whether matrix R is diagonal
    """
    ...

def omi_init_obserr_f_cb (step: int,dim_obs_f: int,obs_f: np.ndarray[tuple[int], np.dtype[np.float64]],
                          obserr_f: np.ndarray[tuple[int], np.dtype[np.float64]]
                         ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    """This is an internal PDAF-OMI function that is used as a call-back function to construct a full observation error covariance matrix used only in stochastic EnKF. This could be used to modify the observation variance when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`.

    Parameters
    ----------
    step : int
        Current time step
    dim_obs_f : int
        Full dimension of observation vector
    obs_f : ndarray[tuple[dim_obs_f], np.float64]
        Full observation vector
    obserr_f : ndarray[tuple[dim_obs_f], np.float64]
        Full observation error stddev

    Returns
    -------
    obserr_f : ndarray[tuple[dim_obs_f], np.float64]
         Full observation error stddev
    """
    ...

def omi_prodRinvA_hyb_l_cb (domain_p: int,step: int,dim_obs_l: int,rank: int,
                            obs_l: np.ndarray[tuple[int], np.dtype[np.float64]],
                            alpha: float,A_l: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                            C_l: np.ndarray[tuple[int, int], np.dtype[np.float64]]
                           ) -> tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                          ]:
    """This function is an internal PDAF-OMI function that is used as a call-back function to perform the matrix multiplication inverse of local observation error covariance and a matrix A in LKNETF. This could be used to modify the observation variance when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`.

    Parameters
    ----------
    domain_p : int
        Index of current local analysis domain
    step : int
        Current time step
    dim_obs_l : int
        Dimension of local observation vector
    rank : int
        Rank of initial covariance matrix
    obs_l : ndarray[tuple[dim_obs_l], np.float64]
        Local vector of observations
    alpha : float
        Hybrid weight
    A_l : ndarray[tuple[dim_obs_l, rank], np.float64]
        Input matrix
    C_l : ndarray[tuple[dim_obs_l, rank], np.float64]
        Output matrix

    Returns
    -------
    A_l : ndarray[tuple[dim_obs_l, rank], np.float64]
         Input matrix
    C_l : ndarray[tuple[dim_obs_l, rank], np.float64]
         Output matrix
    """
    ...

def omi_likelihood_hyb_l_cb (domain_p: int,step: int,dim_obs_l: int,obs_l: np.ndarray[tuple[int], np.dtype[np.float64]],
                             resid_l: np.ndarray[tuple[int], np.dtype[np.float64]],
                             alpha: float,lhood_l: float) -> tuple[np.ndarray[tuple[int], np.dtype[np.float64]], float]:
    """This is an internal PDAF-OMI function that is used as a call-back function to compute the likelihood of the observation for a given ensemble member according to the observations used for the local analysis in LKNETF. This could be used to modify the observation variance when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`. See https://pdaf.awi.de/trac/wiki/U_likelihood_l

    Parameters
    ----------
    domain_p : int
        Current local analysis domain
    step : int
        Current time step
    dim_obs_l : int
        PE-local dimension of obs. vector
    obs_l : ndarray[tuple[dim_obs_l], np.float64]
        PE-local vector of observations
    resid_l : ndarray[tuple[dim_obs_l], np.float64]
        Input vector of residuum
    alpha : float
        Hybrid weight
    lhood_l : float
        Output vector - log likelihood

    Returns
    -------
    resid_l : ndarray[tuple[dim_obs_l], np.float64]
         Input vector of residuum
    lhood_l : float
        Output vector - log likelihood
    """
    ...

def omi_obsstats_l (screen: int) -> None:
    """This function is called in the update routine of local filters and write statistics on locally used and excluded observations.

    Parameters
    ----------
    screen : int
        Verbosity flag
    """
    ...

def omi_weights_l (verbose: int,locweight: int,cradius: np.ndarray[tuple[int], np.dtype[np.float64]],
                   sradius: np.ndarray[tuple[int], np.dtype[np.float64]],
                   matA: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                   ivar_obs_l: np.ndarray[tuple[int], np.dtype[np.float64]],
                   dist_l: np.ndarray[tuple[int], np.dtype[np.float64]]
                  ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    """This function computes a weight vector according to the distances of observations from the local analysis domain with a vector of localisation radius.

    Parameters
    ----------
    verbose : int
        Verbosity flag
    locweight : int
        Types of localization function 0) unit weight; 1) exponential; 2) 5-th order polynomial; 3) 5-th order polynomial with regulatioin using mean variance; 4) 5-th order polynomial with regulatioin using variance of single observation point;
    cradius : ndarray[tuple[nobs_l], np.float64]
        Vector of localization cut-off radii; observation weight=0 if distance > cradius
    sradius : ndarray[tuple[nobs_l], np.float64]
        Vector of support radii of localization function. It has no impact if locweight=0; 	weight = exp(-d / sradius) if locweight=1; weight = 0 if d >= sradius else f(sradius, distance) if locweight in [2,3,4].
    matA : ndarray[tuple[nobs_l, ncols], np.float64]
        
    ivar_obs_l : ndarray[tuple[nobs_l], np.float64]
        Local vector of inverse obs. variances (nobs_l)
    dist_l : ndarray[tuple[nobs_l], np.float64]
        Local vector of obs. distances (nobs_l)

    Returns
    -------
    weight_l : ndarray[tuple[nobs_l], np.float64]
         Output: vector of weights
    """
    ...

def omi_weights_l_sgnl (verbose: int,locweight: int,cradius: float,sradius: float,
                        matA: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                        ivar_obs_l: np.ndarray[tuple[int], np.dtype[np.float64]],
                        dist_l: np.ndarray[tuple[int], np.dtype[np.float64]]
                       ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    """This function computes a weight vector according to the distances of observations from the local analysis domain with given localisation radius.

    Parameters
    ----------
    verbose : int
        Verbosity flag
    locweight : int
        Types of localization function 0) unit weight; 1) exponential; 2) 5-th order polynomial; 3) 5-th order polynomial with regulatioin using mean variance; 4) 5-th order polynomial with regulatioin using variance of single observation point;
    cradius : float
        Vector of localization cut-off radii; observation weight=0 if distance > cradius
    sradius : float
        Vector of support radii of localization function. It has no impact if locweight=0; 	weight = exp(-d / sradius) if locweight=1; weight = 0 if d >= sradius else f(sradius, distance) if locweight in [2,3,4].
    matA : ndarray[tuple[nobs_l, ncols], np.float64]
        
    ivar_obs_l : ndarray[tuple[nobs_l], np.float64]
        Local vector of inverse obs. variances (nobs_l)
    dist_l : ndarray[tuple[nobs_l], np.float64]
        Local vector of obs. distances (nobs_l)

    Returns
    -------
    weight_l : ndarray[tuple[nobs_l], np.float64]
         Output: vector of weights
    """
    ...

def omi_check_error (flag: int) -> int:
    """This function returns the value of the PDAF-OMI internal error flag.

    Parameters
    ----------
    flag : int
        Error flag

    Returns
    -------
    flag : int
        Error flag
    """
    ...

def omi_gather_obsdims () -> None:
    """This function gathers the information about the full dimension of each observation type in each process-local subdomain.

    """
    ...

def omi_obsstats (screen: int) -> None:
    """The function is called in the update routine of global filters and writes statistics on used and excluded observations.

    Parameters
    ----------
    screen : int
        Verbosity flag
    """
    ...

def omi_init_dim_obs_l_iso (i_obs: int,coords_l: np.ndarray[tuple[int], np.dtype[np.float64]],
                            locweight: int,cradius: float,sradius: float,
                            cnt_obs_l: int) -> int:
    """The function has to be called in `init_dim_obs_l_OBTYPE` in each observation module if a domain-localized filter (LESTKF/LETKF/LNETF/LSEIK)is used. It initialises the local observation information for PDAF-OMI for a single local analysis domain. This is used for isotropic localisation where the localisation radius is the same in all directions.

    Parameters
    ----------
    i_obs : int
        index of observation type
    coords_l : ndarray[tuple[ncoord], np.float64]
        Coordinates of current analysis domain
    locweight : int
        Types of localization function 0) unit weight; 1) exponential; 2) 5-th order polynomial; 3) 5-th order polynomial with regulatioin using mean variance; 4) 5-th order polynomial with regulatioin using variance of single observation point;
    cradius : float
        Vector of localization cut-off radii; observation weight=0 if distance > cradius
    sradius : float
        Vector of support radii of localization function. It has no impact if locweight=0; 	weight = exp(-d / sradius) if locweight=1; weight = 0 if d >= sradius else f(sradius, distance) if locweight in [2,3,4].
    cnt_obs_l : int
        Local dimension of current observation vector

    Returns
    -------
    cnt_obs_l : int
        Local dimension of current observation vector
    """
    ...

def omi_init_dim_obs_l_noniso (i_obs: int,coords_l: np.ndarray[tuple[int], np.dtype[np.float64]],
                               locweight: int,cradius: np.ndarray[tuple[int], np.dtype[np.float64]],
                               sradius: np.ndarray[tuple[int], np.dtype[np.float64]],
                               cnt_obs_l: int) -> int:
    """The function has to be called in `init_dim_obs_l_OBTYPE` in each observation module if a domain-localized filter (LESTKF/LETKF/LNETF/LSEIK)is used. It initialises the local observation information for PDAF-OMI for a single local analysis domain. This is used for non-isotropic localisation where the localisation radius is different in each direction. See https://pdaf.awi.de/trac/wiki/OMI_observation_modules#init_dim_obs_l_OBSTYPE and https://pdaf.awi.de/trac/wiki/PDAFomi_init_dim_obs_l#Settingsfornon-isotropiclocalization.

    Parameters
    ----------
    i_obs : int
        index of observation type
    coords_l : ndarray[tuple[ncoord], np.float64]
        Coordinates of current analysis domain
    locweight : int
        Types of localization function 0) unit weight; 1) exponential; 2) 5-th order polynomial; 3) 5-th order polynomial with regulatioin using mean variance; 4) 5-th order polynomial with regulatioin using variance of single observation point;
    cradius : ndarray[tuple[ncoord], np.float64]
        Vector of localization cut-off radii; observation weight=0 if distance > cradius
    sradius : ndarray[tuple[ncoord], np.float64]
        Vector of support radii of localization function. It has no impact if locweight=0; 	weight = exp(-d / sradius) if locweight=1; weight = 0 if d >= sradius else f(sradius, distance) if locweight in [2,3,4].
    cnt_obs_l : int
        Local dimension of current observation vector

    Returns
    -------
    cnt_obs_l : int
        Local dimension of current observation vector
    """
    ...

def omi_init_dim_obs_l_noniso_locweights (i_obs: int,coords_l: np.ndarray[tuple[int], np.dtype[np.float64]],
                                          locweights: np.ndarray[tuple[int], np.dtype[np.intc]],
                                          cradius: np.ndarray[tuple[int], np.dtype[np.float64]],
                                          sradius: np.ndarray[tuple[int], np.dtype[np.float64]],
                                          cnt_obs_l: int) -> int:
    """The function has to be called in `init_dim_obs_l_OBTYPE` in each observation module if a domain-localized filter (LESTKF/LETKF/LNETF/LSEIK)is used. It initialises the local observation information for PDAF-OMI for a single local analysis domain. This is used for non-isotropic localisation and different weight functions for horizontal and vertical directions. See https://pdaf.awi.de/trac/wiki/OMI_observation_modules#init_dim_obs_l_OBSTYPE and https://pdaf.awi.de/trac/wiki/PDAFomi_init_dim_obs_l#Settingdifferentweightfunctsforhorizontalandverticaldirections.

    Parameters
    ----------
    i_obs : int
        index of observation type
    coords_l : ndarray[tuple[ncoord], np.float64]
        Coordinates of current analysis domain
    locweights : ndarray[tuple[2], np.intc]
        Types of localization function 0) unit weight; 1) exponential; 2) 5-th order polynomial; 3) 5-th order polynomial with regulatioin using mean variance; 4) 5-th order polynomial with regulatioin using variance of single observation point; The first dimension is horizontal weight function and the second is the vertical function
    cradius : ndarray[tuple[ncoord], np.float64]
        Vector of localization cut-off radii for each dimension; observation weight=0 if distance > cradius
    sradius : ndarray[tuple[ncoord], np.float64]
        Vector of support radii of localization function for each dimension. It has no impact if locweight=0; 	weight = exp(-d / sradius) if locweight=1; weight = 0 if d >= sradius else f(sradius, distance) if locweight in [2,3,4].
    cnt_obs_l : int
        Local dimension of current observation vector

    Returns
    -------
    cnt_obs_l : int
        Local dimension of current observation vector
    """
    ...

def omi_localize_covar_iso (i_obs: int,locweight: int,cradius: float,sradius: float,
                            coords: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                            HP: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                            HPH: np.ndarray[tuple[int, int], np.dtype[np.float64]]
                           ) -> tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                          ]:
    """The function has to be called in `localize_covar_OBTYPE` in each observation module. It applies the covariance localisation in stochastic EnKF. This is used for isotropic localisation where the localisation radius is the same in all directions. See https://pdaf.awi.de/trac/wiki/PDAFomi_localize_covar

    Parameters
    ----------
    i_obs : int
        index of observation type
    locweight : int
        Types of localization function 0) unit weight; 1) exponential; 2) 5-th order polynomial; 3) 5-th order polynomial with regulatioin using mean variance; 4) 5-th order polynomial with regulatioin using variance of single observation point;
    cradius : float
        Vector of localization cut-off radii; observation weight=0 if distance > cradius
    sradius : float
        Vector of support radii of localization function. It has no impact if locweight=0; 	weight = exp(-d / sradius) if locweight=1; weight = 0 if d >= sradius else f(sradius, distance) if locweight in [2,3,4].
    coords : ndarray[tuple[ncoord, dim_p], np.float64]
        Coordinates of state vector elements
    HP : ndarray[tuple[dim_obs, dim_p], np.float64]
        Matrix HP, dimension (nobs, dim)
    HPH : ndarray[tuple[dim_obs, dim_obs], np.float64]
        Matrix HPH, dimension (nobs, nobs)

    Returns
    -------
    HP : ndarray[tuple[dim_obs, dim_p], np.float64]
         Matrix HP, dimension (nobs, dim)
    HPH : ndarray[tuple[dim_obs, dim_obs], np.float64]
         Matrix HPH, dimension (nobs, nobs)
    """
    ...

def omi_localize_covar_noniso (i_obs: int,locweight: int,cradius: np.ndarray[tuple[int], np.dtype[np.float64]],
                               sradius: np.ndarray[tuple[int], np.dtype[np.float64]],
                               coords: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                               HP: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                               HPH: np.ndarray[tuple[int, int], np.dtype[np.float64]]
                              ) -> tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                             ]:
    """The function has to be called in `localize_covar_OBTYPE` in each observation module. It applies the covariance localisation in stochastic EnKF. This is used for non-isotropic localisation where the localisation radius is different. See https://pdaf.awi.de/trac/wiki/PDAFomi_localize_covar

    Parameters
    ----------
    i_obs : int
        Data type with full observation
    locweight : int
        Types of localization function 0) unit weight; 1) exponential; 2) 5-th order polynomial; 3) 5-th order polynomial with regulatioin using mean variance; 4) 5-th order polynomial with regulatioin using variance of single observation point;
    cradius : ndarray[tuple[ncoord], np.float64]
        Vector of localization cut-off radii for each dimension; observation weight=0 if distance > cradius
    sradius : ndarray[tuple[ncoord], np.float64]
        Vector of support radii of localization function for each dimension. It has no impact if locweight=0; 	weight = exp(-d / sradius) if locweight=1; weight = 0 if d >= sradius else f(sradius, distance) if locweight in [2,3,4].
    coords : ndarray[tuple[ncoord, dim_p], np.float64]
        Coordinates of state vector elements
    HP : ndarray[tuple[dim_obs, dim_p], np.float64]
        Matrix HP, dimension (nobs, dim)
    HPH : ndarray[tuple[dim_obs, dim_obs], np.float64]
        Matrix HPH, dimension (nobs, nobs)

    Returns
    -------
    HP : ndarray[tuple[dim_obs, dim_p], np.float64]
         Matrix HP, dimension (nobs, dim)
    HPH : ndarray[tuple[dim_obs, dim_obs], np.float64]
         Matrix HPH, dimension (nobs, nobs)
    """
    ...

def omi_localize_covar_noniso_locweights (i_obs: int,locweights: np.ndarray[tuple[int], np.dtype[np.intc]],
                                          cradius: np.ndarray[tuple[int], np.dtype[np.float64]],
                                          sradius: np.ndarray[tuple[int], np.dtype[np.float64]],
                                          coords: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                                          HP: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                                          HPH: np.ndarray[tuple[int, int], np.dtype[np.float64]]
                                         ) -> tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                        ]:
    """The function has to be called in `localize_covar_OBTYPE` in each observation module. It applies the covariance localisation in stochastic EnKF. This is used for non-isotropic localisation with different weight function for horizontal and vertical directions. where the localisation radius is different. See https://pdaf.awi.de/trac/wiki/PDAFomi_localize_covar

    Parameters
    ----------
    i_obs : int
        index of observation type
    locweights : ndarray[tuple[2], np.intc]
        Types of localization function 0) unit weight; 1) exponential; 2) 5-th order polynomial; 3) 5-th order polynomial with regulatioin using mean variance; 4) 5-th order polynomial with regulatioin using variance of single observation point; The first dimension is horizontal weight function and the second is the vertical function
    cradius : ndarray[tuple[ncoord], np.float64]
        Vector of localization cut-off radii for each dimension; observation weight=0 if distance > cradius
    sradius : ndarray[tuple[ncoord], np.float64]
        Vector of support radii of localization function for each dimension. It has no impact if locweight=0; 	weight = exp(-d / sradius) if locweight=1; weight = 0 if d >= sradius else f(sradius, distance) if locweight in [2,3,4].
    coords : ndarray[tuple[ncoord, dim_p], np.float64]
        Coordinates of state vector elements
    HP : ndarray[tuple[dim_obs, dim_p], np.float64]
        Matrix HP, dimension (nobs, dim)
    HPH : ndarray[tuple[dim_obs, dim_obs], np.float64]
        Matrix HPH, dimension (nobs, nobs)

    Returns
    -------
    HP : ndarray[tuple[dim_obs, dim_p], np.float64]
         Matrix HP, dimension (nobs, dim)
    HPH : ndarray[tuple[dim_obs, dim_obs], np.float64]
         Matrix HPH, dimension (nobs, nobs)
    """
    ...

def omi_omit_by_inno_l_cb (domain_p: int,dim_obs_l: int,resid_l: np.ndarray[tuple[int], np.dtype[np.float64]],
                           obs_l: np.ndarray[tuple[int], np.dtype[np.float64]]
                          ) -> tuple[np.ndarray[tuple[int], np.dtype[np.float64]], np.ndarray[tuple[int], np.dtype[np.float64]], 
                         ]:
    """The function is called during the analysis step on each local analysis domain. It checks the size of the innovation and sets the observation error to a high value if the squared innovation exceeds a limit relative to the observation error variance.This function is an internal PDAF-OMI function that is used as a call-back function. This could be used to modify the observation vector when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`.

    Parameters
    ----------
    domain_p : int
        Current local analysis domain
    dim_obs_l : int
        PE-local dimension of obs. vector
    resid_l : ndarray[tuple[dim_obs_l], np.float64]
        Input vector of residuum
    obs_l : ndarray[tuple[dim_obs_l], np.float64]
        Input vector of local observations

    Returns
    -------
    resid_l : ndarray[tuple[dim_obs_l], np.float64]
         Input vector of residuum
    obs_l : ndarray[tuple[dim_obs_l], np.float64]
         Input vector of local observations
    """
    ...

def omi_omit_by_inno_cb (dim_obs_f: int,resid_f: np.ndarray[tuple[int], np.dtype[np.float64]],
                         obs_f: np.ndarray[tuple[int], np.dtype[np.float64]]
                        ) -> tuple[np.ndarray[tuple[int], np.dtype[np.float64]], np.ndarray[tuple[int], np.dtype[np.float64]], 
                       ]:
    """The function is called during the analysis step of a global filter. It checks the size of the innovation and sets the observation error to a high value if the squared innovation exceeds a limit relative to the observation error variance.This function is called in the update routine of local filters and write statistics on locally used and excluded observations.This function is an internal PDAF-OMI function that is used as a call-back function. This could be used to modify the observation vector when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`.

    Parameters
    ----------
    dim_obs_f : int
        Full dimension of obs. vector
    resid_f : ndarray[tuple[dim_obs_f], np.float64]
        Input vector of residuum
    obs_f : ndarray[tuple[dim_obs_f], np.float64]
        Input vector of full observations

    Returns
    -------
    resid_f : ndarray[tuple[dim_obs_f], np.float64]
         Input vector of residuum
    obs_f : ndarray[tuple[dim_obs_f], np.float64]
         Input vector of full observations
    """
    ...

def omi_set_localization (i_obs: int,cradius: float,sradius: float,locweight: int
                         ) -> int:
    """This function sets localization information (locweight, cradius, sradius) in OMI, and allocates local arrays for cradius and sradius, i.e. `obs_l`. This variant is for isotropic localization. The function is used by user-supplied implementations of `pyPDAF.PDAF.omi_init_dim_obs_l_iso`. 

    Parameters
    ----------
    i_obs : int
        Observation type index
    cradius : float
        Vector of localization cut-off radii; observation weight=0 if distance > cradius
    sradius : float
        Vector of support radii of localization function. It has no impact if locweight=0; 	weight = exp(-d / sradius) if locweight=1; weight = 0 if d >= sradius else f(sradius, distance) if locweight in [2,3,4].
    locweight : int
        Types of localization function 0) unit weight; 1) exponential; 2) 5-th order polynomial; 3) 5-th order polynomial with regulatioin using mean variance; 4) 5-th order polynomial with regulatioin using variance of single observation point;

    Returns
    -------
    i_obs : int
        Observation type index
    """
    ...

def omi_set_localization_noniso (i_obs: int,cradius: np.ndarray[tuple[int], np.dtype[np.float64]],
                                 sradius: np.ndarray[tuple[int], np.dtype[np.float64]],
                                 locweight: int,locweight_v: int) -> int:
    """This function sets localization information (locweight, cradius, sradius) in OMI, and allocates local arrays for cradius and sradius, i.e. `obs_l`. This variant is for non-isotropic localization. The function is used by user-supplied implementations of `pyPDAF.PDAF.omi_init_dim_obs_l_noniso`. 

    Parameters
    ----------
    i_obs : int
        Type of observation index
    cradius : ndarray[tuple[nradii], np.float64]
        Vector of localization cut-off radii; observation weight=0 if distance > cradius
    sradius : ndarray[tuple[nradii], np.float64]
        Vector of support radii of localization function. It has no impact if locweight=0; 	weight = exp(-d / sradius) if locweight=1; weight = 0 if d >= sradius else f(sradius, distance) if locweight in [2,3,4].
    locweight : int
        Types of localization function 0) unit weight; 1) exponential; 2) 5-th order polynomial; 3) 5-th order polynomial with regulatioin using mean variance; 4) 5-th order polynomial with regulatioin using variance of single observation point;
    locweight_v : int
        Type of localization function in vertical direction (only for nradii=3)

    Returns
    -------
    i_obs : int
        Type of observation index
    """
    ...

def omi_set_dim_obs_l (i_obs: int,cnt_obs_l_all: int,cnt_obs_l: int) -> tuple[int, int, int]:
    """This function initialises number local observations. It also returns number of local observations up to the current observation type. It is used by a user-supplied implementations of `pyPDAF.PDAF.omi_init_dim_obs_l_xxx`.

    Parameters
    ----------
    i_obs : int
        Type of observation index
    cnt_obs_l_all : int
        Local dimension of observation vector over all obs. types
    cnt_obs_l : int
        Local dimension of single observation type vector

    Returns
    -------
    i_obs : int
        Type of observation index
    cnt_obs_l_all : int
        Local dimension of observation vector over all obs. types
    cnt_obs_l : int
        Local dimension of single observation type vector
    """
    ...

def omi_store_obs_l_index (i_obs: int,idx: int,id_obs_l: int,distance: float,
                           cradius_l: float,sradius_l: float) -> int:
    """This function stores the mapping index between the global and local observation vectors, the distance and the cradius and sradius for a single observations in OMI. This variant is for non-factorised localisation. The function is used by user-supplied implementations of `pyPDAF.PDAF.omi_init_dim_obs_l_iso` or `pyPDAF.PDAF.omi_init_dim_obs_l_noniso`. 

    Parameters
    ----------
    i_obs : int
        Type of observation index
    idx : int
        < Element of local observation array to be filled
    id_obs_l : int
        < Index of local observation in full observation array
    distance : float
        < Distance between local analysis domain and observation
    cradius_l : float
        < cut-off radius for this local observation; observation weight=0 if distance > cradius (directional radius in case of non-isotropic localization)
    sradius_l : float
        < support radius for this local observation (directional radius in case of non-isotropic localization) Vector of support radii of localization function. It has no impact if locweight=0; 	weight = exp(-d / sradius) if locweight=1; weight = 0 if d >= sradius else f(sradius, distance) if locweight in [2,3,4].

    Returns
    -------
    i_obs : int
        Type of observation index
    """
    ...

def omi_store_obs_l_index_vdist (i_obs: int,idx: int,id_obs_l: int,distance: float,
                                 cradius_l: float,sradius_l: float,vdist: float
                                ) -> int:
    """This function stores the mapping index between the global and local observation vectors, the distance and the cradius and sradius for a single observations in OMI. This variant is for 2D+1D factorised localisation.
    The function is used by user-supplied implementations of `pyPDAF.PDAF.omi_init_dim_obs_l_noniso_locweights`.

    Parameters
    ----------
    i_obs : int
        Type of observation index
    idx : int
        < Element of local observation array to be filled
    id_obs_l : int
        < Index of local observation in full observation array
    distance : float
        < Distance between local analysis domain and observation
    cradius_l : float
        < cut-off radius for this local observation (directional radius in case of non-isotropic localization)
    sradius_l : float
        < support radius for this local observation (directional radius in case of non-isotropic localization)
    vdist : float
        < support radius in vertical direction for 2+1D factorized localization

    Returns
    -------
    i_obs : int
        Type of observation index
    """
    ...

def omi_assimilate_3dvar_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__distribute_state_pdaf : Callable[[int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__init_dim_obs_pdaf : Callable[[int, 
                                                                     int], int],
                                   py__obs_op_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__prodRinvA_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                   py__cvt_pdaf : Callable[[int, int, int, 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__cvt_adj_pdaf : Callable[[int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__obs_op_lin_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__obs_op_adj_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__prepoststep_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                   py__next_observation_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         float], tuple[int, 
                                                                         int, 
                                                                         float]],
                                   outflag: int) -> int:
    """Using 3DVar for DA with non-diagonal observation error covariance matrix.
    This is a deterministic filtering scheme. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.omi_put_state_3dvar_nondiagR`
    and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_pdaf
    6. py__obs_op_lin_pdaf
    7. py__prodRinvA_pdaf
    8. py__obs_op_adj_pdaf
    9. py__cvt_adj_pdaf
    10. core DA algorithm
    After the iterations: 
    11. py__cvt_pdaf
    12. py__prepoststep_state_pdaf
    13. py__distribute_state_pdaf
    14. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_assimilate_en3dvar_estkf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__distribute_state_pdaf : Callable[[int, 
                                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__init_dim_obs_pdaf : Callable[[int, 
                                                                             int], int],
                                           py__obs_op_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int, 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__prodRinvA_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                           py__cvt_ens_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        int, 
                                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            int, 
                                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__obs_op_lin_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__obs_op_adj_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__prepoststep_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            int, 
                                                                            int, 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                            int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                           py__next_observation_pdaf : Callable[[int, 
                                                                                 int, 
                                                                                 int, 
                                                                                 float], tuple[int, 
                                                                                 int, 
                                                                                 float]],
                                           outflag: int) -> int:
    """Using 3DEnVar for DA with non-diagonal observation error covariance matrix.
    The background error covariance matrix is estimated by ensemble. The 3DEnVar only calculates the analysis of the ensemble mean.
    An ESTKF is used to generate ensemble perturbations. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.omi_put_state_en3dvar_estkf_nondiagR`
    and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_ens_pdaf
    6. py__obs_op_lin_pdaf
    7. py__prodRinvA_pdaf
    8. py__obs_op_adj_pdaf
    9. py__cvt_adj_ens_pdaf
    10. core 3DEnVar algorithm
    After the iterations: 
    11. py__cvt_ens_pdaf
    Perform ESTKF: 12. py__init_dim_obs_pdaf
    13. py__obs_op_pdaf (for ensemble mean
    14. py__obs_op_pdaf (for each ensemble member
    15. py__prodRinvA_pdaf
    16. core ESTKF algorithm
    17. py__prepoststep_state_pdaf
    18. py__distribute_state_pdaf
    19. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_assimilate_en3dvar_lestkf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__distribute_state_pdaf : Callable[[int, 
                                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__init_dim_obs_pdaf : Callable[[int, 
                                                                              int], int],
                                            py__obs_op_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__prodRinvA_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                            py__cvt_ens_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                             int, 
                                                                             int, 
                                                                             int, 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__obs_op_lin_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__obs_op_adj_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__prodRinvA_l_pdaf : Callable[[int, 
                                                                             int, 
                                                                             int, 
                                                                             int, 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                            py__init_n_domains_p_pdaf : Callable[[int, 
                                                                                  int], int],
                                            py__init_dim_l_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int], int],
                                            py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                                int, 
                                                                                int, 
                                                                                int], int],
                                            py__g2l_state_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                           int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__l2g_state_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                           int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__prepoststep_pdaf : Callable[[int, 
                                                                             int, 
                                                                             int, 
                                                                             int, 
                                                                             int, 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                             int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                            py__next_observation_pdaf : Callable[[int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  float], tuple[int, 
                                                                                  int, 
                                                                                  float]],
                                            outflag: int) -> int:
    """It is recommended to use local module for fewer user-supplied functions and improved efficiency.
    I.e., `pyPDAF.PDAF.localomi_assimilate_en3dvar_lestkf_nondiagR`. 
    
    
    Using 3DEnVar for DA with non-diagonal observation error covariance matrix.
    The background error covariance matrix is estimated by ensemble. The 3DEnVar only calculates the analysis of the ensemble mean.
    An LESTKF is used to generate ensemble perturbations. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.omi_put_state_en3dvar_lestkf_nondiagR`
    and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_ens_pdaf
    6. py__obs_op_lin_pdaf
    7. py__prodRinvA_pdaf
    8. py__obs_op_adj_pdaf
    9. py__cvt_adj_ens_pdaf
    10. core DA algorithm
    After the iterations: 
    11. py__cvt_ens_pdaf
    Perform LESTKF: 
    12. py__init_n_domains_p_pdaf
    13. py__init_dim_obs_pdaf
    14. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    15. py__init_dim_l_pdaf
    16. py__init_dim_obs_l_pdaf
    17. py__g2l_state_pdaf (localise mean ensemble in observation space)
    18. py__prodRinvA_l_pdaf
    19. core DA algorithm
    20. py__l2g_state_pdaf
    21. py__prepoststep_state_pdaf
    22. py__distribute_state_pdaf
    23. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A for local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from local state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_assimilate_enkf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__distribute_state_pdaf : Callable[[int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__init_dim_obs_pdaf : Callable[[int, 
                                                                    int], int],
                                  py__obs_op_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__add_obs_err_pdaf : Callable[[int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                  py__init_obs_covar_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      float, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      bool], tuple[float, 
                                                                      bool]],
                                  py__prepoststep_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                  py__next_observation_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        float], tuple[int, 
                                                                        int, 
                                                                        float]]
                                 ) -> int:
    """Using stochastic EnKF (ensemble Kalman filter) for DA with non-diagonal observation error covariance matrix. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.omi_put_state_enkf_nondiagR` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf (for ensemble mean
    5. py__add_obs_err_pdaf
    6. py__init_obscovar_pdaf
    7. py__obs_op_pdaf (for each ensemble member
    8. core DA algorithm
    9. py__prepoststep_state_pdaf
    10. py__distribute_state_pdaf
    11. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__add_obs_err_pdaf : Callable[step:int, dim_obs_p:int, C_p:ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]]
        Add obs error covariance R to HPH in EnKF

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Dimension of observation vector

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            --- Matrix to that observation covariance R is added

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            --- Matrix to that observation covariance R is added


    py__init_obs_covar_pdaf : Callable[step:int, dim_obs:int, dim_obs_p:int, covar:float, obs_p:ndarray[tuple[dim_obs_p], np.float64], isdiag:bool]
        Initialize obs. error cov. matrix R in EnKF

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs** : int

            --- Global size of observation vector

        * **dim_obs_p** : int

            --- Size of process-local observation vector

        * **covar** : float

            --- Observation error covariance matrix

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Process-local vector of observations

        * **isdiag** : bool

            --- 

        **Callback Returns**

        * **covar**:float

            --- Observation error covariance matrix

        * **isdiag**:bool

            --- 


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_assimilate_global_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__distribute_state_pdaf : Callable[[int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__init_dim_obs_pdaf : Callable[[int, 
                                                                      int], int],
                                    py__obs_op_pdaf : Callable[[int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__prodRinvA_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                    py__prepoststep_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                    py__next_observation_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          float], tuple[int, 
                                                                          int, 
                                                                          float]]
                                   ) -> int:
    """Global DA filters for DA except for 3DVars
    with non-diagonal observation error covariance matrix.

    The function is a combination of :func:`pyPDAF.PDAF.omi_put_state_global_nondiagR`
    and :func:`pyPDAF.PDAF.get_state`.

    This function should be called at each model time step.

    The user-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf (for ensemble mean)
        5. py__obs_op_pdaf (for each ensemble member)
        6. py__prodRinvA_pdaf
        7. core DA algorithm
        8. py__prepoststep_state_pdaf
        9. py__distribute_state_pdaf
        10. py__next_observation_pdaf

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_assimilate_hyb3dvar_estkf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__distribute_state_pdaf : Callable[[int, 
                                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__init_dim_obs_pdaf : Callable[[int, 
                                                                              int], int],
                                            py__obs_op_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__prodRinvA_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                            py__cvt_ens_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                             int, 
                                                                             int, 
                                                                             int, 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__cvt_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__cvt_adj_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__obs_op_lin_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__obs_op_adj_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__prepoststep_pdaf : Callable[[int, 
                                                                             int, 
                                                                             int, 
                                                                             int, 
                                                                             int, 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                             int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                            py__next_observation_pdaf : Callable[[int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  float], tuple[int, 
                                                                                  int, 
                                                                                  float]],
                                            outflag: int) -> int:
    """Using Hybrid 3DEnVar for DA with non-diagonal observation error covariance matrix.
    Here, the background error covariance is hybridised by a static background error covariance, and a flow-dependent background error covariance estimated from ensemble. The 3DVar generates an ensemble mean and the ensemble perturbation is generated by
    ESTKF in this implementation. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.omi_put_state_hyb3dvar_estkf_nondiagR`
    and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_pdaf
    6. py__cvt_ens_pdaf
    7. py__obs_op_lin_pdaf
    8. py__prodRinvA_pdaf
    9. py__obs_op_adj_pdaf
    10. py__cvt_adj_pdaf
    11. py__cvt_adj_ens_pdaf
    12. core 3DEnVar algorithm
    After the iterations: 
    13. py__cvt_pdaf
    14. py__cvt_ens_pdaf
    Perform ESTKF: 15. py__init_dim_obs_pdaf
    16. py__obs_op_pdaf (for ensemble mean
    17. py__obs_op_pdaf (for each ensemble member
    18. py__prodRinvA_pdaf
    19. core ESTKF algorithm
    20. py__prepoststep_state_pdaf
    21. py__distribute_state_pdaf
    22. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply ensemble control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint ensemble control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_assimilate_hyb3dvar_lestkf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                             py__distribute_state_pdaf : Callable[[int, 
                                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                             py__init_dim_obs_pdaf : Callable[[int, 
                                                                               int], int],
                                             py__obs_op_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                             py__prodRinvA_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                             py__cvt_ens_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          int, 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                             py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                              int, 
                                                                              int, 
                                                                              int, 
                                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                             py__cvt_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                             py__cvt_adj_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                             py__obs_op_lin_pdaf : Callable[[int, 
                                                                             int, 
                                                                             int, 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                             py__obs_op_adj_pdaf : Callable[[int, 
                                                                             int, 
                                                                             int, 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                             py__prodRinvA_l_pdaf : Callable[[int, 
                                                                              int, 
                                                                              int, 
                                                                              int, 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                             py__init_n_domains_p_pdaf : Callable[[int, 
                                                                                   int], int],
                                             py__init_dim_l_pdaf : Callable[[int, 
                                                                             int, 
                                                                             int], int],
                                             py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                                 int, 
                                                                                 int, 
                                                                                 int], int],
                                             py__g2l_state_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                            int, 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                             py__l2g_state_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                            int, 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                             py__prepoststep_pdaf : Callable[[int, 
                                                                              int, 
                                                                              int, 
                                                                              int, 
                                                                              int, 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                              int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                             py__next_observation_pdaf : Callable[[int, 
                                                                                   int, 
                                                                                   int, 
                                                                                   float], tuple[int, 
                                                                                   int, 
                                                                                   float]],
                                             outflag: int) -> int:
    """It is recommended to use local module for fewer user-supplied functions and improved efficiency.
    I.e., `pyPDAF.PDAF.localomi_assimilate_hyb3dvar_lestkf_nondiagR`. 
    
    
    Using Hybrid 3DEnVar for DA with non-diagonal observation error covariance matrix.
    Here, the background error covariance is hybridised by a static background error covariance, and a flow-dependent background error covariance estimated from ensemble. The 3DVar generates an ensemble mean and the ensemble perturbation is generated by
    LESTKF in this implementation. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.omi_put_state_hyb3dvar_lestkf_nondiagR`
    and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_pdaf
    6. py__cvt_ens_pdaf
    7. py__obs_op_lin_pdaf
    8. py__prodRinvA_pdaf
    9. py__obs_op_adj_pdaf
    10. py__cvt_adj_pdaf
    11. py__cvt_adj_ens_pdaf
    12. core DA algorithm
    After the iterations: 
    13. py__cvt_pdaf
    14. py__cvt_ens_pdaf
    Perform LESTKF: 
    15. py__init_n_domains_p_pdaf
    16. py__init_dim_obs_pdaf
    17. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    18. py__init_dim_l_pdaf
    19. py__init_dim_obs_l_pdaf
    20. py__g2l_state_pdaf
    21. py__init_obs_l_pdaf
    22. py__prodRinvA_l_pdaf
    23. core DA algorithm
    24. py__l2g_state_pdaf
    25. py__prepoststep_state_pdaf
    26. py__distribute_state_pdaf
    27. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A for local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from local state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_assimilate_lenkf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__distribute_state_pdaf : Callable[[int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__init_dim_obs_pdaf : Callable[[int, 
                                                                     int], int],
                                   py__obs_op_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__prepoststep_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                   py__localize_covar_pdaf : Callable[[int, 
                                                                       int, 
                                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]], tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                   py__add_obs_err_pdaf : Callable[[int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                   py__init_obs_covar_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int, 
                                                                       float, 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                       bool], tuple[float, 
                                                                       bool]],
                                   py__next_observation_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         float], tuple[int, 
                                                                         int, 
                                                                         float]]
                                  ) -> int:
    """Using stochastic EnKF (ensemble Kalman filter) with covariance localisation for DA with non-diagonal observation error covariance matrix. This is the only scheme for covariance localisation in PDAF. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.omi_put_state_lenkf_nondiagR` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf (for each ensemble member
    5. py__localize_pdaf
    6. py__add_obs_err_pdaf
    7. py__init_obscovar_pdaf
    8. py__obs_op_pdaf (repeated to reduce storage
    9. core DA algorith
    10. py__prepoststep_state_pdaf
    11. py__distribute_state_pdaf
    12. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__localize_covar_pdaf : Callable[dim_p:int, dim_obs:int, hp_p:ndarray[tuple[dim_obs, dim_p], np.float64], hph:ndarray[tuple[dim_obs, dim_obs], np.float64]]
        Apply localization to HP and HPH^T

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_obs** : int

            --- number of observations

        * **hp_p** : ndarray[tuple[dim_obs, dim_p], np.float64]

            --- pe local part of matrix hp

        * **hph** : ndarray[tuple[dim_obs, dim_obs], np.float64]

            --- matrix hph

        **Callback Returns**

        * **hp_p** : ndarray[tuple[dim_obs, dim_p], np.float64]

            --- pe local part of matrix hp

        * **hph** : ndarray[tuple[dim_obs, dim_obs], np.float64]

            --- matrix hph


    py__add_obs_err_pdaf : Callable[step:int, dim_obs_p:int, C_p:ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]]
        Add obs error covariance R to HPH in EnKF

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Dimension of observation vector

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            --- Matrix to that observation covariance R is added

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            --- Matrix to that observation covariance R is added


    py__init_obs_covar_pdaf : Callable[step:int, dim_obs:int, dim_obs_p:int, covar:float, obs_p:ndarray[tuple[dim_obs_p], np.float64], isdiag:bool]
        Initialize obs. error cov. matrix R in EnKF

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs** : int

            --- Global size of observation vector

        * **dim_obs_p** : int

            --- Size of process-local observation vector

        * **covar** : float

            --- Observation error covariance matrix

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Process-local vector of observations

        * **isdiag** : bool

            --- 

        **Callback Returns**

        * **covar**:float

            --- Observation error covariance matrix

        * **isdiag**:bool

            --- 


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_assimilate_lknetf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__distribute_state_pdaf : Callable[[int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__init_dim_obs_pdaf : Callable[[int, 
                                                                      int], int],
                                    py__obs_op_pdaf : Callable[[int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__prepoststep_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                    py__init_n_domains_p_pdaf : Callable[[int, 
                                                                          int], int],
                                    py__init_dim_l_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int], int],
                                    py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        int], int],
                                    py__prodRinvA_l_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                    py__prodRinvA_hyb_l_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         float, 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                    py__likelihood_l_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      float], float],
                                    py__likelihood_hyb_l_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          float, 
                                                                          float], float],
                                    py__g2l_state_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__l2g_state_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__next_observation_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          float], tuple[int, 
                                                                          int, 
                                                                          float]]
                                   ) -> int:
    """It is recommended to use local module for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_assimilate_lknetf_nondiagR`. 
    Using LKNETF for DA with non-diagonal observation error covariance matrix. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.omi_put_state_lknetf_nondiagR` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    6. py__init_dim_l_pdaf
    7. py__init_dim_obs_l_pdaf
    8. py__g2l_state_pdaf
    9. py__prodRinvA_pdaf
    10. py__likelihood_l_pdaf
    11. core DA algorithm
    12. py__l2g_state_pdaf
    13. py__obs_op_pdaf (only called with `HKN` and `HNK` options called for each ensemble member
    14. py__likelihood_hyb_l_pda
    15. py__prodRinvA_hyb_l_pdaf
    16. py__prepoststep_state_pdaf
    17. py__distribute_state_pdaf
    18. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__prodRinvA_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, dim_ens:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, A_l:ndarray[tuple[dim_obs_l, dim_ens], np.float64], C_l:ndarray[tuple[dim_obs_l, dim_ens], np.float64]]
        Provide product R^-1 A on local analysis domain with hybrid weight

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **dim_ens** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **gamma** : float

            --- Hybrid weight provided by PDAF

        * **A_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Output matrix


    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- nput vector holding the local residual

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    py__likelihood_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, likely_l:float]
        Compute likelihood with hybrid weight

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Input vector holding the local residual

        * **gamma** : float

            --- Hybrid weight provided by PDAF

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_assimilate_lnetf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__distribute_state_pdaf : Callable[[int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__init_dim_obs_pdaf : Callable[[int, 
                                                                     int], int],
                                   py__obs_op_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__prepoststep_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                   py__init_n_domains_p_pdaf : Callable[[int, 
                                                                         int], int],
                                   py__init_dim_l_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int], int],
                                   py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int, 
                                                                       int], int],
                                   py__likelihood_l_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     float], float],
                                   py__g2l_state_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__l2g_state_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__next_observation_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         float], tuple[int, 
                                                                         int, 
                                                                         float]]
                                  ) -> int:
    """It is recommended to use local module for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_assimilate_lnetf_nondiagR`. 
    Using LNETF for DA with non-diagonal observation error covariance matrix. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.omi_put_state_lnetf_nondiagR` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    6. py__init_dim_l_pdaf
    7. py__init_dim_obs_l_pdaf
    8. py__g2l_state_pdaf
    9. py__likelihood_l_pdaf
    10. core DA algorithm
    11. py__l2g_state_pdaf
    12. py__prepoststep_state_pdaf
    13. py__distribute_state_pdaf
    14. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- nput vector holding the local residual

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_assimilate_local_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__distribute_state_pdaf : Callable[[int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__init_dim_obs_pdaf : Callable[[int, 
                                                                     int], int],
                                   py__obs_op_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__prepoststep_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                   py__init_n_domains_p_pdaf : Callable[[int, 
                                                                         int], int],
                                   py__init_dim_l_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int], int],
                                   py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int, 
                                                                       int], int],
                                   py__prodRinvA_l_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                   py__g2l_state_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__l2g_state_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__next_observation_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         float], tuple[int, 
                                                                         int, 
                                                                         float]]
                                  ) -> int:
    """It is recommended to use local module for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_assimilate_nondiagR`. 
    Using domain localised filters for DA with non-diagonal observation error covariance matrix. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.omi_put_state_local_nondiagR` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    6. py__init_dim_l_pdaf
    7. py__init_dim_obs_l_pdaf
    8. py__g2l_state_pdaf
    9. py__init_obs_l_pdaf
    10. py__prodRinvA_l_pdaf
    11. core DA algorithm
    12. py__l2g_state_pdaf
    13. py__prepoststep_state_pdaf
    14. py__distribute_state_pdaf
    15. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_assimilate_nonlin_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__distribute_state_pdaf : Callable[[int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__init_dim_obs_pdaf : Callable[[int, 
                                                                      int], int],
                                    py__obs_op_pdaf : Callable[[int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__likelihood_pdaf : Callable[[int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    float], float],
                                    py__prepoststep_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                    py__next_observation_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          float], tuple[int, 
                                                                          int, 
                                                                          float]]
                                   ) -> int:
    """Using nonlinear filters (particle filter, NETF) for DA except for 3DVars with non-diagonal observation error covariance matrix.
    The function is a combination of `pyPDAF.PDAF.put_state_nonlin_nondiagR` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function This function should be called at each model time step. 
    
    in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf (for ensemble mean
    5. py__obs_op_pdaf (for each ensemble member
    6. py__likelihood_pdaf
    7. core DA algorithm
    8. py__prepoststep_state_pdaf
    9. py__distribute_state_pdaf
    10. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__likelihood_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], resid:ndarray[tuple[dim_obs_p], np.float64], likely:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **resid** : ndarray[tuple[dim_obs_p], np.float64]

            --- Input vector holding the residual

        * **likely** : float

            --- Output value of the likelihood

        **Callback Returns**

        * **likely**:float

            --- Output value of the likelihood


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_put_state_3dvar_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__init_dim_obs_pdaf : Callable[[int, 
                                                                    int], int],
                                  py__obs_op_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__prodRinvA_pdaf : Callable[[int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                  py__cvt_pdaf : Callable[[int, int, int, 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__cvt_adj_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__obs_op_lin_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__obs_op_adj_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__prepoststep_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                  outflag: int) -> int:
    """Using 3DVar for DA with non-diagonal observation error covariance matrix
    without post-processing and analysis distribution to forecsat without OMI. This is a deterministic filtering scheme. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_pdaf
    6. py__obs_op_lin_pdaf
    7. py__prodRinvA_pdaf
    8. py__obs_op_adj_pdaf
    9. py__cvt_adj_pdaf
    10. core DA algorithm
    After the iterations: 
    11. py__cvt_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_put_state_en3dvar_estkf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                          py__init_dim_obs_pdaf : Callable[[int, 
                                                                            int], int],
                                          py__obs_op_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                          py__prodRinvA_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                          py__cvt_ens_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int, 
                                                                       int, 
                                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                          py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           int, 
                                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                          py__obs_op_lin_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                          py__obs_op_adj_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                          py__prepoststep_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           int, 
                                                                           int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                           int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                          outflag: int) -> int:
    """Using 3DEnVar for DA with non-diagonal observation error covariance matrix
    without post-processing and analysis distribution to forecsat without OMI. The background error covariance matrix is estimated by ensemble. The 3DEnVar only calculates the analysis of the ensemble mean.
    An ESTKF is used to generate ensemble perturbations. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_ens_pdaf
    6. py__obs_op_lin_pdaf
    7. py__prodRinvA_pdaf
    8. py__obs_op_adj_pdaf
    9. py__cvt_adj_ens_pdaf
    10. core 3DEnVar algorithm
    After the iterations: 
    11. py__cvt_ens_pdaf
    Perform ESTKF: 12. py__init_dim_obs_pdaf
    13. py__obs_op_pdaf (for ensemble mean
    14. py__obs_op_pdaf (for each ensemble member
    15. py__prodRinvA_pdaf
    16. core ESTKF algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_put_state_en3dvar_lestkf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__init_dim_obs_pdaf : Callable[[int, 
                                                                             int], int],
                                           py__obs_op_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int, 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__prodRinvA_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                           py__cvt_ens_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        int, 
                                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            int, 
                                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__obs_op_lin_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__obs_op_adj_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__prodRinvA_l_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            int, 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                           py__init_n_domains_p_pdaf : Callable[[int, 
                                                                                 int], int],
                                           py__init_dim_l_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int], int],
                                           py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                               int, 
                                                                               int, 
                                                                               int], int],
                                           py__g2l_state_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__l2g_state_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__prepoststep_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            int, 
                                                                            int, 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                            int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                           outflag: int) -> int:
    """It is recommended to use local module for fewer user-supplied functions and improved efficiency.
    I.e., `pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf_nondiagR`. 
    
    
    Using 3DEnVar for DA with non-diagonal observation error covariance matrix
    without post-processing and analysis distribution to forecsat without OMI. The background error covariance matrix is estimated by ensemble. The 3DEnVar only calculates the analysis of the ensemble mean.
    An LESTKF is used to generate ensemble perturbations. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_ens_pdaf
    6. py__obs_op_lin_pdaf
    7. py__prodRinvA_pdaf
    8. py__obs_op_adj_pdaf
    9. py__cvt_adj_ens_pdaf
    10. core DA algorithm
    After the iterations: 
    11. py__cvt_ens_pdaf
    Perform LESTKF: 
    12. py__init_n_domains_p_pdaf
    13. py__init_dim_obs_pdaf
    14. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    15. py__init_dim_l_pdaf
    16. py__init_dim_obs_l_pdaf
    17. py__g2l_state_pdaf (localise mean ensemble in observation space)
    18. py__prodRinvA_l_pdaf
    19. core DA algorithm
    20. py__l2g_state_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A for local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from local state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_put_state_enkf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                 py__init_dim_obs_pdaf : Callable[[int, 
                                                                   int], int],
                                 py__obs_op_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                 py__add_obs_err_pdaf : Callable[[int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                 py__init_obs_covar_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     float, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     bool], tuple[float, 
                                                                     bool]],
                                 py__prepoststep_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                  int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]]]]
                                ) -> int:
    """Using stochastic EnKF (ensemble Kalman filter) for DA with non-diagonal observation error covariance matrix. without post-processing and analysis distribution to forecsat without OMI. This function should be called at each model time step. 
    
    This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf (for ensemble mean
    5. py__add_obs_err_pdaf
    6. py__init_obscovar_pdaf
    7. py__obs_op_pdaf (for each ensemble member
    8. core DA algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__add_obs_err_pdaf : Callable[step:int, dim_obs_p:int, C_p:ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]]
        Add obs error covariance R to HPH in EnKF

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Dimension of observation vector

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            --- Matrix to that observation covariance R is added

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            --- Matrix to that observation covariance R is added


    py__init_obs_covar_pdaf : Callable[step:int, dim_obs:int, dim_obs_p:int, covar:float, obs_p:ndarray[tuple[dim_obs_p], np.float64], isdiag:bool]
        Initialize obs. error cov. matrix R in EnKF

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs** : int

            --- Global size of observation vector

        * **dim_obs_p** : int

            --- Size of process-local observation vector

        * **covar** : float

            --- Observation error covariance matrix

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Process-local vector of observations

        * **isdiag** : bool

            --- 

        **Callback Returns**

        * **covar**:float

            --- Observation error covariance matrix

        * **isdiag**:bool

            --- 


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble



    Returns
    -------
    outflag : int
        
    """
    ...

def omi_put_state_global_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__init_dim_obs_pdaf : Callable[[int, 
                                                                     int], int],
                                   py__obs_op_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__prodRinvA_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                   py__prepoststep_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]]]
                                  ) -> int:
    """Global filters for DA except for 3DVars
    with non-diagonal observation error covariance matrix
    without post-processing and analysis distribution to forecsat.

    This function is usually used in 'flexible' parallelisation
    where the ensemble size is larger than the available number of processes.

    This function should be called at each model time step.

    A :func:`pyPDAF.PDAF.get_state` function is typically
    used afterwards to post-process and distribute the ensemble
    to the model after this function.

    This function should be called at each model time step.

    The function executes the user-supplied function
    in the following sequence:

    1. py__collect_state_pdaf

    2. py__prepoststep_state_pdaf

    3. py__init_dim_obs_pdaf

    4. py__obs_op_pdaf (for ensemble mean)

    5. py__obs_op_pdaf (for each ensemble member)

    6. py__prodRinvA_pdaf

    7. core DA algorithm

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_put_state_hyb3dvar_estkf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__init_dim_obs_pdaf : Callable[[int, 
                                                                             int], int],
                                           py__obs_op_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int, 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__prodRinvA_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                           py__cvt_ens_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        int, 
                                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            int, 
                                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__cvt_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__cvt_adj_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__obs_op_lin_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__obs_op_adj_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__prepoststep_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            int, 
                                                                            int, 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                            int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                           outflag: int) -> int:
    """Using Hybrid 3DEnVar for DA with non-diagonal observation error covariance matrix
    without post-processing and analysis distribution to forecsat without OMI. Here, the background error covariance is hybridised by a static background error covariance, and a flow-dependent background error covariance estimated from ensemble. The 3DVar generates an ensemble mean and the ensemble perturbation is generated by
    ESTKF in this implementation. This function should be called at each model time step. 
    
    This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_pdaf
    6. py__cvt_ens_pdaf
    7. py__obs_op_lin_pdaf
    8. py__prodRinvA_pdaf
    9. py__obs_op_adj_pdaf
    10. py__cvt_adj_pdaf
    11. py__cvt_adj_ens_pdaf
    12. core 3DEnVar algorithm
    After the iterations: 
    13. py__cvt_pdaf
    14. py__cvt_ens_pdaf
    Perform ESTKF: 15. py__init_dim_obs_pdaf
    16. py__obs_op_pdaf (for ensemble mean
    17. py__obs_op_pdaf (for each ensemble member
    18. py__prodRinvA_pdaf
    19. core ESTKF algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply ensemble control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint ensemble control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_put_state_hyb3dvar_lestkf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__init_dim_obs_pdaf : Callable[[int, 
                                                                              int], int],
                                            py__obs_op_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__prodRinvA_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                            py__cvt_ens_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                             int, 
                                                                             int, 
                                                                             int, 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__cvt_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__cvt_adj_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__obs_op_lin_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__obs_op_adj_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__prodRinvA_l_pdaf : Callable[[int, 
                                                                             int, 
                                                                             int, 
                                                                             int, 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                            py__init_n_domains_p_pdaf : Callable[[int, 
                                                                                  int], int],
                                            py__init_dim_l_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int], int],
                                            py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                                int, 
                                                                                int, 
                                                                                int], int],
                                            py__g2l_state_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                           int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__l2g_state_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                           int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__prepoststep_pdaf : Callable[[int, 
                                                                             int, 
                                                                             int, 
                                                                             int, 
                                                                             int, 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                             int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                            outflag: int) -> int:
    """It is recommended to use local module for fewer user-supplied functions and improved efficiency.
    I.e., `pyPDAF.PDAF.localomi_assimilate_hyb3dvar_lestkf_nondiagR`. 
    
    
    Using Hybrid 3DEnVar for DA with non-diagonal observation error covariance matrix
    without post-processing and analysis distribution to forecsat without OMI. Here, the background error covariance is hybridised by a static background error covariance, and a flow-dependent background error covariance estimated from ensemble. The 3DVar generates an ensemble mean and the ensemble perturbation is generated by
    LESTKF in this implementation. This function should be called at each model time step. 
    
    This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_pdaf
    6. py__cvt_ens_pdaf
    7. py__obs_op_lin_pdaf
    8. py__prodRinvA_pdaf
    9. py__obs_op_adj_pdaf
    10. py__cvt_adj_pdaf
    11. py__cvt_adj_ens_pdaf
    12. core DA algorithm
    After the iterations: 
    13. py__cvt_pdaf
    14. py__cvt_ens_pdaf
    Perform LESTKF: 
    15. py__init_n_domains_p_pdaf
    16. py__init_dim_obs_pdaf
    17. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    18. py__init_dim_l_pdaf
    19. py__init_dim_obs_l_pdaf
    20. py__g2l_state_pdaf
    21. py__init_obs_l_pdaf
    22. py__prodRinvA_l_pdaf
    23. core DA algorithm
    24. py__l2g_state_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A for analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from local state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_put_state_lenkf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__init_dim_obs_pdaf : Callable[[int, 
                                                                    int], int],
                                  py__obs_op_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__prepoststep_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                  py__localize_covar_pdaf : Callable[[int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]], tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                  py__add_obs_err_pdaf : Callable[[int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                  py__init_obs_covar_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      float, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      bool], tuple[float, 
                                                                      bool]]
                                 ) -> int:
    """Using stochastic EnKF (ensemble Kalman filter) with covariance localisation for DA with non-diagonal observation error covariance matrix without post-processing and analysis distribution to forecsat without OMI. This is the only scheme for covariance localisation in PDAF. This function should be called at each model time step. 
    
    This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf (for each ensemble member
    5. py__localize_pdaf
    6. py__add_obs_err_pdaf
    7. py__init_obscovar_pdaf
    8. py__obs_op_pdaf (repeated to reduce storage
    9. core DA algorith
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__localize_covar_pdaf : Callable[dim_p:int, dim_obs:int, hp_p:ndarray[tuple[dim_obs, dim_p], np.float64], hph:ndarray[tuple[dim_obs, dim_obs], np.float64]]
        Apply localization to HP and HPH^T

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_obs** : int

            --- number of observations

        * **hp_p** : ndarray[tuple[dim_obs, dim_p], np.float64]

            --- pe local part of matrix hp

        * **hph** : ndarray[tuple[dim_obs, dim_obs], np.float64]

            --- matrix hph

        **Callback Returns**

        * **hp_p** : ndarray[tuple[dim_obs, dim_p], np.float64]

            --- pe local part of matrix hp

        * **hph** : ndarray[tuple[dim_obs, dim_obs], np.float64]

            --- matrix hph


    py__add_obs_err_pdaf : Callable[step:int, dim_obs_p:int, C_p:ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]]
        Add obs error covariance R to HPH in EnKF

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Dimension of observation vector

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            --- Matrix to that observation covariance R is added

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            --- Matrix to that observation covariance R is added


    py__init_obs_covar_pdaf : Callable[step:int, dim_obs:int, dim_obs_p:int, covar:float, obs_p:ndarray[tuple[dim_obs_p], np.float64], isdiag:bool]
        Initialize obs. error cov. matrix R in EnKF

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs** : int

            --- Global size of observation vector

        * **dim_obs_p** : int

            --- Size of process-local observation vector

        * **covar** : float

            --- Observation error covariance matrix

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Process-local vector of observations

        * **isdiag** : bool

            --- 

        **Callback Returns**

        * **covar**:float

            --- Observation error covariance matrix

        * **isdiag**:bool

            --- 



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_put_state_lknetf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__init_dim_obs_pdaf : Callable[[int, 
                                                                     int], int],
                                   py__obs_op_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__prepoststep_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                   py__init_n_domains_p_pdaf : Callable[[int, 
                                                                         int], int],
                                   py__init_dim_l_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int], int],
                                   py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int, 
                                                                       int], int],
                                   py__prodRinvA_l_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                   py__prodRinvA_hyb_l_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        float, 
                                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                   py__likelihood_l_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     float], float],
                                   py__likelihood_hyb_l_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         float, 
                                                                         float], float],
                                   py__g2l_state_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__l2g_state_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]]
                                  ) -> int:
    """It is recommended to use local module for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_assimilate_lknetf_nondiagR`. 
    Using LKNETF for DA with non-diagonal observation error covariance matrix without post-processing and analysis distribution to forecsat without OMI. This function should be called at each model time step. 
    
    This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    6. py__init_dim_l_pdaf
    7. py__init_dim_obs_l_pdaf
    8. py__g2l_state_pdaf
    9. py__prodRinvA_pdaf
    10. py__likelihood_l_pdaf
    11. core DA algorithm
    12. py__l2g_state_pdaf
    13. py__obs_op_pdaf (only called with `HKN` and `HNK` options called for each ensemble member
    14. py__likelihood_hyb_l_pda
    15. py__prodRinvA_hyb_l_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__prodRinvA_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, dim_ens:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, A_l:ndarray[tuple[dim_obs_l, dim_ens], np.float64], C_l:ndarray[tuple[dim_obs_l, dim_ens], np.float64]]
        Provide product R^-1 A on local analysis domain with hybrid weight

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **dim_ens** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **gamma** : float

            --- Hybrid weight provided by PDAF

        * **A_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Output matrix


    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- nput vector holding the local residual

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    py__likelihood_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, likely_l:float]
        Compute likelihood with hybrid weight

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Input vector holding the local residual

        * **gamma** : float

            --- Hybrid weight provided by PDAF

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_put_state_lnetf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__init_dim_obs_pdaf : Callable[[int, 
                                                                    int], int],
                                  py__obs_op_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__prepoststep_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                  py__init_n_domains_p_pdaf : Callable[[int, 
                                                                        int], int],
                                  py__init_dim_l_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int], int],
                                  py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      int], int],
                                  py__likelihood_l_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    float], float],
                                  py__g2l_state_pdaf : Callable[[int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__l2g_state_pdaf : Callable[[int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]]
                                 ) -> int:
    """It is recommended to use local module for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_assimilate_lnetf_nondiagR`. 
    Using LNETF for DA with non-diagonal observation error covariance matrix without post-processing and analysis distribution to forecsat without OMI. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.omi_put_state_lnetf_nondiagR` This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    6. py__init_dim_l_pdaf
    7. py__init_dim_obs_l_pdaf
    8. py__g2l_state_pdaf
    9. py__likelihood_l_pdaf
    10. core DA algorithm
    11. py__l2g_state_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- nput vector holding the local residual

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_put_state_local_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__init_dim_obs_pdaf : Callable[[int, 
                                                                    int], int],
                                  py__obs_op_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__prepoststep_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                  py__init_n_domains_p_pdaf : Callable[[int, 
                                                                        int], int],
                                  py__init_dim_l_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int], int],
                                  py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      int], int],
                                  py__prodRinvA_l_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                  py__g2l_state_pdaf : Callable[[int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__l2g_state_pdaf : Callable[[int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]]
                                 ) -> int:
    """It is recommended to use local module for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_assimilate_nondiagR`. 
    Using domain localised filters for DA with non-diagonal observation error covariance matrix without post-processing and analysis distribution to forecsat without OMI. This function should be called at each model time step. 
    
    This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    6. py__init_dim_l_pdaf
    7. py__init_dim_obs_l_pdaf
    8. py__g2l_state_pdaf
    9. py__init_obs_l_pdaf
    10. py__prodRinvA_l_pdaf
    11. core DA algorithm
    12. py__l2g_state_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_put_state_nonlin_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__init_dim_obs_pdaf : Callable[[int, 
                                                                     int], int],
                                   py__obs_op_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__likelihood_pdaf : Callable[[int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   float], float],
                                   py__prepoststep_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]]]
                                  ) -> int:
    """Using nonlinear filters (particle filter, NETF) for DA except for 3DVars with non-diagonal observation error covariance matrix
    without post-processing and analysis distribution to forecsat without OMI. This function should be called at each model time step. 
    
    This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf (for ensemble mean
    5. py__obs_op_pdaf (for each ensemble member
    6. py__likelihood_pdaf
    7. core DA algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__likelihood_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], resid:ndarray[tuple[dim_obs_p], np.float64], likely:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **resid** : ndarray[tuple[dim_obs_p], np.float64]

            --- Input vector holding the residual

        * **likely** : float

            --- Output value of the likelihood

        **Callback Returns**

        * **likely**:float

            --- Output value of the likelihood


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_set_indices (map: np.ndarray[tuple[int], np.dtype[np.intc]]) -> None:
    """Set index vector to map local state vector to global state vectors. This is called in the user-supplied function `py__init_dim_l_pdaf`.

    Parameters
    ----------
    map : ndarray[tuple[dim_l], np.intc]
        Index array for mapping between local and global state vector
    """
    ...

def local_set_increment_weights (weights: np.ndarray[tuple[int], np.dtype[np.float64]]
                                ) -> None:
    """This function initialises a PDAF_internal local array of increment weights. The weights are applied in in PDAF_local_l2g_cb where the local state vector
    is weighted by given weights. These can e.g. be used to apply a vertical localisation.

    Parameters
    ----------
    weights : ndarray[tuple[dim_l], np.float64]
        Weights array
    """
    ...

def local_clear_increment_weights () -> None:
    """This function deallocates the local increment weight vector in `pyPDAF.PDAF.local_set_increment_weights` if it is allocated

    """
    ...

def local_g2l_cb (step: int,domain_p: int,dim_p: int,state_p: np.ndarray[tuple[int], np.dtype[np.float64]],
                  dim_l: int,state_l: np.ndarray[tuple[int], np.dtype[np.float64]]
                 ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    """Project a global to a local state vector for the localized filters.
    This is the full callback function to be used internally. The mapping is done using the index vector id_lstate_in_pstate that is initialised in `pyPDAF.PDAF.local_set_indices`.

    Parameters
    ----------
    step : int
        Current time step
    domain_p : int
        Current local analysis domain
    dim_p : int
        PE-local full state dimension
    state_p : ndarray[tuple[dim_p], np.float64]
        PE-local full state vector
    dim_l : int
        Local state dimension
    state_l : ndarray[tuple[dim_l], np.float64]
        State vector on local analysis domain

    Returns
    -------
    state_l : ndarray[tuple[dim_l], np.float64]
         State vector on local analysis domain
    """
    ...

def local_l2g_cb (step: int,domain_p: int,dim_l: int,state_l: np.ndarray[tuple[int], np.dtype[np.float64]],
                  dim_p: int,state_p: np.ndarray[tuple[int], np.dtype[np.float64]]
                 ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    """Initialise elements of a global state vector from a local state vector.
    This is the full callback function to be used internally. The mapping is done using the index vector `id_lstate_in_pstate` that is initialised in `pyPDAF.PDAF.local_set_indices`. 
    
    To exclude any element of the local state vector from the initialisationone can set the corresponding index value to 0.

    Parameters
    ----------
    step : int
        Current time step
    domain_p : int
        Current local analysis domain
    dim_l : int
        Local state dimension
    state_l : ndarray[tuple[dim_l], np.float64]
        State vector on local analysis domain
    dim_p : int
        PE-local full state dimension
    state_p : ndarray[tuple[dim_p], np.float64]
        PE-local full state vector

    Returns
    -------
    state_p : ndarray[tuple[dim_p], np.float64]
         PE-local full state vector
    """
    ...

def localomi_assimilate (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                         py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                         py__init_dim_obs_pdaf : Callable[[int, int], int],
                         py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                         py__prepoststep_pdaf : Callable[[int, int, int, 
                                                          int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                         py__init_n_domains_p_pdaf : Callable[[int, int], int],
                         py__init_dim_l_pdaf : Callable[[int, int, int], int],
                         py__init_dim_obs_l_pdaf : Callable[[int, int, 
                                                             int, int], int],
                         py__next_observation_pdaf : Callable[[int, int, 
                                                               int, float], tuple[int, 
                                                               int, float]],
                         outflag: int) -> int:
    """Using domain localised filters for DA with diagonal observation error covariance matrix. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.localomi_put_state` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    6. py__init_dim_l_pdaf
    7. py__init_dim_obs_l_pdaf
    8. py__init_obs_l_pdaf
    9. core DA algorithm
    10. py__prepoststep_state_pdaf
    11. py__distribute_state_pdaf
    12. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_assimilate_en3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__distribute_state_pdaf : Callable[[int, 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__init_dim_obs_pdaf : Callable[[int, 
                                                                          int], int],
                                        py__obs_op_f_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__cvt_ens_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__obs_op_lin_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__obs_op_adj_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__init_n_domains_p_pdaf : Callable[[int, 
                                                                              int], int],
                                        py__init_dim_l_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int], int],
                                        py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            int], int],
                                        py__prepoststep_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                        py__next_observation_pdaf : Callable[[int, 
                                                                              int, 
                                                                              int, 
                                                                              float], tuple[int, 
                                                                              int, 
                                                                              float]],
                                        outflag: int) -> int:
    """Using 3DEnVar for DA with diagonal observation error covariance matrix.
    The background error covariance matrix is estimated by ensemble. The 3DEnVar only calculates the analysis of the ensemble mean.
    An LESTKF is used to generate ensemble perturbations. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf`
    and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_ens_pdaf
    6. py__obs_op_lin_pdaf
    7. py__obs_op_adj_pdaf
    8. py__cvt_adj_ens_pdaf
    9. core DA algorithm
    After the iterations: 
    10. py__cvt_ens_pdaf
    Perform LESTKF: 
    11. py__init_n_domains_p_pdaf
    12. py__init_dim_obs_pdaf
    13. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    14. py__init_dim_l_pdaf
    15. py__init_dim_obs_l_pdaf (localise mean ensemble in observation space)
    16. core DA algorithm
    17. py__prepoststep_state_pdaf
    18. py__distribute_state_pdaf
    19. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_assimilate_en3dvar_lestkf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__distribute_state_pdaf : Callable[[int, 
                                                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__init_dim_obs_pdaf : Callable[[int, 
                                                                                   int], int],
                                                 py__obs_op_pdaf : Callable[[int, 
                                                                             int, 
                                                                             int, 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__prodRinvA_pdaf : Callable[[int, 
                                                                                int, 
                                                                                int, 
                                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                                 py__cvt_ens_pdaf : Callable[[int, 
                                                                              int, 
                                                                              int, 
                                                                              int, 
                                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__obs_op_lin_pdaf : Callable[[int, 
                                                                                 int, 
                                                                                 int, 
                                                                                 np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__obs_op_adj_pdaf : Callable[[int, 
                                                                                 int, 
                                                                                 int, 
                                                                                 np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__prodRinvA_l_pdaf : Callable[[int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                                 py__init_n_domains_p_pdaf : Callable[[int, 
                                                                                       int], int],
                                                 py__init_dim_l_pdaf : Callable[[int, 
                                                                                 int, 
                                                                                 int], int],
                                                 py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                                     int, 
                                                                                     int, 
                                                                                     int], int],
                                                 py__prepoststep_pdaf : Callable[[int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                  int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                                 py__next_observation_pdaf : Callable[[int, 
                                                                                       int, 
                                                                                       int, 
                                                                                       float], tuple[int, 
                                                                                       int, 
                                                                                       float]],
                                                 outflag: int) -> int:
    """Using 3DEnVar for DA with non-diagonal observation error covariance matrix.
    The background error covariance matrix is estimated by ensemble. The 3DEnVar only calculates the analysis of the ensemble mean.
    An LESTKF is used to generate ensemble perturbations. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf_nondiagR`
    and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_ens_pdaf
    6. py__obs_op_lin_pdaf
    7. py__prodRinvA_pdaf
    8. py__obs_op_adj_pdaf
    9. py__cvt_adj_ens_pdaf
    10. core DA algorithm
    After the iterations: 
    11. py__cvt_ens_pdaf
    Perform LESTKF: 
    12. py__init_n_domains_p_pdaf
    13. py__init_dim_obs_pdaf
    14. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    15. py__init_dim_l_pdaf
    16. py__init_dim_obs_l_pdaf (localise mean ensemble in observation space)
    17. py__prodRinvA_l_pdaf
    18. core DA algorithm
    19. py__prepoststep_state_pdaf
    20. py__distribute_state_pdaf
    21. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A with localization

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_assimilate_hyb3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                         py__distribute_state_pdaf : Callable[[int, 
                                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                         py__init_dim_obs_pdaf : Callable[[int, 
                                                                           int], int],
                                         py__obs_op_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                         py__cvt_ens_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                         py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          int, 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                         py__cvt_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                         py__cvt_adj_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                         py__obs_op_lin_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                         py__obs_op_adj_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                         py__init_n_domains_p_pdaf : Callable[[int, 
                                                                               int], int],
                                         py__init_dim_l_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int], int],
                                         py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                             int, 
                                                                             int, 
                                                                             int], int],
                                         py__prepoststep_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          int, 
                                                                          int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                          int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                         py__next_observation_pdaf : Callable[[int, 
                                                                               int, 
                                                                               int, 
                                                                               float], tuple[int, 
                                                                               int, 
                                                                               float]],
                                         outflag: int) -> int:
    """Using Hybrid 3DEnVar for DA with diagonal observation error covariance matrix.
    Here, the background error covariance is hybridised by a static background error covariance, and a flow-dependent background error covariance estimated from ensemble. The 3DVar generates an ensemble mean and the ensemble perturbation is generated by
    LESTKF in this implementation. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf`
    and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_pdaf
    6. py__cvt_ens_pdaf
    7. py__obs_op_lin_pdaf
    8. py__obs_op_adj_pdaf
    9. py__cvt_adj_pdaf
    10. py__cvt_adj_ens_pdaf
    11. core DA algorithm
    After the iterations: 
    12. py__cvt_pdaf
    13. py__cvt_ens_pdaf
    Perform LESTKF: 
    14. py__init_n_domains_p_pdaf
    15. py__init_dim_obs_pdaf
    16. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    17. py__init_dim_l_pdaf
    18. py__init_dim_obs_l_pdaf
    19. py__init_obs_l_pdaf
    20. core DA algorithm
    21. py__prepoststep_state_pdaf
    22. py__distribute_state_pdaf
    23. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_assimilate_hyb3dvar_lestkf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                  py__distribute_state_pdaf : Callable[[int, 
                                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                  py__init_dim_obs_pdaf : Callable[[int, 
                                                                                    int], int],
                                                  py__obs_op_pdaf : Callable[[int, 
                                                                              int, 
                                                                              int, 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                  py__prodRinvA_pdaf : Callable[[int, 
                                                                                 int, 
                                                                                 int, 
                                                                                 np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                                  py__cvt_ens_pdaf : Callable[[int, 
                                                                               int, 
                                                                               int, 
                                                                               int, 
                                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                  py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                                   int, 
                                                                                   int, 
                                                                                   int, 
                                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                  py__cvt_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                  py__cvt_adj_pdaf : Callable[[int, 
                                                                               int, 
                                                                               int, 
                                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                  py__obs_op_lin_pdaf : Callable[[int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                  py__obs_op_adj_pdaf : Callable[[int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                  py__prodRinvA_l_pdaf : Callable[[int, 
                                                                                   int, 
                                                                                   int, 
                                                                                   int, 
                                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                                  py__init_n_domains_p_pdaf : Callable[[int, 
                                                                                        int], int],
                                                  py__init_dim_l_pdaf : Callable[[int, 
                                                                                  int, 
                                                                                  int], int],
                                                  py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                                      int, 
                                                                                      int, 
                                                                                      int], int],
                                                  py__prepoststep_pdaf : Callable[[int, 
                                                                                   int, 
                                                                                   int, 
                                                                                   int, 
                                                                                   int, 
                                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                   int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                                  py__next_observation_pdaf : Callable[[int, 
                                                                                        int, 
                                                                                        int, 
                                                                                        float], tuple[int, 
                                                                                        int, 
                                                                                        float]],
                                                  outflag: int) -> int:
    """Using Hybrid 3DEnVar for DA with non-diagonal observation error covariance matrix.
    Here, the background error covariance is hybridised by a static background error covariance, and a flow-dependent background error covariance estimated from ensemble. The 3DVar generates an ensemble mean and the ensemble perturbation is generated by
    LESTKF in this implementation. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf_nondiagR`
    and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_pdaf
    6. py__cvt_ens_pdaf
    7. py__obs_op_lin_pdaf
    8. py__prodRinvA_pdaf
    9. py__obs_op_adj_pdaf
    10. py__cvt_adj_pdaf
    11. py__cvt_adj_ens_pdaf
    12. core DA algorithm
    After the iterations: 
    13. py__cvt_pdaf
    14. py__cvt_ens_pdaf
    Perform LESTKF: 
    15. py__init_n_domains_p_pdaf
    16. py__init_dim_obs_pdaf
    17. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    18. py__init_dim_l_pdaf
    19. py__init_dim_obs_l_pdaf
    20. py__init_obs_l_pdaf
    21. py__prodRinvA_l_pdaf
    22. core DA algorithm
    23. py__prepoststep_state_pdaf
    24. py__distribute_state_pdaf
    25. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_assimilate_lknetf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                         py__distribute_state_pdaf : Callable[[int, 
                                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                         py__init_dim_obs_pdaf : Callable[[int, 
                                                                           int], int],
                                         py__obs_op_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                         py__prepoststep_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          int, 
                                                                          int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                          int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                         py__init_n_domains_p_pdaf : Callable[[int, 
                                                                               int], int],
                                         py__init_dim_l_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int], int],
                                         py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                             int, 
                                                                             int, 
                                                                             int], int],
                                         py__prodRinvA_l_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                         py__prodRinvA_hyb_l_pdaf : Callable[[int, 
                                                                              int, 
                                                                              int, 
                                                                              int, 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                              float, 
                                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                         py__likelihood_l_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                           float], float],
                                         py__likelihood_hyb_l_pdaf : Callable[[int, 
                                                                               int, 
                                                                               int, 
                                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                               float, 
                                                                               float], float],
                                         py__next_observation_pdaf : Callable[[int, 
                                                                               int, 
                                                                               int, 
                                                                               float], tuple[int, 
                                                                               int, 
                                                                               float]],
                                         outflag: int) -> int:
    """Using LKNETF for DA with non-diagonal observation error covariance matrix. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.localomi_put_state_lknetf_nondiagR` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    6. py__init_dim_l_pdaf
    7. py__init_dim_obs_l_pdaf
    8. py__prodRinvA_pdaf
    9. py__likelihood_l_pdaf
    10. core DA algorithm
    11. py__obs_op_pdaf (only called with `HKN` and `HNK` options called for each ensemble member
    12. py__likelihood_hyb_l_pda
    13. py__prodRinvA_hyb_l_pdaf
    14. py__prepoststep_state_pdaf
    15. py__distribute_state_pdaf
    16. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__prodRinvA_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, dim_ens:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, A_l:ndarray[tuple[dim_obs_l, dim_ens], np.float64], C_l:ndarray[tuple[dim_obs_l, dim_ens], np.float64]]
        Product R^-1 A on local analysis domain with hybrid weight

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **dim_ens** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **gamma** : float

            --- Hybrid weight provided by PDAF

        * **A_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Output matrix


    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute likelihood and apply localization

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- nput vector holding the local residual

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    py__likelihood_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, likely_l:float]
        Compute likelihood and apply localization with tempering

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Input vector holding the local residual

        * **gamma** : float

            --- Hybrid weight provided by PDAF

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_assimilate_lnetf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__distribute_state_pdaf : Callable[[int, 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__init_dim_obs_pdaf : Callable[[int, 
                                                                          int], int],
                                        py__obs_op_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__prepoststep_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                        py__init_n_domains_p_pdaf : Callable[[int, 
                                                                              int], int],
                                        py__init_dim_l_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int], int],
                                        py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            int], int],
                                        py__likelihood_l_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          float], float],
                                        py__next_observation_pdaf : Callable[[int, 
                                                                              int, 
                                                                              int, 
                                                                              float], tuple[int, 
                                                                              int, 
                                                                              float]],
                                        outflag: int) -> int:
    """Using LNETF for DA with non-diagonal observation error covariance matrix. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.localomi_put_state_lnetf_nondiagR` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    6. py__init_dim_l_pdaf
    7. py__init_dim_obs_l_pdaf
    8. py__likelihood_l_pdaf
    9. core DA algorithm
    10. py__prepoststep_state_pdaf
    11. py__distribute_state_pdaf
    12. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute likelihood and apply localization

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- nput vector holding the local residual

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_assimilate_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__distribute_state_pdaf : Callable[[int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__init_dim_obs_pdaf : Callable[[int, 
                                                                    int], int],
                                  py__obs_op_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__prepoststep_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                  py__init_n_domains_p_pdaf : Callable[[int, 
                                                                        int], int],
                                  py__init_dim_l_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int], int],
                                  py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      int], int],
                                  py__prodRinvA_l_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                  py__next_observation_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        float], tuple[int, 
                                                                        int, 
                                                                        float]],
                                  outflag: int) -> int:
    """Using domain localised filters for DA with non-diagonal observation error covariance matrix. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.localomi_put_state_local_nondiagR` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    6. py__init_dim_l_pdaf
    7. py__init_dim_obs_l_pdaf
    8. py__init_obs_l_pdaf
    9. py__prodRinvA_l_pdaf
    10. core DA algorithm
    11. py__prepoststep_state_pdaf
    12. py__distribute_state_pdaf
    13. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product of inverse of R with matrix A

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_put_state (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                        py__init_dim_obs_pdaf : Callable[[int, int], int],
                        py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                        py__prepoststep_pdaf : Callable[[int, int, int, 
                                                         int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                         int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                        py__init_n_domains_p_pdaf : Callable[[int, int], int],
                        py__init_dim_l_pdaf : Callable[[int, int, int], int],
                        py__init_dim_obs_l_pdaf : Callable[[int, int, int, 
                                                            int], int],
                        outflag: int) -> int:
    """Using domain localised filters for DA without post-processing and analysis distribution to forecsat with diagonal observation error covariance matrix. This is a domain localisation method. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. The LESTKF is a more efficient equivalent to the LETKF. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    6. py__init_dim_l_pdaf
    7. py__init_dim_obs_l_pdaf
    8. core DA algorithm
    9. py__prepoststep_state_pdaf
    10. py__distribute_state_pdaf
    11. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_put_state_en3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                       py__init_dim_obs_pdaf : Callable[[int, 
                                                                         int], int],
                                       py__obs_op_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                       py__cvt_ens_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                       py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        int, 
                                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                       py__obs_op_lin_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int, 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                       py__obs_op_adj_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int, 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                       py__init_n_domains_p_pdaf : Callable[[int, 
                                                                             int], int],
                                       py__init_dim_l_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int], int],
                                       py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           int], int],
                                       py__prepoststep_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        int, 
                                                                        int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                        int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                       outflag: int) -> int:
    """Using 3DEnVar for DA without post-processing and analysis distribution to forecsat with diagonal observation error covariance matrix.
    The background error covariance matrix is estimated by ensemble. The 3DEnVar only calculates the analysis of the ensemble mean.
    An LESTKF is used to generate ensemble perturbations. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_ens_pdaf
    6. py__obs_op_lin_pdaf
    7. py__obs_op_adj_pdaf
    8. py__cvt_adj_ens_pdaf
    9. core DA algorithm
    After the iterations: 
    10. py__cvt_ens_pdaf
    Perform LESTKF: 
    11. py__init_n_domains_p_pdaf
    12. py__init_dim_obs_pdaf
    13. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    14. py__init_dim_l_pdaf
    15. py__init_dim_obs_l_pdaf
    16. core DA algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_put_state_en3dvar_lestkf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                py__init_dim_obs_pdaf : Callable[[int, 
                                                                                  int], int],
                                                py__obs_op_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                py__prodRinvA_pdaf : Callable[[int, 
                                                                               int, 
                                                                               int, 
                                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                                py__cvt_ens_pdaf : Callable[[int, 
                                                                             int, 
                                                                             int, 
                                                                             int, 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                                 int, 
                                                                                 int, 
                                                                                 int, 
                                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                 np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                py__obs_op_lin_pdaf : Callable[[int, 
                                                                                int, 
                                                                                int, 
                                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                py__obs_op_adj_pdaf : Callable[[int, 
                                                                                int, 
                                                                                int, 
                                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                py__prodRinvA_l_pdaf : Callable[[int, 
                                                                                 int, 
                                                                                 int, 
                                                                                 int, 
                                                                                 np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                                py__init_n_domains_p_pdaf : Callable[[int, 
                                                                                      int], int],
                                                py__init_dim_l_pdaf : Callable[[int, 
                                                                                int, 
                                                                                int], int],
                                                py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                                    int, 
                                                                                    int, 
                                                                                    int], int],
                                                py__prepoststep_pdaf : Callable[[int, 
                                                                                 int, 
                                                                                 int, 
                                                                                 int, 
                                                                                 int, 
                                                                                 np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                 int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                                outflag: int) -> int:
    """Using 3DEnVar for DA with non-diagonal observation error covariance matrix
    without post-processing and analysis distribution to forecsat without OMI. The background error covariance matrix is estimated by ensemble. The 3DEnVar only calculates the analysis of the ensemble mean.
    An LESTKF is used to generate ensemble perturbations. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_ens_pdaf
    6. py__obs_op_lin_pdaf
    7. py__prodRinvA_pdaf
    8. py__obs_op_adj_pdaf
    9. py__cvt_adj_ens_pdaf
    10. core DA algorithm
    After the iterations: 
    11. py__cvt_ens_pdaf
    Perform LESTKF: 
    12. py__init_n_domains_p_pdaf
    13. py__init_dim_obs_pdaf
    14. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    15. py__init_dim_l_pdaf
    16. py__init_dim_obs_l_pdaf (localise mean ensemble in observation space)
    17. py__prodRinvA_l_pdaf
    18. core DA algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_put_state_hyb3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__init_dim_obs_pdaf : Callable[[int, 
                                                                          int], int],
                                        py__obs_op_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__cvt_ens_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__cvt_pdaf : Callable[[int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__cvt_adj_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__obs_op_lin_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__obs_op_adj_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__init_n_domains_p_pdaf : Callable[[int, 
                                                                              int], int],
                                        py__init_dim_l_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int], int],
                                        py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            int], int],
                                        py__prepoststep_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                        outflag: int) -> int:
    """Using 3DEnVar for DA without post-processing and analysis distribution to forecsat with diagonal observation error covariance matrix.
    Here, the background error covariance is hybridised by a static background error covariance, and a flow-dependent background error covariance estimated from ensemble. The 3DVar generates an ensemble mean and the ensemble perturbation is generated by
    LESTKF in this implementation. 
    
    This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_ens_pdaf
    6. py__obs_op_lin_pdaf
    7. py__obs_op_adj_pdaf
    8. py__cvt_adj_ens_pdaf
    9. core DA algorithm
    After the iterations: 
    10. py__cvt_ens_pdaf
    Perform LESTKF: 
    11. py__init_n_domains_p_pdaf
    12. py__init_dim_obs_pdaf
    13. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    14. py__init_dim_l_pdaf
    15. py__init_dim_obs_l_pdaf (localise mean ensemble in observation space)
    16. core DA algorith
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_put_state_hyb3dvar_lestkf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__init_dim_obs_pdaf : Callable[[int, 
                                                                                   int], int],
                                                 py__obs_op_pdaf : Callable[[int, 
                                                                             int, 
                                                                             int, 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__prodRinvA_pdaf : Callable[[int, 
                                                                                int, 
                                                                                int, 
                                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                                 py__cvt_ens_pdaf : Callable[[int, 
                                                                              int, 
                                                                              int, 
                                                                              int, 
                                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__cvt_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__cvt_adj_pdaf : Callable[[int, 
                                                                              int, 
                                                                              int, 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__obs_op_lin_pdaf : Callable[[int, 
                                                                                 int, 
                                                                                 int, 
                                                                                 np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__obs_op_adj_pdaf : Callable[[int, 
                                                                                 int, 
                                                                                 int, 
                                                                                 np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__prodRinvA_l_pdaf : Callable[[int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                                 py__init_n_domains_p_pdaf : Callable[[int, 
                                                                                       int], int],
                                                 py__init_dim_l_pdaf : Callable[[int, 
                                                                                 int, 
                                                                                 int], int],
                                                 py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                                     int, 
                                                                                     int, 
                                                                                     int], int],
                                                 py__prepoststep_pdaf : Callable[[int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                  int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                                 outflag: int) -> int:
    """Using Hybrid 3DEnVar for DA with non-diagonal observation error covariance matrix
    without post-processing and analysis distribution to forecsat without OMI. Here, the background error covariance is hybridised by a static background error covariance, and a flow-dependent background error covariance estimated from ensemble. The 3DVar generates an ensemble mean and the ensemble perturbation is generated by
    LESTKF in this implementation. This function should be called at each model time step. 
    
    This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    Starting the iterative optimisation:
    5. py__cvt_pdaf
    6. py__cvt_ens_pdaf
    7. py__obs_op_lin_pdaf
    8. py__prodRinvA_pdaf
    9. py__obs_op_adj_pdaf
    10. py__cvt_adj_pdaf
    11. py__cvt_adj_ens_pdaf
    12. core DA algorithm
    After the iterations: 
    13. py__cvt_pdaf
    14. py__cvt_ens_pdaf
    Perform LESTKF: 
    15. py__init_n_domains_p_pdaf
    16. py__init_dim_obs_pdaf
    17. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    18. py__init_dim_l_pdaf
    19. py__init_dim_obs_l_pdaf
    20. py__init_obs_l_pdaf
    21. py__prodRinvA_l_pdaf
    22. core DA algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_put_state_lknetf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__init_dim_obs_pdaf : Callable[[int, 
                                                                          int], int],
                                        py__obs_op_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__prepoststep_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                        py__init_n_domains_p_pdaf : Callable[[int, 
                                                                              int], int],
                                        py__init_dim_l_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int], int],
                                        py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            int], int],
                                        py__prodRinvA_l_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                        py__prodRinvA_hyb_l_pdaf : Callable[[int, 
                                                                             int, 
                                                                             int, 
                                                                             int, 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                             float, 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                        py__likelihood_l_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          float], float],
                                        py__likelihood_hyb_l_pdaf : Callable[[int, 
                                                                              int, 
                                                                              int, 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                              float, 
                                                                              float], float],
                                        outflag: int) -> int:
    """Using LKNETF for DA with non-diagonal observation error covariance matrix without post-processing and analysis distribution to forecsat without OMI. This function should be called at each model time step. 
    
    This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    6. py__init_dim_l_pdaf
    7. py__init_dim_obs_l_pdaf
    8. py__prodRinvA_pdaf
    9. py__likelihood_l_pdaf
    10. core DA algorithm
    11. py__obs_op_pdaf (only called with `HKN` and `HNK` options called for each ensemble member
    12. py__likelihood_hyb_l_pda
    13. py__prodRinvA_hyb_l_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__prodRinvA_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, dim_ens:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, A_l:ndarray[tuple[dim_obs_l, dim_ens], np.float64], C_l:ndarray[tuple[dim_obs_l, dim_ens], np.float64]]
        Product R^-1 A on local analysis domain with hybrid weight

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **dim_ens** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **gamma** : float

            --- Hybrid weight provided by PDAF

        * **A_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Output matrix


    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute likelihood and apply localization

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- nput vector holding the local residual

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    py__likelihood_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, likely_l:float]
        Compute likelihood and apply localization with tempering

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Input vector holding the local residual

        * **gamma** : float

            --- Hybrid weight provided by PDAF

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_put_state_lnetf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                       py__init_dim_obs_pdaf : Callable[[int, 
                                                                         int], int],
                                       py__obs_op_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                       py__prepoststep_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        int, 
                                                                        int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                        int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                       py__init_n_domains_p_pdaf : Callable[[int, 
                                                                             int], int],
                                       py__init_dim_l_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int], int],
                                       py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           int], int],
                                       py__likelihood_l_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         float], float],
                                       outflag: int) -> int:
    """Using LNETF for DA with non-diagonal observation error covariance matrix without post-processing and analysis distribution to forecsat without OMI. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.omi_put_state_lnetf_nondiagR` This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    6. py__init_dim_l_pdaf
    7. py__init_dim_obs_l_pdaf
    8. py__likelihood_l_pdaf
    9. core DA algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute likelihood and apply localization

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- nput vector holding the local residual

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_put_state_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                 py__init_dim_obs_pdaf : Callable[[int, 
                                                                   int], int],
                                 py__obs_op_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                 py__prepoststep_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                  int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                 py__init_n_domains_p_pdaf : Callable[[int, 
                                                                       int], int],
                                 py__init_dim_l_pdaf : Callable[[int, int, 
                                                                 int], int],
                                 py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     int], int],
                                 py__prodRinvA_l_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                 outflag: int) -> int:
    """Using domain localised filters for DA with non-diagonal observation error covariance matrix without post-processing and analysis distribution to forecsat without OMI. This function should be called at each model time step. 
    
    This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    6. py__init_dim_l_pdaf
    7. py__init_dim_obs_l_pdaf
    9. py__init_obs_l_pdaf
    10. py__prodRinvA_l_pdaf
    11. core DA algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product of inverse of R with matrix A

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_assimilate_en3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__distribute_state_pdaf : Callable[[int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__init_dim_obs_pdaf : Callable[[int, 
                                                                       int], int],
                                     py__obs_op_pdaf : Callable[[int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__init_obs_pdaf : Callable[[int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__prodRinvA_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                     py__cvt_ens_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__obs_op_lin_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__obs_op_adj_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__init_dim_obs_f_pdaf : Callable[[int, 
                                                                         int], int],
                                     py__obs_op_f_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__init_obs_f_pdaf : Callable[[int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__init_obs_l_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__prodRinvA_l_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                     py__init_n_domains_p_pdaf : Callable[[int, 
                                                                           int], int],
                                     py__init_dim_l_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int], int],
                                     py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         int], int],
                                     py__g2l_obs_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                                  int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                                     py__init_obsvar_pdaf : Callable[[int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      float], float],
                                     py__init_obsvar_l_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        int, 
                                                                        float], float],
                                     py__prepoststep_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                      int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                     py__next_observation_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           float], tuple[int, 
                                                                           int, 
                                                                           float]]
                                    ) -> int:
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency.
    I.e., `pyPDAF.PDAF.localomi_assimilate_en3dvar_lestkf` or `pyPDAF.PDAF.localomi_assimilate_en3dvar_lestkf_nondiagR`. 
    
    
    Using 3DEnVar for DA without OMI.
    The background error covariance matrix is estimated by ensemble. The 3DEnVar only calculates the analysis of the ensemble mean.
    An LESTKF is used to generate ensemble perturbations. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.local_put_state_en3dvar_lestkf`
    and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    5. py__init_obs_pdaf
    Starting the iterative optimisation:
    6. py__cvt_ens_pdaf
    7. py__obs_op_lin_pdaf
    8. py__prodRinvA_pdaf
    9. py__obs_op_adj_pdaf
    10. py__cvt_adj_ens_pdaf
    11. core DA algorithm
    After the iterations: 
    12. py__cvt_ens_pdaf
    Perform LESTKF: 
    13. py__init_n_domains_p_pdaf
    14. py__init_dim_obs_pdaf
    15. py__obs_op_pdaf (for each ensemble member
    16. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init
    17. py__init_obsvar_pdaf (if global adaptive forgetting factor is used
    loop over each local domain:
    18. py__init_dim_l_pdaf
    19. py__init_dim_obs_l_pdaf
    20. py__g2l_obs_pdaf (localise mean ensemble in observation space)
    21. py__init_obs_l_pdaf
    22. py__g2l_obs_pdaf (localise each ensemble member in observation space
    23. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used
    24. py__prodRinvA_l_pdaf
    25. core DA algorithm
    26. py__prepoststep_state_pdaf
    27. py__distribute_state_pdaf
    28. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f:ndarray[tuple[dim_obs_f], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of the full observation vector

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of observations

        **Callback Returns**

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_assimilate_hyb3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                      py__distribute_state_pdaf : Callable[[int, 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                      py__init_dim_obs_pdaf : Callable[[int, 
                                                                        int], int],
                                      py__obs_op_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                      py__init_obs_pdaf : Callable[[int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                      py__prodRinvA_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                      py__cvt_ens_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                      py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int, 
                                                                       int, 
                                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                      py__cvt_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                      py__cvt_adj_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                      py__obs_op_lin_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                      py__obs_op_adj_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                      py__init_dim_obs_f_pdaf : Callable[[int, 
                                                                          int], int],
                                      py__obs_op_f_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                      py__init_obs_f_pdaf : Callable[[int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                      py__init_obs_l_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                      py__prodRinvA_l_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int, 
                                                                       int, 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                      py__init_n_domains_p_pdaf : Callable[[int, 
                                                                            int], int],
                                      py__init_dim_l_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int], int],
                                      py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          int], int],
                                      py__g2l_obs_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                                   int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                                      py__init_obsvar_pdaf : Callable[[int, 
                                                                       int, 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                       float], float],
                                      py__init_obsvar_l_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         int, 
                                                                         float], float],
                                      py__prepoststep_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int, 
                                                                       int, 
                                                                       int, 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                       int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                      py__next_observation_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            float], tuple[int, 
                                                                            int, 
                                                                            float]]
                                     ) -> int:
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency.
    I.e., `pyPDAF.PDAF.localomi_assimilate_hyb3dvar_lestkf` or `pyPDAF.PDAF.localomi_assimilate_hyb3dvar_lestkf_nondiagR`. 
    
    
    Using Hybrid 3DEnVar for DA without OMI.
    Here, the background error covariance is hybridised by a static background error covariance, and a flow-dependent background error covariance estimated from ensemble. The 3DVar generates an ensemble mean and the ensemble perturbation is generated by
    LESTKF in this implementation. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.local_put_state_hyb3dvar_lestkf`
    and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    5. py__init_obs_pdaf
    Starting the iterative optimisation:
    6. py__cvt_pdaf
    7. py__cvt_ens_pdaf
    8. py__obs_op_lin_pdaf
    9. py__prodRinvA_pdaf
    10. py__obs_op_adj_pdaf
    11. py__cvt_adj_pdaf
    12. py__cvt_adj_ens_pdaf
    13. core DA algorithm
    After the iterations: 
    14. py__cvt_pdaf
    15. py__cvt_ens_pdaf
    Perform LESTKF: 
    16. py__init_n_domains_p_pdaf
    17. py__init_dim_obs_pdaf
    18. py__obs_op_pdaf (for each ensemble member
    19. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in `pyPDAF.PDAF.init`))
    20. py__init_obsvar_pdaf (if global adaptive forgetting factor is used)
    loop over each local domain:
    21. py__init_dim_l_pdaf
    22. py__init_dim_obs_l_pdaf
    23. py__g2l_obs_pdaf (localise mean ensemble in observation space)
    24. py__init_obs_l_pdaf
    25. py__g2l_obs_pdaf (localise each ensemble member in observation space)
    26. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used)
    27. py__prodRinvA_l_pdaf
    28. core DA algorithm
    29. py__prepoststep_state_pdaf
    30. py__distribute_state_pdaf
    31. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f:ndarray[tuple[dim_obs_f], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of the full observation vector

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of observations

        **Callback Returns**

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_assimilate_lestkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__distribute_state_pdaf : Callable[[int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__init_dim_obs_pdaf : Callable[[int, int], int],
                             py__obs_op_pdaf : Callable[[int, int, int, 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__init_obs_l_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__prepoststep_pdaf : Callable[[int, int, 
                                                              int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                             py__prodRinvA_l_pdaf : Callable[[int, int, 
                                                              int, int, 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                             py__init_n_domains_p_pdaf : Callable[[int, 
                                                                   int], int],
                             py__init_dim_l_pdaf : Callable[[int, int, 
                                                             int], int],
                             py__init_dim_obs_l_pdaf : Callable[[int, int, 
                                                                 int, int], int],
                             py__g2l_obs_pdaf : Callable[[int, int, int, 
                                                          int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                          int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                          int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                             py__init_obsvar_pdaf : Callable[[int, int, 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              float], float],
                             py__init_obsvar_l_pdaf : Callable[[int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                int, float], float],
                             py__next_observation_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   float], tuple[int, 
                                                                   int, 
                                                                   float]]
                            ) -> int:
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_assimilate` or `pyPDAF.PDAF.localomi_assimilate_nondiagR`. 
    Using Local ESTKF (error space transform Kalman filter) for DA without OMI. This is a domain localisation method. This function should be called at each model time step. The LESTKF is a more efficient equivalent to the LETKF. 
    
    The function is a combination of `pyPDAF.PDAF.local_put_state_lestkf` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    6. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init
    7. py__init_obsvar_pdaf (if global adaptive forgetting factor is used
    loop over each local domain:
    8. py__init_dim_l_pdaf
    9. py__init_dim_obs_l_pdaf
    10. py__g2l_obs_pdaf (localise mean ensemble in observation space)
    11. py__init_obs_l_pdaf
    12. py__g2l_obs_pdaf (localise each ensemble member in observation space
    13. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used
    14. py__prodRinvA_l_pdaf
    15. core DA algorithm
    16. py__prepoststep_state_pdaf
    17. py__distribute_state_pdaf (18. py__next_observation_pdaf 
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_assimilate_letkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__distribute_state_pdaf : Callable[[int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_dim_obs_pdaf : Callable[[int, int], int],
                            py__obs_op_pdaf : Callable[[int, int, int, 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_obs_l_pdaf : Callable[[int, int, int, 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__prepoststep_pdaf : Callable[[int, int, 
                                                             int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                            py__prodRinvA_l_pdaf : Callable[[int, int, 
                                                             int, int, 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                            py__init_n_domains_p_pdaf : Callable[[int, 
                                                                  int], int],
                            py__init_dim_l_pdaf : Callable[[int, int, int], int],
                            py__init_dim_obs_l_pdaf : Callable[[int, int, 
                                                                int, int], int],
                            py__g2l_obs_pdaf : Callable[[int, int, int, 
                                                         int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                         int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                         int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                            py__init_obsvar_pdaf : Callable[[int, int, 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             float], float],
                            py__init_obsvar_l_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               int, float], float],
                            py__next_observation_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  float], tuple[int, 
                                                                  int, 
                                                                  float]]
                           ) -> int:
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_assimilate` or `pyPDAF.PDAF.localomi_assimilate_nondiagR`. 
    Using local ensemble transform Kalman filter for DA without OMI. This is a domain localisation method. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.local_put_state_letkf` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    6. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init
    7. py__init_obsvar_pdaf (if global adaptive forgetting factor is used
    loop over each local domain:
    8. py__init_dim_l_pdaf
    9. py__init_dim_obs_l_pdaf
    10. py__g2l_obs_pdaf (localise mean ensemble in observation space)
    11. py__init_obs_l_pdaf
    12. py__g2l_obs_pdaf (localise each ensemble member in observation space
    13. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used
    14. py__prodRinvA_l_pdaf
    15. core DA algorithm
    16. py__prepoststep_state_pdaf
    17. py__distribute_state_pdaf
    18. py__next_observation_pdaf 
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_assimilate_lknetf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__distribute_state_pdaf : Callable[[int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__init_dim_obs_pdaf : Callable[[int, int], int],
                             py__obs_op_pdaf : Callable[[int, int, int, 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__init_obs_l_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__prepoststep_pdaf : Callable[[int, int, 
                                                              int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                             py__prodRinvA_l_pdaf : Callable[[int, int, 
                                                              int, int, 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                             py__prodRinvA_hyb_l_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  float, 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                             py__init_n_domains_p_pdaf : Callable[[int, 
                                                                   int], int],
                             py__init_dim_l_pdaf : Callable[[int, int, 
                                                             int], int],
                             py__init_dim_obs_l_pdaf : Callable[[int, int, 
                                                                 int, int], int],
                             py__g2l_obs_pdaf : Callable[[int, int, int, 
                                                          int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                          int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                          int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                             py__init_obsvar_pdaf : Callable[[int, int, 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              float], float],
                             py__init_obsvar_l_pdaf : Callable[[int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                int, float], float],
                             py__likelihood_l_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               float], float],
                             py__likelihood_hyb_l_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   float, 
                                                                   float], float],
                             py__next_observation_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   float], tuple[int, 
                                                                   int, 
                                                                   float]]
                            ) -> int:
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_assimilate` or `pyPDAF.PDAF.localomi_assimilate_lknetf_nondiagR`. 
    This function will is a hybridised LETKF and LNETF for DA without OMI. The LNETF computes the distribution up to the second moment similar to KF but using a nonlinear weighting similar to particle filter. This leads to an equal weights assumption for prior ensemble. The hybridisation with LETKF is expected to lead to improved performance for quasi-Gaussian problems. The function should be called at each model step. 
    
    The function is a combination of `pyPDAF.PDAF.local_put_state_lknetf` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf 
    2. py__prepoststep_state_pdaf 
    3. py__init_n_domains_p_pdaf 
    4. py__init_dim_obs_pdaf 
    5. py__obs_op_pdaf (for each ensemble member)
    6. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in `pyPDAF.PDAF.init`
    7. py__init_obsvar_pdaf (if global adaptive forgetting factor is used
    loop over each local domain:
    8. py__init_dim_l_pdaf 
    9. py__init_dim_obs_l_pdaf 
    10. py__g2l_obs_pdaf (localise each ensemble member in observation space
    11. py__init_obs_l_pdaf 
    12. py__init_obsvar_l_pdaf 
(only called if local adaptive forgetting factor (type_forget=2) is used
    13. py__prodRinvA_pdaf 
    14. py__likelihood_l_pdaf 
    15. core DA algorithm 
    16. py__obs_op_pdaf (only called with `HKN` and `HNK` options called for each ensemble member)
    17. py__likelihood_hyb_l_pdaf
    18. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used
    19. py__prodRinvA_hyb_l_pdaf 
    20. py__prepoststep_state_pdaf 
    21. py__distribute_state_pdaf 
    22. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__prodRinvA_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, dim_ens:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, A_l:ndarray[tuple[dim_obs_l, dim_ens], np.float64], C_l:ndarray[tuple[dim_obs_l, dim_ens], np.float64]]
        Provide product R^-1 A on local analysis domain with hybrid weight

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **dim_ens** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **gamma** : float

            --- Hybrid weight provided by PDAF

        * **A_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance


    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute likelihood

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- nput vector holding the local residual

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    py__likelihood_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, likely_l:float]
        Compute likelihood with hybrid weight

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Input vector holding the local residual

        * **gamma** : float

            --- Hybrid weight provided by PDAF

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_assimilate_lnetf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__distribute_state_pdaf : Callable[[int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_dim_obs_pdaf : Callable[[int, int], int],
                            py__obs_op_pdaf : Callable[[int, int, int, 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_obs_l_pdaf : Callable[[int, int, int, 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__prepoststep_pdaf : Callable[[int, int, 
                                                             int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                            py__likelihood_l_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              float], float],
                            py__init_n_domains_p_pdaf : Callable[[int, 
                                                                  int], int],
                            py__init_dim_l_pdaf : Callable[[int, int, int], int],
                            py__init_dim_obs_l_pdaf : Callable[[int, int, 
                                                                int, int], int],
                            py__g2l_obs_pdaf : Callable[[int, int, int, 
                                                         int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                         int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                         int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                            py__next_observation_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  float], tuple[int, 
                                                                  int, 
                                                                  float]]
                           ) -> int:
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_assimilate` or `pyPDAF.PDAF.localomi_assimilate_lnetf_nondiagR`. 
    This function will use Local Nonlinear Ensemble Transform Filter (LNETF) for DA without OMI. The nonlinear filter computes the distribution up to the second moment similar to KF but using a nonlinear weighting similar to particle filter. This leads to an equal weights assumption for prior ensemble. This function should be called at each model time step. 
    
    The function is a combination of `pyPDAF.PDAF.local_put_state_lnetf` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    6. py__init_dim_l_pdaf
    7. py__init_dim_obs_l_pdaf
    8. py__init_obs_l_pdaf
    9. py__g2l_obs_pdaf (localise each ensemble member in observation space)
    10. py__likelihood_l_pdaf
    11. core DA algorithm
    12. py__prepoststep_state_pdaf
    13. py__distribute_state_pdaf
    14. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- nput vector holding the local residual

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_assimilate_lseik (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__distribute_state_pdaf : Callable[[int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_dim_obs_pdaf : Callable[[int, int], int],
                            py__obs_op_pdaf : Callable[[int, int, int, 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_obs_l_pdaf : Callable[[int, int, int, 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__prepoststep_pdaf : Callable[[int, int, 
                                                             int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                            py__prodRinvA_l_pdaf : Callable[[int, int, 
                                                             int, int, 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                            py__init_n_domains_p_pdaf : Callable[[int, 
                                                                  int], int],
                            py__init_dim_l_pdaf : Callable[[int, int, int], int],
                            py__init_dim_obs_l_pdaf : Callable[[int, int, 
                                                                int, int], int],
                            py__g2l_obs_pdaf : Callable[[int, int, int, 
                                                         int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                         int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                         int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                            py__init_obsvar_pdaf : Callable[[int, int, 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             float], float],
                            py__init_obsvar_l_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               int, float], float],
                            py__next_observation_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  float], tuple[int, 
                                                                  int, 
                                                                  float]]
                           ) -> int:
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_assimilate` or `pyPDAF.PDAF.localomi_assimilate_nondiagR`. 
    Using local singular evolutive interpolated Kalman filter for DA without OMI. This is a domain localisation method. This function should be called at each model time step.
    
    The function is a combination of `pyPDAF.PDAF.local_put_state_lseik` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    6. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init
    7. py__init_obsvar_pdaf (if global adaptive forgetting factor is used
    loop over each local domain:
    8. py__init_dim_l_pdaf
    9. py__init_dim_obs_l_pdaf
    10. py__g2l_obs_pdaf (localise mean ensemble in observation space)
    11. py__init_obs_l_pdaf
    12. py__g2l_obs_pdaf (localise each ensemble member in observation space
    13. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used
    14. py__prodRinvA_l_pdaf
    15. core DA algorithm
    16. py__prepoststep_state_pdaf
    17. py__distribute_state_pdaf
    18. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide time step, time and dimension of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- number of the current time step

        * **nsteps** : int

            --- number of time steps until next obs

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of time steps until next obs

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_put_state_en3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__init_dim_obs_pdaf : Callable[[int, 
                                                                      int], int],
                                    py__obs_op_pdaf : Callable[[int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__init_obs_pdaf : Callable[[int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__prodRinvA_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                    py__cvt_ens_pdaf : Callable[[int, int, 
                                                                 int, int, 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__obs_op_lin_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__obs_op_adj_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__init_dim_obs_f_pdaf : Callable[[int, 
                                                                        int], int],
                                    py__obs_op_f_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__init_obs_f_pdaf : Callable[[int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__init_obs_l_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__prodRinvA_l_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                    py__init_n_domains_p_pdaf : Callable[[int, 
                                                                          int], int],
                                    py__init_dim_l_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int], int],
                                    py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        int], int],
                                    py__g2l_obs_pdaf : Callable[[int, int, 
                                                                 int, int, 
                                                                 np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                                 int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                                    py__init_obsvar_pdaf : Callable[[int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     float], float],
                                    py__init_obsvar_l_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int, 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                       int, 
                                                                       float], float],
                                    py__prepoststep_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]]]]
                                   ) -> int:
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency.
    I.e., `pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf` or `pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf_nondiagR`. 
    
    
    Using 3DEnVar for DA without post-processing and analysis distribution to forecsat without OMI.
    The background error covariance matrix is estimated by ensemble. The 3DEnVar only calculates the analysis of the ensemble mean.
    An LESTKF is used to generate ensemble perturbations. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    5. py__init_obs_pdaf
    Starting the iterative optimisation:
    6. py__cvt_ens_pdaf
    7. py__obs_op_lin_pdaf
    8. py__prodRinvA_pdaf
    9. py__obs_op_adj_pdaf
    10. py__cvt_adj_ens_pdaf
    11. core DA algorithm
    After the iterations: 
    12. py__cvt_ens_pdaf
    Perform LESTKF: 
    13. py__init_n_domains_p_pdaf
    14. py__init_dim_obs_pdaf
    15. py__obs_op_pdaf (for each ensemble member
    16. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init
    17. py__init_obsvar_pdaf (if global adaptive forgetting factor is used
    loop over each local domain:
    18. py__init_dim_l_pdaf
    19. py__init_dim_obs_l_pdaf
    20. py__g2l_obs_pdaf (localise mean ensemble in observation space)
    21. py__init_obs_l_pdaf
    22. py__g2l_obs_pdaf (localise each ensemble member in observation space
    23. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used
    24. py__prodRinvA_pdaf
    25. core DA algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f:ndarray[tuple[dim_obs_f], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of the full observation vector

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of observations

        **Callback Returns**

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_put_state_hyb3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__init_dim_obs_pdaf : Callable[[int, 
                                                                       int], int],
                                     py__obs_op_pdaf : Callable[[int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__init_obs_pdaf : Callable[[int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__prodRinvA_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                     py__cvt_ens_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__cvt_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__cvt_adj_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__obs_op_lin_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__obs_op_adj_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__init_dim_obs_f_pdaf : Callable[[int, 
                                                                         int], int],
                                     py__obs_op_f_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__init_obs_f_pdaf : Callable[[int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__init_obs_l_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__prodRinvA_l_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                     py__init_n_domains_p_pdaf : Callable[[int, 
                                                                           int], int],
                                     py__init_dim_l_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int], int],
                                     py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         int], int],
                                     py__g2l_obs_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                                  int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                                     py__init_obsvar_pdaf : Callable[[int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      float], float],
                                     py__init_obsvar_l_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        int, 
                                                                        float], float],
                                     py__prepoststep_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                      int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]]]
                                    ) -> int:
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency.
    I.e., `pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf` or `pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf_nondiagR`. 
    
    
    Using Hybrid 3DEnVar for DA without post-processing and analysis distribution to forecsat without OMI.
    Here, the background error covariance is hybridised by a static background error covariance, and a flow-dependent background error covariance estimated from ensemble. The 3DVar generates an ensemble mean and the ensemble perturbation is generated by
    LESTKF in this implementation. 
    
    This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_dim_obs_pdaf
    4. py__obs_op_pdaf
    5. py__init_obs_pdaf
    Starting the iterative optimisation:
    6. py__cvt_pdaf
    7. py__cvt_ens_pdaf
    8. py__obs_op_lin_pdaf
    9. py__prodRinvA_pdaf
    10. py__obs_op_adj_pdaf
    11. py__cvt_adj_pdaf
    12. py__cvt_adj_ens_pdaf
    13. core DA algorithm
    After the iterations: 
    14. py__cvt_pdaf
    15. py__cvt_ens_pdaf
    Perform LESTKF: 
    16. py__init_n_domains_p_pdaf
    17. py__init_dim_obs_pdaf
    18. py__obs_op_pdaf (for each ensemble member
    19. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in `pyPDAF.PDAF.init`))
    20. py__init_obsvar_pdaf (if global adaptive forgetting factor is used)
    loop over each local domain:
    21. py__init_dim_l_pdaf
    22. py__init_dim_obs_l_pdaf
    23. py__g2l_obs_pdaf (localise mean ensemble in observation space)
    24. py__init_obs_l_pdaf
    25. py__g2l_obs_pdaf (localise each ensemble member in observation space)
    26. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used)
    27. py__prodRinvA_pdaf
    28. core DA algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f:ndarray[tuple[dim_obs_f], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of the full observation vector

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of observations

        **Callback Returns**

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_put_state_lestkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_dim_obs_pdaf : Callable[[int, int], int],
                            py__obs_op_pdaf : Callable[[int, int, int, 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_obs_l_pdaf : Callable[[int, int, int, 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__prepoststep_pdaf : Callable[[int, int, 
                                                             int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                            py__prodRinvA_l_pdaf : Callable[[int, int, 
                                                             int, int, 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                            py__init_n_domains_p_pdaf : Callable[[int, 
                                                                  int], int],
                            py__init_dim_l_pdaf : Callable[[int, int, int], int],
                            py__init_dim_obs_l_pdaf : Callable[[int, int, 
                                                                int, int], int],
                            py__g2l_obs_pdaf : Callable[[int, int, int, 
                                                         int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                         int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                         int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                            py__init_obsvar_pdaf : Callable[[int, int, 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             float], float],
                            py__init_obsvar_l_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               int, float], float]
                           ) -> int:
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_put_state` or `pyPDAF.PDAF.localomi_put_state_nondiagR`. 
    Using Local ESTKF (error space transform Kalman filter) for DA without post-processing and analysis distribution to forecsat without OMI. This is a domain localisation method. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. The LESTKF is a more efficient equivalent to the LETKF. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    6. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init
    7. py__init_obsvar_pdaf (if global adaptive forgetting factor is used
    loop over each local domain:
    8. py__init_dim_l_pdaf
    9. py__init_dim_obs_l_pdaf
    10. py__g2l_obs_pdaf (localise mean ensemble in observation space)
    11. py__init_obs_l_pdaf
    12. py__g2l_obs_pdaf (localise each ensemble member in observation space
    13. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used
    14. py__prodRinvA_l_pdaf
    15. core DA algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_put_state_letkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                           py__init_dim_obs_pdaf : Callable[[int, int], int],
                           py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                           py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                           py__init_obs_l_pdaf : Callable[[int, int, int, 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                           py__prepoststep_pdaf : Callable[[int, int, int, 
                                                            int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                           py__prodRinvA_l_pdaf : Callable[[int, int, int, 
                                                            int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                           py__init_n_domains_p_pdaf : Callable[[int, int], int],
                           py__init_dim_l_pdaf : Callable[[int, int, int], int],
                           py__init_dim_obs_l_pdaf : Callable[[int, int, 
                                                               int, int], int],
                           py__g2l_obs_pdaf : Callable[[int, int, int, 
                                                        int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                        int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                        int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                           py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            float], float],
                           py__init_obsvar_l_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              int, float], float]
                          ) -> int:
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_put_state` or `pyPDAF.PDAF.localomi_put_state_nondiagR`. 
    Using local ensemble transform Kalman filter for DA without post-processing and analysis distribution to forecsat without OMI. This is a domain localisation method. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    6. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init
    7. py__init_obsvar_pdaf (if global adaptive forgetting factor is used
    loop over each local domain:
    8. py__init_dim_l_pdaf
    9. py__init_dim_obs_l_pdaf
    10. py__g2l_obs_pdaf (localise mean ensemble in observation space)
    11. py__init_obs_l_pdaf
    12. py__g2l_obs_pdaf (localise each ensemble member in observation space
    13. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used
    14. py__prodRinvA_l_pdaf
    15. core DA algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_put_state_lknetf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_dim_obs_pdaf : Callable[[int, int], int],
                            py__obs_op_pdaf : Callable[[int, int, int, 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_obs_l_pdaf : Callable[[int, int, int, 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__prepoststep_pdaf : Callable[[int, int, 
                                                             int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                            py__prodRinvA_l_pdaf : Callable[[int, int, 
                                                             int, int, 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                            py__prodRinvA_hyb_l_pdaf : Callable[[int, int, 
                                                                 int, int, 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 float, 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                            py__init_n_domains_p_pdaf : Callable[[int, 
                                                                  int], int],
                            py__init_dim_l_pdaf : Callable[[int, int, int], int],
                            py__init_dim_obs_l_pdaf : Callable[[int, int, 
                                                                int, int], int],
                            py__g2l_obs_pdaf : Callable[[int, int, int, 
                                                         int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                         int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                         int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                            py__init_obsvar_pdaf : Callable[[int, int, 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             float], float],
                            py__init_obsvar_l_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               int, float], float],
                            py__likelihood_l_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              float], float],
                            py__likelihood_hyb_l_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  float, 
                                                                  float], float]
                           ) -> int:
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_put_state` or `pyPDAF.PDAF.localomi_put_state_lknetf_nondiagR`. 
    This function will is a hybridised LETKF and LNETF for DA without post-processing and analysis distribution to forecsat without OMI. The LNETF computes the distribution up to the second moment similar to KF but using a nonlinear weighting similar to particle filter. This leads to an equal weights assumption for prior ensemble. The hybridisation with LETKF is expected to lead to improved performance for quasi-Gaussian problems.  
    
    This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    6. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init
    7. py__init_obsvar_pdaf (if global adaptive forgetting factor is used
    loop over each local domain:
    8. py__init_dim_l_pdaf
    9. py__init_dim_obs_l_pdaf
    10. py__g2l_obs_pdaf (localise each ensemble member in observation space)
    11. py__init_obs_l_pdaf
    12. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used
    13. py__prodRinvA_pdaf
    14. py__likelihood_l_pdaf
    15. core DA algorithm
    16. py__obs_op_pdaf (only called with `HKN` and `HNK` options called for each ensemble member
    17. py__likelihood_hyb_l_pda
    18. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used
    19. py__prodRinvA_hyb_l_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__prodRinvA_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, dim_ens:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, A_l:ndarray[tuple[dim_obs_l, dim_ens], np.float64], C_l:ndarray[tuple[dim_obs_l, dim_ens], np.float64]]
        Provide product R^-1 A on local analysis domain with hybrid weight

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **dim_ens** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **gamma** : float

            --- Hybrid weight provided by PDAF

        * **A_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance


    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute likelihood

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- nput vector holding the local residual

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    py__likelihood_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, likely_l:float]
        Compute likelihood with hybrid weight

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Input vector holding the local residual

        * **gamma** : float

            --- Hybrid weight provided by PDAF

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_put_state_lnetf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                           py__init_dim_obs_pdaf : Callable[[int, int], int],
                           py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                           py__init_obs_l_pdaf : Callable[[int, int, int, 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                           py__prepoststep_pdaf : Callable[[int, int, int, 
                                                            int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                           py__likelihood_l_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             float], float],
                           py__init_n_domains_p_pdaf : Callable[[int, int], int],
                           py__init_dim_l_pdaf : Callable[[int, int, int], int],
                           py__init_dim_obs_l_pdaf : Callable[[int, int, 
                                                               int, int], int],
                           py__g2l_obs_pdaf : Callable[[int, int, int, 
                                                        int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                        int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                        int], np.ndarray[tuple[int], np.dtype[np.intc]]]
                          ) -> int:
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_put_state` or `pyPDAF.PDAF.localomi_put_state_lnetf_nondiagR`. 
    This function will use Local Nonlinear Ensemble Transform Filter (LNETF) for DA without post-processing and analysis distribution to forecsat without OMI. The nonlinear filter computes the distribution up to the second moment similar to KF but using a nonlinear weighting similar to particle filter. This leads to an equal weights assumption for prior ensemble. 
    
    This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    loop over each local domain:
    6. py__init_dim_l_pdaf
    7. py__init_dim_obs_l_pdaf
    8. py__init_obs_l_pdaf
    9. py__g2l_obs_pdaf (localise each ensemble member in observation space)
    10. py__likelihood_l_pdaf
    11. core DA algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- nput vector holding the local residual

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_put_state_lseik (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                           py__init_dim_obs_pdaf : Callable[[int, int], int],
                           py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                           py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                           py__init_obs_l_pdaf : Callable[[int, int, int, 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                           py__prepoststep_pdaf : Callable[[int, int, int, 
                                                            int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                           py__prodRinvA_l_pdaf : Callable[[int, int, int, 
                                                            int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                           py__init_n_domains_p_pdaf : Callable[[int, int], int],
                           py__init_dim_l_pdaf : Callable[[int, int, int], int],
                           py__init_dim_obs_l_pdaf : Callable[[int, int, 
                                                               int, int], int],
                           py__g2l_obs_pdaf : Callable[[int, int, int, 
                                                        int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                        int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                        int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                           py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            float], float],
                           py__init_obsvar_l_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              int, float], float]
                          ) -> int:
    """It is recommended to use OMI functionalities for fewer user-supplied functions and improved efficiency. I.e., `pyPDAF.PDAF.localomi_put_state` or `pyPDAF.PDAF.localomi_put_state_nondiagR`. 
    Using local singular evolutive interpolated Kalman filter for DA without post-processing and analysis distribution to forecsat without OMI. This is a domain localisation method. This function is usually used in 'flexible' parallelisation. i.e., the ensemble size is larger than the available number of processes. A `pyPDAF.PDAF.get_state` function should be used to post-process and distribute the ensemble to the model after this function. This function should be called at each model time step. 
    
    The function executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__init_n_domains_p_pdaf
    4. py__init_dim_obs_pdaf
    5. py__obs_op_pdaf (for each ensemble member
    6. py__init_obs_pdaf (if global adaptive forgetting factor is used (type_forget=1 in pyPDAF.PDAF.init
    7. py__init_obsvar_pdaf (if global adaptive forgetting factor is used
    loop over each local domain:
    8. py__init_dim_l_pdaf
    9. py__init_dim_obs_l_pdaf
    10. py__g2l_obs_pdaf (localise mean ensemble in observation space)
    11. py__init_obs_l_pdaf
    12. py__g2l_obs_pdaf (localise each ensemble member in observation space
    13. py__init_obsvar_l_pdaf (only called if local adaptive forgetting factor (type_forget=2) is used
    14. py__prodRinvA_l_pdaf
    15. core DA algorithm
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step (negative for call after forecast)

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_ens** : int

            --- size of state ensemble

        * **dim_ens_p** : int

            --- pe-local size of ensemble

        * **dim_obs_p** : int

            --- pe-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state (the array 'state_p' is not generally not initialized in the case of seik. it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- inverse of matrix u

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- pe-local state ensemble


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

