import numpy as np
from typing import Callable

def assimilate_3dvar (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_dim_obs_pdaf : Callable[[int, int], int],
                      py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__prodRinvA_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                      py__cvt_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__cvt_adj_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__obs_op_lin_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__obs_op_adj_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                       int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                      py__next_observation_pdaf : Callable[[int, int, int, 
                                                            float], tuple[int, 
                                                            int, float]]
                     ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.omi_assimilate_3dvar`
    or :func:`pyPDAF.PDAF.omi_assimilate_3dvar_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions
    and improved efficiency.

    3DVar DA for a single step without OMI.
    When 3DVar is used, the background error covariance matrix
    has to be modelled for cotrol variable
    transformation. This is a deterministic filtering
    scheme so no ensemble and
    parallelisation is needed.
    This function should be called at each model time step.

    The function is a combination of
    :func:`pyPDAF.PDAF.put_state_3dvar`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. py__init_obs_pdaf
        6. Iterative optimisation:
            1. py__cvt_pdaf
            2. py__obs_op_lin_pdaf
            3. py__prodRinvA_pdaf
            4. py__obs_op_adj_pdaf
            5. py__cvt_adj_pdaf
            6. core DA algorithm
        7. py__cvt_pdaf
        8. py__prepoststep_state_pdaf
        9. py__distribute_state_pdaf
        10. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by :func:`pyPDAF.PDAF.omi_assimilate_3dvar`
       and :func:`pyPDAF.PDAF.omi_assimilate_3dvar_nondiagR`

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one
                (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def assimilate_en3dvar_estkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__distribute_state_pdaf : Callable[[int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__init_dim_obs_pdaf : Callable[[int, int], int],
                              py__obs_op_pdaf : Callable[[int, int, int, 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__prodRinvA_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                              py__cvt_ens_pdaf : Callable[[int, int, int, 
                                                           int, np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__cvt_adj_ens_pdaf : Callable[[int, int, 
                                                               int, int, 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__obs_op_lin_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__obs_op_adj_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__init_obsvar_pdaf : Callable[[int, int, 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               float], float],
                              py__prepoststep_pdaf : Callable[[int, int, 
                                                               int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                              py__next_observation_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    float], tuple[int, 
                                                                    int, 
                                                                    float]]
                             ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.omi_assimilate_en3dvar_estkf`
    or :func:`pyPDAF.PDAF.omi_assimilate_en3dvar_estkf_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions
    and improved efficiency.

    3DEnVar for a single DA step.
    The background error covariance matrix is estimated
    by an ensemble.
    The 3DEnVar only calculates the analysis of the ensemble mean.
    An ESTKF is used along with 3DEnVar
    to generate ensemble perturbations.
    This function should be called at each model time step.

    The function is a combination of
    :func:`pyPDAF.PDAF.put_state_en3dvar_estkf`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. py__init_obs_pdaf
        6. the iterative optimisation:
            1. py__cvt_ens_pdaf
            2. py__obs_op_lin_pdaf
            3. py__prodRinvA_pdaf
            4. py__obs_op_adj_pdaf
            5. py__cvt_adj_ens_pdaf
            6. core 3DEnVar algorithm
        7. py__cvt_ens_pdaf
        8. ESTKF:
            1. py__init_dim_obs_pdaf
            2. py__obs_op_pdaf (for ensemble mean)
            3. py__init_obs_pdaf
            4. py__obs_op_pdaf (for each ensemble member)
            5. py__init_obsvar_pdaf
               (only relevant for adaptive
               forgetting factor schemes)
            6. py__prodRinvA_pdaf
            7. core ESTKF algorithm
        9. py__prepoststep_state_pdaf
        10. py__distribute_state_pdaf
        11. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.omi_assimilate_en3dvar_estkf`
       and :func:`pyPDAF.PDAF.omi_assimilate_en3dvar_estkf_nondiagR`

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one
                (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def assimilate_en3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__distribute_state_pdaf : Callable[[int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__init_dim_obs_pdaf : Callable[[int, int], int],
                               py__obs_op_pdaf : Callable[[int, int, int, 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__init_obs_pdaf : Callable[[int, int, 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__prodRinvA_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                               py__cvt_ens_pdaf : Callable[[int, int, int, 
                                                            int, np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__cvt_adj_ens_pdaf : Callable[[int, int, 
                                                                int, int, 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__obs_op_lin_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__obs_op_adj_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__init_dim_obs_f_pdaf : Callable[[int, 
                                                                   int], int],
                               py__obs_op_f_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__init_obs_f_pdaf : Callable[[int, int, 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__init_obs_l_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__prodRinvA_l_pdaf : Callable[[int, int, 
                                                                int, int, 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                               py__init_n_domains_p_pdaf : Callable[[int, 
                                                                     int], int],
                               py__init_dim_l_pdaf : Callable[[int, int, 
                                                               int], int],
                               py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int], int],
                               py__g2l_state_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__l2g_state_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__g2l_obs_pdaf : Callable[[int, int, int, 
                                                            int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                            int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                            int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                               py__init_obsvar_pdaf : Callable[[int, int, 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                float], float],
                               py__init_obsvar_l_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  int, 
                                                                  float], float],
                               py__prepoststep_pdaf : Callable[[int, int, 
                                                                int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                               py__next_observation_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     float], tuple[int, 
                                                                     int, 
                                                                     float]],
                               outflag: int) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.localomi_assimilate_en3dvar_lestkf` or
    :func:`pyPDAF.PDAF.localomi_assimilate_en3dvar_lestkf_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions
    and improved efficiency.

    3DEnVar for a single DA step where the ensemble anomaly
    is generated by LESTKF.
    The background error covariance matrix is
    estimated by ensemble.
    The 3DEnVar only calculates the analysis of the ensemble mean.
    An LESTKF is used to generate ensemble perturbations.
    This function should be called at each model time step.

    The function is a combination of
    :func:`pyPDAF.PDAF.put_state_en3dvar_lestkf`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. py__init_obs_pdaf
        6. Starting the iterative optimisation:
            1. py__cvt_ens_pdaf
            2. py__obs_op_lin_pdaf
            3. py__prodRinvA_pdaf
            4. py__obs_op_adj_pdaf
            5. py__cvt_adj_ens_pdaf
            6. core DA algorithm
        7. py__cvt_ens_pdaf
        8. Perform LESTKF:
            1. py__init_n_domains_p_pdaf
            2. py__init_dim_obs_pdaf
            3. py__obs_op_pdaf
               (for each ensemble member)
            4. py__init_obs_pdaf
               (if global adaptive forgetting factor is used
               `type_forget=1` in :func:`pyPDAF.PDAF.init`)
            5. py__init_obsvar_pdaf
               (if global adaptive forgetting factor is used)
            6. loop over each local domain:
                1. py__init_dim_l_pdaf
                2. py__init_dim_obs_l_pdaf
                3. py__g2l_state_pdaf
                4. py__g2l_obs_pdaf
                   (localise mean ensemble in observation space)
                5. py__init_obs_l_pdaf
                6. py__g2l_obs_pdaf
                   (localise each ensemble member
                   in observation space)
                7. py__init_obsvar_l_pdaf
                   (only called if local
                   adaptive forgetting factor
                   `type_forget=2` is used)
                8. py__prodRinvA_l_pdaf
                9. core DA algorithm
                10. py__l2g_state_pdaf
        9. py__prepoststep_state_pdaf
        10. py__distribute_state_pdaf
        11. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_assimilate_en3dvar_lestkf`
       and
       :func:`pyPDAF.PDAF.localomi_assimilate_en3dvar_lestkf_nondiagR`

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one
                (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Acts as the full observation operator on some state vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f:ndarray[tuple[dim_obs_f], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of the full observation vector

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of observations

        **Callback Returns**

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def assimilate_enkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_dim_obs_pdaf : Callable[[int, int], int],
                     py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                     py__add_obs_err_pdaf : Callable[[int, int, np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                     py__init_obs_covar_pdaf : Callable[[int, int, int, 
                                                         float, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         bool], tuple[float, 
                                                         bool]],
                     py__next_observation_pdaf : Callable[[int, int, int, 
                                                           float], tuple[int, 
                                                           int, float]]
                    ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.omi_assimilate_global`
    or :func:`pyPDAF.PDAF.omi_assimilate_enkf_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions
    and improved efficiency.

    Stochastic EnKF (ensemble Kalman filter) [1]_ for a single DA step without OMI.
    This function should be called at each model time step. 

    The function is a combination of
    :func:`pyPDAF.PDAF.put_state_enkf` and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf (for ensemble mean)
        5. py__add_obs_err_pdaf
        6. py__init_obs_pdaf
        7. py__init_obscovar_pdaf
        8. py__obs_op_pdaf (for each ensemble member)
        9. core DA algorithm
        10. py__prepoststep_state_pdaf
        11. py__distribute_state_pdaf
        12. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.omi_assimilate_global`
       and :func:`pyPDAF.PDAF.omi_assimilate_enkf_nondiagR`

    References
    ----------
    .. [1] Evensen, G. (1994), 
           Sequential data assimilation with a nonlinear
           quasi-geostrophic model
           using Monte Carlo methods to forecast error statistics,
           J. Geophys. Res., 99(C5), 1014310162,
           doi:10.1029/94JC00572.

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__add_obs_err_pdaf : Callable[step:int, dim_obs_p:int, C_p:ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]]
        Add obs error covariance R to HPH in EnKF

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Dimension of observation vector

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            --- Matrix to that observation covariance R is added

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            --- Matrix to that observation covariance R is added


    py__init_obs_covar_pdaf : Callable[step:int, dim_obs:int, dim_obs_p:int, covar:float, obs_p:ndarray[tuple[dim_obs_p], np.float64], isdiag:bool]
        Initialize obs. error cov. matrix R in EnKF

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs** : int

            --- Global size of observation vector

        * **dim_obs_p** : int

            --- Size of process-local observation vector

        * **covar** : float

            --- Observation error covariance matrix

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Process-local vector of observations

        * **isdiag** : bool

            --- 

        **Callback Returns**

        * **covar**:float

            --- Observation error covariance matrix

        * **isdiag**:bool

            --- 


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def assimilate_estkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_dim_obs_pdaf : Callable[[int, int], int],
                      py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                       int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                      py__prodRinvA_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                      py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       float], float],
                      py__next_observation_pdaf : Callable[[int, int, int, 
                                                            float], tuple[int, 
                                                            int, float]]
                     ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.omi_assimilate_global`
    or :func:`pyPDAF.PDAF.omi_assimilate_global_nondiagR`
    instead of this function.

    OMI functions need fewer user-supplied functions
    and improve DA efficiency.

    This function calls ESTKF
    (error space transform Kalman filter) [1]_.
    The ESTKF is a more efficient equivalent to the ETKF.

    The function should be called at each model time step.
    The function is a combination of
    :func:`pyPDAF.PDAF.put_state_estkf`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf (for ensemble mean)
        5. py__init_obs_pdaf
        6. py__obs_op_pdaf (for each ensemble member)
        7. py__init_obsvar_pdaf (only relevant
           for adaptive forgetting factor schemes)
        8. py__prodRinvA_pdaf
        9. core DA algorithm
        10. py__prepoststep_state_pdaf
        11. py__distribute_state_pdaf
        12. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.omi_assimilate_global`
       and :func:`pyPDAF.PDAF.omi_assimilate_global_nondiagR`

    References
    ----------
    .. [1] Nerger, L., Janji, T., Schrter, J., Hiller, W. (2012).
           A unification of ensemble square root Kalman filters.
           Monthly Weather Review, 140, 2335-2345.
           doi:10.1175/MWR-D-11-00102.1

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 HV

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one
                (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def assimilate_etkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_dim_obs_pdaf : Callable[[int, int], int],
                     py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                     py__prodRinvA_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                     py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      float], float],
                     py__next_observation_pdaf : Callable[[int, int, int, 
                                                           float], tuple[int, 
                                                           int, float]]
                    ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.omi_assimilate_global`
    or :func:`pyPDAF.PDAF.omi_assimilate_global_nondiagR`.

    PDAFlocal-OMI modules require fewer
    user-supplied functions and improved efficiency.

    Using ETKF (ensemble transform
    Kalman filter) [1]_ for a single DA step without OMI.
    The implementation is baed on [2]_.

    This function should be called at each model time step.
    The function is a combination of 
    :func:`pyPDAF.PDAF.put_state_etkf` and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf (for ensemble mean)
        5. py__init_obs_pdaf
        6. py__obs_op_pdaf (for each ensemble member)
        7. py__init_obsvar_pdaf (only relevant for
           adaptive forgetting factor schemes)
        8. py__prodRinvA_pdaf
        9. core DA algorithm
        10. py__prepoststep_state_pdaf
        11. py__distribute_state_pdaf
        12. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.omi_assimilate_global`
       and :func:`pyPDAF.PDAF.omi_assimilate_global_nondiagR`

    References
    ----------
    .. [1] Bishop, C. H., B. J. Etherton, and S. J. Majumdar (2001)
           Adaptive Sampling with the Ensemble
           Transform Kalman Filter.
           Part I: Theoretical Aspects. Mon. Wea. Rev.,
           129, 420436,
           doi: 10.1175/1520-0493(2001)129<0420:ASWTET>2.0.CO;2.
    .. [2] Nerger, L., Janji, T., Schrter, J., Hiller, W. (2012).
           A unification of ensemble square root Kalman filters.
           Monthly Weather Review, 140, 2335-2345.
           doi:10.1175/MWR-D-11-00102.1

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 HV

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one
                (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def assimilate_hyb3dvar_estkf (py__collect_state_pdaf : Callable[[int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__distribute_state_pdaf : Callable[[int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__init_dim_obs_pdaf : Callable[[int, int], int],
                               py__obs_op_pdaf : Callable[[int, int, int, 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__init_obs_pdaf : Callable[[int, int, 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__prodRinvA_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                               py__cvt_ens_pdaf : Callable[[int, int, int, 
                                                            int, np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__cvt_adj_ens_pdaf : Callable[[int, int, 
                                                                int, int, 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__cvt_pdaf : Callable[[int, int, int, 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__cvt_adj_pdaf : Callable[[int, int, int, 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__obs_op_lin_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__obs_op_adj_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__init_obsvar_pdaf : Callable[[int, int, 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                float], float],
                               py__prepoststep_pdaf : Callable[[int, int, 
                                                                int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                               py__next_observation_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     float], tuple[int, 
                                                                     int, 
                                                                     float]]
                              ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.omi_assimilate_hyb3dvar_estkf`
    or :func:`pyPDAF.PDAF.omi_assimilate_hyb3dvar_estkf_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions
    and improved efficiency.

    Hybrid 3DEnVar for a single DA step where
    the background error covariance is hybridised by
    a static background error covariance,
    and a flow-dependent background error covariance
    estimated from ensemble.
    The 3DVar generates an ensemble mean and
    the ensemble perturbation is generated by
    ESTKF in this implementation.
    This function should be called at each model time step.

    The function is a combination of
    :func:`pyPDAF.PDAF.put_state_hyb3dvar_estkf`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. py__init_obs_pdaf
        6. the iterative optimisation:
            1. py__cvt_pdaf
            2. py__cvt_ens_pdaf
            3. py__obs_op_lin_pdaf
            4. py__prodRinvA_pdaf
            5. py__obs_op_adj_pdaf
            6. py__cvt_adj_pdaf
            7. py__cvt_adj_ens_pdaf
            8. core 3DEnVar algorithm
        7. py__cvt_pdaf
        8. py__cvt_ens_pdaf
        9. Perform ESTKF:
            1. py__init_dim_obs_pdaf
            2. py__obs_op_pdaf
               (for ensemble mean)
            3. py__init_obs_pdaf
            4. py__obs_op_pdaf
               (for each ensemble member)
            5. py__init_obsvar_pdaf
               (only relevant for adaptive
               forgetting factor schemes)
            6. py__prodRinvA_pdaf
            7. core ESTKF algorithm
        10. py__prepoststep_state_pdaf
        11. py__distribute_state_pdaf
        12. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.omi_assimilate_hyb3dvar_estkf` and
       :func:`pyPDAF.PDAF.omi_assimilate_hyb3dvar_estkf_nondiagR`.

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one
                (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def assimilate_hyb3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__distribute_state_pdaf : Callable[[int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__init_dim_obs_pdaf : Callable[[int, 
                                                                  int], int],
                                py__obs_op_pdaf : Callable[[int, int, int, 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__init_obs_pdaf : Callable[[int, int, 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__prodRinvA_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                py__cvt_ens_pdaf : Callable[[int, int, 
                                                             int, int, 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__cvt_adj_ens_pdaf : Callable[[int, int, 
                                                                 int, int, 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__cvt_pdaf : Callable[[int, int, int, 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__cvt_adj_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__obs_op_lin_pdaf : Callable[[int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__obs_op_adj_pdaf : Callable[[int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__init_dim_obs_f_pdaf : Callable[[int, 
                                                                    int], int],
                                py__obs_op_f_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__init_obs_f_pdaf : Callable[[int, int, 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__init_obs_l_pdaf : Callable[[int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__prodRinvA_l_pdaf : Callable[[int, int, 
                                                                 int, int, 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                py__init_n_domains_p_pdaf : Callable[[int, 
                                                                      int], int],
                                py__init_dim_l_pdaf : Callable[[int, int, 
                                                                int], int],
                                py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    int], int],
                                py__g2l_state_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__l2g_state_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__g2l_obs_pdaf : Callable[[int, int, 
                                                             int, int, 
                                                             np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                             int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                             int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                                py__init_obsvar_pdaf : Callable[[int, int, 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 float], float],
                                py__init_obsvar_l_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   int, 
                                                                   float], float],
                                py__prepoststep_pdaf : Callable[[int, int, 
                                                                 int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                 int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                py__next_observation_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      float], tuple[int, 
                                                                      int, 
                                                                      float]]
                               ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.localomi_assimilate_hyb3dvar_lestkf` or
    :func:`pyPDAF.PDAF.localomi_assimilate_hyb3dvar_lestkf_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions
    and improved efficiency.

    Hybrid 3DEnVar for a single DA step where
    the background error covariance is hybridised by
    a static background error covariance,
    and a flow-dependent background error covariance
    estimated from ensemble.
    The 3DVar generates an ensemble mean and
    the ensemble perturbation is generated by
    LESTKF in this implementation.
    This function should be called at each model time step.

    The function is a combination of
    :func:`pyPDAF.PDAF.put_state_hyb3dvar_lestkf`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. py__init_obs_pdaf
        6. The iterative optimisation:
            1. py__cvt_pdaf
            2. py__cvt_ens_pdaf
            3. py__obs_op_lin_pdaf
            4. py__prodRinvA_pdaf
            5. py__obs_op_adj_pdaf
            6. py__cvt_adj_pdaf
            7. py__cvt_adj_ens_pdaf
            8. core DA algorithm
        7. py__cvt_pdaf
        8. py__cvt_ens_pdaf
        9. Perform LESTKF:
            1. py__init_n_domains_p_pdaf
            2. py__init_dim_obs_pdaf
            3. py__obs_op_pdaf
               (for each ensemble member)
            4. py__init_obs_pdaf
               (if global adaptive forgetting factor
               `type_forget=1` in :func:`pyPDAF.PDAF.init`)
            5. py__init_obsvar_pdaf
               (if global adaptive forgetting factor is used)
            6. loop over each local domain:
                1. py__init_dim_l_pdaf
                2. py__init_dim_obs_l_pdaf
                3. py__g2l_state_pdaf
                4. py__g2l_obs_pdaf
                   (localise mean ensemble in observation space)
                5. py__init_obs_l_pdaf
                6. py__g2l_obs_pdaf
                   (localise each ensemble member
                   in observation space)
                7. py__init_obsvar_l_pdaf
                   (only called if local adaptive forgetting
                   factor `type_forget=2` is used)
                8. py__prodRinvA_l_pdaf
                9. core DA algorithm
                10. py__l2g_state_pdaf
        10. py__prepoststep_state_pdaf
        11. py__distribute_state_pdaf
        12. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_assimilate_hyb3dvar_lestkf`
       and
       :func:`pyPDAF.PDAF.localomi_assimilate_hyb3dvar_lestkf_nondiagR`

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one
                (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f:ndarray[tuple[dim_obs_f], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of the full observation vector

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of observations

        **Callback Returns**

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def assimilate_lenkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_dim_obs_pdaf : Callable[[int, int], int],
                      py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                       int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                      py__localize_covar_pdaf : Callable[[int, int, np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]]], tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                      py__add_obs_err_pdaf : Callable[[int, int, np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                      py__init_obs_covar_pdaf : Callable[[int, int, int, 
                                                          float, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          bool], tuple[float, 
                                                          bool]],
                      py__next_observation_pdaf : Callable[[int, int, int, 
                                                            float], tuple[int, 
                                                            int, float]]
                     ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.omi_assimilate_lenkf`
    or :func:`pyPDAF.PDAF.omi_assimilate_lenkf_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions
    and improved efficiency.

    Stochastic EnKF (ensemble Kalman filter)
    with covariance localisation [1]_
    for a single DA step without OMI.

    This is the only scheme for covariance localisation in PDAF.

    This function should be called at each model time step.
    The function is a combination of
    :func:`pyPDAF.PDAF.put_state_lenkf`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf (for each ensemble member)
        5. py__localize_pdaf
        6. py__add_obs_err_pdaf
        7. py__init_obs_pdaf
        8. py__init_obscovar_pdaf
        9. py__obs_op_pdaf (repeated to reduce storage)
        10. core DA algorith
        11. py__prepoststep_state_pdaf
        12. py__distribute_state_pdaf
        13. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.omi_assimilate_lenkf`
       and :func:`pyPDAF.PDAF.omi_assimilate_lenkf_nondiagR`

    References
    ----------
    .. [1] Houtekamer, P. L., and H. L. Mitchell (1998): 
           Data Assimilation Using an Ensemble Kalman Filter
           Technique.
           Mon. Wea. Rev., 126, 796811,
           doi: 10.1175/1520-0493(1998)126<0796:DAUAEK>2.0.CO;2.

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__localize_covar_pdaf : Callable[dim_p:int, dim_obs:int, hp_p:ndarray[tuple[dim_obs, dim_p], np.float64], hph:ndarray[tuple[dim_obs, dim_obs], np.float64]]
        Apply localization to HP and HPH^T

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_obs** : int

            --- number of observations

        * **hp_p** : ndarray[tuple[dim_obs, dim_p], np.float64]

            --- pe local part of matrix hp

        * **hph** : ndarray[tuple[dim_obs, dim_obs], np.float64]

            --- matrix hph

        **Callback Returns**

        * **hp_p** : ndarray[tuple[dim_obs, dim_p], np.float64]

            --- pe local part of matrix hp

        * **hph** : ndarray[tuple[dim_obs, dim_obs], np.float64]

            --- matrix hph


    py__add_obs_err_pdaf : Callable[step:int, dim_obs_p:int, C_p:ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]]
        Add obs error covariance R to HPH in EnKF

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Dimension of observation vector

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            --- Matrix to that observation covariance R is added

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            --- Matrix to that observation covariance R is added


    py__init_obs_covar_pdaf : Callable[step:int, dim_obs:int, dim_obs_p:int, covar:float, obs_p:ndarray[tuple[dim_obs_p], np.float64], isdiag:bool]
        Initialize obs. error cov. matrix R in EnKF

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs** : int

            --- Global size of observation vector

        * **dim_obs_p** : int

            --- Size of process-local observation vector

        * **covar** : float

            --- Observation error covariance matrix

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Process-local vector of observations

        * **isdiag** : bool

            --- 

        **Callback Returns**

        * **covar**:float

            --- Observation error covariance matrix

        * **isdiag**:bool

            --- 


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def assimilate_lestkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__init_dim_obs_pdaf : Callable[[int, int], int],
                       py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__init_obs_l_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__prepoststep_pdaf : Callable[[int, int, int, 
                                                        int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                        int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                       py__prodRinvA_l_pdaf : Callable[[int, int, int, 
                                                        int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                       py__init_n_domains_p_pdaf : Callable[[int, int], int],
                       py__init_dim_l_pdaf : Callable[[int, int, int], int],
                       py__init_dim_obs_l_pdaf : Callable[[int, int, int, 
                                                           int], int],
                       py__g2l_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__l2g_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__g2l_obs_pdaf : Callable[[int, int, int, int, 
                                                    np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                    int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                    int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                       py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        float], float],
                       py__init_obsvar_l_pdaf : Callable[[int, int, int, 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          int, float], float],
                       py__next_observation_pdaf : Callable[[int, int, 
                                                             int, float], tuple[int, 
                                                             int, float]]
                      ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.localomi_assimilate`
    or :func:`pyPDAF.PDAF.localomi_assimilate_nondiagR`.

    PDAFlocal-OMI modules require fewer user-supplied
    functions and improved efficiency.

    Local ESTKF (error space transform Kalman filter) [1]_ for a single DA step without OMI.
    The LESTKF is a more efficient equivalent to the LETKF.

    This function should be called at each model time step.
    The function is a combination of
    :func:`pyPDAF.PDAF.put_state_lestkf`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. py__init_obs_pdaf
           (if global adaptive forgetting factor
           `type_forget=1` is used
           in :func:`pyPDAF.PDAF.init`)
        7. py__init_obsvar_pdaf (if global adaptive
           forgetting factor is used)
        8. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. py__g2l_state_pdaf
            4. py__g2l_obs_pdaf (localise mean ensemble
               in observation space)
            5. py__init_obs_l_pdaf
            6. py__g2l_obs_pdaf
               (localise each ensemble member
               in observation space)
            7. py__init_obsvar_l_pdaf
               (only called if local adaptive
               forgetting factor `type_forget=2` is used)
            8. py__prodRinvA_l_pdaf
            9. core DA algorithm
            10. py__l2g_state_pdaf
        9. py__prepoststep_state_pdaf
        10. py__distribute_state_pdaf
        11. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_assimilate`
       and :func:`pyPDAF.PDAF.localomi_assimilate_nondiagR`

    References
    ----------
    .. [1] Nerger, L., Janji, T., Schrter, J., Hiller, W. (2012).
           A unification of ensemble square root Kalman filters.
           Monthly Weather Review, 140, 2335-2345.
           doi:10.1175/MWR-D-11-00102.1

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def assimilate_letkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_dim_obs_pdaf : Callable[[int, int], int],
                      py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_obs_l_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                       int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                      py__prodRinvA_l_pdaf : Callable[[int, int, int, int, 
                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                      py__init_n_domains_p_pdaf : Callable[[int, int], int],
                      py__init_dim_l_pdaf : Callable[[int, int, int], int],
                      py__init_dim_obs_l_pdaf : Callable[[int, int, int, 
                                                          int], int],
                      py__g2l_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__l2g_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__g2l_obs_pdaf : Callable[[int, int, int, int, 
                                                   np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                   int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                   int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                      py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       float], float],
                      py__init_obsvar_l_pdaf : Callable[[int, int, int, 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         int, float], float],
                      py__next_observation_pdaf : Callable[[int, int, int, 
                                                            float], tuple[int, 
                                                            int, float]]
                     ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.localomi_assimilate`
    or :func:`pyPDAF.PDAF.localomi_assimilate_nondiagR`.

    PDAFlocal-OMI modules require fewer user-supplied
    functions and improved efficiency.

    Local ensemble transform Kalman filter (LETKF) [1]_ for a single DA step without OMI.
    Implementation is based on [2]_.
    Note that the LESTKF is a more efficient equivalent
    to the LETKF.

    This function should be called at each model time step.
    The function is a combination of
    :func:`pyPDAF.PDAF.put_state_letkf`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. py__init_obs_pdaf
           (if global adaptive forgetting factor
           `type_forget=1` is used
           in :func:`pyPDAF.PDAF.init`)
        7. py__init_obsvar_pdaf (if global adaptive
           forgetting factor is used)
        8. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. py__g2l_state_pdaf
            4. py__g2l_obs_pdaf (localise mean ensemble
               in observation space)
            5. py__init_obs_l_pdaf
            6. py__g2l_obs_pdaf (localise each ensemble member
               in observation space)
            7. py__init_obsvar_l_pdaf
               (only called if local adaptive forgetting factor
               `type_forget=2` is used)
            8. py__prodRinvA_l_pdaf
            9. core DA algorithm
            10. py__l2g_state_pdaf
        9. py__prepoststep_state_pdaf
        10. py__distribute_state_pdaf
        11. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_assimilate`
       and :func:`pyPDAF.PDAF.localomi_assimilate_nondiagR`

    References
    ----------
    .. [1] Hunt, B. R., Kostelich, E. J., & Szunyogh, I. (2007).
           Efficient data assimilation for spatiotemporal chaos:
           A local ensemble transform Kalman filter. 
           Physica D: Nonlinear Phenomena, 230(1-2), 112-126.
    .. [2] Nerger, L., Janji, T., Schrter, J., Hiller, W. (2012).
           A unification of ensemble square root Kalman filters.
           Monthly Weather Review, 140, 2335-2345.
           doi:10.1175/MWR-D-11-00102.1

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def assimilate_lnetf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_dim_obs_pdaf : Callable[[int, int], int],
                      py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_obs_l_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                       int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                      py__likelihood_l_pdaf : Callable[[int, int, int, 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        float], float],
                      py__init_n_domains_p_pdaf : Callable[[int, int], int],
                      py__init_dim_l_pdaf : Callable[[int, int, int], int],
                      py__init_dim_obs_l_pdaf : Callable[[int, int, int, 
                                                          int], int],
                      py__g2l_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__l2g_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__g2l_obs_pdaf : Callable[[int, int, int, int, 
                                                   np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                   int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                   int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                      py__next_observation_pdaf : Callable[[int, int, int, 
                                                            float], tuple[int, 
                                                            int, float]]
                     ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.localomi_assimilate`
    or :func:`pyPDAF.PDAF.localomi_assimilate_lnetf_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions
    and improved efficiency.

    Local Nonlinear Ensemble Transform Filter (LNETF) [1]_
    for a single DA step.
    The nonlinear filter computes the distribution up to
    the second moment similar to Kalman filters but
    it uses a nonlinear weighting similar to
    particle filters. This leads to an equal weights assumption
    for the prior ensemble at each step.
    This function should be called at each model time step.

    The function is a combination of
    :func:`pyPDAF.PDAF.put_state_lnetf`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. py__g2l_state_pdaf
            4. py__init_obs_l_pdaf
            5. py__g2l_obs_pdaf (localise each ensemble
               member in observation space)
            6. py__likelihood_l_pdaf
            7. core DA algorithm
            8. py__l2g_state_pdaf
        7. py__prepoststep_state_pdaf
        8. py__distribute_state_pdaf
        9. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_assimilate`
       and :func:`pyPDAF.PDAF.localomi_assimilate_lnetf_nondiagR`

    References
    ----------
    .. [1] Tdter, J., and B. Ahrens, 2015:
           A second-order exact ensemble square root filter
           for nonlinear data assimilation. Mon. Wea. Rev.,
           143, 13471367, doi:10.1175/MWR-D-14-00108.1.

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- nput vector holding the local residual

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def assimilate_lknetf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__init_dim_obs_pdaf : Callable[[int, int], int],
                       py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__init_obs_l_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__prepoststep_pdaf : Callable[[int, int, int, 
                                                        int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                        int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                       py__prodRinvA_l_pdaf : Callable[[int, int, int, 
                                                        int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                       py__prodRinvA_hyb_l_pdaf : Callable[[int, int, int, 
                                                            int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            float, np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                       py__init_n_domains_p_pdaf : Callable[[int, int], int],
                       py__init_dim_l_pdaf : Callable[[int, int, int], int],
                       py__init_dim_obs_l_pdaf : Callable[[int, int, int, 
                                                           int], int],
                       py__g2l_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__l2g_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__g2l_obs_pdaf : Callable[[int, int, int, int, 
                                                    np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                    int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                    int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                       py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        float], float],
                       py__init_obsvar_l_pdaf : Callable[[int, int, int, 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          int, float], float],
                       py__likelihood_l_pdaf : Callable[[int, int, int, 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         float], float],
                       py__likelihood_hyb_l_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             float, float], float],
                       py__next_observation_pdaf : Callable[[int, int, 
                                                             int, float], tuple[int, 
                                                             int, float]]
                      ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.localomi_assimilate`
    or :func:`pyPDAF.PDAF.localomi_assimilate_lknetf_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions
    and improved efficiency.

    A hybridised LETKF and LNETF [1]_ for a single DA step.
    The LNETF computes the distribution up to
    the second moment similar to Kalman filters but
    using a nonlinear weighting similar to
    particle filters. This leads to an equal weights
    assumption for the prior ensemble.
    The hybridisation with LETKF is expected to lead to
    improved performance for quasi-Gaussian problems.
    The function should be called at each model step.

    The function is a combination of
    :func:`pyPDAF.PDAF.put_state_lknetf`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf
           (for each ensemble member)
        6. py__init_obs_pdaf
           (if global adaptive forgetting factor `type_forget=1`
           is used in :func:`pyPDAF.PDAF.init`)
        7. py__init_obsvar_pdaf (if global adaptive
           forgetting factor is used)
        8. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. py__g2l_state_pdaf
            4. py__g2l_obs_pdaf
               (localise each ensemble member
               in observation space)
            5. py__init_obs_l_pdaf
            6. py__init_obsvar_l_pdaf
               (only called if local adaptive forgetting
               factor `type_forget=2` is used)
            7. py__prodRinvA_pdaf
            8. py__likelihood_l_pdaf
            9. core DA algorithm
            10. py__l2g_state_pdaf
        9. py__obs_op_pdaf
           (only called with `HKN` and `HNK` options
           called for each ensemble member)
        10. py__likelihood_hyb_l_pda
        11. py__init_obsvar_l_pdaf
            (only called if local adaptive forgetting
            factor `type_forget=2` is used)
        12. py__prodRinvA_hyb_l_pdaf
        13. py__prepoststep_state_pdaf
        14. py__distribute_state_pdaf
        15. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_assimilate`
       and :func:`pyPDAF.PDAF.localomi_assimilate_lknetf_nondiagR`

    References
    ----------
    .. [1] Nerger, L.. (2022) 
           Data assimilation for nonlinear systems with
           a hybrid nonlinear Kalman ensemble transform filter.
           Q J R Meteorol Soc, 620640. doi:10.1002/qj.4221

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__prodRinvA_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, dim_ens:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, A_l:ndarray[tuple[dim_obs_l, dim_ens], np.float64], C_l:ndarray[tuple[dim_obs_l, dim_ens], np.float64]]
        Provide product R^-1 A on local analysis domain with hybrid weight

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **dim_ens** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **gamma** : float

            --- Hybrid weight provided by PDAF

        * **A_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance


    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute likelihood

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- nput vector holding the local residual

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    py__likelihood_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, likely_l:float]
        Compute likelihood with hybrid weight

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Input vector holding the local residual

        * **gamma** : float

            --- Hybrid weight provided by PDAF

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def assimilate_lseik (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_dim_obs_pdaf : Callable[[int, int], int],
                      py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_obs_l_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                       int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                      py__prodRinvA_l_pdaf : Callable[[int, int, int, int, 
                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                      py__init_n_domains_p_pdaf : Callable[[int, int], int],
                      py__init_dim_l_pdaf : Callable[[int, int, int], int],
                      py__init_dim_obs_l_pdaf : Callable[[int, int, int, 
                                                          int], int],
                      py__g2l_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__l2g_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__g2l_obs_pdaf : Callable[[int, int, int, int, 
                                                   np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                   int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                   int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                      py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       float], float],
                      py__init_obsvar_l_pdaf : Callable[[int, int, int, 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         int, float], float],
                      py__next_observation_pdaf : Callable[[int, int, int, 
                                                            float], tuple[int, 
                                                            int, float]]
                     ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.localomi_assimilate`
    or :func:`pyPDAF.PDAF.localomi_assimilate_nondiagR`.

    PDAF-OMI modules require fewer user-supplied
    functions and improved efficiency.

    Local singular evolutive interpolated Kalman filter [1]_
    for a single DA step.
    This function should be called at each model time step.

    The function is a combination of
    :func:`pyPDAF.PDAF.put_state_lseik` and :func:`pyPDAF.PDAF.get_state`

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. py__init_obs_pdaf
           (if global adaptive forgetting factor `type_forget=1`
           is used in :func:`pyPDAF.PDAF.init`)
        7. py__init_obsvar_pdaf
           (if global adaptive forgetting factor is used)
        8. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. py__g2l_state_pdaf
            4. py__g2l_obs_pdaf (localise mean ensemble
               in observation space)
            5. py__init_obs_l_pdaf
            6. py__g2l_obs_pdaf
               (localise each ensemble member in observation space)
            7. py__init_obsvar_l_pdaf
               (only called if local adaptive forgetting
               factor `type_forget=2` is used)
            8. py__prodRinvA_l_pdaf
            9. core DA algorithm
            10. py__l2g_state_pdaf
        9. py__prepoststep_state_pdaf
        10. py__distribute_state_pdaf
        11. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_assimilate`
       and :func:`pyPDAF.PDAF.localomi_assimilate_nondiagR`

    References
    ----------
    .. [1] Pham, D. T., Verron, J., & Roubaud, M. C. (1998).
           A singular evolutive extended Kalman filter
           for data assimilation
           in oceanography. Journal of Marine systems,
           16(3-4), 323-340.

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def assimilate_netf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_dim_obs_pdaf : Callable[[int, int], int],
                     py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                     py__likelihood_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     float], float],
                     py__next_observation_pdaf : Callable[[int, int, int, 
                                                           float], tuple[int, 
                                                           int, float]]
                    ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.omi_assimilate_global`
    or :func:`pyPDAF.PDAF.omi_assimilate_nonlin_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions
    and improved efficiency.

    This function will use Nonlinear Ensemble
    Transform Filter (NETF) [1]_ 
    for a single DA step. The nonlinear filter
    computes the distribution up to
    the second moment similar to KF but using
    a nonlinear weighting similar to
    particle filter. This leads to an equal
    weights assumption for prior ensemble.
    The function should be called at each model step.

    The function is a combination of
    :func:`pyPDAF.PDAF.put_state_netf`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__init_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. py__likelihood_pdaf
        7. core DA algorithm
        8. py__prepoststep_state_pdaf
        9. py__distribute_state_pdaf
        10. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.omi_assimilate_global`
       and :func:`pyPDAF.PDAF.omi_assimilate_nonlin_nondiagR`

    References
    ----------
    .. [1] Tdter, J., and B. Ahrens, 2015:
           A second-order exact ensemble square root filter
           for nonlinear data assimilation. Mon. Wea. Rev.,
           143, 13471367, doi:10.1175/MWR-D-14-00108.1.

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__likelihood_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], resid:ndarray[tuple[dim_obs_p], np.float64], likely:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **resid** : ndarray[tuple[dim_obs_p], np.float64]

            --- Input vector holding the residual

        * **likely** : float

            --- Output value of the likelihood

        **Callback Returns**

        * **likely**:float

            --- Output value of the likelihood


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def assimilate_pf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                   py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                   py__init_dim_obs_pdaf : Callable[[int, int], int],
                   py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                   py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                   py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                    int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                    int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                   py__likelihood_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                   float], float],
                   py__next_observation_pdaf : Callable[[int, int, int, 
                                                         float], tuple[int, 
                                                         int, float]]
                  ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.omi_assimilate_global`
    or :func:`pyPDAF.PDAF.omi_assimilate_nonlin_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions
    and improved efficiency.

    This function will use particle filter for a single DA step.
    This is a fully nonlinear filter, and may require
    a high number of ensemble members.
    A review of particle filter can be found at [1]_.
    The function should be called at each model step.

    The function is a combination of
    :func:`pyPDAF.PDAF.put_state_pf`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__init_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. py__likelihood_pdaf
        7. core DA algorithm
        8. py__prepoststep_state_pdaf
        9. py__distribute_state_pdaf
        10. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.omi_assimilate_global`
       and :func:`pyPDAF.PDAF.omi_assimilate_nonlin_nondiagR`

    References
    ----------
    .. [1] Van Leeuwen, P. J., Knsch, H. R.,
           Nerger, L., Potthast, R., & Reich, S. (2019).
           Particle filters for highdimensional geoscience
           applications:
           A review. Quarterly Journal of the Royal
           Meteorological Society, 145(723), 2335-2365.

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__likelihood_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], resid:ndarray[tuple[dim_obs_p], np.float64], likely:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **resid** : ndarray[tuple[dim_obs_p], np.float64]

            --- Input vector holding the residual

        * **likely** : float

            --- Output value of the likelihood

        **Callback Returns**

        * **likely**:float

            --- Output value of the likelihood


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def assimilate_seek (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_dim_obs_pdaf : Callable[[int, int], int],
                     py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                     py__prodRinvA_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                     py__next_observation_pdaf : Callable[[int, int, int, 
                                                           float], tuple[int, 
                                                           int, float]]
                    ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.omi_assimilate_global`
    or :func:`pyPDAF.PDAF.omi_assimilate_global_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions
    and improved efficiency.

    This function will use singular evolutive
    extended Kalman filter [1]_ for a single DA step.
    This is a deterministic Kalman filter.
    The function should be called at each model step.

    The function is a combination of
    :func:`pyPDAF.PDAF.put_state_seek`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf (for ensemble mean)
        5. py__init_obs_pdaf
        6. py__obs_op_pdaf (for each ensemble member)
        7. py__prodRinvA_pdaf
        8. core DA algorithm
        9. py__prepoststep_state_pdaf
        10. py__distribute_state_pdaf
        11. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.omi_assimilate_global`
       and :func:`pyPDAF.PDAF.omi_assimilate_global_nondiagR`

    References
    ----------
    .. [1] Pham, D. T., Verron, J., & Roubaud, M. C. (1998).
           A singular evolutive extended Kalman filter
           for data assimilation
           in oceanography. Journal of Marine systems,
           16(3-4), 323-340.

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 HV

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one
                (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def assimilate_seik (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_dim_obs_pdaf : Callable[[int, int], int],
                     py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                     py__prodRinvA_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                     py__next_observation_pdaf : Callable[[int, int, int, 
                                                           float], tuple[int, 
                                                           int, float]]
                    ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.omi_assimilate_global`
    or :func:`pyPDAF.PDAF.omi_assimilate_global_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions
    and improved efficiency.

    This function will use singular evolutive
    interpolated Kalman filter [1]_ for a single DA step.
    The function should be called at each model step.

    The function is a combination of
    :func:`pyPDAF.PDAF.put_state_seik`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf (for ensemble mean)
        5. py__init_obs_pdaf
        6. py__obs_op_pdaf (for each ensemble member)
        7. py__init_obsvar_pdaf (only relevant for
           adaptive forgetting factor schemes)
        8. py__prodRinvA_pdaf
        9. core DA algorithm
        10. py__prepoststep_state_pdaf
        11. py__distribute_state_pdaf
        12. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.omi_assimilate_global`
       and :func:`pyPDAF.PDAF.omi_assimilate_global_nondiagR`

    References
    ----------
    .. [1] Pham, D. T., Verron, J., & Roubaud, M. C. (1998).
           A singular evolutive extended Kalman
           filter for data assimilation
           in oceanography. Journal of Marine systems,
           16(3-4), 323-340.

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 HV

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one
                (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def assimilate_prepost (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                        py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                        py__prepoststep_pdaf : Callable[[int, int, int, 
                                                         int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                         int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                        py__next_observation_pdaf : Callable[[int, int, 
                                                              int, float], tuple[int, 
                                                              int, float]]
                       ) -> int:
    r"""It is used to preprocess and postprocess of the ensemble.

    No DA is performed in this function.
    Compared to :func:`pyPDAF.PDAF.prepost`,
    this function sets assimilation flag, 
    which means that it is acted as an assimilation in PDAF.

    The function is a combination of
    :func:`pyPDAF.PDAF.put_state_prepost`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf (preprocess, step < 0)
        3. py__prepoststep_state_pdaf (postprocess, step > 0)
        4. py__distribute_state_pdaf
        5. py__next_observation_pdaf

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def deallocate () -> None:
    r"""Finalise the PDAF systems
    including freeing some of
    the memory used by PDAF.

    This function cannot be used to
    free all allocated PDAF memory.
    Therefore, one should not use
    :func:`pyPDAF.PDAF.init` afterwards.

    """
    ...

def diag_effsample (weights: np.ndarray[tuple[int], np.dtype[np.float64]]
                   ) -> float:
    r"""Calculating the effective sample size of a particle filter.

    Based on [1]_, it is defined as the
    inverse of the sum of the squared particle filter weights:
    :math:`N_{eff} = \frac{1}{\sum_{i=1}^{N} w_i^2}`
    where :math:`w_i` is the weight of particle with index i.
    and :math:`N` is the number of particles.

    If the :math:`N_{eff}=N`, all weights are identical,
    and the filter has no influence on the analysis.
    If :math:`N_{eff}=0`, the filter is collapsed.

    This is typically called during the analysis step
    of a particle filter,
    e.g. in the analysis step of NETF and LNETF.

    References
    ----------
    .. [1] Doucet, A., de Freitas, N., Gordon, N. (2001). 
           An Introduction to Sequential Monte Carlo Methods.
           In: Doucet, A., de Freitas, N., Gordon, N. (eds)
           Sequential Monte Carlo Methods in Practice.
           Statistics for Engineering and Information Science.
           Springer, New York, NY.
           https://doi.org/10.1007/978-1-4757-3437-9_1

    Parameters
    ----------
    weights : ndarray[tuple[dim_sample], np.float64]
        weights of the particles
        The array dimension `dim_sample` is Number of particles

    Returns
    -------
    effSample : float
        effecfive sample/particle size
    """
    ...

def diag_ensstats (element: int,state: np.ndarray[tuple[int], np.dtype[np.float64]],
                   ens: np.ndarray[tuple[int, int], np.dtype[np.float64]]
                  ) -> tuple[float, float, int]:
    r"""Computing the skewness and kurtosis of
    the ensemble of a given element of the state vector.

    The definition used for kurtosis follows that used by [1]_.

    References
    ----------
    .. [1] Lawson, W. G., & Hansen, J. A. (2004).
           Implications of stochastic and deterministic
           filters as ensemble-based
           data assimilation methods in varying regimes
           of error growth.
           Monthly weather review, 132(8), 1966-1981.

    Parameters
    ----------
    element : int
        Index of state vector/ensemble element to be used.
        If element=0, mean values over all elements are computed
    state : ndarray[tuple[dim], np.float64]
        State vector (typically ensemble mean)
        The array dimension `dim` is PE-local state dimension
    ens : ndarray[tuple[dim, dim_ens], np.float64]
        State ensemble
        The 1st-th dimension dim is PE-local state dimension
        The 2nd-th dimension dim_ens is Ensemble size

    Returns
    -------
    skewness : float
        Skewness of ensemble
    kurtosis : float
        Kurtosis of ensemble
    status : int
        Status flag (0=success)
    """
    ...

def diag_histogram (ncall: int,element: int,state: np.ndarray[tuple[int], np.dtype[np.float64]],
                    ens: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                    hist: np.ndarray[tuple[int], np.dtype[np.intc]]) -> tuple[np.ndarray[tuple[int], np.dtype[np.intc]], float, int]:
    r"""Computing the rank histogram of an ensemble.

    A rank histogram is used to diagnose
    the reliability of the ensemble [1]_.
    A perfectly reliable ensemble should have
    a uniform rank histogram.

    The function can be called in the
    pre/poststep routine of PDAF
    both before and after the analysis step
    to collect the histogram information.

    References
    ----------
    .. [1] Hamill, T. M. (2001).
           Interpretation of rank histograms
           for verifying ensemble forecasts.
           Monthly Weather Review, 129(3), 550-560.

    Parameters
    ----------
    ncall : int
        The number of calls used to increment the histogram and
        is needed to compute the delta-measure that
        describes the deviation from the ideal histogram.
    element : int
        Element of vector used for histogram. If element=0, all elements are used
    state : ndarray[tuple[dim], np.float64]
        Assumed truth
        The array dimension `dim` is State dimension
    ens : ndarray[tuple[dim, dim_ens], np.float64]
        Ensemble
        The 1st-th dimension dim is State dimension
        The 2nd-th dimension dim_ens is Ensemble size
    hist : ndarray[tuple[dim_ens+1], np.intc]
        Histogram about the state

    Returns
    -------
    hist : ndarray[tuple[dim_ens+1], np.intc]
         Histogram about the state

    delta : float
        deviation measure from flat histogram.
        It must be initialised to be 0
    status : int
        Status flag (0=success)
    """
    ...

def eofcovar (dim_fields: np.ndarray[tuple[int], np.dtype[np.intc]],offsets: np.ndarray[tuple[int], np.dtype[np.intc]],
              remove_mstate: int,do_mv: int,states: np.ndarray[tuple[int, int], np.dtype[np.float64]],
              meanstate: np.ndarray[tuple[int], np.dtype[np.float64]],verbose: int
             ) -> tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], np.ndarray[tuple[int], np.dtype[np.float64]], 
              np.ndarray[tuple[int], np.dtype[np.float64]], np.ndarray[tuple[int, int], np.dtype[np.float64]], 
              np.ndarray[tuple[int], np.dtype[np.float64]], int]:
    r"""EOF analysis of an ensemble of state vectors by singular value decomposition.

    Typically, this function is used with
    :func:`pyPDAF.PDAF.SampleEns`
    to generate an ensemble of a chosen size 
    (up to the number of EOFs plus one).

    Here, the function performs a singular value decomposition
    of the ensemble anomaly of the input matrix,
    which is usually an ensemble formed by state vectors
    at multiple time steps.
    The singular values and corresponding singular vectors
    can be used to
    construct a covariance matrix.
    This can be used as the initial error covariance
    for the initial ensemble.

    A multivariate scaling can be performed to ensure that all fields in the state vectors have unit variance.

    It can be useful to store more EOFs than one finally
    might want to use to have the flexibility
    to carry the ensemble size.

    See also
    `PDAF webpage <https://pdaf.awi.de/trac/wiki/EnsembleGeneration>`_

    Parameters
    ----------
    dim_fields : ndarray[tuple[nfields], np.intc]
        Size of each model field. This argument is effective only when `do_mv = 1`.
        Each model field, e.g., sea surface temperature, or 3D sea salinity,
        can be 2D or 3D with different number of grid points. Each element
        of the array specifies the size of each model field.
        The array dimension `nfields` is the number of model fields in state vector.
        For example, if the state vector contains temperature and humidity,
        `nfields=2`. This variable is effective only when `do_mv = 1`.
    offsets : ndarray[tuple[nfields], np.intc]
        Starting position of each field.
        This variable is effective only when `do_mv = 1`.
        For example, if the state vector contains temperature and humidity,
        this array specifies the first index of the physical field in the state vector.
        Following Fortran notation, the offset values start from 1.
        The array dimension `nfields` is the number of model fields in state vector.
        For example, if the state vector contains temperature and humidity,
        `nfields=2`. This variable is effective only when `do_mv = 1`.
    remove_mstate : int
        Switch for only computing EOF of the ensemble anomaly.
        
        This option can be used if `states` are not centred on 0, i.e., anomaly values.
            0. do nothing
            1. remove the mean of `states` over `nstates` dimension
               before EOF computation
    do_mv : int
        Switch for multivariate scaling
            0. do nothing
            1. Each model field are scaled by its standard deviation
               such that each model field has unit standard deviation.
               This option makes use of `nfields`, `dim_fields` and `offsets` arguments.
    states : ndarray[tuple[dim_state, nstates], np.float64]
        An ensemble of state vectors.
        This argument should ideally be the anomalies of an ensemble,
        and each member is from a different model time.
        However, one can set `remove_mstate = 1` if this is not an ensemble anomaly.
        The 1st-th dimension dim_state is the dimension of state vector.
        The 2nd-th dimension nstates is the number of state vectors, typically number of different time steps, or number of ensemble members.
    meanstate : ndarray[tuple[dim_state], np.float64]
        Mean state
        The returned value equlas to the input unless `remove_mstate=1`
        The array dimension `dim_state` is the dimension of state vector.
    verbose : int
        Verbosity flag

    Returns
    -------
    states : ndarray[tuple[dim_state, nstates], np.float64]
         An ensemble of state vectors.
        This argument should ideally be the anomalies of an ensemble,
        and each member is from a different model time.
        However, one can set `remove_mstate = 1` if this is not an ensemble anomaly.

        The 1st-th dimension dim_state is the dimension of state vector.
        The 2nd-th dimension nstates is the number of state vectors, typically number of different time steps, or number of ensemble members.
    stddev : ndarray[tuple[nfields], np.float64]
         Standard deviation of each model field in `states`.
        If `do_mv = 1`, stddev should be `1.0`.

        The array dimension `nfields` is the number of model fields in state vector.
        For example, if the state vector contains temperature and humidity,
        `nfields=2`. This variable is effective only when `do_mv = 1`.
    svals : ndarray[tuple[nstates], np.float64]
         Singular values of `states` scaled by :math:`\frac{1}{\sqrt{nstates-1}}`.

        The array dimension `nstates` is the number of state vectors, typically number of different time steps, or number of ensemble members.
    svec : ndarray[tuple[dim_state, nstates], np.float64]
         Singular vectors of `states`

        The 1st-th dimension dim_state is the dimension of state vector.
        The 2nd-th dimension nstates is the number of state vectors, typically number of different time steps, or number of ensemble members.
    meanstate : ndarray[tuple[dim_state], np.float64]
         Mean state
        The returned value equlas to the input unless `remove_mstate=1`

        The array dimension `dim_state` is the dimension of state vector.
    status : int
        Status flag
    """
    ...

def gather_dim_obs_f (dim_obs_p: int) -> int:
    r"""Gathers the dimension of observation vector
    across multiple local domains/filter processors.

    This function is typically used in deprecated PDAF functions
    without OMI.

    This function can be used in the user-supplied function of
    :func:`py__init_dim_obs_f_pdaf`,
    but it is recommended to use :func:`pyPDAF.PDAF.omi_gather_obs`
    with OMI.

    This function does two things:
        1. Receiving observation dimension on each local process.
        2. Gather the total dimension of observation
           across local process and the displacement of PE-local
           observations relative to the total observation vector

    The dimension of observations are used to allocate observation
    arrays. Therefore, it must be used before
    :func:`pyPDAF.PDAF.gather_obs_f` or
    :func:`pyPDAF.PDAF.gather_obs_f2`.

    Parameters
    ----------
    dim_obs_p : int
        PE-local observation dimension

    Returns
    -------
    dim_obs_f : int
        Full observation dimension
    """
    ...

def gather_obs_f (obs_p: np.ndarray[tuple[int], np.dtype[np.float64]],dimobs_f: int
                 ) -> tuple[np.ndarray[tuple[int], np.dtype[np.float64]], int]:
    r"""In the local filters (LESKTF, LETKF, LSEIK, LNETF) this function returns the total observation vector from process-local observations. The function depends on `pyPDAF.PDAF.gather_dim_obs_f` which defines the process-local observation dimensions. Further, the related routine `pyPDAF.PDAF.gather_obs_f2` is used to
    gather the associated 2D observation coordinates
    

    Parameters
    ----------
    obs_p : ndarray[tuple[dimobs_p], np.float64]
        PE-local vector
        The array dimension `dimobs_p` is dimensions of PE local obs
    dimobs_f : int
        dimension of full gathered obs

    Returns
    -------
    obs_f : ndarray[tuple[dimobs_f], np.float64]
         Full gathered vector

        The array dimension `dimobs_f` is dimension of full gathered obs
    status : int
        Status flag:
        (0) no error;
        (1) when PDAF_gather_dim_obs_f not executed before
    """
    ...

def gather_obs_f2 (coords_p: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                   dimobs_f: int) -> tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], int]:
    r"""In the local filters (LESKTF, LETKF, LSEIK, LNETF)
    this function returns the full observation coordinates from process-local observation coordinates. The function depends on `pyPDAF.PDAF.gather_dim_obs_f` which defines the process-local observation dimensions. Further, the related routine `pyPDAF.PDAF.gather_obs_f` is used to gather the associated observation vectors. 
    
    The routine is typically used in the routines `py__init_dim_obs_f_pdaf` if the analysis step of the local filters is parallelized.

    Parameters
    ----------
    coords_p : ndarray[tuple[nrows, dimobs_p], np.float64]
        PE-local array
        The 1st-th dimension nrows is Number of rows in array
        The 2nd-th dimension dimobs_p is dimensions of PE local obs
    dimobs_f : int
        dimension of full gathered obs

    Returns
    -------
    coords_f : ndarray[tuple[nrows, dimobs_f], np.float64]
         Full gathered array

        The 1st-th dimension nrows is Number of rows in array
        The 2nd-th dimension dimobs_f is dimension of full gathered obs
    status : int
        Status flag:
        (0) no error;
        (1) when PDAF_gather dim_obs_f not executed before
    """
    ...

def generate_obs (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                  py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                  py__init_dim_obs_pdaf : Callable[[int, int], int],
                  py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                  py__get_obs_f_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                  py__init_obserr_f_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                  py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                   int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                   int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                  py__next_observation_pdaf : Callable[[int, int, int, 
                                                        float], tuple[int, 
                                                        int, float]]
                 ) -> int:
    r"""Generation of synthetic observations based on
    given error statistics and observation operator.

    When diagonal observation error covariance matrix is used,
    it is recommended to use
    :func:`pyPDAF.PDAF.omi_generate_obs` functionalities
    for fewer user-supplied functions and improved efficiency.

    The generated synthetic observations are based on
    each member of model forecast.
    Therefore, an ensemble of observations can be obtained.
    In a typical experiment,
    one may only need one ensemble member.
    The implementation strategy is similar to
    an assimilation step. This means that, 
    one can reuse many user-supplied functions for
    assimilation and observation generation.

    The function is a combination of
    :func:`pyPDAF.PDAF.put_state_generate_obs`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pda
        5. py__init_obserr_f_pdaf
        6. py__get_obs_f_pdaf
        7. py__prepoststep_state_pdaf
        8. py__distribute_state_pdaf
        9. py__next_observation_pdaf

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__get_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f:ndarray[tuple[dim_obs_f], np.float64]]
        Provide observation vector to user

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of the full observation vector

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of synthetic observations (process-local)

        **Callback Returns**

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of synthetic observations (process-local)


    py__init_obserr_f_pdaf : Callable[step:int, dim_obs_f:int, obs_f:ndarray[tuple[dim_obs_f], np.float64], obserr_f:ndarray[tuple[dim_obs_f], np.float64]]
        Initialize vector of observation error standard deviations

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Full dimension of observation vector

        * **obs_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full observation vector

        * **obserr_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full observation error stddev

        **Callback Returns**

        * **obserr_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full observation error stddev


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def get_assim_flag () -> int:
    r"""This function returns the flag that indicates if the DA is performed in the last time step. It only works for online DA systems. 


    Returns
    -------
    did_assim : int
        Flag: (1) for assimilation; (0) else
    """
    ...

def get_ensstats () -> tuple[np.ndarray[tuple[int, ], np.dtype[float]], np.ndarray[tuple[int, ], np.dtype[float]], 
                   int]:
    r"""This is a diagnotics function for LKNETF which returns the skewness and kutosis used there. 


    Returns
    -------
    dims : ndarray[tuple[1], np.intc]
         dimension of pointer

    c_skew_ptr : ndarray[float]
        Skewness array
    c_kurt_ptr : ndarray[float]
        kurtosis array
    status : int
        Status flag
    """
    ...

def get_localfilter () -> int:
    r"""This function returns whether a local filter is used. 


    Returns
    -------
    lfilter : int
        Whether the filter is domain-localized (1) or not (0)
    """
    ...

def get_memberid (memberid: int) -> int:
    r"""This function returns the ensemble member id on the current process. 
    For example, it can be called during the ensemble integration if ensemble-specific forcing is applied. It can also be used in the user-supplied functions such as `py__collect_state_pdaf` and `py__distribute_state_pdaf`.

    Parameters
    ----------
    memberid : int
        Index in the local ensemble

    Returns
    -------
    memberid : int
        Index in the local ensemble
    """
    ...

def get_obsmemberid (memberid: int) -> int:
    r"""This function returns the ensemble member id when observation operator is being applied. 
    This function is used specifically for user-supplied function `py__obs_op_pdaf`.

    Parameters
    ----------
    memberid : int
        Index in the local observed ensemble

    Returns
    -------
    memberid : int
        Index in the local observed ensemble
    """
    ...

def get_smootherens () -> tuple[np.ndarray[tuple[int, ], np.dtype[float]], int, int]:
    r"""This function returns the smoothed ensemble in earlier time steps. It is only used when the smoother options is used .


    Returns
    -------
    c_sens_point : ndarray[float]
        A smoother array
    maxlag : int
        Number of past timesteps processed in sens
    dims : ndarray[tuple[3], np.intc]
         dimension of pointer

    status : int
        Status flag
    """
    ...

def get_state (steps: int,doexit: int,py__next_observation_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            float], tuple[int, 
                                                                            int, 
                                                                            float]],
               py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
               py__prepoststep_pdaf : Callable[[int, int, int, int, int, 
                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
               flag: int) -> tuple[int, float, int, int]:
    r"""Distributing analysis state vector to an array.

    The primary purpose of this function is to distribute
    the analysis state vector to the model.
    This is attained by the user-supplied function
    :func:`py__distribute_state_pdaf`.
    One can also use this function to get the state vector
    for other purposes, e.g. to write the state vector to a file.

    In this function, the user-supplied function
    :func:`py__next_observation_pdaf` is executed
    to specify the number of forecast time steps
    until the next assimilation step.
    One can also use the user-supplied function to
    end the assimilation.

    In an online DA system, this function also execute
    the user-supplied function :func:`py__prepoststep_state_pdaf`,
    when this function is first called. The purpose of this design
    is to call this function right after :func:`pyPDAF.PDAF.init`
    to process the initial ensemble before using it to
    initialse model forecast. This user-supplied function
    will not be called afterwards.

    This function is also used in flexible parallel system
    where the number of ensemble members are greater than
    the parallel model tasks. In this case, this function
    is called multiple times to distribute the analysis ensemble.

    User-supplied function are executed in the following sequence:

        1. py__prepoststep_state_pdaf
           (only in online system when first called)
        2. py__distribute_state_pdaf
        3. py__next_observation_pdaf

    Parameters
    ----------
    steps : int
        number of forecast time steps for next assimilation
        The input value can be an arbitrary integer
    doexit : int
        Whether to exit from forecasts
    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Processing the ensemble when this function is called
        by the first time in an online PDAF system
        before distributing to the model to initialise the next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    flag : int
        Status flag

    Returns
    -------
    steps : int
        number of forecast time steps for next assimilation
        The input value can be an arbitrary integer
    time : float
        current model time
    doexit : int
        Whether to exit from forecasts
    flag : int
        Status flag
    """
    ...

def init (filtertype: int,subtype: int,stepnull: int,param_int: np.ndarray[tuple[int], np.dtype[np.intc]],
          param_real: np.ndarray[tuple[int], np.dtype[np.float64]],COMM_model: int,
          COMM_filter: int,COMM_couple: int,task_id: int,n_modeltasks: int,
          in_filterpe: bool,py__init_ens_pdaf : Callable[[int, int, int, 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          int]],
          in_screen: int) -> tuple[np.ndarray[tuple[int], np.dtype[np.intc]], np.ndarray[tuple[int], np.dtype[np.float64]], 
                         int]:
    r"""This function initialises the PDAF system.

    It is called once at the beginning of the assimilation.

    The function specifies the type of DA methods,
    parameters of the filters, the MPI communicators,
    and other parallel options.
    The filter options including `filtertype`, `subtype`,
    `param_int`, and `param_real`
    are introduced in
    `PDAF filter options wiki page <https://pdaf.awi.de/trac/wiki/AvailableOptionsforInitPDAF>`_.
    Note that the size of `param_int` and `param_real` depends on
    the filter type and subtype. However, for most filters,
    they require at least the state vector size and ensemble size
    for `param_int`, and the forgetting factor for `param_real`.

    The MPI communicators asked by this function depends on
    the parallelisation strategy.
    For the default parallelisation strategy, the user
    can use the parallelisation module
    provided under in `example directory <https://github.com/yumengch/pyPDAF/blob/main/example>`_
    without modifications.
    The parallelisation can differ based on online and offline cases.
    Users can also refer to `parallelisation documentation <https://yumengch.github.io/pyPDAF/parallel.html>`_ for
    explanations or modifications.

    This function also asks for a user-supplied function
    :func:`py__init_ens_pdaf`.
    This function is designed to provides an initial ensemble
    to the internal PDAF ensemble array.
    The internal PDAF ensemble then can be distributed to
    initialise the model forecast using
    :func:`pyPDAF.PDAF.get_state`.
    This user-supplied function can be empty if the model
    has already read the ensemble from restart files.

    Parameters
    ----------
    filtertype : int
        type of filter
    subtype : int
        sub-type of filter
    stepnull : int
        initial time step of assimilation
    param_int : ndarray[tuple[dim_pint], np.intc]
        integer filter parameters
        in all available filters,
        the size of state vector, and
        number of ensemble members must be given;
        additional required parameters are filter specific
        See `pyPDAF filter parameters <https://pdaf.awi.de/trac/wiki/AvailableOptionsforInitPDAF>`_
        The array dimension `dim_pint` is dimension of `param_int`
    param_real : ndarray[tuple[dim_preal], np.float64]
        real/float filter parameters
        the forgetting factor must be given;
        additional required parameters are filter specific
        See `pyPDAF filter parameters <https://pdaf.awi.de/trac/wiki/AvailableOptionsforInitPDAF>`_
        The array dimension `dim_preal` is dimension of `param_real`
    COMM_model : int
        model MPI communicator
    COMM_filter : int
        filter MPI communicator
    COMM_couple : int
        coupling MPI communicator
    task_id : int
        index of parallel model task on current process;
        the index starts from 1
    n_modeltasks : int
        number of parallel model tasks
        See [pyPDAF parallel strategy](https://yumengch.github.io/pyPDAF/parallel.html)
    in_filterpe : bool
        True if the current PE is a filter PE else False
    py__init_ens_pdaf : Callable[filtertype:int, dim_p:int, dim_ens:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[:, :], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        initialise PDAF internal ensemble array `ens_p`;
        for SEEK, one also need to fill `uinv`;
        this function is called by processes
        with `filterpe = .true.` only

        **Callback Parameters**

        * **filtertype** : int

            --- filter type given in PDAF_init

        * **dim_p** : int

            --- PE-local state dimension given by PDAF_init

        * **dim_ens** : int

            --- number of ensemble members

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state
                This array must be filled with the initial
                state of the model for SEEK, but it is not
                used for ensemble-based filters.
                
                One can still make use of this array within
                this function.

        * **uinv** : ndarray[tuple[:, :], np.float64]

            --- This array is the inverse of matrix
                formed by right singular vectors of error
                covariance matrix of ensemble perturbations.
                
                This array has to be filled in SEEK, but it is
                not used for ensemble-based filters.
                Nevertheless, one can still make use of this
                array within this function e.g.,
                for generating an initial ensemble perturbation
                from a given covariance matrix.
                
                Dimension of this array is determined by the
                filter type.
                
                - (dim_ens, dim_ens) for (L)ETKF, (L)NETF, (L)KNETF, and SEEK
                - (dim_ens - 1, dim_ens - 1) for (L)SEIK, (L)ESTKF, and 3DVar using ensemble
                - (1, 1) for (L)EnKF, particle filters and gen_obs

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state
                This array must be filled with the initial
                state of the model for SEEK, but it is not
                used for ensemble-based filters.
                
                One can still make use of this array within
                this function.

        * **uinv** : ndarray[tuple[:, :], np.float64]

            --- This array is the inverse of matrix
                formed by right singular vectors of error
                covariance matrix of ensemble perturbations.
                
                This array has to be filled in SEEK, but it is
                not used for ensemble-based filters.
                Nevertheless, one can still make use of this
                array within this function e.g.,
                for generating an initial ensemble perturbation
                from a given covariance matrix.
                
                Dimension of this array is determined by the
                filter type.
                
                - (dim_ens, dim_ens) for (L)ETKF, (L)NETF, (L)KNETF, and SEEK
                - (dim_ens - 1, dim_ens - 1) for (L)SEIK, (L)ESTKF, and 3DVar using ensemble
                - (1, 1) for (L)EnKF, particle filters and gen_obs

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag**:int

            --- pdaf status flag


    in_screen : int
        Verbosity level of PDAF screen output

    Returns
    -------
    param_int : ndarray[tuple[dim_pint], np.intc]
         integer filter parameters
        in all available filters,
        the size of state vector, and
        number of ensemble members must be given;
        additional required parameters are filter specific
        See `pyPDAF filter parameters <https://pdaf.awi.de/trac/wiki/AvailableOptionsforInitPDAF>`_

        The array dimension `dim_pint` is dimension of `param_int`
    param_real : ndarray[tuple[dim_preal], np.float64]
         real/float filter parameters
        the forgetting factor must be given;
        additional required parameters are filter specific
        See `pyPDAF filter parameters <https://pdaf.awi.de/trac/wiki/AvailableOptionsforInitPDAF>`_

        The array dimension `dim_preal` is dimension of `param_real`
    flag : int
        Status flag, 0: no error, error codes:
    """
    ...

def local_weight (wtype: int,rtype: int,cradius: float,sradius: float,distance: float,
                  A: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                  var_obs: float,verbose: int) -> float:
    r"""The function is used for localisation in the analysis step of a filter and computes a weight according to the specified distance and the settings for the localising function. Typically the function is called in `py__prodRinvA_l_pdaf` in the domain-localised filters. Also, the function is typically called for the LEnKF in the `py__localize_covar_pdaf`. 
    This function is usually only used in user-codes that do not use PDAF-OMI.

    Parameters
    ----------
    wtype : int
        Type of weight function
    rtype : int
        Type of regulated weighting
    cradius : float
        Cut-off radius (check `PDAF-OMI wiki <https://pdaf.awi.de/trac/wiki/OMI_observation_modules#init_dim_obs_l_OBSTYPE>`_)
    sradius : float
        Support radius (check `PDAF-OMI wiki <https://pdaf.awi.de/trac/wiki/OMI_observation_modules#init_dim_obs_l_OBSTYPE>`_)
    distance : float
        Distance to observation
    A : ndarray[tuple[nrows, ncols], np.float64]
        Input matrix
        The 1st-th dimension nrows is Number of rows in matrix A
        The 2nd-th dimension ncols is Number of columns in matrix A
    var_obs : float
        Observation variance
    verbose : int
        Verbosity flag

    Returns
    -------
    weight : float
        Weights
    """
    ...

def print_info (printtype: int) -> None:
    r"""Printing the wallclock time and memory measured by PDAF.

    This is called at the end of the DA program.

    Parameters
    ----------
    printtype : int
        Type of information to be printed
            - printtype=1: Basic timers
            - printtype=3: Timers showing the time spent in the different call-back routines
              (this variant was added with PDAF 1.15)
            - printtype=4: More detailed timers about parts of the filter algorithm
              (before PDAF 1.15, this was timer level 3)
            - printtype=5: Very detailed timers about various operations in the filter algorithm
              (before PDAF 1.15, this was timer level 4)
            - printtype=10: Memory usage (The value 10 is valid since PDAF V2.1. For older versions use 2)
                - Memory required for the ensemble array,
                  state vector, and transform matrix
                - Memory required by the analysis step
                - Memory required to perform the ensemble transformation
    """
    ...

def put_state_3dvar (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_dim_obs_pdaf : Callable[[int, int], int],
                     py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__prodRinvA_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                     py__cvt_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__cvt_adj_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__obs_op_lin_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__obs_op_adj_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]]]
                    ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.omi_put_state_3dvar`
    or :func:`pyPDAF.PDAF.omi_put_state_3dvar_nondiagR`.

    PDAF-OMI modules require fewer user-supplied
    functions and improved efficiency.

    3DVar DA for a single DA step.

    Compared to :func:`pyPDAF.PDAF.assimilate_3dvar`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will not
    be assigned by user-supplied functions as well.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    When 3DVar is used, the background error covariance matrix
    has to be modelled for cotrol variable transformation.
    This is a deterministic filtering scheme so no ensemble
    and parallelisation is needed.
    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. py__init_obs_pdaf
        6. Iterative optimisation:
            1. py__cvt_pdaf
            2. py__obs_op_lin_pdaf
            3. py__prodRinvA_pdaf
            4. py__obs_op_adj_pdaf
            5. py__cvt_adj_pdaf
            6. core DA algorithm
        7. py__cvt_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.omi_put_state_3dvar`
       and :func:`pyPDAF.PDAF.omi_put_state_3dvar_nondiagR`

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one
                (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def put_state_en3dvar_estkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__init_dim_obs_pdaf : Callable[[int, int], int],
                             py__obs_op_pdaf : Callable[[int, int, int, 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__prodRinvA_pdaf : Callable[[int, int, int, 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                             py__cvt_ens_pdaf : Callable[[int, int, int, 
                                                          int, np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__cvt_adj_ens_pdaf : Callable[[int, int, 
                                                              int, int, 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__obs_op_lin_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__obs_op_adj_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__init_obsvar_pdaf : Callable[[int, int, 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              float], float],
                             py__prepoststep_pdaf : Callable[[int, int, 
                                                              int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]]]]
                            ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.omi_put_state_en3dvar_estkf`
    or :func:`pyPDAF.PDAF.omi_put_state_en3dvar_estkf_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions
    and improved efficiency.

    3DEnVar for a single DA step.

    Compared to :func:`pyPDAF.PDAF.assimilate_en3dvar_estkf`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will not be
    assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    The background error covariance matrix is
    estimated by an ensemble.
    The 3DEnVar only calculates the analysis of the ensemble mean.
    An ESTKF is used along with 3DEnVar to
    generate ensemble perturbations.
    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. py__init_obs_pdaf
        6. the iterative optimisation:
            1. py__cvt_ens_pdaf
            2. py__obs_op_lin_pdaf
            3. py__prodRinvA_pdaf
            4. py__obs_op_adj_pdaf
            5. py__cvt_adj_ens_pdaf
            6. core 3DEnVar algorithm
        7. py__cvt_ens_pdaf
        8. ESTKF:
            1. py__init_dim_obs_pdaf
            2. py__obs_op_pdaf (for ensemble mean)
            3. py__init_obs_pdaf
            4. py__obs_op_pdaf (for each ensemble member)
            5. py__init_obsvar_pdaf
               (only relevant for adaptive forgetting factor schemes)
            6. py__prodRinvA_pdaf
            7. core ESTKF algorithm

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.omi_put_state_en3dvar_estkf`
       and :func:`pyPDAF.PDAF.omi_put_state_en3dvar_estkf_nondiagR`

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one
                (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def put_state_en3dvar_lestkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__init_dim_obs_pdaf : Callable[[int, int], int],
                              py__obs_op_pdaf : Callable[[int, int, int, 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__prodRinvA_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                              py__cvt_ens_pdaf : Callable[[int, int, int, 
                                                           int, np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__cvt_adj_ens_pdaf : Callable[[int, int, 
                                                               int, int, 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__obs_op_lin_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__obs_op_adj_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__init_dim_obs_f_pdaf : Callable[[int, 
                                                                  int], int],
                              py__obs_op_f_pdaf : Callable[[int, int, int, 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__init_obs_f_pdaf : Callable[[int, int, 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__init_obs_l_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__prodRinvA_l_pdaf : Callable[[int, int, 
                                                               int, int, 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                              py__init_n_domains_p_pdaf : Callable[[int, 
                                                                    int], int],
                              py__init_dim_l_pdaf : Callable[[int, int, 
                                                              int], int],
                              py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  int], int],
                              py__g2l_state_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__l2g_state_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__g2l_obs_pdaf : Callable[[int, int, int, 
                                                           int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                           int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                           int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                              py__init_obsvar_pdaf : Callable[[int, int, 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               float], float],
                              py__init_obsvar_l_pdaf : Callable[[int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 int, float], float],
                              py__prepoststep_pdaf : Callable[[int, int, 
                                                               int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]]]]
                             ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf`
    or :func:`pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions
    and improved efficiency.

    3DEnVar for a single DA step without post-processing,
    distributing analysis, and setting next observation step,
    where the ensemble anomaly is generated by LESTKF.

    Compared to :func:`pyPDAF.PDAF.assimilate_en3dvar_lestkf`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    The background error covariance matrix is estimated by ensemble.
    The 3DEnVar only calculates the analysis of the ensemble mean.
    An LESTKF is used to generate ensemble perturbations.
    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. py__init_obs_pdaf
        6. Starting the iterative optimisation:
            1. py__cvt_ens_pdaf
            2. py__obs_op_lin_pdaf
            3. py__prodRinvA_pdaf
            4. py__obs_op_adj_pdaf
            5. py__cvt_adj_ens_pdaf
            6. core DA algorithm
        7. py__cvt_ens_pdaf
        8. Perform LESTKF:
            1. py__init_n_domains_p_pdaf
            2. py__init_dim_obs_pdaf
            3. py__obs_op_pdaf
               (for each ensemble member)
            4. py__init_obs_pdaf
               (if global adaptive forgetting factor is used
               `type_forget=1` in :func:`pyPDAF.PDAF.init`)
            5. py__init_obsvar_pdaf
               (if global adaptive forgetting factor is used)
            6. loop over each local domain:
                1. py__init_dim_l_pdaf
                2. py__init_dim_obs_l_pdaf
                3. py__g2l_state_pdaf
                4. py__g2l_obs_pdaf
                   (localise mean ensemble in observation space)
                5. py__init_obs_l_pdaf
                6. py__g2l_obs_pdaf
                   (localise each ensemble member in observation space)
                7. py__init_obsvar_l_pdaf
                   (only called if local adaptive forgetting factor
                   `type_forget=2` is used)
                8. py__prodRinvA_l_pdaf
                9. core DA algorithm
                10. py__l2g_state_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf`
       and :func:`pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf_nondiagR`

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one
                (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f:ndarray[tuple[dim_obs_f], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of the full observation vector

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of observations

        **Callback Returns**

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def put_state_enkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__init_dim_obs_pdaf : Callable[[int, int], int],
                    py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                    py__add_obs_err_pdaf : Callable[[int, int, np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                    py__init_obs_covar_pdaf : Callable[[int, int, int, 
                                                        float, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        bool], tuple[float, 
                                                        bool]]
                   ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.omi_put_state_global`
    or :func:`pyPDAF.PDAF.omi_put_state_enkf_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions
    and improved efficiency.

    Stochastic EnKF (ensemble Kalman filter) [1]_ for a single DA step without OMI.

    Compared to :func:`pyPDAF.PDAF.assimilate_enkf`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    This function should be called at each model time step. 

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf (for ensemble mean)
        5. py__add_obs_err_pdaf
        6. py__init_obs_pdaf
        7. py__init_obscovar_pdaf
        8. py__obs_op_pdaf (for each ensemble member)
        9. core DA algorithm

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.omi_put_state_global`
       and :func:`pyPDAF.PDAF.omi_put_state_enkf_nondiagR`

    References
    ----------
    .. [1] Evensen, G. (1994), 
           Sequential data assimilation with a
           nonlinear quasi-geostrophic model
           using Monte Carlo methods to forecast error statistics,
           J. Geophys. Res., 99(C5), 1014310162, doi:10.1029/94JC00572.

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__add_obs_err_pdaf : Callable[step:int, dim_obs_p:int, C_p:ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]]
        Add obs error covariance R to HPH in EnKF

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Dimension of observation vector

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            --- Matrix to that observation covariance R is added

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            --- Matrix to that observation covariance R is added


    py__init_obs_covar_pdaf : Callable[step:int, dim_obs:int, dim_obs_p:int, covar:float, obs_p:ndarray[tuple[dim_obs_p], np.float64], isdiag:bool]
        Initialize obs. error cov. matrix R in EnKF

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs** : int

            --- Global size of observation vector

        * **dim_obs_p** : int

            --- Size of process-local observation vector

        * **covar** : float

            --- Observation error covariance matrix

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Process-local vector of observations

        * **isdiag** : bool

            --- 

        **Callback Returns**

        * **covar**:float

            --- Observation error covariance matrix

        * **isdiag**:bool

            --- 



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def put_state_estkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_dim_obs_pdaf : Callable[[int, int], int],
                     py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                     py__prodRinvA_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                     py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      float], float]
                    ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.omi_put_state_global`
    or :func:`pyPDAF.PDAF.omi_put_state_global_nondiagR`
    instead of this function.

    OMI functions need fewer user-supplied functions
    and improve DA efficiency.

    This function calls ESTKF
    (error space transform Kalman filter) [1]_.

    Compared to :func:`pyPDAF.PDAF.assimilate_estkf`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    The ESTKF is a more efficient equivalent to the ETKF.

    The function should be called at each model time step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf (for ensemble mean)
        5. py__init_obs_pdaf
        6. py__obs_op_pdaf (for each ensemble member)
        7. py__init_obsvar_pdaf (only relevant for
           adaptive forgetting factor schemes)
        8. py__prodRinvA_pdaf
        9. core DA algorithm

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.omi_put_state_global`
       and :func:`pyPDAF.PDAF.omi_put_state_global_nondiagR`.

    References
    ----------
    .. [1] Nerger, L., Janji, T., Schrter, J., Hiller, W. (2012). 
           A unification of ensemble square root Kalman filters. 
           Monthly Weather Review, 140, 2335-2345. doi:10.1175/MWR-D-11-00102.1

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one
                (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def put_state_etkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__init_dim_obs_pdaf : Callable[[int, int], int],
                    py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                    py__prodRinvA_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                    py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     float], float]
                   ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.omi_put_state_global`
    or :func:`pyPDAF.PDAF.omi_put_state_global_nondiagR`.

    PDAFlocal-OMI modules require fewer user-supplied
    functions and improved efficiency.

    Using ETKF (ensemble transform Kalman filter) [1]_ for a single DA step without OMI.
    The implementation is baed on [2]_.

    Compared to :func:`pyPDAF.PDAF.assimilate_etkf`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf (for ensemble mean)
        5. py__init_obs_pdaf
        6. py__obs_op_pdaf (for each ensemble member)
        7. py__init_obsvar_pdaf (only relevant for
           adaptive forgetting factor schemes)
        8. py__prodRinvA_pdaf
        9. core DA algorithm

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.omi_put_state_global`
       and :func:`pyPDAF.PDAF.omi_put_state_global_nondiagR`

    References
    ----------
    .. [1] Bishop, C. H., B. J. Etherton, and S. J. Majumdar (2001)
           Adaptive Sampling with the Ensemble Transform Kalman Filter.
           Part I: Theoretical Aspects. Mon. Wea. Rev., 129, 420436,
           doi: 10.1175/1520-0493(2001)129<0420:ASWTET>2.0.CO;2. 
    .. [2] Nerger, L., Janji, T., Schrter, J., Hiller, W. (2012). 
           A unification of ensemble square root Kalman filters. 
           Monthly Weather Review, 140, 2335-2345. doi:10.1175/MWR-D-11-00102.1

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one
                (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def put_state_generate_obs (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_dim_obs_pdaf : Callable[[int, int], int],
                            py__obs_op_pdaf : Callable[[int, int, int, 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__get_obs_f_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_obserr_f_pdaf : Callable[[int, int, 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__prepoststep_pdaf : Callable[[int, int, 
                                                             int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]]]
                           ) -> int:
    r"""Generation of synthetic observations
    based on given error statistics and observation operator
    without post-processing, distributing analysis,
    and setting next observation step.

    When diagonal observation error covariance matrix is used,
    it is recommended to use
    :func:`pyPDAF.PDAF.omi_generate_obs` functionalities
    for fewer user-supplied functions and improved efficiency.

    The generated synthetic observations are
    based on each member of model forecast.
    Therefore, an ensemble of observations can be obtained.
    In a typical experiment,
    one may only need one ensemble member.

    Compared to :func:`pyPDAF.PDAF.generate_obs`,
    this function has no :func:`get_state` call.
    This means that the next DA step will
    not be assigned by user-supplied functions.
    This function is typically used when there
    are not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    The implementation strategy is similar to
    an assimilation step. This means that, 
    one can reuse many user-supplied functions for
    assimilation and observation generation.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pda
        5. py__init_obserr_f_pdaf
        6. py__get_obs_f_pdaf

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__get_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f:ndarray[tuple[dim_obs_f], np.float64]]
        Provide observation vector to user

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of the full observation vector

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of synthetic observations (process-local)

        **Callback Returns**

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of synthetic observations (process-local)


    py__init_obserr_f_pdaf : Callable[step:int, dim_obs_f:int, obs_f:ndarray[tuple[dim_obs_f], np.float64], obserr_f:ndarray[tuple[dim_obs_f], np.float64]]
        Initialize vector of observation errors

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Full dimension of observation vector

        * **obs_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full observation vector

        * **obserr_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full observation error stddev

        **Callback Returns**

        * **obserr_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full observation error stddev


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def put_state_hyb3dvar_estkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__init_dim_obs_pdaf : Callable[[int, int], int],
                              py__obs_op_pdaf : Callable[[int, int, int, 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__prodRinvA_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                              py__cvt_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__cvt_adj_pdaf : Callable[[int, int, int, 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__cvt_ens_pdaf : Callable[[int, int, int, 
                                                           int, np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__cvt_adj_ens_pdaf : Callable[[int, int, 
                                                               int, int, 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__obs_op_lin_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__obs_op_adj_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__init_obsvar_pdaf : Callable[[int, int, 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               float], float],
                              py__prepoststep_pdaf : Callable[[int, int, 
                                                               int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]]]]
                             ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.omi_put_state_hyb3dvar_estkf`
    or :func:`pyPDAF.PDAF.omi_put_state_hyb3dvar_estkf_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions
    and improved efficiency.

    Hybrid 3DEnVar for a single DA step where
    the background error covariance is hybridised by
    a static background error covariance,
    and a flow-dependent background error covariance
    estimated from ensemble.

    Compared to :func:`pyPDAF.PDAF.assimilate_hyb3dvar_estkf`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    The 3DVar generates an ensemble mean and
    the ensemble perturbation is generated by
    ESTKF in this implementation.
    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. py__init_obs_pdaf
        6. the iterative optimisation:
            1. py__cvt_pdaf
            2. py__cvt_ens_pdaf
            3. py__obs_op_lin_pdaf
            4. py__prodRinvA_pdaf
            5. py__obs_op_adj_pdaf
            6. py__cvt_adj_pdaf
            7. py__cvt_adj_ens_pdaf
            8. core 3DEnVar algorithm
        7. py__cvt_pdaf
        8. py__cvt_ens_pdaf
        9. Perform ESTKF:
            1. py__init_dim_obs_pdaf
            2. py__obs_op_pdaf
               (for ensemble mean)
            3. py__init_obs_pdaf
            4. py__obs_op_pdaf
               (for each ensemble member)
            5. py__init_obsvar_pdaf
               (only relevant for adaptive
               forgetting factor schemes)
            6. py__prodRinvA_pdaf
            7. core ESTKF algorithm

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.omi_put_state_hyb3dvar_estkf`
       and :func:`pyPDAF.PDAF.omi_put_state_hyb3dvar_estkf_nondiagR`

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one
                (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def put_state_hyb3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__init_dim_obs_pdaf : Callable[[int, int], int],
                               py__obs_op_pdaf : Callable[[int, int, int, 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__init_obs_pdaf : Callable[[int, int, 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__prodRinvA_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                               py__cvt_ens_pdaf : Callable[[int, int, int, 
                                                            int, np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__cvt_adj_ens_pdaf : Callable[[int, int, 
                                                                int, int, 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__cvt_pdaf : Callable[[int, int, int, 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__cvt_adj_pdaf : Callable[[int, int, int, 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__obs_op_lin_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__obs_op_adj_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__init_dim_obs_f_pdaf : Callable[[int, 
                                                                   int], int],
                               py__obs_op_f_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__init_obs_f_pdaf : Callable[[int, int, 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__init_obs_l_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__prodRinvA_l_pdaf : Callable[[int, int, 
                                                                int, int, 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                               py__init_n_domains_p_pdaf : Callable[[int, 
                                                                     int], int],
                               py__init_dim_l_pdaf : Callable[[int, int, 
                                                               int], int],
                               py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int], int],
                               py__g2l_state_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__l2g_state_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__g2l_obs_pdaf : Callable[[int, int, int, 
                                                            int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                            int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                            int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                               py__init_obsvar_pdaf : Callable[[int, int, 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                float], float],
                               py__init_obsvar_l_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  int, 
                                                                  float], float],
                               py__prepoststep_pdaf : Callable[[int, int, 
                                                                int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]]]]
                              ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf`
    or :func:`pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions
    and improved efficiency.

    Hybrid 3DEnVar for a single DA step using
    non-diagnoal observation error covariance matrix
    without post-processing, distributing analysis,
    and setting next observation step, where
    the background error covariance is hybridised by
    a static background error covariance,
    and a flow-dependent background error covariance
    estimated from ensemble.

    Compared to :func:`pyPDAF.PDAF.assimilate_hyb3dvar_lestkf`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    The 3DVar generates an ensemble mean and
    the ensemble perturbation is generated by
    LESTKF in this implementation.
    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. py__init_obs_pdaf
        6. The iterative optimisation:
            1. py__cvt_pdaf
            2. py__cvt_ens_pdaf
            3. py__obs_op_lin_pdaf
            4. py__prodRinvA_pdaf
            5. py__obs_op_adj_pdaf
            6. py__cvt_adj_pdaf
            7. py__cvt_adj_ens_pdaf
            8. core DA algorithm
        7. py__cvt_pdaf
        8. py__cvt_ens_pdaf
        9. Perform LESTKF:
            1. py__init_n_domains_p_pdaf
            2. py__init_dim_obs_pdaf
            3. py__obs_op_pdaf
               (for each ensemble member)
            4. py__init_obs_pdaf
               (if global adaptive forgetting factor
               `type_forget=1` in :func:`pyPDAF.PDAF.init`)
            5. py__init_obsvar_pdaf
               (if global adaptive forgetting factor is used)
            6. loop over each local domain:
                1. py__init_dim_l_pdaf
                2. py__init_dim_obs_l_pdaf
                3. py__g2l_state_pdaf
                4. py__g2l_obs_pdaf
                   (localise mean ensemble in observation space)
                5. py__init_obs_l_pdaf
                6. py__g2l_obs_pdaf
                   (localise each ensemble member
                   in observation space)
                7. py__init_obsvar_l_pdaf
                   (only called if local adaptive forgetting
                   factor `type_forget=2` is used)
                8. py__prodRinvA_l_pdaf
                9. core DA algorithm
                10. py__l2g_state_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf`
       and :func:`pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf_nondiagR`

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one
                (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f:ndarray[tuple[dim_obs_f], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of the full observation vector

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of observations

        **Callback Returns**

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def put_state_lenkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_dim_obs_pdaf : Callable[[int, int], int],
                     py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                     py__localize_covar_pdaf : Callable[[int, int, np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]]], tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                     py__add_obs_err_pdaf : Callable[[int, int, np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                     py__init_obs_covar_pdaf : Callable[[int, int, int, 
                                                         float, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         bool], tuple[float, 
                                                         bool]]
                    ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.omi_put_state_lenkf`
    or :func:`pyPDAF.PDAF.omi_put_state_lenkf_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions
    and improved efficiency.

    Stochastic EnKF (ensemble Kalman filter)
    with covariance localisation [1]_
    for a single DA step without OMI.

    Compared to :func:`pyPDAF.PDAF.assimilate_lenkf`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    This is the only scheme for covariance localisation in PDAF.

    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf (for each ensemble member)
        5. py__localize_pdaf
        6. py__add_obs_err_pdaf
        7. py__init_obs_pdaf
        8. py__init_obscovar_pdaf
        9. py__obs_op_pdaf (repeated to reduce storage)
        10. core DA algorith

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.omi_put_state_lenkf`
       and :func:`pyPDAF.PDAF.omi_put_state_lenkf_nondiagR`

    References
    ----------
    .. [1] Houtekamer, P. L., and H. L. Mitchell (1998): 
           Data Assimilation Using an Ensemble Kalman
           Filter Technique.
           Mon. Wea. Rev., 126, 796811,
           doi: 10.1175/1520-0493(1998)126<0796:DAUAEK>2.0.CO;2.

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__localize_covar_pdaf : Callable[dim_p:int, dim_obs:int, hp_p:ndarray[tuple[dim_obs, dim_p], np.float64], hph:ndarray[tuple[dim_obs, dim_obs], np.float64]]
        Apply localization to HP and HPH^T

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_obs** : int

            --- number of observations

        * **hp_p** : ndarray[tuple[dim_obs, dim_p], np.float64]

            --- pe local part of matrix hp

        * **hph** : ndarray[tuple[dim_obs, dim_obs], np.float64]

            --- matrix hph

        **Callback Returns**

        * **hp_p** : ndarray[tuple[dim_obs, dim_p], np.float64]

            --- pe local part of matrix hp

        * **hph** : ndarray[tuple[dim_obs, dim_obs], np.float64]

            --- matrix hph


    py__add_obs_err_pdaf : Callable[step:int, dim_obs_p:int, C_p:ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]]
        Add obs error covariance R to HPH in EnKF

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Dimension of observation vector

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            --- Matrix to that observation covariance R is added

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            --- Matrix to that observation covariance R is added


    py__init_obs_covar_pdaf : Callable[step:int, dim_obs:int, dim_obs_p:int, covar:float, obs_p:ndarray[tuple[dim_obs_p], np.float64], isdiag:bool]
        Initialize obs. error cov. matrix R in EnKF

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs** : int

            --- Global size of observation vector

        * **dim_obs_p** : int

            --- Size of process-local observation vector

        * **covar** : float

            --- Observation error covariance matrix

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Process-local vector of observations

        * **isdiag** : bool

            --- 

        **Callback Returns**

        * **covar**:float

            --- Observation error covariance matrix

        * **isdiag**:bool

            --- 



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def put_state_lestkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_dim_obs_pdaf : Callable[[int, int], int],
                      py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_obs_l_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                       int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                      py__prodRinvA_l_pdaf : Callable[[int, int, int, int, 
                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                      py__init_n_domains_p_pdaf : Callable[[int, int], int],
                      py__init_dim_l_pdaf : Callable[[int, int, int], int],
                      py__init_dim_obs_l_pdaf : Callable[[int, int, int, 
                                                          int], int],
                      py__g2l_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__l2g_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__g2l_obs_pdaf : Callable[[int, int, int, int, 
                                                   np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                   int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                   int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                      py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       float], float],
                      py__init_obsvar_l_pdaf : Callable[[int, int, int, 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         int, float], float]
                     ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.localomi_put_state`
    or :func:`pyPDAF.PDAF.localomi_put_state_nondiagR`.

    PDAFlocal-OMI modules require fewer user-supplied functions
    and improved efficiency.

    Local ESTKF (error space transform Kalman filter) [1]_ for a single DA step without OMI.

    Compared to :func:`pyPDAF.PDAF.assimilate_lestkf`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    The LESTKF is a more efficient equivalent to the LETKF.

    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. py__init_obs_pdaf
           (if global adaptive forgetting factor `type_forget=1` is used
           in :func:`pyPDAF.PDAF.init`)
        7. py__init_obsvar_pdaf (if global adaptive
           forgetting factor is used)
        8. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. py__g2l_state_pdaf
            4. py__g2l_obs_pdaf (localise mean ensemble
               in observation space)
            5. py__init_obs_l_pdaf
            6. py__g2l_obs_pdaf
               (localise each ensemble member in observation space)
            7. py__init_obsvar_l_pdaf
               (only called if local adaptive forgetting factor
               `type_forget=2` is used)
            8. py__prodRinvA_l_pdaf
            9. core DA algorithm
            10. py__l2g_state_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_put_state`
       and :func:`pyPDAF.PDAF.localomi_put_state_nondiagR`

    References
    ----------
    .. [1] Nerger, L., Janji, T., Schrter, J., Hiller, W. (2012). 
           A unification of ensemble square root Kalman filters. 
           Monthly Weather Review, 140, 2335-2345.
           doi:10.1175/MWR-D-11-00102.1

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def put_state_letkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_dim_obs_pdaf : Callable[[int, int], int],
                     py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_obs_l_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                     py__prodRinvA_l_pdaf : Callable[[int, int, int, int, 
                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                     py__init_n_domains_p_pdaf : Callable[[int, int], int],
                     py__init_dim_l_pdaf : Callable[[int, int, int], int],
                     py__init_dim_obs_l_pdaf : Callable[[int, int, int, 
                                                         int], int],
                     py__g2l_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__l2g_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__g2l_obs_pdaf : Callable[[int, int, int, int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                  int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                  int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                     py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      float], float],
                     py__init_obsvar_l_pdaf : Callable[[int, int, int, 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        int, float], float]
                    ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.localomi_put_state`
    or :func:`pyPDAF.PDAF.localomi_put_state_nondiagR`.

    PDAFlocal-OMI modules require fewer user-supplied
    functions and improved efficiency.

    Local ensemble transform Kalman filter (LETKF) [1]_
    for a single DA step without OMI.
    Implementation is based on [2]_.

    Compared to :func:`pyPDAF.PDAF.assimilate_letkf`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    Note that the LESTKF is a more efficient equivalent to the LETKF.

    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. py__init_obs_pdaf
           (if global adaptive forgetting factor
           `type_forget=1` is used
           in :func:`pyPDAF.PDAF.init`)
        7. py__init_obsvar_pdaf (if global adaptive forgetting
           factor is used)
        8. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. py__g2l_state_pdaf
            4. py__g2l_obs_pdaf (localise mean ensemble
               in observation space)
            5. py__init_obs_l_pdaf
            6. py__g2l_obs_pdaf (localise each ensemble member
               in observation space)
            7. py__init_obsvar_l_pdaf
               (only called if local adaptive forgetting factor
               `type_forget=2` is used)
            8. py__prodRinvA_l_pdaf
            9. core DA algorithm
            10. py__l2g_state_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_put_state`
       and :func:`pyPDAF.PDAF.localomi_put_state_nondiagR`

    References
    ----------
    .. [1] Hunt, B. R., Kostelich, E. J., & Szunyogh, I. (2007).
           Efficient data assimilation for spatiotemporal chaos:
           A local ensemble transform Kalman filter. 
           Physica D: Nonlinear Phenomena, 230(1-2), 112-126.
    .. [2] Nerger, L., Janji, T., Schrter, J., Hiller, W. (2012). 
           A unification of ensemble square root Kalman filters. 
           Monthly Weather Review, 140, 2335-2345.
           doi:10.1175/MWR-D-11-00102.1

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def put_state_lnetf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_dim_obs_pdaf : Callable[[int, int], int],
                     py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_obs_l_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                     py__likelihood_l_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       float], float],
                     py__init_n_domains_p_pdaf : Callable[[int, int], int],
                     py__init_dim_l_pdaf : Callable[[int, int, int], int],
                     py__init_dim_obs_l_pdaf : Callable[[int, int, int, 
                                                         int], int],
                     py__g2l_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__l2g_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__g2l_obs_pdaf : Callable[[int, int, int, int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                  int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                  int], np.ndarray[tuple[int], np.dtype[np.intc]]]
                    ) -> int:
    r"""It is recommended to use :func:`pyPDAF.PDAF.localomi_put_state`
    or :func:`pyPDAF.PDAF.localomi_put_state_lnetf_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions
    and improved efficiency.

    Local Nonlinear Ensemble Transform Filter (LNETF) [1]_
    for a single DA step.

    Compared to :func:`pyPDAF.PDAF.assimilate_lnetf`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    The nonlinear filter computes the distribution up to
    the second moment similar to Kalman filters
    but it uses a nonlinear weighting similar to
    particle filters. This leads to an equal weights
    assumption for the prior ensemble at each step.
    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. py__g2l_state_pdaf
            4. py__init_obs_l_pdaf
            5. py__g2l_obs_pdaf (localise each ensemble member
               in observation space)
            6. py__likelihood_l_pdaf
            7. core DA algorithm
            8. py__l2g_state_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_put_state`
       and :func:`pyPDAF.PDAF.localomi_put_state_lnetf_nondiagR`

    References
    ----------
    .. [1] Tdter, J., and B. Ahrens, 2015:
           A second-order exact ensemble square root filter
           for nonlinear data assimilation. Mon. Wea. Rev.,
           143, 13471367, doi:10.1175/MWR-D-14-00108.1.

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- nput vector holding the local residual

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def put_state_lknetf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_dim_obs_pdaf : Callable[[int, int], int],
                      py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_obs_l_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                       int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                      py__prodRinvA_l_pdaf : Callable[[int, int, int, int, 
                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                      py__prodRinvA_hyb_l_pdaf : Callable[[int, int, int, 
                                                           int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           float, np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                      py__init_n_domains_p_pdaf : Callable[[int, int], int],
                      py__init_dim_l_pdaf : Callable[[int, int, int], int],
                      py__init_dim_obs_l_pdaf : Callable[[int, int, int, 
                                                          int], int],
                      py__g2l_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__l2g_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__g2l_obs_pdaf : Callable[[int, int, int, int, 
                                                   np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                   int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                   int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                      py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       float], float],
                      py__init_obsvar_l_pdaf : Callable[[int, int, int, 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         int, float], float],
                      py__likelihood_l_pdaf : Callable[[int, int, int, 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        float], float],
                      py__likelihood_hyb_l_pdaf : Callable[[int, int, int, 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            float, float], float]
                     ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.localomi_put_state`
    or :func:`pyPDAF.PDAF.localomi_put_state_lknetf_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions
    and improved efficiency.

    A hybridised LETKF and LNETF [1]_ for a single DA step.

    Compared to :func:`pyPDAF.PDAF.assimilate_lknetf`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    The LNETF computes the distribution up to
    the second moment similar to Kalman filters but
    using a nonlinear weighting similar to
    particle filters. This leads to an equal weights
    assumption for the prior ensemble.
    The hybridisation with LETKF is expected to lead to
    improved performance for
    quasi-Gaussian problems.
    The function should be called at each model step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf
           (for each ensemble member)
        6. py__init_obs_pdaf
           (if global adaptive forgetting factor `type_forget=1`
           is used in :func:`pyPDAF.PDAF.init`)
        7. py__init_obsvar_pdaf (if global adaptive
           forgetting factor is used)
        8. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. py__g2l_state_pdaf
            4. py__g2l_obs_pdaf
               (localise each ensemble member in observation space)
            5. py__init_obs_l_pdaf
            6. py__init_obsvar_l_pdaf
               (only called if local adaptive forgetting factor
               `type_forget=2` is used)
            7. py__prodRinvA_pdaf
            8. py__likelihood_l_pdaf
            9. core DA algorithm
            10. py__l2g_state_pdaf
        9. py__obs_op_pdaf
           (only called with `HKN` and `HNK` options called
           for each ensemble member)
        10. py__likelihood_hyb_l_pda
        11. py__init_obsvar_l_pdaf
            (only called if local adaptive forgetting factor
            `type_forget=2` is used)
        12. py__prodRinvA_hyb_l_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_put_state`
       and :func:`pyPDAF.PDAF.localomi_put_state_lknetf_nondiagR`

    References
    ----------
    .. [1] Nerger, L.. (2022) 
           Data assimilation for nonlinear systems with
           a hybrid nonlinear Kalman ensemble transform filter.
           Q J R Meteorol Soc, 620640. doi:10.1002/qj.4221

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__prodRinvA_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, dim_ens:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, A_l:ndarray[tuple[dim_obs_l, dim_ens], np.float64], C_l:ndarray[tuple[dim_obs_l, dim_ens], np.float64]]
        Provide product R^-1 A on local analysis domain with hybrid weight

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **dim_ens** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **gamma** : float

            --- Hybrid weight provided by PDAF

        * **A_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance


    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute likelihood

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- nput vector holding the local residual

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    py__likelihood_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, likely_l:float]
        Compute likelihood with hybrid weight

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Input vector holding the local residual

        * **gamma** : float

            --- Hybrid weight provided by PDAF

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def put_state_lseik (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_dim_obs_pdaf : Callable[[int, int], int],
                     py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_obs_l_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                     py__prodRinvA_l_pdaf : Callable[[int, int, int, int, 
                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                     py__init_n_domains_p_pdaf : Callable[[int, int], int],
                     py__init_dim_l_pdaf : Callable[[int, int, int], int],
                     py__init_dim_obs_l_pdaf : Callable[[int, int, int, 
                                                         int], int],
                     py__g2l_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__l2g_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__g2l_obs_pdaf : Callable[[int, int, int, int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                  int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                  int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                     py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      float], float],
                     py__init_obsvar_l_pdaf : Callable[[int, int, int, 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        int, float], float]
                    ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.localomi_put_state`
    or :func:`pyPDAF.PDAF.localomi_put_state_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions
    and improved efficiency.

    Local singular evolutive interpolated Kalman filter [1]_
    for a single DA step.

    Compared to :func:`pyPDAF.PDAF.assimilate_lseik`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. py__init_obs_pdaf
           (if global adaptive forgetting factor `type_forget=1`
           is used in :func:`pyPDAF.PDAF.init`)
        7. py__init_obsvar_pdaf
           (if global adaptive forgetting factor is used)
        8. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. py__g2l_state_pdaf
            4. py__g2l_obs_pdaf (localise mean ensemble
               in observation space)
            5. py__init_obs_l_pdaf
            6. py__g2l_obs_pdaf
               (localise each ensemble member in observation space)
            7. py__init_obsvar_l_pdaf
               (only called if local adaptive forgetting factor
               `type_forget=2` is used)
            8. py__prodRinvA_l_pdaf
            9. core DA algorithm
            10. py__l2g_state_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_put_state`
       and :func:`pyPDAF.PDAF.localomi_put_state_nondiagR`

    References
    ----------
    .. [1] Pham, D. T., Verron, J., & Roubaud, M. C. (1998).
           A singular evolutive extended Kalman filter for data assimilation
           in oceanography. Journal of Marine systems, 16(3-4), 323-340.

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def put_state_netf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__init_dim_obs_pdaf : Callable[[int, int], int],
                    py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                    py__likelihood_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    float], float]
                   ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.omi_put_state_global`
    or :func:`pyPDAF.PDAF.omi_put_state_nonlin_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions
    and improved efficiency.

    This function will use
    Nonlinear Ensemble Transform Filter (NETF) [1]_ 
    for a single DA step.

    Compared to :func:`pyPDAF.PDAF.assimilate_netf`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    The nonlinear filter computes the distribution up to
    the second moment similar to KF but using
    a nonlinear weighting similar to
    particle filter. This leads to an equal weights
    assumption for prior ensemble.
    The function should be called at each model step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__init_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. py__likelihood_pdaf
        7. core DA algorithm

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.omi_put_state_global`
       and :func:`pyPDAF.PDAF.omi_put_state_nonlin_nondiagR`

    References
    ----------
    .. [1] Tdter, J., and B. Ahrens, 2015:
           A second-order exact ensemble square root filter
           for nonlinear data assimilation. Mon. Wea. Rev.,
           143, 13471367, doi:10.1175/MWR-D-14-00108.1.

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__likelihood_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], resid:ndarray[tuple[dim_obs_p], np.float64], likely:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **resid** : ndarray[tuple[dim_obs_p], np.float64]

            --- Input vector holding the residual

        * **likely** : float

            --- Output value of the likelihood

        **Callback Returns**

        * **likely**:float

            --- Output value of the likelihood



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def put_state_pf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                  py__init_dim_obs_pdaf : Callable[[int, int], int],
                  py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                  py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                  py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                   int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                   int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                  py__likelihood_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                  float], float]
                 ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.omi_put_state_global`
    or :func:`pyPDAF.PDAF.omi_put_state_nonlin_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions
    and improved efficiency.

    This function will use particle filter for a single DA step.

    Compared to :func:`pyPDAF.PDAF.assimilate_pf`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    This is a fully nonlinear filter, and may require
    a high number of ensemble members.
    A review of particle filter can be found at [1]_.
    The function should be called at each model step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__init_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. py__likelihood_pdaf
        7. core DA algorithm

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.omi_put_state_global`
       and :func:`pyPDAF.PDAF.omi_put_state_nonlin_nondiagR`

    References
    ----------
    .. [1] Van Leeuwen, P. J., Knsch, H. R., Nerger, L.,
           Potthast, R., & Reich, S. (2019).
           Particle filters for highdimensional
           geoscience applications:
           A review. 
           Quarterly Journal of the Royal Meteorological Society,
           145(723), 2335-2365.

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__likelihood_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], resid:ndarray[tuple[dim_obs_p], np.float64], likely:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **resid** : ndarray[tuple[dim_obs_p], np.float64]

            --- Input vector holding the residual

        * **likely** : float

            --- Output value of the likelihood

        **Callback Returns**

        * **likely**:float

            --- Output value of the likelihood



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def put_state_prepost (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__prepoststep_pdaf : Callable[[int, int, int, 
                                                        int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                        int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]]]]
                      ) -> int:
    r"""It is used to preprocess and postprocess of the ensemble.

    No DA is performed in this function.
    Compared to :func:`pyPDAF.PDAF.assimilate_prepost`,
    this function does not set assimilation flag, 
    and does not distribute the processed ensemble to the model field.
    This function also does not set the next assimilation step as
    :func:`pyPDAF.PDAF.assimilate_prepost`
    because it does not call :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf (preprocess, step < 0)

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def put_state_seek (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__init_dim_obs_pdaf : Callable[[int, int], int],
                    py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                    py__prodRinvA_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]]
                   ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.omi_put_state_global`
    or :func:`pyPDAF.PDAF.omi_put_state_global_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions
    and improved efficiency.

    This function will use
    singular evolutive extended Kalman filter [1]_ for
    a single DA step.

    Compared to :func:`pyPDAF.PDAF.assimilate_seek`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    This is a deterministic Kalman filter.
    The function should be called at each model step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf (for ensemble mean)
        5. py__init_obs_pdaf
        6. py__obs_op_pdaf (for each ensemble member)
        7. py__prodRinvA_pdaf
        8. core DA algorithm

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.omi_put_state_global`
       and :func:`pyPDAF.PDAF.omi_put_state_global_nondiagR`

    References
    ----------
    .. [1] Pham, D. T., Verron, J., & Roubaud, M. C. (1998).
           A singular evolutive extended Kalman filter for data assimilation
           in oceanography. Journal of Marine systems, 16(3-4), 323-340.

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 HV

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one
                (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def put_state_seik (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__init_dim_obs_pdaf : Callable[[int, int], int],
                    py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                    py__prodRinvA_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                    py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     float], float]
                   ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.omi_put_state_global`
    or :func:`pyPDAF.PDAF.omi_put_state_global_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions
    and improved efficiency.

    This function will use
    singular evolutive interpolated Kalman filter [1]_ for
    a single DA step.

    Compared to :func:`pyPDAF.PDAF.assimilate_seik`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions.
    The next DA step will not be assigned by user-supplied
    functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    The function should be called at each model step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf (for ensemble mean)
        5. py__init_obs_pdaf
        6. py__obs_op_pdaf (for each ensemble member)
        7. py__init_obsvar_pdaf (only relevant for
           adaptive forgetting factor schemes)
        8. py__prodRinvA_pdaf
        9. core DA algorithm

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.omi_put_state_global`
       and :func:`pyPDAF.PDAF.omi_put_state_global_nondiagR`

    References
    ----------
    .. [1] Pham, D. T., Verron, J., & Roubaud, M. C. (1998).
           A singular evolutive extended Kalman filter
           for data assimilation
           in oceanography. Journal of Marine systems, 16(3-4), 323-340.

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one
                (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def reset_forget (forget_in: float) -> None:
    r"""This function allows a user to reset the forgetting factor manually during the assimilation process. For the local ensemble Kalman filters the forgetting factor can be set either globally of differently for each local analysis domain. For the LNETF and the global filters only a global setting of the forgeting factor is possible. In addition, the implementation of adaptive choices for the forgetting factor (beyond what is implemented in PDAF) are possible.

    Parameters
    ----------
    forget_in : float
        New value of forgetting factor
    """
    ...

def SampleEns (modes: np.ndarray[tuple[int, int], np.dtype[np.float64]],
               svals: np.ndarray[tuple[int], np.dtype[np.float64]],state: np.ndarray[tuple[int], np.dtype[np.float64]],
               verbose: int,flag: int) -> tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], np.ndarray[tuple[int], np.dtype[np.float64]], 
                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                      int]:
    r"""This function generates an ensemble from singular values and their vectors (EOF modes) centred on given mean state. The singular values and vectors are derived from the ensemble anomalies which can be obtained from a long model trajectory using `pyPDAF.PDAF.eofcovar`.

    Parameters
    ----------
    modes : ndarray[tuple[dim, dim_ens-1], np.float64]
        Array of EOF modes
        The 1st-th dimension dim is Size of state vector
    svals : ndarray[tuple[dim_ens-1], np.float64]
        Vector of singular values
    state : ndarray[tuple[dim], np.float64]
        PE-local model mean state
        The array dimension `dim` is Size of state vector
    verbose : int
        Verbosity flag
    flag : int
        Status flag

    Returns
    -------
    modes : ndarray[tuple[dim, dim_ens-1], np.float64]
         Array of EOF modes

        The 1st-th dimension dim is Size of state vector
    state : ndarray[tuple[dim], np.float64]
         PE-local model mean state

        The array dimension `dim` is Size of state vector
    ens : ndarray[tuple[dim, dim_ens], np.float64]
         State ensemble

        The 1st-th dimension dim is Size of state vector
        The 2nd-th dimension dim_ens is Size of ensemble
    flag : int
        Status flag
    """
    ...

def set_debug_flag (debugval: int) -> None:
    r"""This function activates the debug output of the PDAF. Starting from the use of this function, the debug infomation is sent to screen output.  The screen output end when the debug flag is set to 0. We recommend using debugging output for single local domain, e.g. `if domain_p = 1: pyPDAF.PDAF.set_debug_flag(1)`.
    

    Parameters
    ----------
    debugval : int
        Value of debugging flag; print debug information for >0
    """
    ...

def set_ens_pointer () -> tuple[np.ndarray[tuple[int, ], np.dtype[float]], int]:
    r"""This function returns the ensemble array in a numpy array where the internal array data has the same memoery address as PDAF ensemble array.


    Returns
    -------
    c_ens_point : ndarray[float]
        Pointer to smoother array
    dims : ndarray[tuple[2], np.intc]
         dimension of the pointer

    status : int
        Status flag
    """
    ...

def set_smootherens (maxlag: int) -> tuple[np.ndarray[tuple[int, ], np.dtype[float]], int]:
    r"""This function can be used in the offline implementation when a smoother is used. It is typically called in `py__init_ens_pdaf` in the call to `pyPDAF.PDAF.PDAF_init`. The function `pyPDAF.PDAF.set_smootherens` is used when the smoother extension of a filter is used. In this case, the smoothed ensemble states at earlier times are stored in an internal array of PDAF. To be able to smooth post times, the smoother algorithm must have access to the past ensembles. In the offline mode the user has to manually fill the smoother ensemble array from ensembles read in from files. In the online mode, the smoother array is filled automatically during the cycles of forecast phases and analysis steps. 

    Parameters
    ----------
    maxlag : int
        Number of past timesteps processed in sens

    Returns
    -------
    c_sens_point : ndarray[float]
        Pointer to smoother array
    dims : ndarray[tuple[3], np.intc]
         dimension of the pointer

    status : int
        Status flag
    """
    ...

def seik_TtimesA (A: np.ndarray[tuple[int, int], np.dtype[np.float64]]
                 ) -> np.ndarray[tuple[int, int], np.dtype[np.float64]]:
    r"""This is an internal function in PDAF where it perform matrix calculation of B = TA. This allows for two types of T matrix. The resulting matrix B is the transformation matrix act on the full forecast ensemble. Mathematical description of the function is the second term of Eq. (23) and the T matrix is defined in Eq. (13) in
    Nerger, L., Janji, T., Schrter, J., Hiller, W. (2012). A unification of ensemble square root Kalman filters. Monthly Weather Review, 140, 2335-2345. doi:10.1175/MWR-D-11-00102.1
    

    Parameters
    ----------
    A : ndarray[tuple[rank, dim_col], np.float64]
        Input matrix
        The 1st-th dimension rank is Rank of initial covariance matrix
        The 2nd-th dimension dim_col is Number of columns in A and B

    Returns
    -------
    B : ndarray[tuple[rank+1, dim_col], np.float64]
         Output matrix (TA)

        The 1st-th dimension dim_col is Number of columns in A and B
    """
    ...

def etkf_Tleft (A: np.ndarray[tuple[int, int], np.dtype[np.float64]]) -> np.ndarray[tuple[int, int], np.dtype[np.float64]]:
    r"""This is an internal function in PDAF where it perform matrix calculation of B = TA. This function performs the second term of Eq. (34) i
    Nerger, L., Janji, T., Schrter, J., Hiller, W. (2012). A unification of ensemble square root Kalman filters. Monthly Weather Review, 140, 2335-2345. doi:10.1175/MWR-D-11-00102.1
    

    Parameters
    ----------
    A : ndarray[tuple[dim_ens, dim], np.float64]
        Input/output matrix
        The 1st-th dimension dim_ens is Rank of initial covariance matrix
        The 2nd-th dimension dim is Number of columns in A and B

    Returns
    -------
    A : ndarray[tuple[dim_ens, dim], np.float64]
         Input/output matrix

        The 1st-th dimension dim_ens is Rank of initial covariance matrix
        The 2nd-th dimension dim is Number of columns in A and B
    """
    ...

def estkf_OmegaA (A: np.ndarray[tuple[int, int], np.dtype[np.float64]]
                 ) -> np.ndarray[tuple[int, int], np.dtype[np.float64]]:
    r"""This function is an internal function in PDAF. This function performs the second term of Eq. (29) i
    Nerger, L., Janji, T., Schrter, J., Hiller, W. (2012). A unification of ensemble square root Kalman filters. Monthly Weather Review, 140, 2335-2345. doi:10.1175/MWR-D-11-00102.1
    

    Parameters
    ----------
    A : ndarray[tuple[rank, dim_col], np.float64]
        Input matrix
        The 1st-th dimension rank is Rank of initial covariance matrix
        The 2nd-th dimension dim_col is Number of columns in A and B

    Returns
    -------
    B : ndarray[tuple[rank+1, dim_col], np.float64]
         Output matrix (TA)

        The 1st-th dimension dim_col is Number of columns in A and B
    """
    ...

def enkf_omega (seed: np.ndarray[tuple[int], np.dtype[np.intc]],omega: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                norm: float,otype: int,screen: int) -> tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], float]:
    r"""Generation of a random matrix with orthogonal basis following SEEK approach for EnKF with given properties.

    Parameters
    ----------
    seed : ndarray[tuple[4], np.intc]
        Seed for random number generation
    omega : ndarray[tuple[dim_ens, r], np.float64]
        Random matrix
        The 1st-th dimension dim_ens is Ensemble size
        The 2nd-th dimension r is Approximated rank of covar matrix
    norm : float
        Norm for ensemble transformation
    otype : int
        Type of Omega:
        (1) Simple Gaussian random matrix
        (2) Columns of unit norm
        (3) Columns of norm dim_ens^(-1/2)
        (4) Projection orthogonal (1,..,1)^T
        (6) Combination of 2 and 4
        (7) Combination of 3 and 4
        (8) Rows of sum 0 and variance 1
    screen : int
        Verbosity flag

    Returns
    -------
    omega : ndarray[tuple[dim_ens, r], np.float64]
         Random matrix

        The 1st-th dimension dim_ens is Ensemble size
        The 2nd-th dimension r is Approximated rank of covar matrix
    norm : float
        Norm for ensemble transformation
    """
    ...

def seik_omega (omega: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                omegatype: int,screen: int) -> np.ndarray[tuple[int, int], np.dtype[np.float64]]:
    r"""Generation of a random matrix with orthogonal basis following SEIK approach.

    Parameters
    ----------
    omega : ndarray[tuple[rank+1, rank], np.float64]
        Matrix Omega
        The 1st-th dimension rank is Approximated rank of covar matrix
    omegatype : int
        Select type of Omega:
          (1) generated from random vectors
          (0) generated from deterministic vectors (Householder)
    screen : int
        Verbosity flag

    Returns
    -------
    omega : ndarray[tuple[rank+1, rank], np.float64]
         Matrix Omega

        The 1st-th dimension rank is Approximated rank of covar matrix
    """
    ...

def incremental (steps: int,py__dist_stateinc_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               int, int], None]
                ) -> None:
    r"""This is a helper function to apply analysis increment to model state in model forecast phase. It simply calls the user-supplied function. 

    Parameters
    ----------
    steps : int
        Time steps over which increment is distributed
    py__dist_stateinc_pdaf : Callable[dim_p:int, state_inc_p:ndarray[tuple[dim_p], np.float64], first:int, steps:int]
        Add state increment during integration

        **Callback Parameters**

        * **dim_p** : int

            --- Dimension of PE-local state

        * **state_inc_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        * **first** : int

            --- Flag for first call of each forecast

        * **steps** : int

            --- number of time steps in forecast

        **Callback Returns**


    """
    ...

def add_increment (state_p: np.ndarray[tuple[int], np.dtype[np.float64]]
                  ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    r"""This function directly adds analysis increment to given state vector without the need for user-supplied functions.

    Parameters
    ----------
    state_p : ndarray[tuple[dim_p], np.float64]
        State vector
        The array dimension `dim_p` is State dimension

    Returns
    -------
    state_p : ndarray[tuple[dim_p], np.float64]
         State vector

        The array dimension `dim_p` is State dimension
    """
    ...

def local_weights (wtype: int,cradius: float,sradius: float,distance: np.ndarray[tuple[int], np.dtype[np.float64]],
                   verbose: int) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    r"""This function returns a vector of the localisation weights based on distance and localisation functions and radii. This function is particularly useful for mannually apply covariance localisations for state or observation errors.

    Parameters
    ----------
    wtype : int
        Type of weight function
        (0): unit weight (=1 up to distance=cradius)
        (1): exponential decrease (1/e at distance=sradius; 0 for distance>cradius)
        (2): 5th order polynomial (Gaspari&Cohn 1999; 0 for distance>cradius)
    cradius : float
        Parameter for cut-off
    sradius : float
        Support radius
    distance : ndarray[tuple[dim], np.float64]
        Array holding distances
        The array dimension `dim` is Size of distance and weight arrays
    verbose : int
        Verbosity flag

    Returns
    -------
    weight : ndarray[tuple[dim], np.float64]
         Array for weights

        The array dimension `dim` is Size of distance and weight arrays
    """
    ...

def diag_CRPS (element: int,oens: np.ndarray[tuple[int, int], np.dtype[np.float64]],
               obs: np.ndarray[tuple[int], np.dtype[np.float64]]) -> tuple[float, float, float, float, int]:
    r"""Obtain a continuous rank probability score for an ensemble.

    The implementation is based on [1]_.

    References
    ----------
    .. [1] Hersbach, H. (2000), 
           Decomposition of the Continuous Ranked Probability
           Score for
           Ensemble Prediction Systems,
           Wea. Forecasting, 15, 559570,
           doi:10.1175/1520-0434(2000)015<0559:DOTCRP>2.0.CO;2

    Parameters
    ----------
    element : int
        ID of element to be used. If element=0, mean values over all elements are computed
    oens : ndarray[tuple[dim, dim_ens], np.float64]
        State ensemble
        The 1st-th dimension dim is PE-local state dimension
        The 2nd-th dimension dim_ens is Ensemble size
    obs : ndarray[tuple[dim], np.float64]
        State ensemble
        The array dimension `dim` is PE-local state dimension

    Returns
    -------
    CRPS : float
        CRPS
    reli : float
        Reliability
    resol : float
        resolution
    uncert : float
        uncertainty
    status : int
        Status flag (0=success)
    """
    ...

def force_analysis () -> None:
    r"""This function overwrite member index of the ensemble state by local_dim_ens (number of ensembles for current process, in full parallel setup, this is 1.) and the counter cnt_steps by nsteps-1.
    This forces that the analysis step is executed at the next call to PDAF assimilation functions.

    """
    ...

def gather_obs_f2_flex (dim_obs_f: int,coords_p: np.ndarray[tuple[int, int], np.dtype[np.float64]]
                       ) -> tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], int]:
    r"""In the local filters (LESKTF, LETKF, LSEIK, LNETF)
    this function returns the full observation coordinates from process-local observation coordinates. `pyPDAF.PDAF.gather_obs_f_flex` is used to get corresponding observations. Unlike `pyPDAF.PDAF.gather_obs_f2`, the function does not use depends on
    `pyPDAF.PDAF.gather_dim_obs_f`

    Parameters
    ----------
    dim_obs_f : int
        Full observation dimension
    coords_p : ndarray[tuple[nrows, dim_obs_p], np.float64]
        PE-local array
        The 1st-th dimension nrows is Number of rows in array
        The 2nd-th dimension dim_obs_p is PE-local observation dimension

    Returns
    -------
    coords_f : ndarray[tuple[nrows, dim_obs_f], np.float64]
         Full gathered array

        The 1st-th dimension nrows is Number of rows in array
        The 2nd-th dimension dim_obs_f is Full observation dimension
    status : int
        Status flag: (0) no error
    """
    ...

def gather_obs_f_flex (dim_obs_f: int,obs_p: np.ndarray[tuple[int], np.dtype[np.float64]]
                      ) -> tuple[np.ndarray[tuple[int], np.dtype[np.float64]], int]:
    r"""In the local filters (LESKTF, LETKF, LSEIK, LNETF) this function returns the total observation vector from process-local observations. `pyPDAF.PDAF.gather_obs_f2_flex` is used to get corresponding coordinates.
    Unlike `pyPDAF.PDAF.gather_obs_f`, the function does not use depends on `pyPDAF.PDAF.gather_dim_obs_f`

    Parameters
    ----------
    dim_obs_f : int
        Full observation dimension
    obs_p : ndarray[tuple[dim_obs_p], np.float64]
        PE-local vector
        The array dimension `dim_obs_p` is PE-local observation dimension

    Returns
    -------
    obs_f : ndarray[tuple[dim_obs_f], np.float64]
         Full gathered vector

        The array dimension `dim_obs_f` is Full observation dimension
    status : int
        Status flag: (0) no error
    """
    ...

def prepost (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
             py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
             py__prepoststep_pdaf : Callable[[int, int, int, int, int, 
                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                              int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                              np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
             py__next_observation_pdaf : Callable[[int, int, int, float], tuple[int, 
                                                   int, float]]
            ) -> int:
    r"""This function does not perform any DA. It is used to perform a preprocess and postprocess of the ensemble. Compared to `pyPDAF.PDAF.assimilate_prepost`, this function does not set assimilation flag.
    The function is a combination of `pyPDAF.PDAF.put_state_prepost` and `pyPDAF.PDAF.get_state`, and executes the user-supplied function in the following sequence: 
    1. py__collect_state_pdaf
    2. py__prepoststep_state_pdaf
    3. py__prepoststep_state_pdaf
    4. py__distribute_state_pdaf
    5. py__next_observation_pdaf
    

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def set_memberid (memberid: int) -> int:
    r"""This function sets the ensemble member index to given value.

    Parameters
    ----------
    memberid : int
        Index in the local ensemble

    Returns
    -------
    memberid : int
        Index in the local ensemble
    """
    ...

def set_comm_pdaf (in_COMM_pdaf: int) -> None:
    r"""Setting the MPI communicator used by PDAF.

    Without using this function `MPI_COMM_WORLD` is used.
    This function is very useful if a set of processors is dedicated for I/O or other operations.

    Parameters
    ----------
    in_COMM_pdaf : int
        MPI communicator used by PDAF
    """
    ...

def set_offline_mode (screen: int) -> None:
    r"""This function activates offline mode.

    Parameters
    ----------
    screen : int
        Verbosity flag
    """
    ...

def print_domain_stats (n_domains_p: int) -> None:
    r"""This function make screen output of statistics of the local domains on current process.

    Parameters
    ----------
    n_domains_p : int
        Number of PE-local analysis domains
    """
    ...

def init_local_obsstats () -> None:
    r"""This function initialise the observation statistics of local domain. This statistics can be updated by `pyPDAF.PDAF.incr_local_obsstats`, and can be viewed by `pyPDAF.PDAF.print_local_obsstats`.

    """
    ...

def incr_local_obsstats (dim_obs_l: int) -> None:
    r"""This function update the observation statistics of local domain. This statistics should be initialised by `pyPDAF.PDAF.init_local_obsstats`, and can be viewed by `pyPDAF.PDAF.print_local_obsstats`.

    Parameters
    ----------
    dim_obs_l : int
        Number of locally assimilated observations
    """
    ...

def print_local_obsstats (screen: int) -> int:
    r"""This function print the observation statistics of local domain on screen. This statistics should be initialised by `pyPDAF.PDAF.init_local_obsstats`, and can be updated by `pyPDAF.PDAF.incr_local_obsstats`.

    Parameters
    ----------
    screen : int
        Verbosity flag

    Returns
    -------
    n_domains_with_obs : int
        number of domains with observations
    """
    ...

def omit_obs_omi (state_p: np.ndarray[tuple[int], np.dtype[np.float64]],
                  ens_p: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                  obs_p: np.ndarray[tuple[int], np.dtype[np.float64]],py__init_obs_pdaf : Callable[[int, 
                                                                                                    int, 
                                                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                  py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                  compute_mean: int,screen: int) -> tuple[np.ndarray[tuple[int], np.dtype[np.float64]], np.ndarray[tuple[int], np.dtype[np.float64]], 
                                              ]:
    r"""This function computes innovation and omit corresponding observations in assimilation if the innovation is too large. This function is used by some of the global filters, e.g. EnKF, LEnKF, PF, NETF, with OMI.

    Parameters
    ----------
    state_p : ndarray[tuple[dim_p], np.float64]
        on exit: PE-local forecast mean state
        The array dimension `dim_p` is PE-local dimension of model state
    ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]
        PE-local state ensemble
        The 1st-th dimension dim_p is PE-local dimension of model state
        The 2nd-th dimension dim_ens is Size of ensemble
    obs_p : ndarray[tuple[dim_obs_p], np.float64]
        PE-local observation vector
        The array dimension `dim_obs_p` is PE-local dimension of observation vector
    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    compute_mean : int
        (1) compute mean; (0) state_p holds mean
    screen : int
        Verbosity flag

    Returns
    -------
    state_p : ndarray[tuple[dim_p], np.float64]
         on exit: PE-local forecast mean state

        The array dimension `dim_p` is PE-local dimension of model state
    obs_p : ndarray[tuple[dim_obs_p], np.float64]
         PE-local observation vector

        The array dimension `dim_obs_p` is PE-local dimension of observation vector
    """
    ...

def diag_CRPS_nompi (element: int,oens: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                     obs: np.ndarray[tuple[int], np.dtype[np.float64]]
                    ) -> tuple[float, float, float, float, int]:
    r"""A continuous rank probability score for
    an ensemble without using MPI parallelisation.

    The implementation is based on [1]_.

    References
    ----------
    .. [1] Hersbach, H. (2000), 
           Decomposition of the Continuous Ranked Probability
           Score for
           Ensemble Prediction Systems,
           Wea. Forecasting, 15, 559570,
           doi:10.1175/1520-0434(2000)015<0559:DOTCRP>2.0.CO;2

    Parameters
    ----------
    element : int
        ID of element to be used
        If element=0, mean values over all elements are computed
    oens : ndarray[tuple[dim, dim_ens], np.float64]
        State ensemble
        The 1st-th dimension dim is PE-local state dimension
        The 2nd-th dimension dim_ens is Ensemble size
    obs : ndarray[tuple[dim], np.float64]
        State ensemble
        The array dimension `dim` is PE-local state dimension

    Returns
    -------
    CRPS : float
        CRPS
    reli : float
        Reliability
    resol : float
        resolution
    uncert : float
        uncertainty
    status : int
        Status flag (0=success)
    """
    ...

def omi_init (n_obs: int) -> None:
    r"""Allocating an array of `obs_f` derived types instances.

    This function initialises the number of observation types,
    which should be called at the start of the DA system
    after :func:`pyPDAF.PDAF.init`.

    Parameters
    ----------
    n_obs : int
        number of observations
    """
    ...

def omi_set_doassim (i_obs: int,doassim: int) -> None:
    r"""Setting the `doassim` attribute of `obs_f`.

    Properties of `obs_f` are typically set in user-supplied function
    `py__init_dim_obs_pdaf`.

    If `doassim` is set to 0,
    the given type of observation is not assimilated in the DA system. 

    Parameters
    ----------
    i_obs : int
        index of observation types
    doassim : int
        0) do not assimilate;
        1) assimilate the observation type
    """
    ...

def omi_set_disttype (i_obs: int,disttype: int) -> None:
    r"""Setting the `disttype` attribute of `obs_f`.

    Properties of `obs_f` are typically set in user-supplied function
    `py__init_dim_obs_pdaf`.

    `disttype` determines the way the distance
    between observation and model grid is calculated in OMI.
    See `PDAF distance computation <https://pdaf.awi.de/trac/wiki/OMI_observation_modules#thisobsdisttype>`_.

    Parameters
    ----------
    i_obs : int
        index of observations
    disttype : int
        0) Cartesian; 1) Cartesian periodic
        2) Approximation to geographic distance in metres using latitude and longitude expressed in radians
        3) Using Haversine formula to compute distance in metres between two points on the surface of a sphere
        10) 3D Cartesian distance for 2D+1D factorised localisation where horizontal and vertical distances are treated separately
        11) 3D Cartesian periodic distance for 2D+1D factorised localisation where horizontal and vertical distances are treated separately
        12) Same as 2) for horizontal distance but vertical distance is in units chosen by users
        13) Same as 3) for horizontal distance but vertical distance is in units chosen by users
    """
    ...

def omi_set_ncoord (i_obs: int,ncoord: int) -> None:
    r"""Setting the `ncoord` attribute of `obs_f`.

    Properties of `obs_f` are typically set in user-supplied function
    `py__init_dim_obs_pdaf`.

    `disttype` gives the coordinate dimension of the observation.

    Parameters
    ----------
    i_obs : int
        index of observations
    ncoord : int
        Dimension of the observation coordinate
    """
    ...

def omi_set_id_obs_p (i_obs: int,id_obs_p: np.ndarray[tuple[int, int], np.dtype[np.intc]]
                     ) -> None:
    r"""Setting the `id_obs_p` attribute of `obs_f`.

    The function is typically used in user-supplied
    function `py__init_dim_obs_pdaf`.

    Here, `id_obs_p(nrows, dim_obs_p)` is a 2D array of integers.
    The value of `nrows` depends on the observation operator
    used for an observation.

    Examples:

    - `nrows=1`: observations are located on model grid point.
      In this case,
      `id_obs_p` stores the index of the state vector
      (starting from 1) corresponds to the observations,
      e.g. `id_obs_p[0, j] = i` means that the location
      and variable of the `i`-th element of the state vector
      is the same as the `j`-th observation.

    - `nrows=4`: each observation corresponds to
      4 indices of elements in the state vector.
      In this case,
      the location of these elements is used to perform bi-linear interpolation
      from model grid to observation location.
      This information is used in the :func:`pyPDAF.PDAF.omi_obs_op_gridavg`
      and :func:`pyPDAF.PDAF.omi_obs_op_interp_lin` functions.
      When interpolation is needed,
      the weighting of the interpolation is done
      in the :func:`pyPDAF.PDAF.omi_get_interp_coeff_lin`,
      :func:`pyPDAF.PDAF.omi_get_interp_coeff_lin1D`,
      and :func:`pyPDAF.PDAF.omi_get_interp_coeff_tri` functions.
      The details of interpolation setup can be found at
      `PDAF wiki page <https://pdaf.awi.de/trac/wiki/OMI_observation_operators#Initializinginterpolationcoefficients>`_.


    Parameters
    ----------
    i_obs : int
        index of observations
    id_obs_p : ndarray[tuple[nrows, dim_obs_p], np.intc]
        indice corresponds to observations in the state vector
        The 1st-th dimension nrows is Number of values to be averaged or used for interpolation
        The 2nd-th dimension dim_obs_p is dimension of PE local obs
    """
    ...

def omi_set_icoeff_p (i_obs: int,icoeff_p: np.ndarray[tuple[int, int], np.dtype[np.float64]]
                     ) -> None:
    r"""This function sets the `icoeff_p` attribute of `obs_f` typically used in user-supplied function `py__init_dim_obs_pdaf`. `icoeff_p(nrows, dim_obs_p)` is a 2D array of real number used to implement
    interpolations. This is used in tandem with `id_obs_p`. Checking the documentation of `pyPDAF.PDAF.omi_set_id_obs_p` for some details. Also, see https://pdaf.awi.de/trac/wiki/OMI_observation_operators#Initializinginterpolationcoefficients for setting these values.

    Parameters
    ----------
    i_obs : int
        index of observations
    icoeff_p : ndarray[tuple[nrows, dim_obs_p], np.float64]
        weighting coefficients for interpolations
        The 1st-th dimension nrows is Number of values to be averaged
        The 2nd-th dimension dim_obs_p is dimension of PE local obs
    """
    ...

def omi_set_domainsize (i_obs: int,domainsize: np.ndarray[tuple[int], np.dtype[np.float64]]
                       ) -> None:
    r"""This function sets the `domainsize` attribute of `obs_f` typically used in user-supplied function `py__init_dim_obs_pdaf`. `domainsize(ncoord)` is the size of the domain in each spatial dimension. This information is used to compute the Cartesian disance with periodic boundary. If the value of one dimension is `<=0`, no periodicity is assumed in that dimension. 

    Parameters
    ----------
    i_obs : int
        index of observations
    domainsize : ndarray[tuple[ncoord], np.float64]
        Size of the domain in each dimension
        The array dimension `ncoord` is state dimension
    """
    ...

def omi_set_obs_err_type (i_obs: int,obs_err_type: int) -> None:
    r"""This function sets the `obs_err_type` attribute of `obs_f` typically used in user-supplied function `py__init_dim_obs_pdaf`. `obs_err_type` is an integer that specifies the type of observation error. 

    Parameters
    ----------
    i_obs : int
        index of observations
    obs_err_type : int
        0) Gaussian (default); 1) double exponential (Laplacian)
    """
    ...

def omi_set_use_global_obs (i_obs: int,use_global_obs: int) -> None:
    r"""This function sets the `use_global_obs` attribute of `obs_f` typically used in user-supplied function `py__init_dim_obs_pdaf`. In the domain-localized filters (LESTK, LETKF, LSEIK, LNETF) observations are assimilated that are located within the localization around some grid point. When a model uses parallelisation with domain-decomposition some of these observations might belong to a different process-domain. In the default mode (use_global_obs=1) PDAF-OMI gathers all globally available observations so that each process has access to all observations.
    It can be more efficient to limit the observations on a process-domain to those observations that are located inside the domain or within the localization radius around it. Then, in the local analyses less observations have to be checked for their distance. Setting use_global_obs=0 activates this feature. However, it needs additional preparations to make PDAF-OMI aware of the limiting coordinates of a process sub-domain. See https://pdaf.awi.de/trac/wiki/OMI_use_global_obs for the use of `pyPDAF.PDAF.omi_set_domain_limits`.

    Parameters
    ----------
    i_obs : int
        index of observations
    use_global_obs : int
        0) Using process-local observations; 1) using cross-process observations (default)
    """
    ...

def omi_set_inno_omit (i_obs: int,inno_omit: float) -> None:
    r"""This function sets the `inno_omit` attribute of `obs_f` typically used in user-supplied function `py__init_dim_obs_pdaf`. Setting this variable to a value > 0.0 activates the functionality that observations are omitted (made irrelevant) from the analysis update if the difference of their value and the ensemble mean to too large. If inno_omit=2.0, an observation would be omitted if the squared difference between the observed ensemble mean state and the observation value is larger than 2 times the observation error variance
    See https://pdaf.awi.de/trac/wiki/PDAFomi_additional_functionality#Omittingobservationsthatarepotentialoutliers

    Parameters
    ----------
    i_obs : int
        index of observations
    inno_omit : float
        Threshold of innovation to be omitted
    """
    ...

def omi_set_inno_omit_ivar (i_obs: int,inno_omit_ivar: float) -> None:
    r"""This function sets the `inno_omit_ivar` attribute of `obs_f` typically used in user-supplied function `py__init_dim_obs_pdaf`. This is used to specify the inverse of the observations variance to omit the observation. By default it is `1e-12` for a large observation error, but users can adjust this value to ensure that the observation is omitted based on applications
    

    Parameters
    ----------
    i_obs : int
        index of observations
    inno_omit_ivar : float
        Inverse of observation variance for omiited observations
    """
    ...

def omi_gather_obs (i_obs: int,obs_p: np.ndarray[tuple[int], np.dtype[np.float64]],
                    ivar_obs_p: np.ndarray[tuple[int], np.dtype[np.float64]],
                    ocoord_p: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                    cradius: float) -> int:
    r"""Gather the dimension of a given type of observation across
    multiple local domains/filter processors.

    This function can be used in the user-supplied function of
    :func:`py__init_dim_obs_f_pdaf`.

    This function does three things:
        1. Receiving observation dimension on each local process.
        2. Gather the total dimension of given observation type
           across local process and the displacement of PE-local
           observations relative to the total observation vector
        3. Set the observation vector, observation coordinates, 
           the inverse of the observation variance, and localisation
           radius for this observation type.

    

    

    Parameters
    ----------
    i_obs : int
        index of observation type
    obs_p : ndarray[tuple[dim_obs_p], np.float64]
        PE-local observation vector
        The array dimension `dim_obs_p` is dimension of PE-local observation vector
    ivar_obs_p : ndarray[tuple[dim_obs_p], np.float64]
        PE-local inverse of observation error variance
        The array dimension `dim_obs_p` is dimension of PE-local observation vector
    ocoord_p : ndarray[tuple[thisobs(i_obs)%ncoord, dim_obs_p], np.float64]
        pe-local observation coordinates
        The 1st-th dimension dim_obs_p is dimension of PE-local observation vector
    cradius : float
        localization radius

    Returns
    -------
    dim_obs : int
        Full number of observations
    """
    ...

def omi_gather_obsstate (i_obs: int,obsstate_p: np.ndarray[tuple[int], np.dtype[np.float64]],
                         obsstate_f: np.ndarray[tuple[int], np.dtype[np.float64]]
                        ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    r"""This function is used to implement custom observation operators. See https://pdaf.awi.de/trac/wiki/OMI_observation_operators#Implementingyourownobservationoperator

    Parameters
    ----------
    i_obs : int
        index of observations
    obsstate_p : ndarray[tuple[thisobs(i_obs)%dim_obs_p], np.float64]
        Vector of process-local observed state
    obsstate_f : ndarray[tuple[nobs_f_all], np.float64]
        Full observed vector for all types
        The array dimension `nobs_f_all` is dimension of the observation

    Returns
    -------
    obsstate_f : ndarray[tuple[nobs_f_all], np.float64]
         Full observed vector for all types

        The array dimension `nobs_f_all` is dimension of the observation
    """
    ...

def omi_set_domain_limits (lim_coords: np.ndarray[tuple[int, int], np.dtype[np.float64]]
                          ) -> None:
    r"""This is used to set the domain limits for the use of `pyPDAF.PDAF.omi_set_use_global_obs`.Currently, it only supports 2D limitations. See https://pdaf.awi.de/trac/wiki/PDAFomi_additional_functionality#PDAFomi_set_domain_limit
    

    Parameters
    ----------
    lim_coords : ndarray[tuple[2, 2], np.float64]
        geographic coordinate array (1: longitude, 2: latitude)
    """
    ...

def omi_set_debug_flag (debugval: int) -> None:
    r"""This sets the debug flag for OMI. If set to 1, debug information is printed to the screen.
    The debug flag can be set to 0 to stop the debugging. See https://pdaf.awi.de/trac/wiki/OMI_debugging

    Parameters
    ----------
    debugval : int
        Value for debugging flag
    """
    ...

def omi_deallocate_obs (i_obs: int) -> None:
    r"""Deallocate OMI-internal obsrevation arrays

    This function should not be called by users
    because it is called internally in PDAF.

    Parameters
    ----------
    i_obs : int
        index of observations
    """
    ...

def omi_obs_op_gridpoint (i_obs: int,state_p: np.ndarray[tuple[int], np.dtype[np.float64]],
                          obs_f_all: np.ndarray[tuple[int], np.dtype[np.float64]]
                         ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    r"""A (partial) identity observation operator

    This observation operator is used
    when observations and model use the same grid. 

    The observations operator selects state vectors
    where observations are present based on properties given
    in `obs_f`, e.g., `id_obs_p`.

    The function is used in
    the user-supplied function :func:`py__obs_op_pdaf`.

    Parameters
    ----------
    i_obs : int
        index of observations
    state_p : ndarray[tuple[dim_p], np.float64]
        PE-local model state (dim_p)
        The array dimension `dim_p` is dimension of model state
    obs_f_all : ndarray[tuple[nobs_f_all], np.float64]
        Full observed state for all observation types (nobs_f_all)
        The array dimension `nobs_f_all` is dimension of the observation

    Returns
    -------
    obs_f_all : ndarray[tuple[nobs_f_all], np.float64]
         Full observed state for all observation types (nobs_f_all)

        The array dimension `nobs_f_all` is dimension of the observation
    """
    ...

def omi_obs_op_gridavg (i_obs: int,nrows: int,state_p: np.ndarray[tuple[int], np.dtype[np.float64]],
                        obs_f_all: np.ndarray[tuple[int], np.dtype[np.float64]]
                       ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    r"""Observation operator that average values on given model grid points.

    The averaged model grid points are specified in `id_obs_p` property of `obs_f`,
    which can be set in :func:`pyPDAF.PDAF.omi_set_id_obs_p`.

    The function is used in the user-supplied function `py__obs_op_pdaf`. 

    Parameters
    ----------
    i_obs : int
        index of observations
    nrows : int
        Number of values to be averaged
    state_p : ndarray[tuple[dim_p], np.float64]
        PE-local model state (dim_p)
        The array dimension `dim_p` is dimension of model state
    obs_f_all : ndarray[tuple[nobs_f_all], np.float64]
        Full observed state for all observation types (nobs_f_all)
        The array dimension `nobs_f_all` is dimension of the observation

    Returns
    -------
    obs_f_all : ndarray[tuple[nobs_f_all], np.float64]
         Full observed state for all observation types (nobs_f_all)

        The array dimension `nobs_f_all` is dimension of the observation
    """
    ...

def omi_obs_op_interp_lin (i_obs: int,nrows: int,state_p: np.ndarray[tuple[int], np.dtype[np.float64]],
                           obs_f_all: np.ndarray[tuple[int], np.dtype[np.float64]]
                          ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    r"""Observation operator that linearly interpolates model grid values to observation location.

    The grid points used by linear interpolation is specified in `id_obs_p` of `obs_f`,
    which can be set by :func:`pyPDAF.PDAF.omi_set_id_obs_p`.

    The function also requires `icoeff_p` attribute of `obs_f`,
    which can be set by :func:`pyPDAF.PDAF.omi_set_icoeff_p`

    The interpolation coefficient can be obtained by :func:`pyPDAF.PDAF.omi_get_interp_coeff_lin1D`,
    :func:`pyPDAF.PDAF.omi_get_interp_coeff_lin`, and
    :func:`pyPDAF.PDAF.omi_get_interp_coeff_tri`

    The details of interpolation setup can be found at
    `PDAF wiki page <https://pdaf.awi.de/trac/wiki/OMI_observation_operators#Initializinginterpolationcoefficients>`_

    The function is used in the user-supplied function `py__obs_op_pdaf`. 

    Parameters
    ----------
    i_obs : int
        index of observations
    nrows : int
        Number of values to be averaged
    state_p : ndarray[tuple[dim_p], np.float64]
        PE-local model state (dim_p)
        The array dimension `dim_p` is dimension of model state
    obs_f_all : ndarray[tuple[nobs_f_all], np.float64]
        Full observed state for all observation types (nobs_f_all)
        The array dimension `nobs_f_all` is dimension of the observation

    Returns
    -------
    obs_f_all : ndarray[tuple[nobs_f_all], np.float64]
         Full observed state for all observation types (nobs_f_all)

        The array dimension `nobs_f_all` is dimension of the observation
    """
    ...

def omi_obs_op_adj_gridavg (i_obs: int,nrows: int,state_p: np.ndarray[tuple[int], np.dtype[np.float64]],
                            obs_f_all: np.ndarray[tuple[int], np.dtype[np.float64]]
                           ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    r"""The adjoint observation operator of :func:`pyPDAF.PDAF.omi_obs_op_gridavg`.

    Parameters
    ----------
    i_obs : int
        index of observations
    nrows : int
        Number of values to be averaged
    state_p : ndarray[tuple[dim_p], np.float64]
        PE-local model state (dim_p)
        The array dimension `dim_p` is dimension of model state
    obs_f_all : ndarray[tuple[nobs_f_all], np.float64]
        Full observed state for all observation types (nobs_f_all)
        The array dimension `nobs_f_all` is dimension of the observation

    Returns
    -------
    state_p : ndarray[tuple[dim_p], np.float64]
         PE-local model state (dim_p)

        The array dimension `dim_p` is dimension of model state
    """
    ...

def omi_obs_op_adj_gridpoint (i_obs: int,state_p: np.ndarray[tuple[int], np.dtype[np.float64]],
                              obs_f_all: np.ndarray[tuple[int], np.dtype[np.float64]]
                             ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    r"""The adjoint observation operator of :func:`pyPDAF.PDAF.omi_obs_op_gridpoint`.

    Parameters
    ----------
    i_obs : int
        index of observations
    state_p : ndarray[tuple[dim_p], np.float64]
        PE-local model state (dim_p)
        The array dimension `dim_p` is dimension of model state
    obs_f_all : ndarray[tuple[nobs_f_all], np.float64]
        Full observed state for all observation types (nobs_f_all)
        The array dimension `nobs_f_all` is dimension of the observation

    Returns
    -------
    state_p : ndarray[tuple[dim_p], np.float64]
         PE-local model state (dim_p)

        The array dimension `dim_p` is dimension of model state
    """
    ...

def omi_obs_op_adj_interp_lin (i_obs: int,nrows: int,state_p: np.ndarray[tuple[int], np.dtype[np.float64]],
                               obs_f_all: np.ndarray[tuple[int], np.dtype[np.float64]]
                              ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    r"""The adjoint observation operator of :func:`pyPDAF.PDAF.omi_obs_op_interp_lin`.

    Parameters
    ----------
    i_obs : int
        index of observations
    nrows : int
        Number of values to be averaged
    state_p : ndarray[tuple[dim_p], np.float64]
        PE-local model state (dim_p)
        The array dimension `dim_p` is dimension of model state
    obs_f_all : ndarray[tuple[nobs_f_all], np.float64]
        Full observed state for all observation types (nobs_f_all)
        The array dimension `nobs_f_all` is dimension of the observation

    Returns
    -------
    state_p : ndarray[tuple[dim_p], np.float64]
         PE-local model state (dim_p)

        The array dimension `dim_p` is dimension of model state
    """
    ...

def omi_get_interp_coeff_tri (gpc: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                              oc: np.ndarray[tuple[int], np.dtype[np.float64]],
                              icoeff: np.ndarray[tuple[int], np.dtype[np.float64]]
                             ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    r"""The coefficient for linear interpolation in 2D on unstructure triangular grid.

    The resulting coefficient is used in :func:`omi_obs_op_interp_lin`.

    This function is for triangular model grid interpolation coefficients determined as barycentric coordinates.

    Parameters
    ----------
    gpc : ndarray[tuple[3, 2], np.float64]
        Coordinates of grid points with dimension of (3, 2).
        3 grid points surrounding the observation;
        each containing lon and lat coordinates.
        The order of the grid points in gcoords has to
        be consistent with the order of the indices specified in
        `id_obs_p` of `obs_f`.
    oc : ndarray[tuple[2], np.float64]
        Coordinates of observation (targeted location); dim(2)
    icoeff : ndarray[tuple[3], np.float64]
        Interpolation coefficients; dim(3)

    Returns
    -------
    icoeff : ndarray[tuple[3], np.float64]
         Interpolation coefficients; dim(3)

    """
    ...

def omi_get_interp_coeff_lin1D (gpc: np.ndarray[tuple[int], np.dtype[np.float64]],
                                oc: float,icoeff: np.ndarray[tuple[int], np.dtype[np.float64]]
                               ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    r"""The coefficient for linear interpolation in 1D.

    The resulting coefficient is used in :func:`omi_obs_op_interp_lin`.

    

    Parameters
    ----------
    gpc : ndarray[tuple[2], np.float64]
        Coordinates of grid points surrounding the observations (dim=2)
    oc : float
        Coordinates of observation (targeted location)
    icoeff : ndarray[tuple[2], np.float64]
        Interpolation coefficients (dim=2)

    Returns
    -------
    icoeff : ndarray[tuple[2], np.float64]
         Interpolation coefficients (dim=2)

    """
    ...

def omi_get_interp_coeff_lin (gpc: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                              oc: np.ndarray[tuple[int], np.dtype[np.float64]],
                              icoeff: np.ndarray[tuple[int], np.dtype[np.float64]]
                             ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    r"""The coefficient for linear interpolation up to 3D.

    The resulting coefficient is used in :func:`omi_obs_op_interp_lin`.

    See introduction in `PDAF-OMI wiki page 
    <https://pdaf.awi.de/trac/wiki/OMI_observation_operators#PDAFomi_get_interp_coeff_lin>`_

    Parameters
    ----------
    gpc : ndarray[tuple[num_gp, n_dim], np.float64]
        Coordinates of grid points
        The order of the grid points in gcoords has to
        be consistent with the order of the indices specified in
        `id_obs_p` of `obs_f`.
        The 1st-th dimension num_gp is Length of icoeff
        The 2nd-th dimension n_dim is Number of dimensions in interpolation
    oc : ndarray[tuple[n_dim], np.float64]
        Coordinates of observation
        The array dimension `n_dim` is Number of dimensions in interpolation
    icoeff : ndarray[tuple[num_gp], np.float64]
        Interpolation coefficients (num_gp)
        The array dimension `num_gp` is Length of icoeff

    Returns
    -------
    icoeff : ndarray[tuple[num_gp], np.float64]
         Interpolation coefficients (num_gp)

        The array dimension `num_gp` is Length of icoeff
    """
    ...

def omi_assimilate_3dvar (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__init_dim_obs_pdaf : Callable[[int, int], int],
                          py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__cvt_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__cvt_adj_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__obs_op_lin_pdaf : Callable[[int, int, int, 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__obs_op_adj_pdaf : Callable[[int, int, int, 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__prepoststep_pdaf : Callable[[int, int, int, 
                                                           int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                          py__next_observation_pdaf : Callable[[int, int, 
                                                                int, float], tuple[int, 
                                                                int, float]],
                          outflag: int) -> int:
    r"""3DVar DA for a single DA step
    using diagnoal observation error covariance matrix.

    See :func:`pyPDAF.PDAF.omi_assimilate_3dvar_nondiagR`
    for non-diagonal observation error covariance matrix.

    When 3DVar is used, the background error covariance matrix
    has to be modelled for cotrol variable transformation.
    This is a deterministic filtering scheme
    so no ensemble and parallelisation is needed.
    This function should be called at each model time step.

    The function is a combination of
    :func:`pyPDAF.PDAF.omi_put_state_3dvar`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. Iterative optimisation:
            1. py__cvt_pdaf
            2. py__obs_op_lin_pdaf
            3. py__obs_op_adj_pdaf
            4. py__cvt_adj_pdaf
            5. core DA algorithm
        6. py__cvt_pdaf
        7. py__prepoststep_state_pdaf
        8. py__distribute_state_pdaf
        9. py__next_observation_pdaf

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_assimilate_en3dvar_estkf (py__collect_state_pdaf : Callable[[int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__distribute_state_pdaf : Callable[[int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__init_dim_obs_pdaf : Callable[[int, 
                                                                    int], int],
                                  py__obs_op_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__cvt_ens_pdaf : Callable[[int, int, 
                                                               int, int, 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__obs_op_lin_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__obs_op_adj_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__prepoststep_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                  py__next_observation_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        float], tuple[int, 
                                                                        int, 
                                                                        float]],
                                  outflag: int) -> int:
    r"""3DEnVar for a single DA step
    using diagnoal observation error covariance matrix.

    See :func:`pyPDAF.PDAF.omi_assimilate_en3dvar_estkf_nondiagR`
    for using non-diagonal observation error covariance matirx.

    Here, the background error covariance matrix is
    estimated by an ensemble.
    The 3DEnVar only calculates the analysis of the ensemble mean.
    An ESTKF is used along with 3DEnVar to generate ensemble perturbations.
    This function should be called at each model time step.

    The function is a combination of
    :func:`pyPDAF.PDAF.omi_put_state_en3dvar_estkf`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. the iterative optimisation:
            1. py__cvt_ens_pdaf
            2. py__obs_op_lin_pdaf
            3. py__obs_op_adj_pdaf
            4. py__cvt_adj_ens_pdaf
            5. core 3DEnVar algorithm
        6. py__cvt_ens_pdaf
        7. ESTKF:
            1. py__init_dim_obs_pdaf
            2. py__obs_op_pdaf (for ensemble mean)
            3. py__obs_op_pdaf (for each ensemble member)
            4. core ESTKF algorithm
        8. py__prepoststep_state_pdaf
        9. py__distribute_state_pdaf
        10. py__next_observation_pdaf

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_assimilate_en3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__distribute_state_pdaf : Callable[[int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__init_dim_obs_pdaf : Callable[[int, 
                                                                     int], int],
                                   py__obs_op_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__cvt_ens_pdaf : Callable[[int, int, 
                                                                int, int, 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__obs_op_lin_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__obs_op_adj_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__init_n_domains_p_pdaf : Callable[[int, 
                                                                         int], int],
                                   py__init_dim_l_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int], int],
                                   py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int, 
                                                                       int], int],
                                   py__g2l_state_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__l2g_state_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__prepoststep_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                   py__next_observation_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         float], tuple[int, 
                                                                         int, 
                                                                         float]],
                                   outflag: int) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.localomi_assimilate_en3dvar_lestkf`
    or :func:`pyPDAF.PDAF.localomi_assimilate_en3dvar_lestkf_nondiagR`.

    PDAFlocal-OMI modules require fewer user-supplied
    functions and improved efficiency.

    3DEnVar for a single DA step where the ensemble anomaly
    is generated by LESTKF using diagnoal observation
    error covariance matrix.
    The background error covariance matrix is estimated by ensemble.
    The 3DEnVar only calculates the analysis of the ensemble mean.
    An LESTKF is used to generate ensemble perturbations.
    This function should be called at each model time step.

    The function is a combination of
    :func:`pyPDAF.PDAF.omi_put_state_en3dvar_lestkf`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. Starting the iterative optimisation:
            1. py__cvt_ens_pdaf
            2. py__obs_op_lin_pdaf
            3. py__obs_op_adj_pdaf
            4. py__cvt_adj_ens_pdaf
            5. core DA algorithm
        6. py__cvt_ens_pdaf
        7. Perform LESTKF:
            1. py__init_n_domains_p_pdaf
            2. py__init_dim_obs_pdaf
            3. py__obs_op_pdaf
               (for each ensemble member)
            4. loop over each local domain:
                1. py__init_dim_l_pdaf
                2. py__init_dim_obs_l_pdaf
                3. py__g2l_state_pdaf
                4. core DA algorithm
                5. py__l2g_state_pdaf
        8. py__prepoststep_state_pdaf
        9. py__distribute_state_pdaf
        10. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_assimilate_en3dvar_lestkf`
       and :func:`pyPDAF.PDAF.localomi_assimilate_en3dvar_lestkf_nondiagR`

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from local state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_assimilate_global (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                           py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                           py__init_dim_obs_pdaf : Callable[[int, int], int],
                           py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                           py__prepoststep_pdaf : Callable[[int, int, int, 
                                                            int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                           py__next_observation_pdaf : Callable[[int, int, 
                                                                 int, float], tuple[int, 
                                                                 int, float]]
                          ) -> int:
    r"""Global filters except for 3DVar
    for a single DA step using diagnoal
    observation error covariance matrix.

    See :func:`pyPDAF.PDAF.omi_assimilate_enkf_nondiagR`, 
    or :func:`pyPDAF.PDAF.omi_assimilate_global_nondiagR`,
    or :func:`pyPDAF.PDAF.omi_assimilate_nonlin_nondiagR`
    for non-diagonal observation error covariance matrix.

    Here, this function call is used for
    global stochastic EnKF [1]_, E(S)TKF [2]_, 
    SEEK [2]_, SEIK [2]_, NETF [3]_, and particle filter [4]_.
    The filter type is set in :func:`pyPDAF.PDAF.init`.
    This function should be called at each model time step. 

    The function is a combination of
    :func:`pyPDAF.PDAF.omi_put_state_global` and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf (for ensemble mean)
        5. py__obs_op_pdaf (for each ensemble member)
        6. core DA algorithm
        7. py__prepoststep_state_pdaf
        8. py__distribute_state_pdaf
        9. py__next_observation_pdaf

    References
    ----------
    .. [1] Evensen, G. (1994), 
           Sequential data assimilation with
           a nonlinear quasi-geostrophic model
           using Monte Carlo methods to forecast error statistics,
           J. Geophys. Res., 99(C5), 1014310162, doi:10.1029/94JC00572.
    .. [2] Nerger, L., Janji, T., Schrter, J., Hiller, W. (2012). 
           A unification of ensemble square root Kalman filters. 
           Monthly Weather Review, 140, 2335-2345.
           doi:10.1175/MWR-D-11-00102.1
    .. [3] Tdter, J., and B. Ahrens, 2015:
           A second-order exact ensemble square root filter
           for nonlinear data assimilation. Mon. Wea. Rev.,
           143, 13471367, doi:10.1175/MWR-D-14-00108.1.
    .. [4] Van Leeuwen, P. J., Knsch, H. R., Nerger, L.,
           Potthast, R., & Reich, S. (2019).
           Particle filters for highdimensional geoscience applications:
           A review. Quarterly Journal of the Royal Meteorological Society, 145(723), 2335-2365.

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def omi_assimilate_hyb3dvar_estkf (py__collect_state_pdaf : Callable[[int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__distribute_state_pdaf : Callable[[int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__init_dim_obs_pdaf : Callable[[int, 
                                                                     int], int],
                                   py__obs_op_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__cvt_ens_pdaf : Callable[[int, int, 
                                                                int, int, 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__cvt_pdaf : Callable[[int, int, int, 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__cvt_adj_pdaf : Callable[[int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__obs_op_lin_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__obs_op_adj_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__prepoststep_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                   py__next_observation_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         float], tuple[int, 
                                                                         int, 
                                                                         float]],
                                   outflag: int) -> int:
    r"""Hybrid 3DEnVar for a single DA step
    using diagnoal observation error covariance matrix.

    See :func:`pyPDAF.PDAF.omi_assimilate_hyb3dvar_estkf_nondiagR`
    for non-diagonal observation error covariance matrix.

    Here the background error covariance is hybridised by
    a static background error covariance,
    and a flow-dependent background error covariance
    estimated from ensemble.
    The 3DVar generates an ensemble mean and
    the ensemble perturbation is generated by
    ESTKF in this implementation.
    This function should be called at each model time step.

    The function is a combination of
    :func:`pyPDAF.PDAF.omi_put_state_hyb3dvar_estkf`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. the iterative optimisation:
            1. py__cvt_pdaf
            2. py__cvt_ens_pdaf
            3. py__obs_op_lin_pdaf
            4. py__obs_op_adj_pdaf
            5. py__cvt_adj_pdaf
            6. py__cvt_adj_ens_pdaf
            7. core 3DEnVar algorithm
        6. py__cvt_pdaf
        7. py__cvt_ens_pdaf
        8. Perform ESTKF:
            1. py__init_dim_obs_pdaf
            2. py__obs_op_pdaf
               (for ensemble mean)
            3. py__obs_op_pdaf
               (for each ensemble member)
            4. core ESTKF algorithm
        9. py__prepoststep_state_pdaf
        10. py__distribute_state_pdaf
        11. py__next_observation_pdaf

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply ensemble control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint ensemble control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_assimilate_hyb3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__distribute_state_pdaf : Callable[[int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__init_dim_obs_pdaf : Callable[[int, 
                                                                      int], int],
                                    py__obs_op_pdaf : Callable[[int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__cvt_ens_pdaf : Callable[[int, int, 
                                                                 int, int, 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__cvt_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__cvt_adj_pdaf : Callable[[int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__obs_op_lin_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__obs_op_adj_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__init_n_domains_p_pdaf : Callable[[int, 
                                                                          int], int],
                                    py__init_dim_l_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int], int],
                                    py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        int], int],
                                    py__g2l_state_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__l2g_state_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__prepoststep_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                    py__next_observation_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          float], tuple[int, 
                                                                          int, 
                                                                          float]],
                                    outflag: int) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.localomi_assimilate_hyb3dvar_lestkf`
    or :func:`pyPDAF.PDAF.localomi_assimilate_hyb3dvar_lestkf_nondiagR`.

    PDAFlocal-OMI modules require fewer user-supplied
    functions and improved efficiency.

    Hybrid 3DEnVar for a single DA step
    using diagnoal observation error covariance matrix where
    the background error covariance is hybridised by
    a static background error covariance,
    and a flow-dependent background error covariance
    estimated from ensemble.
    The 3DVar generates an ensemble mean and
    the ensemble perturbation is generated by
    LESTKF in this implementation.
    This function should be called at each model time step.

    The function is a combination of
    :func:`pyPDAF.PDAF.omi_put_state_hyb3dvar_lestkf`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. The iterative optimisation:
            1. py__cvt_pdaf
            2. py__cvt_ens_pdaf
            3. py__obs_op_lin_pdaf
            4. py__obs_op_adj_pdaf
            5. py__cvt_adj_pdaf
            6. py__cvt_adj_ens_pdaf
            7. core DA algorithm
        6. py__cvt_pdaf
        7. py__cvt_ens_pdaf
        8. Perform LESTKF:
            1. py__init_n_domains_p_pdaf
            2. py__init_dim_obs_pdaf
            3. py__obs_op_pdaf
               (for each ensemble member)
            4. loop over each local domain:
                1. py__init_dim_l_pdaf
                2. py__init_dim_obs_l_pdaf
                3. py__g2l_state_pdaf
                4. core DA algorithm
                5. py__l2g_state_pdaf
        9. py__prepoststep_state_pdaf
        10. py__distribute_state_pdaf
        11. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_assimilate_hyb3dvar_lestkf`
       and :func:`pyPDAF.PDAF.localomi_assimilate_hyb3dvar_lestkf_nondiagR`

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from local state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_assimilate_lenkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__init_dim_obs_pdaf : Callable[[int, int], int],
                          py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__prepoststep_pdaf : Callable[[int, int, int, 
                                                           int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                          py__localize_covar_pdaf : Callable[[int, int, 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]]], tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                          py__next_observation_pdaf : Callable[[int, int, 
                                                                int, float], tuple[int, 
                                                                int, float]]
                         ) -> int:
    r"""Covariance localised stochastic EnKF
    for a single DA step using diagnoal observation error covariance matrix.

    See :func:`pyPDAF.PDAF.omi_assimilate_lenkf_nondiagR`
    for non-diagnoal observation error covariance matrix.

    This is the only scheme for covariance localisation in PDAF.

    The implementation is based on [1]_.

    This function should be called at each model time step.
    The function is a combination of
    :func:`pyPDAF.PDAF.omi_put_state_lenkf`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf (for each ensemble member)
        5. py__localize_pdaf
        6. py__obs_op_pdaf (repeated to reduce storage)
        7. core DA algorith
        8. py__prepoststep_state_pdaf
        9. py__distribute_state_pdaf
        10. py__next_observation_pdaf

    References
    ----------
    .. [1] Houtekamer, P. L., and H. L. Mitchell (1998): 
           Data Assimilation Using an Ensemble Kalman Filter Technique.
           Mon. Wea. Rev., 126, 796811,
           doi: 10.1175/1520-0493(1998)126<0796:DAUAEK>2.0.CO;2.

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__localize_covar_pdaf : Callable[dim_p:int, dim_obs:int, hp_p:ndarray[tuple[dim_obs, dim_p], np.float64], hph:ndarray[tuple[dim_obs, dim_obs], np.float64]]
        Apply localization to HP and HPH^T

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_obs** : int

            --- number of observations

        * **hp_p** : ndarray[tuple[dim_obs, dim_p], np.float64]

            --- pe local part of matrix hp

        * **hph** : ndarray[tuple[dim_obs, dim_obs], np.float64]

            --- matrix hph

        **Callback Returns**

        * **hp_p** : ndarray[tuple[dim_obs, dim_p], np.float64]

            --- pe local part of matrix hp

        * **hph** : ndarray[tuple[dim_obs, dim_obs], np.float64]

            --- matrix hph


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def omi_assimilate_local (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__init_dim_obs_pdaf : Callable[[int, int], int],
                          py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__prepoststep_pdaf : Callable[[int, int, int, 
                                                           int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                          py__init_n_domains_p_pdaf : Callable[[int, int], int],
                          py__init_dim_l_pdaf : Callable[[int, int, int], int],
                          py__init_dim_obs_l_pdaf : Callable[[int, int, 
                                                              int, int], int],
                          py__g2l_state_pdaf : Callable[[int, int, int, 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__l2g_state_pdaf : Callable[[int, int, int, 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__next_observation_pdaf : Callable[[int, int, 
                                                                int, float], tuple[int, 
                                                                int, float]]
                         ) -> int:
    r"""It is recommended to use :func:`pyPDAF.PDAF.localomi_assimilate`
    or :func:`pyPDAF.PDAF.localomi_assimilate_nondiagR`,
    or :func:`pyPDAF.PDAF.localomi_assimilate_lnetf_nondiagR`,
    or :func:`pyPDAF.PDAF.localomi_assimilate_lknetf_nondiagR`.

    PDAFlocal-OMI modules require fewer user-supplied
    functions and improved efficiency.

    Domain local filters for a single DA step
    using diagnoal observation error covariance matrix.
    Here, this function call is used for LE(S)TKF [1]_, 
    LSEIK [1]_, LNETF [2]_, and LKNETF [3]_.
    The filter type is set in :func:`pyPDAF.PDAF.init`.
    This function should be called at each model time step.
    The function is a combination of
    :func:`pyPDAF.PDAF.omi_put_state_local`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. py__g2l_state_pdaf
            4. core DA algorithm
            5. py__l2g_state_pdaf
        7. py__prepoststep_state_pdaf
        8. py__distribute_state_pdaf
        9. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_assimilate`
       and :func:`pyPDAF.PDAF.localomi_assimilate_nondiagR`,
       and :func:`pyPDAF.PDAF.localomi_assimilate_lnetf_nondiagR`,
       and :func:`pyPDAF.PDAF.localomi_assimilate_lknetf_nondiagR`.

    References
    ----------
    .. [1] Nerger, L., Janji, T., Schrter, J., Hiller, W. (2012). 
           A unification of ensemble square root Kalman filters. 
           Monthly Weather Review, 140, 2335-2345.
           doi:10.1175/MWR-D-11-00102.1
    .. [2] Tdter, J., and B. Ahrens, 2015:
           A second-order exact ensemble square root filter
           for nonlinear data assimilation. Mon. Wea. Rev.,
           143, 13471367, doi:10.1175/MWR-D-14-00108.1.
    .. [3] Nerger, L.. (2022) 
           Data assimilation for nonlinear systems with
           a hybrid nonlinear Kalman ensemble transform filter. 
           Q J R Meteorol Soc, 620640. doi:10.1002/qj.4221

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def omi_generate_obs (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_dim_obs_pdaf : Callable[[int, int], int],
                      py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__get_obs_f_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                       int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                      py__next_observation_pdaf : Callable[[int, int, int, 
                                                            float], tuple[int, 
                                                            int, float]]
                     ) -> int:
    r"""Generation of synthetic observations
    based on given error statistics and observation operator
    for diagonal observation error covariance matrix.

    If non-diagonal observation error covariance matrix has to be used,
    the generic :func:`pyPDAF.PDAF.generate_obs` can be used.

    The generated synthetic observations are
    based on each member of model forecast.
    Therefore, an ensemble of observations can
    be obtained. In a typical experiment,
    one may only need one ensemble member.
    The implementation strategy is similar to
    an assimilation step. This means that, 
    one can reuse many user-supplied functions
    for assimilation and observation generation.

    The function is a combination of
    :func:`pyPDAF.PDAF.omi_put_state_generate_obs`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pda
        5. py__get_obs_f_pdaf
        6. py__prepoststep_state_pdaf
        7. py__distribute_state_pdaf
        8. py__next_observation_pdaf

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__get_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f:ndarray[tuple[dim_obs_f], np.float64]]
        Provide observation vector to user

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of the full observation vector

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of synthetic observations (process-local)

        **Callback Returns**

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of synthetic observations (process-local)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def omi_put_state_3dvar (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                         py__init_dim_obs_pdaf : Callable[[int, int], int],
                         py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                         py__cvt_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                         py__cvt_adj_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                         py__obs_op_lin_pdaf : Callable[[int, int, int, 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                         py__obs_op_adj_pdaf : Callable[[int, int, int, 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                         py__prepoststep_pdaf : Callable[[int, int, int, 
                                                          int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                         outflag: int) -> int:
    r"""3DVar DA for a single DA step
    using diagnoal observation error covariance matrix
    without post-processing, distributing analysis,
    and setting next observation step.

    See :func:`pyPDAF.PDAF.omi_put_state_3dvar_nondiagR`
    for non-diagonal observation error covariance matrix.

    Compared to :func:`pyPDAF.PDAF.omi_assimilate_3dvar`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    When 3DVar is used, the background error covariance matrix
    has to be modelled for cotrol variable transformation.
    This is a deterministic filtering scheme
    so no ensemble and parallelisation is needed.
    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. Iterative optimisation:
            1. py__cvt_pdaf
            2. py__obs_op_lin_pdaf
            3. py__obs_op_adj_pdaf
            4. py__cvt_adj_pdaf
            5. core DA algorithm
        6. py__cvt_pdaf

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_put_state_en3dvar_estkf (py__collect_state_pdaf : Callable[[int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                 py__init_dim_obs_pdaf : Callable[[int, 
                                                                   int], int],
                                 py__obs_op_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                 py__cvt_ens_pdaf : Callable[[int, int, 
                                                              int, int, 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                 py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                 py__obs_op_lin_pdaf : Callable[[int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                 py__obs_op_adj_pdaf : Callable[[int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                 py__prepoststep_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                  int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                 outflag: int) -> int:
    r"""3DEnVar for a single DA step
    using diagnoal observation error covariance matrix
    without post-processing, distributing analysis,
    and setting next observation step.

    See :func:`pyPDAF.PDAF.omi_put_state_en3dvar_estkf_nondiagR`
    for non-diagonal observation error covariance matrix.

    Compared to :func:`pyPDAF.PDAF.omi_assimilate_en3dvar_estkf`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    The background error covariance matrix is
    estimated by an ensemble.
    The 3DEnVar only calculates the analysis of
    the ensemble mean.
    An ESTKF is used along with 3DEnVar to
    generate ensemble perturbations.
    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. the iterative optimisation:
            1. py__cvt_ens_pdaf
            2. py__obs_op_lin_pdaf
            3. py__obs_op_adj_pdaf
            4. py__cvt_adj_ens_pdaf
            5. core 3DEnVar algorithm
        6. py__cvt_ens_pdaf
        7. ESTKF:
            1. py__init_dim_obs_pdaf
            2. py__obs_op_pdaf (for ensemble mean)
            3. py__obs_op_pdaf (for each ensemble member)
            4. core ESTKF algorithm

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_put_state_en3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__init_dim_obs_pdaf : Callable[[int, 
                                                                    int], int],
                                  py__obs_op_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__cvt_ens_pdaf : Callable[[int, int, 
                                                               int, int, 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__obs_op_lin_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__obs_op_adj_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__init_n_domains_p_pdaf : Callable[[int, 
                                                                        int], int],
                                  py__init_dim_l_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int], int],
                                  py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      int], int],
                                  py__g2l_state_pdaf : Callable[[int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__l2g_state_pdaf : Callable[[int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__prepoststep_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                  outflag: int) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf`
    or :func:`pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf_nondiagR`.

    PDAFlocal-OMI modules require fewer user-supplied
    functions and improved efficiency.

    3DEnVar for a single DA step where the ensemble anomaly
    is generated by LESTKF using diagnoal observation
    error covariance matrix.

    Compared to
    :func:`pyPDAF.PDAF.omi_assimilate_en3dvar_lestkf`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    The background error covariance matrix is
    estimated by ensemble.
    The 3DEnVar only calculates the analysis of the ensemble mean.
    An LESTKF is used to generate ensemble perturbations.
    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. Starting the iterative optimisation:
            1. py__cvt_ens_pdaf
            2. py__obs_op_lin_pdaf
            3. py__obs_op_adj_pdaf
            4. py__cvt_adj_ens_pdaf
            5. core DA algorithm
        6. py__cvt_ens_pdaf
        7. Perform LESTKF:
            1. py__init_n_domains_p_pdaf
            2. py__init_dim_obs_pdaf
            3. py__obs_op_pdaf
               (for each ensemble member)
            4. loop over each local domain:
                1. py__init_dim_l_pdaf
                2. py__init_dim_obs_l_pdaf
                3. py__g2l_state_pdaf
                4. core DA algorithm
                5. py__l2g_state_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf`
       and :func:`pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf_nondiagR`

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from local state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_put_state_generate_obs (py__collect_state_pdaf : Callable[[int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__init_dim_obs_pdaf : Callable[[int, 
                                                                  int], int],
                                py__obs_op_pdaf : Callable[[int, int, int, 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__get_obs_f_pdaf : Callable[[int, int, 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__prepoststep_pdaf : Callable[[int, int, 
                                                                 int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                 int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]]]]
                               ) -> int:
    r"""Generation of synthetic observations
    based on given error statistics and
    observation operator for diagonal observation
    error covariance matrix
    without post-processing, distributing analysis,
    and setting next observation step.

    If non-diagonal observation error covariance matrix has to be used,
    the generic :func:`pyPDAF.PDAF.put_generate_obs` can be used.

    The generated synthetic observations are
    based on each member of model forecast.
    Therefore, an ensemble of observations can be obtained.
    In a typical experiment,
    one may only need one ensemble member.

    Compared to :func:`pyPDAF.PDAF.omi_generate_obs`,
    this function has no :func:`get_state` call.
    This means that the next DA step will
    not be assigned by user-supplied functions.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    The implementation strategy is similar to
    an assimilation step. This means that, 
    one can reuse many user-supplied functions
    for assimilation and observation generation.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pda
        5. py__get_obs_f_pdaf

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__get_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f:ndarray[tuple[dim_obs_f], np.float64]]
        Provide observation vector to user

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of the full observation vector

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of synthetic observations (process-local)

        **Callback Returns**

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of synthetic observations (process-local)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def omi_put_state_global (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__init_dim_obs_pdaf : Callable[[int, int], int],
                          py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__prepoststep_pdaf : Callable[[int, int, int, 
                                                           int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]]]]
                         ) -> int:
    r"""Global filters except for 3DVar for
    a single DA step using diagnoal observation error covariance matrix
    without post-processing, distributing analysis,
    and setting next observation step.

    See :func:`pyPDAF.PDAF.omi_put_state_enkf_nondiagR`, 
    or :func:`pyPDAF.PDAF.omi_put_state_global_nondiagR`,
    or :func:`pyPDAF.PDAF.omi_put_state_nonlin_nondiagR`
    for non-diagonal observation error covariance matrix.

    OMI functions need fewer user-supplied functions and
    improve DA efficiency.

    Here, this function call is used for
    global stochastic EnKF [1]_, E(S)TKF [2]_, 
    SEEK [2]_, SEIK [2]_, NETF [3]_, and particle filter [4]_.
    The filter type is set in :func:`pyPDAF.PDAF.init`.
    Compared to :func:`pyPDAF.PDAF.omi_assimilate_global`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    The ESTKF is a more efficient equivalent to the ETKF.

    The function should be called at each model time step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf (for ensemble mean)
        5. py__init_obs_pdaf
        6. py__obs_op_pdaf (for each ensemble member)
        7. py__init_obsvar_pdaf (only relevant for
           adaptive forgetting factor schemes)
        8. py__prodRinvA_pdaf
        9. core DA algorithm

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.omi_put_state_global`
       and :func:`pyPDAF.PDAF.omi_put_state_global_nondiagR`.

    References
    ----------
    .. [1] Evensen, G. (1994), 
           Sequential data assimilation with
           a nonlinear quasi-geostrophic model
           using Monte Carlo methods to forecast error statistics,
           J. Geophys. Res., 99(C5), 1014310162, doi:10.1029/94JC00572.
    .. [2] Nerger, L., Janji, T., Schrter, J., Hiller, W. (2012). 
           A unification of ensemble square root Kalman filters. 
           Monthly Weather Review, 140, 2335-2345.
           doi:10.1175/MWR-D-11-00102.1
    .. [3] Tdter, J., and B. Ahrens, 2015:
           A second-order exact ensemble square root filter
           for nonlinear data assimilation. Mon. Wea. Rev.,
           143, 13471367, doi:10.1175/MWR-D-14-00108.1.
    .. [4] Van Leeuwen, P. J., Knsch, H. R., Nerger, L.,
           Potthast, R., & Reich, S. (2019).
           Particle filters for highdimensional geoscience applications:
           A review. Quarterly Journal of the
           Royal Meteorological Society, 145(723), 2335-2365.

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def omi_put_state_hyb3dvar_estkf (py__collect_state_pdaf : Callable[[int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__init_dim_obs_pdaf : Callable[[int, 
                                                                    int], int],
                                  py__obs_op_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__cvt_ens_pdaf : Callable[[int, int, 
                                                               int, int, 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__cvt_pdaf : Callable[[int, int, int, 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__cvt_adj_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__obs_op_lin_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__obs_op_adj_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__prepoststep_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                  outflag: int) -> int:
    r"""Hybrid 3DEnVar for a single DA step
    using diagnoal observation error covariance matrix
    without post-processing, distributing analysis,
    and setting next observation step.

    See :func:`pyPDAF.PDAF.omi_put_state_hyb3dvar_estkf_nondiagR`
    for non-diagonal observation error covariance matrix.

    Hybrid 3DEnVar for a single DA step where
    the background error covariance is hybridised by
    a static background error covariance,
    and a flow-dependent background error covariance
    estimated from ensemble.

    Compared to
    :func:`pyPDAF.PDAF.omi_assimilate_hyb3dvar_estkf`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    The 3DVar generates an ensemble mean and
    the ensemble perturbation is generated by
    ESTKF in this implementation.
    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. the iterative optimisation:
            1. py__cvt_pdaf
            2. py__cvt_ens_pdaf
            3. py__obs_op_lin_pdaf
            4. py__obs_op_adj_pdaf
            5. py__cvt_adj_pdaf
            6. py__cvt_adj_ens_pdaf
            7. core 3DEnVar algorithm
        6. py__cvt_pdaf
        7. py__cvt_ens_pdaf
        8. Perform ESTKF:
            1. py__init_dim_obs_pdaf
            2. py__obs_op_pdaf
               (for ensemble mean)
            3. py__obs_op_pdaf
               (for each ensemble member)
            4. core ESTKF algorithm


    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply ensemble control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint ensemble control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_put_state_hyb3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__init_dim_obs_pdaf : Callable[[int, 
                                                                     int], int],
                                   py__obs_op_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__cvt_ens_pdaf : Callable[[int, int, 
                                                                int, int, 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__cvt_pdaf : Callable[[int, int, int, 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__cvt_adj_pdaf : Callable[[int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__obs_op_lin_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__obs_op_adj_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__init_n_domains_p_pdaf : Callable[[int, 
                                                                         int], int],
                                   py__init_dim_l_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int], int],
                                   py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int, 
                                                                       int], int],
                                   py__g2l_state_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__l2g_state_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__prepoststep_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                   outflag: int) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf`
    or :func:`pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf_nondiagR`.

    PDAFlocal-OMI modules require fewer user-supplied
    functions and improved efficiency.

    Hybrid 3DEnVar for a single DA step using
    diagnoal observation error covariance matrix
    without post-processing, distributing analysis,
    and setting next observation step, where
    the background error covariance is hybridised by
    a static background error covariance,
    and a flow-dependent background error covariance
    estimated from ensemble.

    Compared to
    :func:`pyPDAF.PDAF.omi_assimilate_hyb3dvar_lestkf`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    The 3DVar generates an ensemble mean and
    the ensemble perturbation is generated by
    LESTKF in this implementation.
    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. The iterative optimisation:
            1. py__cvt_pdaf
            2. py__cvt_ens_pdaf
            3. py__obs_op_lin_pdaf
            4. py__obs_op_adj_pdaf
            5. py__cvt_adj_pdaf
            6. py__cvt_adj_ens_pdaf
            7. core DA algorithm
        6. py__cvt_pdaf
        7. py__cvt_ens_pdaf
        8. Perform LESTKF:
            1. py__init_n_domains_p_pdaf
            2. py__init_dim_obs_pdaf
            3. py__obs_op_pdaf
               (for each ensemble member)
            4. loop over each local domain:
                1. py__init_dim_l_pdaf
                2. py__init_dim_obs_l_pdaf
                3. py__g2l_state_pdaf
                4. core DA algorithm
                5. py__l2g_state_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf`
       and :func:`pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf_nondiagR`

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from local state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_put_state_lenkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                         py__init_dim_obs_pdaf : Callable[[int, int], int],
                         py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                         py__prepoststep_pdaf : Callable[[int, int, int, 
                                                          int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                         py__localize_covar_pdaf : Callable[[int, int, 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]], tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]]]
                        ) -> int:
    r"""Stochastic EnKF (ensemble Kalman filter)
    with covariance localisation using diagnoal observation
    error covariance matrix
    without post-processing, distributing analysis,
    and setting next observation step.

    See :func:`pyPDAF.PDAF.omi_put_state_lenkf_nondiagR`
    for non-diagonal observation error covariance matrix.

    Stochastic EnKF (ensemble Kalman filter) with covariance localisation [1]_
    for a single DA step.

    Compared to :func:`pyPDAF.PDAF.omi_assimilate_lenkf`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    This is the only scheme for covariance localisation in PDAF.

    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf (for each ensemble member)
        5. py__localize_pdaf
        6. py__obs_op_pdaf (repeated to reduce storage)
        7. core DA algorith

    References
    ----------
    .. [1] Houtekamer, P. L., and H. L. Mitchell (1998): 
           Data Assimilation Using an Ensemble Kalman Filter Technique.
           Mon. Wea. Rev., 126, 796811,
           doi: 10.1175/1520-0493(1998)126<0796:DAUAEK>2.0.CO;2.

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__localize_covar_pdaf : Callable[dim_p:int, dim_obs:int, hp_p:ndarray[tuple[dim_obs, dim_p], np.float64], hph:ndarray[tuple[dim_obs, dim_obs], np.float64]]
        Apply localization to HP and HPH^T

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_obs** : int

            --- number of observations

        * **hp_p** : ndarray[tuple[dim_obs, dim_p], np.float64]

            --- pe local part of matrix hp

        * **hph** : ndarray[tuple[dim_obs, dim_obs], np.float64]

            --- matrix hph

        **Callback Returns**

        * **hp_p** : ndarray[tuple[dim_obs, dim_p], np.float64]

            --- pe local part of matrix hp

        * **hph** : ndarray[tuple[dim_obs, dim_obs], np.float64]

            --- matrix hph



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def omi_put_state_local (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                         py__init_dim_obs_pdaf : Callable[[int, int], int],
                         py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                         py__prepoststep_pdaf : Callable[[int, int, int, 
                                                          int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                         py__init_n_domains_p_pdaf : Callable[[int, int], int],
                         py__init_dim_l_pdaf : Callable[[int, int, int], int],
                         py__init_dim_obs_l_pdaf : Callable[[int, int, 
                                                             int, int], int],
                         py__g2l_state_pdaf : Callable[[int, int, int, 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                         py__l2g_state_pdaf : Callable[[int, int, int, 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]]
                        ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.localomi_put_state`
    or :func:`pyPDAF.PDAF.localomi_put_state_nondiagR`,
    or :func:`pyPDAF.PDAF.localomi_put_state_lnetf_nondiagR`,
    or :func:`pyPDAF.PDAF.localomi_put_state_lknetf_nondiagR`.

    PDAFlocal-OMI modules require fewer user-supplied
    functions and improved efficiency.

    Domain local filters for a single DA step using
    diagnoal observation error covariance matrix
    without post-processing, distributing analysis,
    and setting next observation step.

    Here, this function call is used for LE(S)TKF [1]_, 
    LSEIK [1]_, LNETF [2]_, and LKNETF [3]_.
    The filter type is set in :func:`pyPDAF.PDAF.init`.
    Compared to :func:`pyPDAF.PDAF.omi_assimilate_local`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    The LESTKF is a more efficient equivalent to the LETKF.

    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. py__g2l_state_pdaf
            4. core DA algorithm
            5. py__l2g_state_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by :func:`pyPDAF.PDAF.omi_put_state`
       and :func:`pyPDAF.PDAF.localomi_put_state_nondiagR`,
       and :func:`pyPDAF.PDAF.localomi_put_state_lnetf_nondiagR`,
       and :func:`pyPDAF.PDAF.localomi_put_state_lknetf_nondiagR`.

    References
    ----------
    .. [1] Nerger, L., Janji, T., Schrter, J., Hiller, W. (2012). 
           A unification of ensemble square root Kalman filters. 
           Monthly Weather Review, 140, 2335-2345.
           doi:10.1175/MWR-D-11-00102.1
    .. [2] Tdter, J., and B. Ahrens, 2015:
           A second-order exact ensemble square root filter
           for nonlinear data assimilation. Mon. Wea. Rev.,
           143, 13471367, doi:10.1175/MWR-D-14-00108.1.
    .. [3] Nerger, L.. (2022) 
           Data assimilation for nonlinear systems with
           a hybrid nonlinear Kalman ensemble transform filter. 
           Q J R Meteorol Soc, 620640. doi:10.1002/qj.4221

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector



    Returns
    -------
    flag : int
        Status flag
    """
    ...

def omi_init_obs_f_cb (step: int,dim_obs_f: int,observation_f: np.ndarray[tuple[int], np.dtype[np.float64]]
                      ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    r"""This function is an internal PDAF-OMI function that is used as a call-back function to initialise the observation vector. This could be used to modify the observation vector when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`.

    Parameters
    ----------
    step : int
        Current time step
    dim_obs_f : int
        Dimension of full observation vector
    observation_f : ndarray[tuple[dim_obs_f], np.float64]
        Full observation vector
        The array dimension `dim_obs_f` is Dimension of full observation vector

    Returns
    -------
    observation_f : ndarray[tuple[dim_obs_f], np.float64]
         Full observation vector

        The array dimension `dim_obs_f` is Dimension of full observation vector
    """
    ...

def omi_init_obsvar_cb (step: int,dim_obs_p: int,obs_p: np.ndarray[tuple[int], np.dtype[np.float64]],
                        meanvar: float) -> float:
    r"""This function is an internal PDAF function that is used as a call-back function to initialise the observation error variance. This could be used to modify the observation variance when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`.

    Parameters
    ----------
    step : int
        Current time step
    dim_obs_p : int
        PE-local dimension of observation vector
    obs_p : ndarray[tuple[dim_obs_p], np.float64]
        PE-local observation vector
        The array dimension `dim_obs_p` is PE-local dimension of observation vector
    meanvar : float
        Mean observation error variance

    Returns
    -------
    meanvar : float
        Mean observation error variance
    """
    ...

def omi_g2l_obs_cb (domain_p: int,step: int,dim_obs_f: int,dim_obs_l: int,
                    ostate_f: np.ndarray[tuple[int], np.dtype[np.float64]],
                    ostate_l: np.ndarray[tuple[int], np.dtype[np.float64]]
                   ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    r"""This function is an internal PDAF-OMI function that is used as a call-back function to convert between global and local observation vectors in domain localisation.
    

    Parameters
    ----------
    domain_p : int
        Index of current local analysis domain
    step : int
        Current time step
    dim_obs_f : int
        Dimension of full PE-local observation vector
    dim_obs_l : int
        Dimension of local observation vector
    ostate_f : ndarray[tuple[dim_obs_f], np.float64]
        Full PE-local obs.ervation vector
        The array dimension `dim_obs_f` is Dimension of full PE-local observation vector
    ostate_l : ndarray[tuple[dim_obs_l], np.float64]
        Observation vector on local domain
        The array dimension `dim_obs_l` is Dimension of local observation vector

    Returns
    -------
    ostate_l : ndarray[tuple[dim_obs_l], np.float64]
         Observation vector on local domain

        The array dimension `dim_obs_l` is Dimension of local observation vector
    """
    ...

def omi_init_obs_l_cb (domain_p: int,step: int,dim_obs_l: int,observation_l: np.ndarray[tuple[int], np.dtype[np.float64]]
                      ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    r"""This function is an internal PDAF-OMI function that is used as a call-back function to initialise local observation vector in domain localisation. This could be used to modify the observation variance when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`.

    Parameters
    ----------
    domain_p : int
        Index of current local analysis domain index
    step : int
        Current time step
    dim_obs_l : int
        Local dimension of observation vector
    observation_l : ndarray[tuple[dim_obs_l], np.float64]
        Local observation vector
        The array dimension `dim_obs_l` is Local dimension of observation vector

    Returns
    -------
    observation_l : ndarray[tuple[dim_obs_l], np.float64]
         Local observation vector

        The array dimension `dim_obs_l` is Local dimension of observation vector
    """
    ...

def omi_init_obsvar_l_cb (domain_p: int,step: int,dim_obs_l: int,obs_l: np.ndarray[tuple[int], np.dtype[np.float64]],
                          meanvar_l: float) -> float:
    r"""This function is an internal PDAF-OMI function that is used as a call-back function to initialise local observation vector in domain localisation. This could be used to modify the observation variance when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`.

    Parameters
    ----------
    domain_p : int
        Index of current local analysis domain
    step : int
        Current time step
    dim_obs_l : int
        Local dimension of observation vector
    obs_l : ndarray[tuple[dim_obs_l], np.float64]
        Local observation vector
        The array dimension `dim_obs_l` is Local dimension of observation vector
    meanvar_l : float
        Mean local observation error variance

    Returns
    -------
    meanvar_l : float
        Mean local observation error variance
    """
    ...

def omi_prodRinvA_l_cb (domain_p: int,step: int,dim_obs_l: int,rank: int,
                        obs_l: np.ndarray[tuple[int], np.dtype[np.float64]],
                        A_l: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                        C_l: np.ndarray[tuple[int, int], np.dtype[np.float64]]
                       ) -> tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                      ]:
    r"""This function is an internal PDAF-OMI function that is used as a call-back function to perform the matrix multiplication inverse of local observation error covariance and a matrix A in domain localisation. This could be used to modify the observation variance when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`.

    Parameters
    ----------
    domain_p : int
        Index of current local analysis domain
    step : int
        Current time step
    dim_obs_l : int
        Dimension of local observation vector
    rank : int
        Rank of initial covariance matrix
    obs_l : ndarray[tuple[dim_obs_l], np.float64]
        Local vector of observations
        The array dimension `dim_obs_l` is Dimension of local observation vector
    A_l : ndarray[tuple[dim_obs_l, rank], np.float64]
        Input matrix
        The 1st-th dimension dim_obs_l is Dimension of local observation vector
        The 2nd-th dimension rank is Rank of initial covariance matrix
    C_l : ndarray[tuple[dim_obs_l, rank], np.float64]
        Output matrix
        The 1st-th dimension dim_obs_l is Dimension of local observation vector
        The 2nd-th dimension rank is Rank of initial covariance matrix

    Returns
    -------
    A_l : ndarray[tuple[dim_obs_l, rank], np.float64]
         Input matrix

        The 1st-th dimension dim_obs_l is Dimension of local observation vector
        The 2nd-th dimension rank is Rank of initial covariance matrix
    C_l : ndarray[tuple[dim_obs_l, rank], np.float64]
         Output matrix

        The 1st-th dimension dim_obs_l is Dimension of local observation vector
        The 2nd-th dimension rank is Rank of initial covariance matrix
    """
    ...

def omi_likelihood_l_cb (domain_p: int,step: int,dim_obs_l: int,obs_l: np.ndarray[tuple[int], np.dtype[np.float64]],
                         resid_l: np.ndarray[tuple[int], np.dtype[np.float64]],
                         lhood_l: float) -> tuple[np.ndarray[tuple[int], np.dtype[np.float64]], float]:
    r"""This is an internal PDAF-OMI function that is used as a call-back function to compute the likelihood of the observation for a given ensemble member according to the observations used for the local analysis in the localized LNETF. This could be used to modify the observation variance when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`. See https://pdaf.awi.de/trac/wiki/U_likelihood_l

    Parameters
    ----------
    domain_p : int
        Current local analysis domain
    step : int
        Current time step
    dim_obs_l : int
        PE-local dimension of obs. vector
    obs_l : ndarray[tuple[dim_obs_l], np.float64]
        PE-local vector of observations
        The array dimension `dim_obs_l` is PE-local dimension of obs. vector
    resid_l : ndarray[tuple[dim_obs_l], np.float64]
        Input vector of residuum
        The array dimension `dim_obs_l` is PE-local dimension of obs. vector
    lhood_l : float
        Output vector - log likelihood

    Returns
    -------
    resid_l : ndarray[tuple[dim_obs_l], np.float64]
         Input vector of residuum

        The array dimension `dim_obs_l` is PE-local dimension of obs. vector
    lhood_l : float
        Output vector - log likelihood
    """
    ...

def omi_prodRinvA_cb (step: int,dim_obs_p: int,ncol: int,obs_p: np.ndarray[tuple[int], np.dtype[np.float64]],
                      A_p: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                      C_p: np.ndarray[tuple[int, int], np.dtype[np.float64]]
                     ) -> np.ndarray[tuple[int, int], np.dtype[np.float64]]:
    r"""This function is an internal PDAF-OMI function that is used as a call-back function to perform the matrix multiplication inverse of observation errro covariance and a matrix A. This could be used to modify the observation variance when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`.

    Parameters
    ----------
    step : int
        Current time step
    dim_obs_p : int
        Dimension of PE-local observation vector
    ncol : int
        Number of columns in A_p and C_p
    obs_p : ndarray[tuple[dim_obs_p], np.float64]
        PE-local vector of observations
        The array dimension `dim_obs_p` is Dimension of PE-local observation vector
    A_p : ndarray[tuple[dim_obs_p, ncol], np.float64]
        Input matrix
        The 1st-th dimension dim_obs_p is Dimension of PE-local observation vector
        The 2nd-th dimension ncol is Number of columns in A_p and C_p
    C_p : ndarray[tuple[dim_obs_p, ncol], np.float64]
        Output matrix
        The 1st-th dimension dim_obs_p is Dimension of PE-local observation vector
        The 2nd-th dimension ncol is Number of columns in A_p and C_p

    Returns
    -------
    C_p : ndarray[tuple[dim_obs_p, ncol], np.float64]
         Output matrix

        The 1st-th dimension dim_obs_p is Dimension of PE-local observation vector
        The 2nd-th dimension ncol is Number of columns in A_p and C_p
    """
    ...

def omi_likelihood_cb (step: int,dim_obs: int,obs: np.ndarray[tuple[int], np.dtype[np.float64]],
                       resid: np.ndarray[tuple[int], np.dtype[np.float64]],
                       lhood: float) -> float:
    r"""This is an internal PDAF-OMI function that is used as a call-back function to compute the likelihood of the observation for a given ensemble member according to the observations used for the local analysis for NETF or particle filter. This could be used to modify the observation variance when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`. See https://pdaf.awi.de/trac/wiki/U_likelihood_l

    Parameters
    ----------
    step : int
        Current time step
    dim_obs : int
        PE-local dimension of obs. vector
    obs : ndarray[tuple[dim_obs], np.float64]
        PE-local vector of observations
        The array dimension `dim_obs` is PE-local dimension of obs. vector
    resid : ndarray[tuple[dim_obs], np.float64]
        Input vector of residuum
        The array dimension `dim_obs` is PE-local dimension of obs. vector
    lhood : float
        Output vector - log likelihood

    Returns
    -------
    lhood : float
        Output vector - log likelihood
    """
    ...

def omi_add_obs_error_cb (step: int,dim_obs_p: int,C_p: np.ndarray[tuple[int, int], np.dtype[np.float64]]
                         ) -> np.ndarray[tuple[int, int], np.dtype[np.float64]]:
    r"""This is an internal PDAF-OMI function that is used as a call-back function to add random observation error to stochastic EnKF. This could be used to modify the observation variance when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`. See https://pdaf.awi.de/trac/wiki/U_likelihood_l

    Parameters
    ----------
    step : int
        Current time step
    dim_obs_p : int
        Dimension of PE-local observation vector
    C_p : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]
        Matrix to which R is added
        The 1st-th dimension dim_obs_p is Dimension of PE-local observation vector
        The 2nd-th dimension dim_obs_p is Dimension of PE-local observation vector

    Returns
    -------
    C_p : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]
         Matrix to which R is added

        The 1st-th dimension dim_obs_p is Dimension of PE-local observation vector
        The 2nd-th dimension dim_obs_p is Dimension of PE-local observation vector
    """
    ...

def omi_init_obscovar_cb (step: int,dim_obs: int,dim_obs_p: int,covar: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                          m_state_p: np.ndarray[tuple[int], np.dtype[np.float64]],
                          isdiag: bool) -> tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], bool]:
    r"""This is an internal PDAF-OMI function that is used as a call-back function to construct a full observation error covariance matrix used only in stochastic EnKF. This could be used to modify the observation variance when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`.

    Parameters
    ----------
    step : int
        Current time step
    dim_obs : int
        Dimension of observation vector
    dim_obs_p : int
        PE-local dimension of obs. vector
    covar : ndarray[tuple[dim_obs, dim_obs], np.float64]
        Observation error covar. matrix
        The 1st-th dimension dim_obs is Dimension of observation vector
        The 2nd-th dimension dim_obs is Dimension of observation vector
    m_state_p : ndarray[tuple[dim_obs_p], np.float64]
        Observation vector
        The array dimension `dim_obs_p` is PE-local dimension of obs. vector
    isdiag : bool
        Whether matrix R is diagonal

    Returns
    -------
    covar : ndarray[tuple[dim_obs, dim_obs], np.float64]
         Observation error covar. matrix

        The 1st-th dimension dim_obs is Dimension of observation vector
        The 2nd-th dimension dim_obs is Dimension of observation vector
    isdiag : bool
        Whether matrix R is diagonal
    """
    ...

def omi_init_obserr_f_cb (step: int,dim_obs_f: int,obs_f: np.ndarray[tuple[int], np.dtype[np.float64]],
                          obserr_f: np.ndarray[tuple[int], np.dtype[np.float64]]
                         ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    r"""This is an internal PDAF-OMI function that is used as a call-back function to construct a full observation error covariance matrix used only in stochastic EnKF. This could be used to modify the observation variance when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`.

    Parameters
    ----------
    step : int
        Current time step
    dim_obs_f : int
        Full dimension of observation vector
    obs_f : ndarray[tuple[dim_obs_f], np.float64]
        Full observation vector
        The array dimension `dim_obs_f` is Full dimension of observation vector
    obserr_f : ndarray[tuple[dim_obs_f], np.float64]
        Full observation error stddev
        The array dimension `dim_obs_f` is Full dimension of observation vector

    Returns
    -------
    obserr_f : ndarray[tuple[dim_obs_f], np.float64]
         Full observation error stddev

        The array dimension `dim_obs_f` is Full dimension of observation vector
    """
    ...

def omi_prodRinvA_hyb_l_cb (domain_p: int,step: int,dim_obs_l: int,rank: int,
                            obs_l: np.ndarray[tuple[int], np.dtype[np.float64]],
                            alpha: float,A_l: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                            C_l: np.ndarray[tuple[int, int], np.dtype[np.float64]]
                           ) -> tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                          ]:
    r"""This function is an internal PDAF-OMI function that is used as a call-back function to perform the matrix multiplication inverse of local observation error covariance and a matrix A in LKNETF. This could be used to modify the observation variance when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`.

    Parameters
    ----------
    domain_p : int
        Index of current local analysis domain
    step : int
        Current time step
    dim_obs_l : int
        Dimension of local observation vector
    rank : int
        Rank of initial covariance matrix
    obs_l : ndarray[tuple[dim_obs_l], np.float64]
        Local vector of observations
        The array dimension `dim_obs_l` is Dimension of local observation vector
    alpha : float
        Hybrid weight
    A_l : ndarray[tuple[dim_obs_l, rank], np.float64]
        Input matrix
        The 1st-th dimension dim_obs_l is Dimension of local observation vector
        The 2nd-th dimension rank is Rank of initial covariance matrix
    C_l : ndarray[tuple[dim_obs_l, rank], np.float64]
        Output matrix
        The 1st-th dimension dim_obs_l is Dimension of local observation vector
        The 2nd-th dimension rank is Rank of initial covariance matrix

    Returns
    -------
    A_l : ndarray[tuple[dim_obs_l, rank], np.float64]
         Input matrix

        The 1st-th dimension dim_obs_l is Dimension of local observation vector
        The 2nd-th dimension rank is Rank of initial covariance matrix
    C_l : ndarray[tuple[dim_obs_l, rank], np.float64]
         Output matrix

        The 1st-th dimension dim_obs_l is Dimension of local observation vector
        The 2nd-th dimension rank is Rank of initial covariance matrix
    """
    ...

def omi_likelihood_hyb_l_cb (domain_p: int,step: int,dim_obs_l: int,obs_l: np.ndarray[tuple[int], np.dtype[np.float64]],
                             resid_l: np.ndarray[tuple[int], np.dtype[np.float64]],
                             alpha: float,lhood_l: float) -> tuple[np.ndarray[tuple[int], np.dtype[np.float64]], float]:
    r"""This is an internal PDAF-OMI function that is used as a call-back function to compute the likelihood of the observation for a given ensemble member according to the observations used for the local analysis in LKNETF. This could be used to modify the observation variance when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`. See https://pdaf.awi.de/trac/wiki/U_likelihood_l

    Parameters
    ----------
    domain_p : int
        Current local analysis domain
    step : int
        Current time step
    dim_obs_l : int
        PE-local dimension of obs. vector
    obs_l : ndarray[tuple[dim_obs_l], np.float64]
        PE-local vector of observations
        The array dimension `dim_obs_l` is PE-local dimension of obs. vector
    resid_l : ndarray[tuple[dim_obs_l], np.float64]
        Input vector of residuum
        The array dimension `dim_obs_l` is PE-local dimension of obs. vector
    alpha : float
        Hybrid weight
    lhood_l : float
        Output vector - log likelihood

    Returns
    -------
    resid_l : ndarray[tuple[dim_obs_l], np.float64]
         Input vector of residuum

        The array dimension `dim_obs_l` is PE-local dimension of obs. vector
    lhood_l : float
        Output vector - log likelihood
    """
    ...

def omi_obsstats_l (screen: int) -> None:
    r"""This function is called in the update routine of local filters and write statistics on locally used and excluded observations.

    Parameters
    ----------
    screen : int
        Verbosity flag
    """
    ...

def omi_weights_l (verbose: int,locweight: int,cradius: np.ndarray[tuple[int], np.dtype[np.float64]],
                   sradius: np.ndarray[tuple[int], np.dtype[np.float64]],
                   matA: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                   ivar_obs_l: np.ndarray[tuple[int], np.dtype[np.float64]],
                   dist_l: np.ndarray[tuple[int], np.dtype[np.float64]]
                  ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    r"""This function computes a weight vector according to the distances of observations from the local analysis domain with a vector of localisation radius.

    Parameters
    ----------
    verbose : int
        Verbosity flag
    locweight : int
        Types of localization function:
            0. unit weight;
            1. exponential;
            2. 5-th order polynomial;
            3. 5-th order polynomial with regulatioin using mean variance;
            4. 5-th order polynomial with regulatioin using variance of single observation point;
    cradius : ndarray[tuple[nobs_l], np.float64]
        Vector of localization cut-off radii; observation weight=0 if distance > cradius
        The array dimension `nobs_l` is Number of local observations
    sradius : ndarray[tuple[nobs_l], np.float64]
        Vector of support radii of localization function.
        It has no impact if locweight=0; 	weight = exp(-d / sradius) if locweight=1;
        weight = 0 if d >= sradius else f(sradius, distance) if locweight in [2,3,4].
        The array dimension `nobs_l` is Number of local observations
    matA : ndarray[tuple[nobs_l, ncols], np.float64]
        input matrix
        The 1st-th dimension nobs_l is Number of local observations
        The 2nd-th dimension ncols is the number of columns
    ivar_obs_l : ndarray[tuple[nobs_l], np.float64]
        Local vector of inverse obs. variances (nobs_l)
        The array dimension `nobs_l` is Number of local observations
    dist_l : ndarray[tuple[nobs_l], np.float64]
        Local vector of obs. distances (nobs_l)
        The array dimension `nobs_l` is Number of local observations

    Returns
    -------
    weight_l : ndarray[tuple[nobs_l], np.float64]
         Output: vector of weights

        The array dimension `nobs_l` is Number of local observations
    """
    ...

def omi_weights_l_sgnl (verbose: int,locweight: int,cradius: float,sradius: float,
                        matA: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                        ivar_obs_l: np.ndarray[tuple[int], np.dtype[np.float64]],
                        dist_l: np.ndarray[tuple[int], np.dtype[np.float64]]
                       ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    r"""This function computes a weight vector according to the distances of observations from the local analysis domain with given localisation radius.

    Parameters
    ----------
    verbose : int
        Verbosity flag
    locweight : int
        Types of localization function
            0) unit weight;
            1) exponential;
            2) 5-th order polynomial;
            3) 5-th order polynomial with regulatioin using mean variance;
            4) 5-th order polynomial with regulatioin using variance of single observation point;
    cradius : float
        Vector of localization cut-off radii; observation weight=0 if distance > cradius
    sradius : float
        Vector of support radii of localization function.
        It has no impact if locweight=0; 	weight = exp(-d / sradius) if locweight=1;
        weight = 0 if d >= sradius else f(sradius, distance) if locweight in [2,3,4].
    matA : ndarray[tuple[nobs_l, ncols], np.float64]
        input matrix
        The 1st-th dimension nobs_l is Number of local observations
        The 2nd-th dimension ncols is number of columns
    ivar_obs_l : ndarray[tuple[nobs_l], np.float64]
        Local vector of inverse obs. variances (nobs_l)
        The array dimension `nobs_l` is Number of local observations
    dist_l : ndarray[tuple[nobs_l], np.float64]
        Local vector of obs. distances (nobs_l)
        The array dimension `nobs_l` is Number of local observations

    Returns
    -------
    weight_l : ndarray[tuple[nobs_l], np.float64]
         Output: vector of weights

        The array dimension `nobs_l` is Number of local observations
    """
    ...

def omi_check_error (flag: int) -> int:
    r"""This function returns the value of the PDAF-OMI internal error flag.

    Parameters
    ----------
    flag : int
        Error flag

    Returns
    -------
    flag : int
        Error flag
    """
    ...

def omi_gather_obsdims () -> None:
    r"""This function gathers the information about the full dimension of each observation type in each process-local subdomain.

    """
    ...

def omi_obsstats (screen: int) -> None:
    r"""The function is called in the update routine of global filters and writes statistics on used and excluded observations.

    Parameters
    ----------
    screen : int
        Verbosity flag
    """
    ...

def omi_init_dim_obs_l_iso (i_obs: int,coords_l: np.ndarray[tuple[int], np.dtype[np.float64]],
                            locweight: int,cradius: float,sradius: float,
                            cnt_obs_l: int) -> int:
    r"""The function has to be called in `init_dim_obs_l_OBTYPE` in each observation module if a domain-localized filter (LESTKF/LETKF/LNETF/LSEIK)is used. It initialises the local observation information for PDAF-OMI for a single local analysis domain. This is used for isotropic localisation where the localisation radius is the same in all directions.

    Parameters
    ----------
    i_obs : int
        index of observation type
    coords_l : ndarray[tuple[ncoord], np.float64]
        Coordinates of current analysis domain
        The array dimension `ncoord` is number of coordinate dimension
    locweight : int
        Types of localization function
        0) unit weight; 1) exponential; 2) 5-th order polynomial;
        3) 5-th order polynomial with regulatioin using mean variance;
        4) 5-th order polynomial with regulatioin using variance of single observation point;
    cradius : float
        Vector of localization cut-off radii; observation weight=0 if distance > cradius
    sradius : float
        Vector of support radii of localization function.
        It has no impact if locweight=0; 	weight = exp(-d / sradius) if locweight=1;
        weight = 0 if d >= sradius else f(sradius, distance) if locweight in [2,3,4].
    cnt_obs_l : int
        Local dimension of current observation vector

    Returns
    -------
    cnt_obs_l : int
        Local dimension of current observation vector
    """
    ...

def omi_init_dim_obs_l_noniso (i_obs: int,coords_l: np.ndarray[tuple[int], np.dtype[np.float64]],
                               locweight: int,cradius: np.ndarray[tuple[int], np.dtype[np.float64]],
                               sradius: np.ndarray[tuple[int], np.dtype[np.float64]],
                               cnt_obs_l: int) -> int:
    r"""The function has to be called in `init_dim_obs_l_OBTYPE` in each observation module if a domain-localized filter (LESTKF/LETKF/LNETF/LSEIK)is used. It initialises the local observation information for PDAF-OMI for a single local analysis domain. This is used for non-isotropic localisation where the localisation radius is different in each direction. See https://pdaf.awi.de/trac/wiki/OMI_observation_modules#init_dim_obs_l_OBSTYPE and https://pdaf.awi.de/trac/wiki/PDAFomi_init_dim_obs_l#Settingsfornon-isotropiclocalization.

    Parameters
    ----------
    i_obs : int
        index of observation type
    coords_l : ndarray[tuple[ncoord], np.float64]
        Coordinates of current analysis domain
        The array dimension `ncoord` is number of coordinate dimension
    locweight : int
        Types of localization function
        0) unit weight; 1) exponential; 2) 5-th order polynomial;
        3) 5-th order polynomial with regulatioin using mean variance;
        4) 5-th order polynomial with regulatioin using variance of single observation point;
    cradius : ndarray[tuple[ncoord], np.float64]
        Vector of localization cut-off radii; observation weight=0 if distance > cradius
        The array dimension `ncoord` is number of coordinate dimension
    sradius : ndarray[tuple[ncoord], np.float64]
        Vector of support radii of localization function.
        It has no impact if locweight=0; 	weight = exp(-d / sradius) if locweight=1;
        weight = 0 if d >= sradius else f(sradius, distance) if locweight in [2,3,4].
        The array dimension `ncoord` is number of coordinate dimension
    cnt_obs_l : int
        Local dimension of current observation vector

    Returns
    -------
    cnt_obs_l : int
        Local dimension of current observation vector
    """
    ...

def omi_init_dim_obs_l_noniso_locweights (i_obs: int,coords_l: np.ndarray[tuple[int], np.dtype[np.float64]],
                                          locweights: np.ndarray[tuple[int], np.dtype[np.intc]],
                                          cradius: np.ndarray[tuple[int], np.dtype[np.float64]],
                                          sradius: np.ndarray[tuple[int], np.dtype[np.float64]],
                                          cnt_obs_l: int) -> int:
    r"""The function has to be called in `init_dim_obs_l_OBTYPE` in each observation module if a domain-localized filter (LESTKF/LETKF/LNETF/LSEIK)is used. It initialises the local observation information for PDAF-OMI for a single local analysis domain. This is used for non-isotropic localisation and different weight functions for horizontal and vertical directions. See https://pdaf.awi.de/trac/wiki/OMI_observation_modules#init_dim_obs_l_OBSTYPE and https://pdaf.awi.de/trac/wiki/PDAFomi_init_dim_obs_l#Settingdifferentweightfunctsforhorizontalandverticaldirections.

    Parameters
    ----------
    i_obs : int
        index of observation type
    coords_l : ndarray[tuple[ncoord], np.float64]
        Coordinates of current analysis domain
        The array dimension `ncoord` is number of coordinate dimension
    locweights : ndarray[tuple[2], np.intc]
        Types of localization function
        0) unit weight; 1) exponential; 2) 5-th order polynomial;
        3) 5-th order polynomial with regulatioin using mean variance;
        4) 5-th order polynomial with regulatioin using variance of single observation point;
        The first dimension is horizontal weight function and the second is the vertical function
    cradius : ndarray[tuple[ncoord], np.float64]
        Vector of localization cut-off radii for each dimension; observation weight=0 if distance > cradius
        The array dimension `ncoord` is number of coordinate dimension
    sradius : ndarray[tuple[ncoord], np.float64]
        Vector of support radii of localization function for each dimension.
        It has no impact if locweight=0; 	weight = exp(-d / sradius) if locweight=1;
        weight = 0 if d >= sradius else f(sradius, distance) if locweight in [2,3,4].
        The array dimension `ncoord` is number of coordinate dimension
    cnt_obs_l : int
        Local dimension of current observation vector

    Returns
    -------
    cnt_obs_l : int
        Local dimension of current observation vector
    """
    ...

def omi_localize_covar_iso (i_obs: int,locweight: int,cradius: float,sradius: float,
                            coords: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                            HP: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                            HPH: np.ndarray[tuple[int, int], np.dtype[np.float64]]
                           ) -> tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                          ]:
    r"""The function has to be called in `localize_covar_OBTYPE` in each observation module. It applies the covariance localisation in stochastic EnKF. This is used for isotropic localisation where the localisation radius is the same in all directions. See https://pdaf.awi.de/trac/wiki/PDAFomi_localize_covar

    Parameters
    ----------
    i_obs : int
        index of observation type
    locweight : int
        Types of localization function
        0) unit weight; 1) exponential; 2) 5-th order polynomial;
        3) 5-th order polynomial with regulatioin using mean variance;
        4) 5-th order polynomial with regulatioin using variance of single observation point;
    cradius : float
        Vector of localization cut-off radii; observation weight=0 if distance > cradius
    sradius : float
        Vector of support radii of localization function.
        It has no impact if locweight=0; 	weight = exp(-d / sradius) if locweight=1;
        weight = 0 if d >= sradius else f(sradius, distance) if locweight in [2,3,4].
    coords : ndarray[tuple[ncoord, dim_p], np.float64]
        Coordinates of state vector elements
        The 1st-th dimension ncoord is number of coordinate dimension
        The 2nd-th dimension dim_p is State dimension
    HP : ndarray[tuple[dim_obs, dim_p], np.float64]
        Matrix HP, dimension (nobs, dim)
        The 1st-th dimension dim_obs is Observation dimension
        The 2nd-th dimension dim_p is State dimension
    HPH : ndarray[tuple[dim_obs, dim_obs], np.float64]
        Matrix HPH, dimension (nobs, nobs)
        The 1st-th dimension dim_obs is Observation dimension
        The 2nd-th dimension dim_obs is Observation dimension

    Returns
    -------
    HP : ndarray[tuple[dim_obs, dim_p], np.float64]
         Matrix HP, dimension (nobs, dim)

        The 1st-th dimension dim_obs is Observation dimension
        The 2nd-th dimension dim_p is State dimension
    HPH : ndarray[tuple[dim_obs, dim_obs], np.float64]
         Matrix HPH, dimension (nobs, nobs)

        The 1st-th dimension dim_obs is Observation dimension
        The 2nd-th dimension dim_obs is Observation dimension
    """
    ...

def omi_localize_covar_noniso (i_obs: int,locweight: int,cradius: np.ndarray[tuple[int], np.dtype[np.float64]],
                               sradius: np.ndarray[tuple[int], np.dtype[np.float64]],
                               coords: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                               HP: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                               HPH: np.ndarray[tuple[int, int], np.dtype[np.float64]]
                              ) -> tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                             ]:
    r"""The function has to be called in `localize_covar_OBTYPE` in each observation module. It applies the covariance localisation in stochastic EnKF. This is used for non-isotropic localisation where the localisation radius is different. See https://pdaf.awi.de/trac/wiki/PDAFomi_localize_covar

    Parameters
    ----------
    i_obs : int
        Data type with full observation
    locweight : int
        Types of localization function
        0) unit weight; 1) exponential; 2) 5-th order polynomial;
        3) 5-th order polynomial with regulatioin using mean variance;
        4) 5-th order polynomial with regulatioin using variance of single observation point;
    cradius : ndarray[tuple[ncoord], np.float64]
        Vector of localization cut-off radii for each dimension; observation weight=0 if distance > cradius
        The array dimension `ncoord` is number of coordinate dimension
    sradius : ndarray[tuple[ncoord], np.float64]
        Vector of support radii of localization function for each dimension.
        It has no impact if locweight=0; 	weight = exp(-d / sradius) if locweight=1;
        weight = 0 if d >= sradius else f(sradius, distance) if locweight in [2,3,4].
        The array dimension `ncoord` is number of coordinate dimension
    coords : ndarray[tuple[ncoord, dim_p], np.float64]
        Coordinates of state vector elements
        The 1st-th dimension ncoord is number of coordinate dimension
        The 2nd-th dimension dim_p is State dimension
    HP : ndarray[tuple[dim_obs, dim_p], np.float64]
        Matrix HP, dimension (nobs, dim)
        The 1st-th dimension dim_obs is Observation dimension
        The 2nd-th dimension dim_p is State dimension
    HPH : ndarray[tuple[dim_obs, dim_obs], np.float64]
        Matrix HPH, dimension (nobs, nobs)
        The 1st-th dimension dim_obs is Observation dimension
        The 2nd-th dimension dim_obs is Observation dimension

    Returns
    -------
    HP : ndarray[tuple[dim_obs, dim_p], np.float64]
         Matrix HP, dimension (nobs, dim)

        The 1st-th dimension dim_obs is Observation dimension
        The 2nd-th dimension dim_p is State dimension
    HPH : ndarray[tuple[dim_obs, dim_obs], np.float64]
         Matrix HPH, dimension (nobs, nobs)

        The 1st-th dimension dim_obs is Observation dimension
        The 2nd-th dimension dim_obs is Observation dimension
    """
    ...

def omi_localize_covar_noniso_locweights (i_obs: int,locweights: np.ndarray[tuple[int], np.dtype[np.intc]],
                                          cradius: np.ndarray[tuple[int], np.dtype[np.float64]],
                                          sradius: np.ndarray[tuple[int], np.dtype[np.float64]],
                                          coords: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                                          HP: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                                          HPH: np.ndarray[tuple[int, int], np.dtype[np.float64]]
                                         ) -> tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                        ]:
    r"""The function has to be called in `localize_covar_OBTYPE` in each observation module. It applies the covariance localisation in stochastic EnKF. This is used for non-isotropic localisation with different weight function for horizontal and vertical directions. where the localisation radius is different. See https://pdaf.awi.de/trac/wiki/PDAFomi_localize_covar

    Parameters
    ----------
    i_obs : int
        index of observation type
    locweights : ndarray[tuple[2], np.intc]
        Types of localization function
        0) unit weight; 1) exponential; 2) 5-th order polynomial;
        3) 5-th order polynomial with regulatioin using mean variance;
        4) 5-th order polynomial with regulatioin using variance of single observation point;
        The first dimension is horizontal weight function and the second is the vertical function
    cradius : ndarray[tuple[ncoord], np.float64]
        Vector of localization cut-off radii for each dimension; observation weight=0 if distance > cradius
        The array dimension `ncoord` is number of coordinate dimension
    sradius : ndarray[tuple[ncoord], np.float64]
        Vector of support radii of localization function for each dimension.
        It has no impact if locweight=0; 	weight = exp(-d / sradius) if locweight=1;
        weight = 0 if d >= sradius else f(sradius, distance) if locweight in [2,3,4].
        The array dimension `ncoord` is number of coordinate dimension
    coords : ndarray[tuple[ncoord, dim_p], np.float64]
        Coordinates of state vector elements
        The 1st-th dimension ncoord is number of coordinate dimension
        The 2nd-th dimension dim_p is State dimension
    HP : ndarray[tuple[dim_obs, dim_p], np.float64]
        Matrix HP, dimension (nobs, dim)
        The 1st-th dimension dim_obs is Observation dimension
        The 2nd-th dimension dim_p is State dimension
    HPH : ndarray[tuple[dim_obs, dim_obs], np.float64]
        Matrix HPH, dimension (nobs, nobs)
        The 1st-th dimension dim_obs is Observation dimension
        The 2nd-th dimension dim_obs is Observation dimension

    Returns
    -------
    HP : ndarray[tuple[dim_obs, dim_p], np.float64]
         Matrix HP, dimension (nobs, dim)

        The 1st-th dimension dim_obs is Observation dimension
        The 2nd-th dimension dim_p is State dimension
    HPH : ndarray[tuple[dim_obs, dim_obs], np.float64]
         Matrix HPH, dimension (nobs, nobs)

        The 1st-th dimension dim_obs is Observation dimension
        The 2nd-th dimension dim_obs is Observation dimension
    """
    ...

def omi_omit_by_inno_l_cb (domain_p: int,dim_obs_l: int,resid_l: np.ndarray[tuple[int], np.dtype[np.float64]],
                           obs_l: np.ndarray[tuple[int], np.dtype[np.float64]]
                          ) -> tuple[np.ndarray[tuple[int], np.dtype[np.float64]], np.ndarray[tuple[int], np.dtype[np.float64]], 
                         ]:
    r"""The function is called during the analysis step on each local analysis domain. It checks the size of the innovation and sets the observation error to a high value if the squared innovation exceeds a limit relative to the observation error variance.This function is an internal PDAF-OMI function that is used as a call-back function. This could be used to modify the observation vector when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`.

    Parameters
    ----------
    domain_p : int
        Current local analysis domain
    dim_obs_l : int
        PE-local dimension of obs. vector
    resid_l : ndarray[tuple[dim_obs_l], np.float64]
        Input vector of residuum
        The array dimension `dim_obs_l` is PE-local dimension of obs. vector
    obs_l : ndarray[tuple[dim_obs_l], np.float64]
        Input vector of local observations
        The array dimension `dim_obs_l` is PE-local dimension of obs. vector

    Returns
    -------
    resid_l : ndarray[tuple[dim_obs_l], np.float64]
         Input vector of residuum

        The array dimension `dim_obs_l` is PE-local dimension of obs. vector
    obs_l : ndarray[tuple[dim_obs_l], np.float64]
         Input vector of local observations

        The array dimension `dim_obs_l` is PE-local dimension of obs. vector
    """
    ...

def omi_omit_by_inno_cb (dim_obs_f: int,resid_f: np.ndarray[tuple[int], np.dtype[np.float64]],
                         obs_f: np.ndarray[tuple[int], np.dtype[np.float64]]
                        ) -> tuple[np.ndarray[tuple[int], np.dtype[np.float64]], np.ndarray[tuple[int], np.dtype[np.float64]], 
                       ]:
    r"""The function is called during the analysis step of a global filter. It checks the size of the innovation and sets the observation error to a high value if the squared innovation exceeds a limit relative to the observation error variance.This function is called in the update routine of local filters and write statistics on locally used and excluded observations.This function is an internal PDAF-OMI function that is used as a call-back function. This could be used to modify the observation vector when OMI is used with `pyPDAF.PDAF.assimilate_xxx` instead of `pyPDAF.PDAF.omi_assimilate_xxx`.

    Parameters
    ----------
    dim_obs_f : int
        Full dimension of obs. vector
    resid_f : ndarray[tuple[dim_obs_f], np.float64]
        Input vector of residuum
        The array dimension `dim_obs_f` is Full dimension of obs. vector
    obs_f : ndarray[tuple[dim_obs_f], np.float64]
        Input vector of full observations
        The array dimension `dim_obs_f` is Full dimension of obs. vector

    Returns
    -------
    resid_f : ndarray[tuple[dim_obs_f], np.float64]
         Input vector of residuum

        The array dimension `dim_obs_f` is Full dimension of obs. vector
    obs_f : ndarray[tuple[dim_obs_f], np.float64]
         Input vector of full observations

        The array dimension `dim_obs_f` is Full dimension of obs. vector
    """
    ...

def omi_set_localization (i_obs: int,cradius: float,sradius: float,locweight: int
                         ) -> int:
    r"""This function sets localization information (locweight, cradius, sradius) in OMI, and allocates local arrays for cradius and sradius, i.e. `obs_l`. This variant is for isotropic localization. The function is used by user-supplied implementations of `pyPDAF.PDAF.omi_init_dim_obs_l_iso`. 

    Parameters
    ----------
    i_obs : int
        Observation type index
    cradius : float
        Vector of localization cut-off radii; observation weight=0 if distance > cradius
    sradius : float
        Vector of support radii of localization function.
        It has no impact if locweight=0; 	weight = exp(-d / sradius) if locweight=1;
        weight = 0 if d >= sradius else f(sradius, distance) if locweight in [2,3,4].
    locweight : int
        Types of localization function
        0) unit weight; 1) exponential; 2) 5-th order polynomial;
        3) 5-th order polynomial with regulatioin using mean variance;
        4) 5-th order polynomial with regulatioin using variance of single observation point;

    Returns
    -------
    i_obs : int
        Observation type index
    """
    ...

def omi_set_localization_noniso (i_obs: int,cradius: np.ndarray[tuple[int], np.dtype[np.float64]],
                                 sradius: np.ndarray[tuple[int], np.dtype[np.float64]],
                                 locweight: int,locweight_v: int) -> int:
    r"""This function sets localization information (locweight, cradius, sradius) in OMI, and allocates local arrays for cradius and sradius, i.e. `obs_l`. This variant is for non-isotropic localization. The function is used by user-supplied implementations of `pyPDAF.PDAF.omi_init_dim_obs_l_noniso`. 

    Parameters
    ----------
    i_obs : int
        Type of observation index
    cradius : ndarray[tuple[nradii], np.float64]
        Vector of localization cut-off radii; observation weight=0 if distance > cradius
        The array dimension `nradii` is Number of radii to consider for localization
    sradius : ndarray[tuple[nradii], np.float64]
        Vector of support radii of localization function.
        It has no impact if locweight=0; 	weight = exp(-d / sradius) if locweight=1;
        weight = 0 if d >= sradius else f(sradius, distance) if locweight in [2,3,4].
        The array dimension `nradii` is Number of radii to consider for localization
    locweight : int
        Types of localization function
        0) unit weight; 1) exponential; 2) 5-th order polynomial;
        3) 5-th order polynomial with regulatioin using mean variance;
        4) 5-th order polynomial with regulatioin using variance of single observation point;
    locweight_v : int
        Type of localization function in vertical direction (only for nradii=3)

    Returns
    -------
    i_obs : int
        Type of observation index
    """
    ...

def omi_set_dim_obs_l (i_obs: int,cnt_obs_l_all: int,cnt_obs_l: int) -> tuple[int, int, int]:
    r"""This function initialises number local observations. It also returns number of local observations up to the current observation type. It is used by a user-supplied implementations of `pyPDAF.PDAF.omi_init_dim_obs_l_xxx`.

    Parameters
    ----------
    i_obs : int
        Type of observation index
    cnt_obs_l_all : int
        Local dimension of observation vector over all obs. types
    cnt_obs_l : int
        Local dimension of single observation type vector

    Returns
    -------
    i_obs : int
        Type of observation index
    cnt_obs_l_all : int
        Local dimension of observation vector over all obs. types
    cnt_obs_l : int
        Local dimension of single observation type vector
    """
    ...

def omi_store_obs_l_index (i_obs: int,idx: int,id_obs_l: int,distance: float,
                           cradius_l: float,sradius_l: float) -> int:
    r"""This function stores the mapping index between the global and local observation vectors, the distance and the cradius and sradius for a single observations in OMI. This variant is for non-factorised localisation. The function is used by user-supplied implementations of `pyPDAF.PDAF.omi_init_dim_obs_l_iso` or `pyPDAF.PDAF.omi_init_dim_obs_l_noniso`. 

    Parameters
    ----------
    i_obs : int
        Type of observation index
    idx : int
        Element of local observation array to be filled
    id_obs_l : int
        Index of local observation in full observation array
    distance : float
        Distance between local analysis domain and observation
    cradius_l : float
        cut-off radius for this local observation; observation weight=0 if distance > cradius
         (directional radius in case of non-isotropic localization)
    sradius_l : float
        support radius for this local observation
         (directional radius in case of non-isotropic localization)
        Vector of support radii of localization function.
        It has no impact if locweight=0; 	weight = exp(-d / sradius) if locweight=1;
        weight = 0 if d >= sradius else f(sradius, distance) if locweight in [2,3,4].

    Returns
    -------
    i_obs : int
        Type of observation index
    """
    ...

def omi_store_obs_l_index_vdist (i_obs: int,idx: int,id_obs_l: int,distance: float,
                                 cradius_l: float,sradius_l: float,vdist: float
                                ) -> int:
    r"""This function stores the mapping index between the global and local observation vectors, the distance and the cradius and sradius for a single observations in OMI. This variant is for 2D+1D factorised localisation.
    The function is used by user-supplied implementations of `pyPDAF.PDAF.omi_init_dim_obs_l_noniso_locweights`.

    Parameters
    ----------
    i_obs : int
        Type of observation index
    idx : int
        Element of local observation array to be filled
    id_obs_l : int
        Index of local observation in full observation array
    distance : float
        Distance between local analysis domain and observation
    cradius_l : float
        cut-off radius for this local observation
         (directional radius in case of non-isotropic localization)
    sradius_l : float
        support radius for this local observation
         (directional radius in case of non-isotropic localization)
    vdist : float
        support radius in vertical direction for 2+1D factorized localization

    Returns
    -------
    i_obs : int
        Type of observation index
    """
    ...

def omi_assimilate_3dvar_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__distribute_state_pdaf : Callable[[int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__init_dim_obs_pdaf : Callable[[int, 
                                                                     int], int],
                                   py__obs_op_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__prodRinvA_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                   py__cvt_pdaf : Callable[[int, int, int, 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__cvt_adj_pdaf : Callable[[int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__obs_op_lin_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__obs_op_adj_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__prepoststep_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                   py__next_observation_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         float], tuple[int, 
                                                                         int, 
                                                                         float]],
                                   outflag: int) -> int:
    r"""3DVar DA for a single DA step
    using non-diagnoal observation error covariance matrix.

    See :func:`pyPDAF.PDAF.omi_assimilate_3dvar`
    for simpler user-supplied functions
    using diagonal observation error covariance matrix.

    When 3DVar is used, the background error covariance matrix
    has to be modelled for cotrol variable transformation.
    This is a deterministic filtering scheme
    so no ensemble and parallelisation is needed.
    This function should be called at each model time step.

    The function is a combination of
    :func:`pyPDAF.PDAF.omi_put_state_3dvar_nondiagR`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. Iterative optimisation:
            1. py__cvt_pdaf
            2. py__obs_op_lin_pdaf
            3. py__prodRinvA_pdaf
            4. py__obs_op_adj_pdaf
            5. py__cvt_adj_pdaf
            6. core DA algorithm
        6. py__cvt_pdaf
        7. py__prepoststep_state_pdaf
        8. py__distribute_state_pdaf
        9. py__next_observation_pdaf

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one
                (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_assimilate_en3dvar_estkf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__distribute_state_pdaf : Callable[[int, 
                                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__init_dim_obs_pdaf : Callable[[int, 
                                                                             int], int],
                                           py__obs_op_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int, 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__prodRinvA_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                           py__cvt_ens_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        int, 
                                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            int, 
                                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__obs_op_lin_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__obs_op_adj_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__prepoststep_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            int, 
                                                                            int, 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                            int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                           py__next_observation_pdaf : Callable[[int, 
                                                                                 int, 
                                                                                 int, 
                                                                                 float], tuple[int, 
                                                                                 int, 
                                                                                 float]],
                                           outflag: int) -> int:
    r"""3DEnVar for a single DA step
    using non-diagnoal observation error covariance matrix.

    See :func:`pyPDAF.PDAF.omi_assimilate_en3dvar_estkf`
    for simpler user-supplied functions
    using diagonal observation error covariance matirx.

    Here, the background error covariance matrix is
    estimated by an ensemble.
    The 3DEnVar only calculates the analysis of the ensemble mean.
    An ESTKF is used along with 3DEnVar to generate ensemble perturbations.
    This function should be called at each model time step.

    The function is a combination of
    :func:`pyPDAF.PDAF.omi_put_state_en3dvar_estkf_nondiagR`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. the iterative optimisation:
            1. py__cvt_ens_pdaf
            2. py__obs_op_lin_pdaf
            3. py__prodRinvA_pdaf
            4. py__obs_op_adj_pdaf
            5. py__cvt_adj_ens_pdaf
            6. core 3DEnVar algorithm
        6. py__cvt_ens_pdaf
        7. ESTKF:
            1. py__init_dim_obs_pdaf
            2. py__obs_op_pdaf (for ensemble mean)
            3. py__obs_op_pdaf (for each ensemble member)
            4. py__prodRinvA_pdaf
            5. core ESTKF algorithm
        8. py__prepoststep_state_pdaf
        9. py__distribute_state_pdaf
        10. py__next_observation_pdaf

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one
                (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_assimilate_en3dvar_lestkf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__distribute_state_pdaf : Callable[[int, 
                                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__init_dim_obs_pdaf : Callable[[int, 
                                                                              int], int],
                                            py__obs_op_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__prodRinvA_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                            py__cvt_ens_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                             int, 
                                                                             int, 
                                                                             int, 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__obs_op_lin_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__obs_op_adj_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__prodRinvA_l_pdaf : Callable[[int, 
                                                                             int, 
                                                                             int, 
                                                                             int, 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                            py__init_n_domains_p_pdaf : Callable[[int, 
                                                                                  int], int],
                                            py__init_dim_l_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int], int],
                                            py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                                int, 
                                                                                int, 
                                                                                int], int],
                                            py__g2l_state_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                           int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__l2g_state_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                           int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__prepoststep_pdaf : Callable[[int, 
                                                                             int, 
                                                                             int, 
                                                                             int, 
                                                                             int, 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                             int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                            py__next_observation_pdaf : Callable[[int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  float], tuple[int, 
                                                                                  int, 
                                                                                  float]],
                                            outflag: int) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.localomi_assimilate_en3dvar_lestkf_nondiagR`
    or :func:`pyPDAF.PDAF.localomi_assimilate_en3dvar_lestkf`.

    PDAFlocal-OMI modules require fewer user-supplied
    functions and improved efficiency.

    3DEnVar for a single DA step where the ensemble anomaly
    is generated by LESTKF
    using non-diagnoal observation error covariance matrix.
    The background error covariance matrix is estimated by ensemble.
    The 3DEnVar only calculates the analysis of the ensemble mean.
    An LESTKF is used to generate ensemble perturbations.
    This function should be called at each model time step.

    The function is a combination of
    :func:`pyPDAF.PDAF.omi_put_state_en3dvar_lestkf_nondiagR`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. Starting the iterative optimisation:
            1. py__cvt_ens_pdaf
            2. py__obs_op_lin_pdaf
            3. py__prodRinvA_pdaf
            4. py__obs_op_adj_pdaf
            5. py__cvt_adj_ens_pdaf
            6. core DA algorithm
        6. py__cvt_ens_pdaf
        7. Perform LESTKF:
            1. py__init_n_domains_p_pdaf
            2. py__init_dim_obs_pdaf
            3. py__obs_op_pdaf
               (for each ensemble member)
            4. loop over each local domain:
                1. py__init_dim_l_pdaf
                2. py__init_dim_obs_l_pdaf
                3. py__g2l_state_pdaf
                4. py__prodRinvA_l_pdaf
                5. core DA algorithm
                6. py__l2g_state_pdaf
        8. py__prepoststep_state_pdaf
        9. py__distribute_state_pdaf
        10. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_assimilate_en3dvar_lestkf`
       and :func:`pyPDAF.PDAF.localomi_assimilate_en3dvar_lestkf_nondiagR`

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one
                (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A for local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from local state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_assimilate_enkf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__distribute_state_pdaf : Callable[[int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__init_dim_obs_pdaf : Callable[[int, 
                                                                    int], int],
                                  py__obs_op_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__add_obs_err_pdaf : Callable[[int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                  py__init_obs_covar_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      float, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      bool], tuple[float, 
                                                                      bool]],
                                  py__prepoststep_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                  py__next_observation_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        float], tuple[int, 
                                                                        int, 
                                                                        float]]
                                 ) -> int:
    r"""Stochastic EnKF for a single DA step
    using non-diagnoal observation error covariance matrix.

    See :func:`pyPDAF.PDAF.omi_assimilate_global`
    for simpler user-supplied functions
    using diagonal observation error covariance matrix.

    The stochastic EnKF is proposed by Evensen [1]_ and
    is a Monte Carlo approximation of the KF.

    This function should be called at each model time step. 

    The function is a combination of
    :func:`pyPDAF.PDAF.omi_put_state_enkf_nondiagR` and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf (for ensemble mean)
        5. py__add_obs_err_pdaf
        6. py__init_obscovar_pdaf
        7. py__obs_op_pdaf (for each ensemble member)
        8. core DA algorithm
        9. py__prepoststep_state_pdaf
        10. py__distribute_state_pdaf
        11. py__next_observation_pdaf

    References
    ----------
    .. [1] Evensen, G. (1994), 
           Sequential data assimilation with
           a nonlinear quasi-geostrophic model
           using Monte Carlo methods to forecast error statistics,
           J. Geophys. Res., 99(C5), 1014310162, doi:10.1029/94JC00572.

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__add_obs_err_pdaf : Callable[step:int, dim_obs_p:int, C_p:ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]]
        Add obs error covariance R to HPH in EnKF

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Dimension of observation vector

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            --- Matrix to that observation covariance R is added

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            --- Matrix to that observation covariance R is added


    py__init_obs_covar_pdaf : Callable[step:int, dim_obs:int, dim_obs_p:int, covar:float, obs_p:ndarray[tuple[dim_obs_p], np.float64], isdiag:bool]
        Initialize obs. error cov. matrix R in EnKF

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs** : int

            --- Global size of observation vector

        * **dim_obs_p** : int

            --- Size of process-local observation vector

        * **covar** : float

            --- Observation error covariance matrix

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Process-local vector of observations

        * **isdiag** : bool

            --- 

        **Callback Returns**

        * **covar**:float

            --- Observation error covariance matrix

        * **isdiag**:bool

            --- 


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_assimilate_global_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__distribute_state_pdaf : Callable[[int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__init_dim_obs_pdaf : Callable[[int, 
                                                                      int], int],
                                    py__obs_op_pdaf : Callable[[int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__prodRinvA_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                    py__prepoststep_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                    py__next_observation_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          float], tuple[int, 
                                                                          int, 
                                                                          float]]
                                   ) -> int:
    r"""Global filters except for 3DVar and stochastic EnKF
    for a single DA step using non-diagnoal observation
    error covariance matrix.

    See :func:`pyPDAF.PDAF.omi_assimilate_global`
    for simpler user-supplied functions
    using diagonal observation error covariance matrix.

    Here, this function call is used for global, E(S)TKF [1]_, 
    SEEK [1]_, SEIK [1]_.
    The filter type is set in :func:`pyPDAF.PDAF.init`.
    This function should be called at each model time step. 

    The function is a combination of
    :func:`pyPDAF.PDAF.omi_put_state_global` and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf (for ensemble mean)
        5. py__obs_op_pdaf (for each ensemble member)
        6. py__prodRinvA_pdaf
        7. core DA algorithm
        8. py__prepoststep_state_pdaf
        9. py__distribute_state_pdaf
        10. py__next_observation_pdaf

    References
    ----------
    .. [1] Nerger, L., Janji, T., Schrter, J., Hiller, W. (2012). 
           A unification of ensemble square root Kalman filters. 
           Monthly Weather Review, 140, 2335-2345.
           doi:10.1175/MWR-D-11-00102.1

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one
                (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_assimilate_hyb3dvar_estkf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__distribute_state_pdaf : Callable[[int, 
                                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__init_dim_obs_pdaf : Callable[[int, 
                                                                              int], int],
                                            py__obs_op_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__prodRinvA_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                            py__cvt_ens_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                             int, 
                                                                             int, 
                                                                             int, 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__cvt_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__cvt_adj_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__obs_op_lin_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__obs_op_adj_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__prepoststep_pdaf : Callable[[int, 
                                                                             int, 
                                                                             int, 
                                                                             int, 
                                                                             int, 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                             int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                            py__next_observation_pdaf : Callable[[int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  float], tuple[int, 
                                                                                  int, 
                                                                                  float]],
                                            outflag: int) -> int:
    r"""Hybrid 3DEnVar for a single DA step
    using non-diagnoal observation error covariance matrix.

    See :func:`pyPDAF.PDAF.omi_assimilate_hyb3dvar_estkf`
    for simpler user-supplied functions
    using diagonal observation error covariance matrix.

    Here the background error covariance is hybridised by
    a static background error covariance,
    and a flow-dependent background error covariance
    estimated from ensemble.
    The 3DVar generates an ensemble mean and
    the ensemble perturbation is generated by
    ESTKF in this implementation.
    This function should be called at each model time step.

    The function is a combination of
    :func:`pyPDAF.PDAF.omi_put_state_hyb3dvar_estkf_nondiagR`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. the iterative optimisation:
            1. py__cvt_pdaf
            2. py__cvt_ens_pdaf
            3. py__obs_op_lin_pdaf
            4. py__prodRinvA_pdaf
            5. py__obs_op_adj_pdaf
            6. py__cvt_adj_pdaf
            7. py__cvt_adj_ens_pdaf
            8. core 3DEnVar algorithm
        6. py__cvt_pdaf
        7. py__cvt_ens_pdaf
        8. Perform ESTKF:
            1. py__init_dim_obs_pdaf
            2. py__obs_op_pdaf
               (for ensemble mean)
            3. py__obs_op_pdaf
               (for each ensemble member)
            4. py__prodRinvA_pdaf
            5. core ESTKF algorithm
        9. py__prepoststep_state_pdaf
        10. py__distribute_state_pdaf
        11. py__next_observation_pdaf

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one
                (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply ensemble control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint ensemble control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_assimilate_hyb3dvar_lestkf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                             py__distribute_state_pdaf : Callable[[int, 
                                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                             py__init_dim_obs_pdaf : Callable[[int, 
                                                                               int], int],
                                             py__obs_op_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                             py__prodRinvA_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                             py__cvt_ens_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          int, 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                             py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                              int, 
                                                                              int, 
                                                                              int, 
                                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                             py__cvt_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                             py__cvt_adj_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                             py__obs_op_lin_pdaf : Callable[[int, 
                                                                             int, 
                                                                             int, 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                             py__obs_op_adj_pdaf : Callable[[int, 
                                                                             int, 
                                                                             int, 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                             py__prodRinvA_l_pdaf : Callable[[int, 
                                                                              int, 
                                                                              int, 
                                                                              int, 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                             py__init_n_domains_p_pdaf : Callable[[int, 
                                                                                   int], int],
                                             py__init_dim_l_pdaf : Callable[[int, 
                                                                             int, 
                                                                             int], int],
                                             py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                                 int, 
                                                                                 int, 
                                                                                 int], int],
                                             py__g2l_state_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                            int, 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                             py__l2g_state_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                            int, 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                             py__prepoststep_pdaf : Callable[[int, 
                                                                              int, 
                                                                              int, 
                                                                              int, 
                                                                              int, 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                              int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                             py__next_observation_pdaf : Callable[[int, 
                                                                                   int, 
                                                                                   int, 
                                                                                   float], tuple[int, 
                                                                                   int, 
                                                                                   float]],
                                             outflag: int) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.localomi_assimilate_hyb3dvar_lestkf_nondiagR`
    or :func:`pyPDAF.PDAF.localomi_assimilate_hyb3dvar_lestkf`.

    PDAFlocal-OMI modules require fewer user-supplied functions
    and improved efficiency.

    Hybrid 3DEnVar for a single DA step
    using diagnoal observation error covariance matrix where
    the background error covariance is hybridised by
    a static background error covariance,
    and a flow-dependent background error covariance
    estimated from ensemble.
    The 3DVar generates an ensemble mean and
    the ensemble perturbation is generated by
    LESTKF in this implementation.
    This function should be called at each model time step.

    The function is a combination of
    :func:`pyPDAF.PDAF.omi_put_state_hyb3dvar_lestkf_nondiagR`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. The iterative optimisation:
            1. py__cvt_pdaf
            2. py__cvt_ens_pdaf
            3. py__obs_op_lin_pdaf
            4. py__prodRinvA_pdaf
            5. py__obs_op_adj_pdaf
            6. py__cvt_adj_pdaf
            7. py__cvt_adj_ens_pdaf
            8. core DA algorithm
        6. py__cvt_pdaf
        7. py__cvt_ens_pdaf
        8. Perform LESTKF:
            1. py__init_n_domains_p_pdaf
            2. py__init_dim_obs_pdaf
            3. py__obs_op_pdaf
               (for each ensemble member)
            4. loop over each local domain:
                1. py__init_dim_l_pdaf
                2. py__init_dim_obs_l_pdaf
                3. py__g2l_state_pdaf
                4. py__prodRinvA_l_pdaf
                5. core DA algorithm
                6. py__l2g_state_pdaf
        9. py__prepoststep_state_pdaf
        10. py__distribute_state_pdaf
        11. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_assimilate_hyb3dvar_lestkf`
       and :func:`pyPDAF.PDAF.localomi_assimilate_hyb3dvar_lestkf_nondiagR`

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one
                (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A for local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from local state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_assimilate_lenkf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__distribute_state_pdaf : Callable[[int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__init_dim_obs_pdaf : Callable[[int, 
                                                                     int], int],
                                   py__obs_op_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__prepoststep_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                   py__localize_covar_pdaf : Callable[[int, 
                                                                       int, 
                                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]], tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                   py__add_obs_err_pdaf : Callable[[int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                   py__init_obs_covar_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int, 
                                                                       float, 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                       bool], tuple[float, 
                                                                       bool]],
                                   py__next_observation_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         float], tuple[int, 
                                                                         int, 
                                                                         float]]
                                  ) -> int:
    r"""Covariance localised stochastic EnKF
    for a single DA step using non-diagnoal observation error covariance matrix.

    See :func:`pyPDAF.PDAF.omi_assimilate_lenkf`
    for simpler user-supplied functions
    using diagnoal observation error covariance matrix.

    This stochastic EnKF is implemented based on [1]_

    This is the only scheme for covariance localisation in PDAF.

    This function should be called at each model time step.
    The function is a combination of
    :func:`pyPDAF.PDAF.omi_put_state_lenkf_nondiagR`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf (for each ensemble member)
        5. py__localize_pdaf
        6. py__add_obs_err_pdaf
        7. py__init_obscovar_pdaf
        8. py__obs_op_pdaf (repeated to reduce storage)
        9. core DA algorith
        10. py__prepoststep_state_pdaf
        11. py__distribute_state_pdaf
        12. py__next_observation_pdaf

    References
    ----------
    .. [1] Houtekamer, P. L., and H. L. Mitchell (1998): 
           Data Assimilation Using an Ensemble Kalman Filter Technique.
           Mon. Wea. Rev., 126, 796811,
           doi: 10.1175/1520-0493(1998)126<0796:DAUAEK>2.0.CO;2.

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__localize_covar_pdaf : Callable[dim_p:int, dim_obs:int, hp_p:ndarray[tuple[dim_obs, dim_p], np.float64], hph:ndarray[tuple[dim_obs, dim_obs], np.float64]]
        Apply localization to HP and HPH^T

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_obs** : int

            --- number of observations

        * **hp_p** : ndarray[tuple[dim_obs, dim_p], np.float64]

            --- pe local part of matrix hp

        * **hph** : ndarray[tuple[dim_obs, dim_obs], np.float64]

            --- matrix hph

        **Callback Returns**

        * **hp_p** : ndarray[tuple[dim_obs, dim_p], np.float64]

            --- pe local part of matrix hp

        * **hph** : ndarray[tuple[dim_obs, dim_obs], np.float64]

            --- matrix hph


    py__add_obs_err_pdaf : Callable[step:int, dim_obs_p:int, C_p:ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]]
        Add obs error covariance R to HPH in EnKF

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Dimension of observation vector

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            --- Matrix to that observation covariance R is added

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            --- Matrix to that observation covariance R is added


    py__init_obs_covar_pdaf : Callable[step:int, dim_obs:int, dim_obs_p:int, covar:float, obs_p:ndarray[tuple[dim_obs_p], np.float64], isdiag:bool]
        Initialize obs. error cov. matrix R in EnKF

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs** : int

            --- Global size of observation vector

        * **dim_obs_p** : int

            --- Size of process-local observation vector

        * **covar** : float

            --- Observation error covariance matrix

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Process-local vector of observations

        * **isdiag** : bool

            --- 

        **Callback Returns**

        * **covar**:float

            --- Observation error covariance matrix

        * **isdiag**:bool

            --- 


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_assimilate_lknetf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__distribute_state_pdaf : Callable[[int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__init_dim_obs_pdaf : Callable[[int, 
                                                                      int], int],
                                    py__obs_op_pdaf : Callable[[int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__prepoststep_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                    py__init_n_domains_p_pdaf : Callable[[int, 
                                                                          int], int],
                                    py__init_dim_l_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int], int],
                                    py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        int], int],
                                    py__prodRinvA_l_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                    py__prodRinvA_hyb_l_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         float, 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                    py__likelihood_l_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      float], float],
                                    py__likelihood_hyb_l_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          float, 
                                                                          float], float],
                                    py__g2l_state_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__l2g_state_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__next_observation_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          float], tuple[int, 
                                                                          int, 
                                                                          float]]
                                   ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.localomi_assimilate_lknetf_nondiagR`
    or :func:`pyPDAF.PDAF.localomi_assimilate`.

    PDAFlocal-OMI modules require fewer user-supplied
    functions and improved efficiency.

    LKNETF [1]_ for a single DA step using non-diagnoal
    observation error covariance matrix.
    See :func:`pyPDAF.PDAF.localomi_assimilate`
    for using diagnoal observation error covariance matrix.
    The filter type is set in :func:`pyPDAF.PDAF.init`.
    This function should be called at each model time step.
    The function is a combination of
    :func:`pyPDAF.PDAF.omi_put_state_lknetf_nondiagR`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. py__g2l_state_pdaf
            4. py__prodRinvA_pdaf
            5. py__likelihood_l_pdaf
            6. core DA algorithm
            7. py__l2g_state_pdaf
            8. py__obs_op_pdaf
               (only called with `HKN` and `HNK` options
               called for each ensemble member)
            9. py__likelihood_hyb_l_pda
            10. py__prodRinvA_hyb_l_pdaf
        7. py__prepoststep_state_pdaf
        8. py__distribute_state_pdaf
        9. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_assimilate`
       and :func:`pyPDAF.PDAF.localomi_assimilate_lnetf_nondiagR`.

    References
    ----------
    .. [1] Nerger, L.. (2022) 
           Data assimilation for nonlinear systems with
           a hybrid nonlinear Kalman ensemble transform filter. 
           Q J R Meteorol Soc, 620640. doi:10.1002/qj.4221

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__prodRinvA_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, dim_ens:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, A_l:ndarray[tuple[dim_obs_l, dim_ens], np.float64], C_l:ndarray[tuple[dim_obs_l, dim_ens], np.float64]]
        Provide product R^-1 A on local analysis domain with hybrid weight

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **dim_ens** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **gamma** : float

            --- Hybrid weight provided by PDAF

        * **A_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Output matrix


    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- nput vector holding the local residual

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    py__likelihood_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, likely_l:float]
        Compute likelihood with hybrid weight

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Input vector holding the local residual

        * **gamma** : float

            --- Hybrid weight provided by PDAF

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_assimilate_lnetf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__distribute_state_pdaf : Callable[[int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__init_dim_obs_pdaf : Callable[[int, 
                                                                     int], int],
                                   py__obs_op_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__prepoststep_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                   py__init_n_domains_p_pdaf : Callable[[int, 
                                                                         int], int],
                                   py__init_dim_l_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int], int],
                                   py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int, 
                                                                       int], int],
                                   py__likelihood_l_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     float], float],
                                   py__g2l_state_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__l2g_state_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__next_observation_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         float], tuple[int, 
                                                                         int, 
                                                                         float]]
                                  ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.localomi_assimilate_lnetf_nondiagR`
    or :func:`pyPDAF.PDAF.localomi_assimilate`.

    PDAFlocal-OMI modules require fewer user-supplied functions
    and improved efficiency.

    LNETF [1]_ for a single DA step using
    non-diagnoal observation error covariance matrix.
    See :func:`pyPDAF.PDAF.localomi_assimilate`
    for using diagnoal observation error covariance matrix.
    The filter type is set in :func:`pyPDAF.PDAF.init`.
    This function should be called at each model time step.
    The function is a combination of
    :func:`pyPDAF.PDAF.omi_put_state_lnetf_nondiagR`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. py__g2l_state_pdaf
            4. py__likelihood_l_pdaf
            5. core DA algorithm
            6. py__l2g_state_pdaf
        7. py__prepoststep_state_pdaf
        8. py__distribute_state_pdaf
        9. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_assimilate`
       and :func:`pyPDAF.PDAF.localomi_assimilate_lnetf_nondiagR`.

    References
    ----------
    .. [1] Tdter, J., and B. Ahrens, 2015:
           A second-order exact ensemble square root filter
           for nonlinear data assimilation. Mon. Wea. Rev.,
           143, 13471367, doi:10.1175/MWR-D-14-00108.1.

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- nput vector holding the local residual

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_assimilate_local_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__distribute_state_pdaf : Callable[[int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__init_dim_obs_pdaf : Callable[[int, 
                                                                     int], int],
                                   py__obs_op_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__prepoststep_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                   py__init_n_domains_p_pdaf : Callable[[int, 
                                                                         int], int],
                                   py__init_dim_l_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int], int],
                                   py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int, 
                                                                       int], int],
                                   py__prodRinvA_l_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                   py__g2l_state_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__l2g_state_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__next_observation_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         float], tuple[int, 
                                                                         int, 
                                                                         float]]
                                  ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.localomi_assimilate_nondiagR`
    or :func:`pyPDAF.PDAF.localomi_assimilate`.

    PDAFlocal-OMI modules require fewer user-supplied functions
    and improved efficiency.

    Domain local filters for a single DA step
    using non-diagnoal observation error covariance matrix.
    Here, this function call is used for LE(S)TKF [1]_ and LSEIK [1]_
    The filter type is set in :func:`pyPDAF.PDAF.init`.
    This function should be called at each model time step.
    The function is a combination of
    :func:`pyPDAF.PDAF.omi_put_state_local_nondiagR`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. py__g2l_state_pdaf
            4. py__init_obs_l_pdaf
            5. py__prodRinvA_l_pdaf
            6. core DA algorithm
            7. py__l2g_state_pdaf
        7. py__prepoststep_state_pdaf
        8. py__distribute_state_pdaf
        9. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_assimilate`
       and :func:`pyPDAF.PDAF.localomi_assimilate_nondiagR`.

    References
    ----------
    .. [1] Nerger, L., Janji, T., Schrter, J., Hiller, W. (2012). 
           A unification of ensemble square root Kalman filters. 
           Monthly Weather Review, 140, 2335-2345.
           doi:10.1175/MWR-D-11-00102.1

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_assimilate_nonlin_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__distribute_state_pdaf : Callable[[int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__init_dim_obs_pdaf : Callable[[int, 
                                                                      int], int],
                                    py__obs_op_pdaf : Callable[[int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__likelihood_pdaf : Callable[[int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    float], float],
                                    py__prepoststep_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                    py__next_observation_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          float], tuple[int, 
                                                                          int, 
                                                                          float]]
                                   ) -> int:
    r"""Global nonlinear filters for a single DA step
    using non-diagnoal observation error covariance matrix.

    See :func:`pyPDAF.PDAF.omi_assimilate_global_nondiagR`
    for simpler user-supplied functions
    using diagonal observation error covariance matrix.

    Here, this function call is used for global NETF [1]_,
    and particle filter [2]_.
    The filter type is set in :func:`pyPDAF.PDAF.init`.
    This function should be called at each model time step. 

    The function is a combination of
    :func:`pyPDAF.PDAF.omi_put_state_global_nondiagR` and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf (for ensemble mean)
        5. py__obs_op_pdaf (for each ensemble member)
        6. py__likelihood_pdaf
        7. core DA algorithm
        8. py__prepoststep_state_pdaf
        9. py__distribute_state_pdaf
        10. py__next_observation_pdaf

    References
    ----------
    .. [1] Tdter, J., and B. Ahrens, 2015:
           A second-order exact ensemble square root filter
           for nonlinear data assimilation. Mon. Wea. Rev.,
           143, 13471367, doi:10.1175/MWR-D-14-00108.1.
    .. [2] Van Leeuwen, P. J., Knsch, H. R., Nerger, L.,
           Potthast, R., & Reich, S. (2019).
           Particle filters for highdimensional geoscience applications:
           A review. Quarterly Journal of the Royal Meteorological Society, 145(723), 2335-2365.

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__likelihood_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], resid:ndarray[tuple[dim_obs_p], np.float64], likely:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **resid** : ndarray[tuple[dim_obs_p], np.float64]

            --- Input vector holding the residual

        * **likely** : float

            --- Output value of the likelihood

        **Callback Returns**

        * **likely**:float

            --- Output value of the likelihood


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_put_state_3dvar_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__init_dim_obs_pdaf : Callable[[int, 
                                                                    int], int],
                                  py__obs_op_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__prodRinvA_pdaf : Callable[[int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                  py__cvt_pdaf : Callable[[int, int, int, 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__cvt_adj_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__obs_op_lin_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__obs_op_adj_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__prepoststep_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                  outflag: int) -> int:
    r"""3DVar DA for a single DA step
    using non-diagnoal observation error covariance matrix
    without post-processing, distributing analysis,
    and setting next observation step.

    See :func:`pyPDAF.PDAF.omi_put_state_3dvar`
    for simpler user-supplied functions using
    diagonal observation error covariance matrix.

    Compared to
    :func:`pyPDAF.PDAF.omi_assimilate_3dvar_nondiagR`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions.
    The next DA step will not be assigned
    by user-supplied functions as well.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    When 3DVar is used, the background error covariance matrix
    has to be modelled for cotrol variable transformation.
    This is a deterministic filtering scheme
    so no ensemble and parallelisation is needed.
    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. Iterative optimisation:
            1. py__cvt_pdaf
            2. py__obs_op_lin_pdaf
            3. py__prodRinvA_pdaf
            4. py__obs_op_adj_pdaf
            5. py__cvt_adj_pdaf
            6. core DA algorithm
        6. py__cvt_pdaf

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one
                (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_put_state_en3dvar_estkf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                          py__init_dim_obs_pdaf : Callable[[int, 
                                                                            int], int],
                                          py__obs_op_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                          py__prodRinvA_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                          py__cvt_ens_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int, 
                                                                       int, 
                                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                          py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           int, 
                                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                          py__obs_op_lin_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                          py__obs_op_adj_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                          py__prepoststep_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           int, 
                                                                           int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                           int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                          outflag: int) -> int:
    r"""3DEnVar for a single DA step
    using non-diagnoal observation error covariance matrix
    without post-processing, distributing analysis,
    and setting next observation step.

    See :func:`pyPDAF.PDAF.omi_put_state_en3dvar_estkf`
    for simpler user-supplied functions
    using diagonal observation error covariance matrix.

    Compared to
    :func:`pyPDAF.PDAF.omi_assimilate_en3dvar_estkf_nondiagR`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    The background error covariance matrix is
    estimated by an ensemble.
    The 3DEnVar only calculates the analysis of the ensemble mean.
    An ESTKF is used along with 3DEnVar to generate ensemble perturbations.
    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. the iterative optimisation:
            1. py__cvt_ens_pdaf
            2. py__obs_op_lin_pdaf
            3. py__prodRinvA_pdaf
            4. py__obs_op_adj_pdaf
            5. py__cvt_adj_ens_pdaf
            6. core 3DEnVar algorithm
        6. py__cvt_ens_pdaf
        7. ESTKF:
            1. py__init_dim_obs_pdaf
            2. py__obs_op_pdaf (for ensemble mean)
            3. py__obs_op_pdaf (for each ensemble member)
            4. py__prodRinvA_pdaf
            5. core ESTKF algorithm

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one
                (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_put_state_en3dvar_lestkf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__init_dim_obs_pdaf : Callable[[int, 
                                                                             int], int],
                                           py__obs_op_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int, 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__prodRinvA_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                           py__cvt_ens_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        int, 
                                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            int, 
                                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__obs_op_lin_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__obs_op_adj_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__prodRinvA_l_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            int, 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                           py__init_n_domains_p_pdaf : Callable[[int, 
                                                                                 int], int],
                                           py__init_dim_l_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int], int],
                                           py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                               int, 
                                                                               int, 
                                                                               int], int],
                                           py__g2l_state_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__l2g_state_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__prepoststep_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            int, 
                                                                            int, 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                            int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                           outflag: int) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf_nondiagR`
    or :func:`pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf`.

    PDAFlocal-OMI modules require fewer user-supplied
    functions and improved efficiency.

    3DEnVar for a single DA step without post-processing,
    distributing analysis, and setting next observation step,
    where the ensemble anomaly is generated by LESTKF
    using non-diagnoal observation error covariance matrix.

    Compared to
    :func:`pyPDAF.PDAF.omi_assimilate_en3dvar_lestkf_nondiagR`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    The background error covariance matrix is
    estimated by ensemble.
    The 3DEnVar only calculates the analysis of the ensemble mean.
    An LESTKF is used to generate ensemble perturbations.
    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. Starting the iterative optimisation:
            1. py__cvt_ens_pdaf
            2. py__obs_op_lin_pdaf
            3. py__prodRinvA_pdaf
            4. py__obs_op_adj_pdaf
            5. py__cvt_adj_ens_pdaf
            6. core DA algorithm
        6. py__cvt_ens_pdaf
        7. Perform LESTKF:
            1. py__init_n_domains_p_pdaf
            2. py__init_dim_obs_pdaf
            3. py__obs_op_pdaf
               (for each ensemble member)
            4. loop over each local domain:
                1. py__init_dim_l_pdaf
                2. py__init_dim_obs_l_pdaf
                3. py__g2l_state_pdaf
                4. py__prodRinvA_l_pdaf
                5. core DA algorithm
                6. py__l2g_state_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf_nondiagR`
       and :func:`pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf`

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one
                (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A for local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from local state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_put_state_enkf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                 py__init_dim_obs_pdaf : Callable[[int, 
                                                                   int], int],
                                 py__obs_op_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                 py__add_obs_err_pdaf : Callable[[int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                 py__init_obs_covar_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     float, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     bool], tuple[float, 
                                                                     bool]],
                                 py__prepoststep_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                  int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]]]]
                                ) -> int:
    r"""Stochastic EnKF for a single DA step
    using non-diagnoal observation error covariance matrix
    without post-processing, distributing analysis,
    and setting next observation step.

    See :func:`pyPDAF.PDAF.omi_put_state_global`
    for simpler user-supplied functions
    using diagonal observation error covariance matrix.

    The stochastic EnKF is implemented based on [1]_.

    Compared to
    :func:`pyPDAF.PDAF.omi_assimilate_enkf_nondiagR`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    This function should be called at each model time step. 

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf (for ensemble mean)
        5. py__add_obs_err_pdaf
        6. py__init_obscovar_pdaf
        7. py__obs_op_pdaf (for each ensemble member)
        8. core DA algorithm

    References
    ----------
    .. [1] Evensen, G. (1994), 
           Sequential data assimilation with
           a nonlinear quasi-geostrophic model
           using Monte Carlo methods to forecast error statistics,
           J. Geophys. Res., 99(C5), 1014310162, doi:10.1029/94JC00572.

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__add_obs_err_pdaf : Callable[step:int, dim_obs_p:int, C_p:ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]]
        Add obs error covariance R to HPH in EnKF

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Dimension of observation vector

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            --- Matrix to that observation covariance R is added

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            --- Matrix to that observation covariance R is added


    py__init_obs_covar_pdaf : Callable[step:int, dim_obs:int, dim_obs_p:int, covar:float, obs_p:ndarray[tuple[dim_obs_p], np.float64], isdiag:bool]
        Initialize obs. error cov. matrix R in EnKF

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs** : int

            --- Global size of observation vector

        * **dim_obs_p** : int

            --- Size of process-local observation vector

        * **covar** : float

            --- Observation error covariance matrix

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Process-local vector of observations

        * **isdiag** : bool

            --- 

        **Callback Returns**

        * **covar**:float

            --- Observation error covariance matrix

        * **isdiag**:bool

            --- 


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble



    Returns
    -------
    outflag : int
        
    """
    ...

def omi_put_state_global_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__init_dim_obs_pdaf : Callable[[int, 
                                                                     int], int],
                                   py__obs_op_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__prodRinvA_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                   py__prepoststep_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]]]
                                  ) -> int:
    r"""Global filters except for 3DVar and stochastic EnKF
    for a single DA step using non-diagnoal observation
    error covariance matrix
    without post-processing, distributing analysis,
    and setting next observation step.

    See :func:`pyPDAF.PDAF.omi_put_state_global`
    for simpler user-supplied functions
    using diagonal observation error covariance matrix.

    Here, this function call is used for global, E(S)TKF [1]_, 
    SEEK [1]_, SEIK [1]_.
    The filter type is set in :func:`pyPDAF.PDAF.init`.

    Compared to
    :func:`pyPDAF.PDAF.omi_assimilate_global_nondiagR`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    This function should be called at each model time step. 

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf (for ensemble mean)
        5. py__obs_op_pdaf (for each ensemble member)
        6. py__prodRinvA_pdaf
        7. core DA algorithm

    References
    ----------
    .. [1] Nerger, L., Janji, T., Schrter, J., Hiller, W. (2012). 
           A unification of ensemble square root Kalman filters. 
           Monthly Weather Review, 140, 2335-2345.
           doi:10.1175/MWR-D-11-00102.1

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one
                (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_put_state_hyb3dvar_estkf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__init_dim_obs_pdaf : Callable[[int, 
                                                                             int], int],
                                           py__obs_op_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int, 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__prodRinvA_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                           py__cvt_ens_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        int, 
                                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            int, 
                                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__cvt_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__cvt_adj_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__obs_op_lin_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__obs_op_adj_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                           py__prepoststep_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            int, 
                                                                            int, 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                            int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                           outflag: int) -> int:
    r"""Hybrid 3DEnVar for a single DA step
    using non-diagnoal observation error covariance matrix
    without post-processing, distributing analysis,
    and setting next observation step.

    See :func:`pyPDAF.PDAF.omi_put_state_hyb3dvar_estkf`
    for simpler user-supplied functions
    using diagonal observation error covariance matrix.

    Here the background error covariance is hybridised by
    a static background error covariance,
    and a flow-dependent background error covariance
    estimated from ensemble.

    Compared to
    :func:`pyPDAF.PDAF.omi_assimilate_hyb3dvar_estkf_nondiagR`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    The 3DVar generates an ensemble mean and
    the ensemble perturbation is generated by
    ESTKF in this implementation.
    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. the iterative optimisation:
            1. py__cvt_pdaf
            2. py__cvt_ens_pdaf
            3. py__obs_op_lin_pdaf
            4. py__prodRinvA_pdaf
            5. py__obs_op_adj_pdaf
            6. py__cvt_adj_pdaf
            7. py__cvt_adj_ens_pdaf
            8. core 3DEnVar algorithm
        6. py__cvt_pdaf
        7. py__cvt_ens_pdaf
        8. Perform ESTKF:
            1. py__init_dim_obs_pdaf
            2. py__obs_op_pdaf
               (for ensemble mean)
            3. py__obs_op_pdaf
               (for each ensemble member)
            4. py__prodRinvA_pdaf
            5. core ESTKF algorithm

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one
                (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply ensemble control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint ensemble control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_put_state_hyb3dvar_lestkf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__init_dim_obs_pdaf : Callable[[int, 
                                                                              int], int],
                                            py__obs_op_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__prodRinvA_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                            py__cvt_ens_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                             int, 
                                                                             int, 
                                                                             int, 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__cvt_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__cvt_adj_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__obs_op_lin_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__obs_op_adj_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__prodRinvA_l_pdaf : Callable[[int, 
                                                                             int, 
                                                                             int, 
                                                                             int, 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                            py__init_n_domains_p_pdaf : Callable[[int, 
                                                                                  int], int],
                                            py__init_dim_l_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int], int],
                                            py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                                int, 
                                                                                int, 
                                                                                int], int],
                                            py__g2l_state_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                           int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__l2g_state_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                           int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                            py__prepoststep_pdaf : Callable[[int, 
                                                                             int, 
                                                                             int, 
                                                                             int, 
                                                                             int, 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                             int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                            outflag: int) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf_nondiagR`
    or :func:`pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf`.

    PDAFlocal-OMI modules require fewer user-supplied
    functions and improved efficiency.

    Hybrid 3DEnVar for a single DA step
    using non-diagnoal observation error covariance matrix
    without post-processing, distributing analysis,
    and setting next observation step, where
    the background error covariance is hybridised by
    a static background error covariance,
    and a flow-dependent background error covariance
    estimated from ensemble.

    Compared to
    :func:`pyPDAF.PDAF.omi_assimilate_hyb3dvar_lestkf_nondiagR`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    The 3DVar generates an ensemble mean and
    the ensemble perturbation is generated by
    LESTKF in this implementation.
    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. The iterative optimisation:
            1. py__cvt_pdaf
            2. py__cvt_ens_pdaf
            3. py__obs_op_lin_pdaf
            4. py__prodRinvA_pdaf
            5. py__obs_op_adj_pdaf
            6. py__cvt_adj_pdaf
            7. py__cvt_adj_ens_pdaf
            8. core DA algorithm
        6. py__cvt_pdaf
        7. py__cvt_ens_pdaf
        8. Perform LESTKF:
            1. py__init_n_domains_p_pdaf
            2. py__init_dim_obs_pdaf
            3. py__obs_op_pdaf
               (for each ensemble member)
            4. loop over each local domain:
                1. py__init_dim_l_pdaf
                2. py__init_dim_obs_l_pdaf
                3. py__g2l_state_pdaf
                4. py__prodRinvA_l_pdaf
                5. core DA algorithm
                6. py__l2g_state_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf`
       and :func:`pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf_nondiagR`

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one
                (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A for analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from local state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_put_state_lenkf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__init_dim_obs_pdaf : Callable[[int, 
                                                                    int], int],
                                  py__obs_op_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__prepoststep_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                  py__localize_covar_pdaf : Callable[[int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]], tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                  py__add_obs_err_pdaf : Callable[[int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                  py__init_obs_covar_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      float, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      bool], tuple[float, 
                                                                      bool]]
                                 ) -> int:
    r"""Covariance localised stochastic EnKF
    for a single DA step using non-diagnoal observation
    error covariance matrix
    without post-processing, distributing analysis,
    and setting next observation step.

    See :func:`pyPDAF.PDAF.omi_put_state_lenkf`
    for simpler user-supplied functions
    using diagnoal observation error covariance matrix.

    This function is implemented based on [1]_.

    This is the only scheme for covariance localisation in PDAF.

    Compared to
    :func:`pyPDAF.PDAF.omi_assimilate_lenkf_nondiagR`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf (for each ensemble member)
        5. py__localize_pdaf
        6. py__add_obs_err_pdaf
        7. py__init_obscovar_pdaf
        8. py__obs_op_pdaf (repeated to reduce storage)
        9. core DA algorithm

    References
    ----------
    .. [1] Houtekamer, P. L., and H. L. Mitchell (1998): 
           Data Assimilation Using an Ensemble Kalman Filter Technique.
           Mon. Wea. Rev., 126, 796811,
           doi: 10.1175/1520-0493(1998)126<0796:DAUAEK>2.0.CO;2.

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__localize_covar_pdaf : Callable[dim_p:int, dim_obs:int, hp_p:ndarray[tuple[dim_obs, dim_p], np.float64], hph:ndarray[tuple[dim_obs, dim_obs], np.float64]]
        Apply localization to HP and HPH^T

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **dim_obs** : int

            --- number of observations

        * **hp_p** : ndarray[tuple[dim_obs, dim_p], np.float64]

            --- pe local part of matrix hp

        * **hph** : ndarray[tuple[dim_obs, dim_obs], np.float64]

            --- matrix hph

        **Callback Returns**

        * **hp_p** : ndarray[tuple[dim_obs, dim_p], np.float64]

            --- pe local part of matrix hp

        * **hph** : ndarray[tuple[dim_obs, dim_obs], np.float64]

            --- matrix hph


    py__add_obs_err_pdaf : Callable[step:int, dim_obs_p:int, C_p:ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]]
        Add obs error covariance R to HPH in EnKF

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Dimension of observation vector

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            --- Matrix to that observation covariance R is added

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            --- Matrix to that observation covariance R is added


    py__init_obs_covar_pdaf : Callable[step:int, dim_obs:int, dim_obs_p:int, covar:float, obs_p:ndarray[tuple[dim_obs_p], np.float64], isdiag:bool]
        Initialize obs. error cov. matrix R in EnKF

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs** : int

            --- Global size of observation vector

        * **dim_obs_p** : int

            --- Size of process-local observation vector

        * **covar** : float

            --- Observation error covariance matrix

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Process-local vector of observations

        * **isdiag** : bool

            --- 

        **Callback Returns**

        * **covar**:float

            --- Observation error covariance matrix

        * **isdiag**:bool

            --- 



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_put_state_lknetf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__init_dim_obs_pdaf : Callable[[int, 
                                                                     int], int],
                                   py__obs_op_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__prepoststep_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                   py__init_n_domains_p_pdaf : Callable[[int, 
                                                                         int], int],
                                   py__init_dim_l_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int], int],
                                   py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int, 
                                                                       int], int],
                                   py__prodRinvA_l_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                   py__prodRinvA_hyb_l_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        float, 
                                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                   py__likelihood_l_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     float], float],
                                   py__likelihood_hyb_l_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         float, 
                                                                         float], float],
                                   py__g2l_state_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__l2g_state_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]]
                                  ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.localomi_put_state_lknetf_nondiagR`
    or :func:`pyPDAF.PDAF.localomi_put_state`.

    PDAFlocal-OMI modules require fewer user-supplied
    functions and improved efficiency.

    LKNETF [1]_ for a single DA step using
    non-diagnoal observation error covariance matrix
    without post-processing, distributing analysis,
    and setting next observation step.

    See :func:`pyPDAF.PDAF.localomi_assimilate`
    for using diagnoal observation error covariance matrix.
    The filter type is set in :func:`pyPDAF.PDAF.init`.

    Compared to
    :func:`pyPDAF.PDAF.omi_assimilate_lknetf_nondiagR`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. py__g2l_state_pdaf
            4. py__prodRinvA_pdaf
            5. py__likelihood_l_pdaf
            6. core DA algorithm
            7. py__l2g_state_pdaf
            8. py__obs_op_pdaf
               (only called with `HKN` and `HNK` options
               called for each ensemble member)
            9. py__likelihood_hyb_l_pda
            10. py__prodRinvA_hyb_l_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_put_state`
       and :func:`pyPDAF.PDAF.localomi_put_state_lnetf_nondiagR`.

    References
    ----------
    .. [1] Nerger, L.. (2022) 
           Data assimilation for nonlinear systems with
           a hybrid nonlinear Kalman ensemble transform filter.
           Q J R Meteorol Soc, 620640. doi:10.1002/qj.4221

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__prodRinvA_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, dim_ens:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, A_l:ndarray[tuple[dim_obs_l, dim_ens], np.float64], C_l:ndarray[tuple[dim_obs_l, dim_ens], np.float64]]
        Provide product R^-1 A on local analysis domain with hybrid weight

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **dim_ens** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **gamma** : float

            --- Hybrid weight provided by PDAF

        * **A_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Output matrix


    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- nput vector holding the local residual

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    py__likelihood_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, likely_l:float]
        Compute likelihood with hybrid weight

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Input vector holding the local residual

        * **gamma** : float

            --- Hybrid weight provided by PDAF

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_put_state_lnetf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__init_dim_obs_pdaf : Callable[[int, 
                                                                    int], int],
                                  py__obs_op_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__prepoststep_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                  py__init_n_domains_p_pdaf : Callable[[int, 
                                                                        int], int],
                                  py__init_dim_l_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int], int],
                                  py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      int], int],
                                  py__likelihood_l_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    float], float],
                                  py__g2l_state_pdaf : Callable[[int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__l2g_state_pdaf : Callable[[int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]]
                                 ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.localomi_put_state_lnetf_nondiagR`
    or :func:`pyPDAF.PDAF.localomi_put_state`.

    PDAFlocal-OMI modules require fewer user-supplied
    functions and improved efficiency.

    LNETF [1]_ for a single DA step
    using non-diagnoal observation error covariance matrix
    without post-processing, distributing analysis,
    and setting next observation step.

    See :func:`pyPDAF.PDAF.localomi_put_state`
    for using diagnoal observation error covariance matrix.
    The filter type is set in :func:`pyPDAF.PDAF.init`.

    Compared to
    :func:`pyPDAF.PDAF.omi_assimilate_lnetf_nondiagR`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. py__g2l_state_pdaf
            4. py__likelihood_l_pdaf
            5. core DA algorithm
            6. py__l2g_state_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_put_state`
       and :func:`pyPDAF.PDAF.localomi_put_state_lnetf_nondiagR`.

    References
    ----------
    .. [1] Tdter, J., and B. Ahrens, 2015:
           A second-order exact ensemble square root filter
           for nonlinear data assimilation. Mon. Wea. Rev.,
           143, 13471367, doi:10.1175/MWR-D-14-00108.1.

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- nput vector holding the local residual

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_put_state_local_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__init_dim_obs_pdaf : Callable[[int, 
                                                                    int], int],
                                  py__obs_op_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__prepoststep_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                  py__init_n_domains_p_pdaf : Callable[[int, 
                                                                        int], int],
                                  py__init_dim_l_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int], int],
                                  py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      int], int],
                                  py__prodRinvA_l_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                  py__g2l_state_pdaf : Callable[[int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__l2g_state_pdaf : Callable[[int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]]
                                 ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.localomi_put_state_nondiagR`
    or :func:`pyPDAF.PDAF.localomi_put_state`.

    PDAFlocal-OMI modules require fewer user-supplied
    functions and improved efficiency.

    Domain local filters for a single DA step
    using non-diagnoal observation error covariance matrix
    without post-processing, distributing analysis,
    and setting next observation step.

    Here, this function call is used for LE(S)TKF [1]_ and LSEIK [1]_
    The filter type is set in :func:`pyPDAF.PDAF.init`.

    Compared to
    :func:`pyPDAF.PDAF.omi_assimilate_local_nondiagR`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. py__g2l_state_pdaf
            4. py__init_obs_l_pdaf
            5. py__prodRinvA_l_pdaf
            6. core DA algorithm
            7. py__l2g_state_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_put_state`
       and :func:`pyPDAF.PDAF.localomi_put_state_nondiagR`.

    References
    ----------
    .. [1] Nerger, L., Janji, T., Schrter, J., Hiller, W. (2012). 
           A unification of ensemble square root Kalman filters. 
           Monthly Weather Review, 140, 2335-2345. doi:10.1175/MWR-D-11-00102.1

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        **Callback Returns**

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain


    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        * **state_l** : ndarray[tuple[dim_l], np.float64]

            --- state vector on local analysis domain

        * **dim_p** : int

            --- pe-local full state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local full state vector



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_put_state_nonlin_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__init_dim_obs_pdaf : Callable[[int, 
                                                                     int], int],
                                   py__obs_op_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__likelihood_pdaf : Callable[[int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   float], float],
                                   py__prepoststep_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]]]
                                  ) -> int:
    r"""Global nonlinear filters for a single DA step
    using non-diagnoal observation error covariance matrix
    without post-processing, distributing analysis,
    and setting next observation step.

    See :func:`pyPDAF.PDAF.omi_put_state_global_nondiagR`
    for simpler user-supplied functions
    using diagonal observation error covariance matrix.

    Here, this function call is used for global NETF [1]_,
    and particle filter [2]_.
    The filter type is set in :func:`pyPDAF.PDAF.init`.

    Compared to
    :func:`pyPDAF.PDAF.omi_assimilate_nonlin_nondiagR`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    This function should be called at each model time step. 

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf (for ensemble mean)
        5. py__obs_op_pdaf (for each ensemble member)
        6. py__likelihood_pdaf
        7. core DA algorithm

    References
    ----------
    .. [1] Tdter, J., and B. Ahrens, 2015:
           A second-order exact ensemble square root filter
           for nonlinear data assimilation. Mon. Wea. Rev.,
           143, 13471367, doi:10.1175/MWR-D-14-00108.1.
    .. [2] Van Leeuwen, P. J., Knsch, H. R., Nerger, L.,
           Potthast, R., & Reich, S. (2019).
           Particle filters for highdimensional geoscience applications:
           A review.
           Quarterly Journal of the Royal Meteorological Society,
           145(723), 2335-2365.

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__likelihood_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], resid:ndarray[tuple[dim_obs_p], np.float64], likely:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **resid** : ndarray[tuple[dim_obs_p], np.float64]

            --- Input vector holding the residual

        * **likely** : float

            --- Output value of the likelihood

        **Callback Returns**

        * **likely**:float

            --- Output value of the likelihood


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_set_indices (map: np.ndarray[tuple[int], np.dtype[np.intc]]) -> None:
    r"""Set index vector to map local state vector to global state vectors. This is called in the user-supplied function `py__init_dim_l_pdaf`.

    Parameters
    ----------
    map : ndarray[tuple[dim_l], np.intc]
        Index array for mapping between local and global state vector
        The array dimension `dim_l` is Dimension of local state vector
    """
    ...

def local_set_increment_weights (weights: np.ndarray[tuple[int], np.dtype[np.float64]]
                                ) -> None:
    r"""This function initialises a PDAF_internal local array of increment weights. The weights are applied in in PDAF_local_l2g_cb where the local state vector
    is weighted by given weights. These can e.g. be used to apply a vertical localisation.

    Parameters
    ----------
    weights : ndarray[tuple[dim_l], np.float64]
        Weights array
        The array dimension `dim_l` is Dimension of local state vector
    """
    ...

def local_clear_increment_weights () -> None:
    r"""This function deallocates the local increment weight vector in `pyPDAF.PDAF.local_set_increment_weights` if it is allocated

    """
    ...

def local_g2l_cb (step: int,domain_p: int,dim_p: int,state_p: np.ndarray[tuple[int], np.dtype[np.float64]],
                  dim_l: int,state_l: np.ndarray[tuple[int], np.dtype[np.float64]]
                 ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    r"""Project a global to a local state vector for the localized filters.
    This is the full callback function to be used internally. The mapping is done using the index vector id_lstate_in_pstate that is initialised in `pyPDAF.PDAF.local_set_indices`.

    Parameters
    ----------
    step : int
        Current time step
    domain_p : int
        Current local analysis domain
    dim_p : int
        PE-local full state dimension
    state_p : ndarray[tuple[dim_p], np.float64]
        PE-local full state vector
        The array dimension `dim_p` is PE-local full state dimension
    dim_l : int
        Local state dimension
    state_l : ndarray[tuple[dim_l], np.float64]
        State vector on local analysis domain
        The array dimension `dim_l` is Local state dimension

    Returns
    -------
    state_l : ndarray[tuple[dim_l], np.float64]
         State vector on local analysis domain

        The array dimension `dim_l` is Local state dimension
    """
    ...

def local_l2g_cb (step: int,domain_p: int,dim_l: int,state_l: np.ndarray[tuple[int], np.dtype[np.float64]],
                  dim_p: int,state_p: np.ndarray[tuple[int], np.dtype[np.float64]]
                 ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    r"""Initialise elements of a global state vector from a local state vector.
    This is the full callback function to be used internally. The mapping is done using the index vector `id_lstate_in_pstate` that is initialised in `pyPDAF.PDAF.local_set_indices`. 
    
    To exclude any element of the local state vector from the initialisationone can set the corresponding index value to 0.

    Parameters
    ----------
    step : int
        Current time step
    domain_p : int
        Current local analysis domain
    dim_l : int
        Local state dimension
    state_l : ndarray[tuple[dim_l], np.float64]
        State vector on local analysis domain
        The array dimension `dim_l` is Local state dimension
    dim_p : int
        PE-local full state dimension
    state_p : ndarray[tuple[dim_p], np.float64]
        PE-local full state vector
        The array dimension `dim_p` is PE-local full state dimension

    Returns
    -------
    state_p : ndarray[tuple[dim_p], np.float64]
         PE-local full state vector

        The array dimension `dim_p` is PE-local full state dimension
    """
    ...

def localomi_assimilate (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                         py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                         py__init_dim_obs_pdaf : Callable[[int, int], int],
                         py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                         py__prepoststep_pdaf : Callable[[int, int, int, 
                                                          int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                         py__init_n_domains_p_pdaf : Callable[[int, int], int],
                         py__init_dim_l_pdaf : Callable[[int, int, int], int],
                         py__init_dim_obs_l_pdaf : Callable[[int, int, 
                                                             int, int], int],
                         py__next_observation_pdaf : Callable[[int, int, 
                                                               int, float], tuple[int, 
                                                               int, float]],
                         outflag: int) -> int:
    r"""Domain local filters for a single DA step
    using diagnoal observation error covariance matrix.

    Here, this function call is used for LE(S)TKF [1]_,
    LSEIK [1]_, LNETF [2]_, and LKNETF [3]_.
    The filter type is set in :func:`pyPDAF.PDAF.init`.
    This function should be called at each model time step.
    The function is a combination of
    :func:`pyPDAF.PDAF.localomi_put_state_local`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. core DA algorithm
        7. py__prepoststep_state_pdaf
        8. py__distribute_state_pdaf
        9. py__next_observation_pdaf

    References
    ----------
    .. [1] Nerger, L., Janji, T., Schrter, J., Hiller, W. (2012). 
           A unification of ensemble square root Kalman filters. 
           Monthly Weather Review, 140, 2335-2345.
           doi:10.1175/MWR-D-11-00102.1
    .. [2] Tdter, J., and B. Ahrens, 2015:
           A second-order exact ensemble square root filter
           for nonlinear data assimilation. Mon. Wea. Rev.,
           143, 13471367, doi:10.1175/MWR-D-14-00108.1.
    .. [3] Nerger, L.. (2022) 
           Data assimilation for nonlinear systems with
           a hybrid nonlinear Kalman ensemble transform filter. 
           Q J R Meteorol Soc, 620640. doi:10.1002/qj.4221

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_assimilate_en3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__distribute_state_pdaf : Callable[[int, 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__init_dim_obs_pdaf : Callable[[int, 
                                                                          int], int],
                                        py__obs_op_f_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__cvt_ens_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__obs_op_lin_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__obs_op_adj_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__init_n_domains_p_pdaf : Callable[[int, 
                                                                              int], int],
                                        py__init_dim_l_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int], int],
                                        py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            int], int],
                                        py__prepoststep_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                        py__next_observation_pdaf : Callable[[int, 
                                                                              int, 
                                                                              int, 
                                                                              float], tuple[int, 
                                                                              int, 
                                                                              float]],
                                        outflag: int) -> int:
    r"""3DEnVar for a single DA step where the ensemble anomaly
    is generated by LESTKF using diagnoal observation
    error covariance matrix.

    The background error covariance matrix is estimated by ensemble.
    The 3DEnVar only calculates the analysis of the ensemble mean.
    An LESTKF is used to generate ensemble perturbations.
    This function should be called at each model time step.

    The function is a combination of
    :func:`pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. Starting the iterative optimisation:
            1. py__cvt_ens_pdaf
            2. py__obs_op_lin_pdaf
            3. py__obs_op_adj_pdaf
            4. py__cvt_adj_ens_pdaf
            5. core DA algorithm
        6. py__cvt_ens_pdaf
        7. Perform LESTKF:
            1. py__init_n_domains_p_pdaf
            2. py__init_dim_obs_pdaf
            3. py__obs_op_pdaf
               (for each ensemble member)
            4. loop over each local domain:
                1. py__init_dim_l_pdaf
                2. py__init_dim_obs_l_pdaf
                3. core DA algorithm
        8. py__prepoststep_state_pdaf
        9. py__distribute_state_pdaf
        10. py__next_observation_pdaf

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_assimilate_en3dvar_lestkf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__distribute_state_pdaf : Callable[[int, 
                                                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__init_dim_obs_pdaf : Callable[[int, 
                                                                                   int], int],
                                                 py__obs_op_pdaf : Callable[[int, 
                                                                             int, 
                                                                             int, 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__prodRinvA_pdaf : Callable[[int, 
                                                                                int, 
                                                                                int, 
                                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                                 py__cvt_ens_pdaf : Callable[[int, 
                                                                              int, 
                                                                              int, 
                                                                              int, 
                                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__obs_op_lin_pdaf : Callable[[int, 
                                                                                 int, 
                                                                                 int, 
                                                                                 np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__obs_op_adj_pdaf : Callable[[int, 
                                                                                 int, 
                                                                                 int, 
                                                                                 np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__prodRinvA_l_pdaf : Callable[[int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                                 py__init_n_domains_p_pdaf : Callable[[int, 
                                                                                       int], int],
                                                 py__init_dim_l_pdaf : Callable[[int, 
                                                                                 int, 
                                                                                 int], int],
                                                 py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                                     int, 
                                                                                     int, 
                                                                                     int], int],
                                                 py__prepoststep_pdaf : Callable[[int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                  int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                                 py__next_observation_pdaf : Callable[[int, 
                                                                                       int, 
                                                                                       int, 
                                                                                       float], tuple[int, 
                                                                                       int, 
                                                                                       float]],
                                                 outflag: int) -> int:
    r"""3DEnVar for a single DA step where the ensemble anomaly
    is generated by LESTKF using
    non-diagnoal observation error covariance matrix.

    Here, the background error covariance matrix is
    estimated by ensemble.
    The 3DEnVar only calculates the analysis of the ensemble mean.
    An LESTKF is used to generate ensemble perturbations.
    This function should be called at each model time step.

    The function is a combination of
    :func:`pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf_nondiagR`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. Starting the iterative optimisation:
            1. py__cvt_ens_pdaf
            2. py__obs_op_lin_pdaf
            3. py__prodRinvA_pdaf
            4. py__obs_op_adj_pdaf
            5. py__cvt_adj_ens_pdaf
            6. core DA algorithm
        6. py__cvt_ens_pdaf
        7. Perform LESTKF:
            1. py__init_n_domains_p_pdaf
            2. py__init_dim_obs_pdaf
            3. py__obs_op_pdaf
               (for each ensemble member)
            4. loop over each local domain:
                1. py__init_dim_l_pdaf
                2. py__init_dim_obs_l_pdaf
                3. py__prodRinvA_l_pdaf
                4. core DA algorithm
        8. py__prepoststep_state_pdaf
        9. py__distribute_state_pdaf
        10. py__next_observation_pdaf

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one
                (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A with localization

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_assimilate_hyb3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                         py__distribute_state_pdaf : Callable[[int, 
                                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                         py__init_dim_obs_pdaf : Callable[[int, 
                                                                           int], int],
                                         py__obs_op_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                         py__cvt_ens_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                         py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          int, 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                         py__cvt_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                         py__cvt_adj_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                         py__obs_op_lin_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                         py__obs_op_adj_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                         py__init_n_domains_p_pdaf : Callable[[int, 
                                                                               int], int],
                                         py__init_dim_l_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int], int],
                                         py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                             int, 
                                                                             int, 
                                                                             int], int],
                                         py__prepoststep_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          int, 
                                                                          int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                          int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                         py__next_observation_pdaf : Callable[[int, 
                                                                               int, 
                                                                               int, 
                                                                               float], tuple[int, 
                                                                               int, 
                                                                               float]],
                                         outflag: int) -> int:
    r"""Hybrid 3DEnVar for a single DA step
    using diagnoal observation error covariance matrix.

    Here, the background error covariance is hybridised by
    a static background error covariance,
    and a flow-dependent background error covariance
    estimated from ensemble.
    The 3DVar generates an ensemble mean and
    the ensemble perturbation is generated by
    LESTKF in this implementation.
    This function should be called at each model time step.

    The function is a combination of
    :func:`pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. The iterative optimisation:
            1. py__cvt_pdaf
            2. py__cvt_ens_pdaf
            3. py__obs_op_lin_pdaf
            4. py__obs_op_adj_pdaf
            5. py__cvt_adj_pdaf
            6. py__cvt_adj_ens_pdaf
            7. core DA algorithm
        6. py__cvt_pdaf
        7. py__cvt_ens_pdaf
        8. Perform LESTKF:
            1. py__init_n_domains_p_pdaf
            2. py__init_dim_obs_pdaf
            3. py__obs_op_pdaf
               (for each ensemble member)
            4. loop over each local domain:
                1. py__init_dim_l_pdaf
                2. py__init_dim_obs_l_pdaf
                3. core DA algorithm
        9. py__prepoststep_state_pdaf
        10. py__distribute_state_pdaf
        11. py__next_observation_pdaf

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_assimilate_hyb3dvar_lestkf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                  py__distribute_state_pdaf : Callable[[int, 
                                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                  py__init_dim_obs_pdaf : Callable[[int, 
                                                                                    int], int],
                                                  py__obs_op_pdaf : Callable[[int, 
                                                                              int, 
                                                                              int, 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                  py__prodRinvA_pdaf : Callable[[int, 
                                                                                 int, 
                                                                                 int, 
                                                                                 np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                                  py__cvt_ens_pdaf : Callable[[int, 
                                                                               int, 
                                                                               int, 
                                                                               int, 
                                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                  py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                                   int, 
                                                                                   int, 
                                                                                   int, 
                                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                  py__cvt_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                  py__cvt_adj_pdaf : Callable[[int, 
                                                                               int, 
                                                                               int, 
                                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                  py__obs_op_lin_pdaf : Callable[[int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                  py__obs_op_adj_pdaf : Callable[[int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                  py__prodRinvA_l_pdaf : Callable[[int, 
                                                                                   int, 
                                                                                   int, 
                                                                                   int, 
                                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                                  py__init_n_domains_p_pdaf : Callable[[int, 
                                                                                        int], int],
                                                  py__init_dim_l_pdaf : Callable[[int, 
                                                                                  int, 
                                                                                  int], int],
                                                  py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                                      int, 
                                                                                      int, 
                                                                                      int], int],
                                                  py__prepoststep_pdaf : Callable[[int, 
                                                                                   int, 
                                                                                   int, 
                                                                                   int, 
                                                                                   int, 
                                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                   int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                                  py__next_observation_pdaf : Callable[[int, 
                                                                                        int, 
                                                                                        int, 
                                                                                        float], tuple[int, 
                                                                                        int, 
                                                                                        float]],
                                                  outflag: int) -> int:
    r"""Hybrid 3DEnVar for a single DA step
    using diagnoal observation error covariance matrix.

    Here, the background error covariance is
    hybridised by a static background error covariance,
    and a flow-dependent background error covariance
    estimated from ensemble.
    The 3DVar generates an ensemble mean and
    the ensemble perturbation is generated by
    LESTKF in this implementation.
    This function should be called at each model time step.

    The function is a combination of
    :func:`pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf_nondiagR`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. The iterative optimisation:
            1. py__cvt_pdaf
            2. py__cvt_ens_pdaf
            3. py__obs_op_lin_pdaf
            4. py__prodRinvA_pdaf
            5. py__obs_op_adj_pdaf
            6. py__cvt_adj_pdaf
            7. py__cvt_adj_ens_pdaf
            8. core DA algorithm
        6. py__cvt_pdaf
        7. py__cvt_ens_pdaf
        8. Perform LESTKF:
            1. py__init_n_domains_p_pdaf
            2. py__init_dim_obs_pdaf
            3. py__obs_op_pdaf
               (for each ensemble member)
            4. loop over each local domain:
                1. py__init_dim_l_pdaf
                2. py__init_dim_obs_l_pdaf
                3. py__prodRinvA_l_pdaf
                4. core DA algorithm
        9. py__prepoststep_state_pdaf
        10. py__distribute_state_pdaf
        11. py__next_observation_pdaf

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one
                (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_assimilate_lknetf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                         py__distribute_state_pdaf : Callable[[int, 
                                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                         py__init_dim_obs_pdaf : Callable[[int, 
                                                                           int], int],
                                         py__obs_op_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                         py__prepoststep_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          int, 
                                                                          int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                          int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                         py__init_n_domains_p_pdaf : Callable[[int, 
                                                                               int], int],
                                         py__init_dim_l_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int], int],
                                         py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                             int, 
                                                                             int, 
                                                                             int], int],
                                         py__prodRinvA_l_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                         py__prodRinvA_hyb_l_pdaf : Callable[[int, 
                                                                              int, 
                                                                              int, 
                                                                              int, 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                              float, 
                                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                         py__likelihood_l_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                           float], float],
                                         py__likelihood_hyb_l_pdaf : Callable[[int, 
                                                                               int, 
                                                                               int, 
                                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                               float, 
                                                                               float], float],
                                         py__next_observation_pdaf : Callable[[int, 
                                                                               int, 
                                                                               int, 
                                                                               float], tuple[int, 
                                                                               int, 
                                                                               float]],
                                         outflag: int) -> int:
    r"""LKNETF for a single DA step using
    non-diagnoal observation error covariance matrix.

    See :func:`pyPDAF.PDAF.localomi_assimilate` for
    using diagnoal observation error covariance matrix.
    The non-linear filter is proposed in [1]_.
    The filter type is set in :func:`pyPDAF.PDAF.init`.
    This function should be called at each model time step.
    The function is a combination of
    :func:`pyPDAF.PDAF.localomi_put_state_lknetf_nondiagR`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. py__prodRinvA_pdaf
            4. py__likelihood_l_pdaf
            5. core DA algorithm
            6. py__obs_op_pdaf
               (only called with `HKN` and `HNK` options
               called for each ensemble member)
            7. py__likelihood_hyb_l_pda
            8. py__prodRinvA_hyb_l_pdaf
        7. py__prepoststep_state_pdaf
        8. py__distribute_state_pdaf
        9. py__next_observation_pdaf

    References
    ----------
    .. [1] Nerger, L.. (2022) 
           Data assimilation for nonlinear systems with
           a hybrid nonlinear Kalman ensemble transform filter. 
           Q J R Meteorol Soc, 620640. doi:10.1002/qj.4221

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__prodRinvA_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, dim_ens:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, A_l:ndarray[tuple[dim_obs_l, dim_ens], np.float64], C_l:ndarray[tuple[dim_obs_l, dim_ens], np.float64]]
        Product R^-1 A on local analysis domain with hybrid weight

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **dim_ens** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **gamma** : float

            --- Hybrid weight provided by PDAF

        * **A_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Output matrix


    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute likelihood and apply localization

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- nput vector holding the local residual

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    py__likelihood_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, likely_l:float]
        Compute likelihood and apply localization with tempering

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Input vector holding the local residual

        * **gamma** : float

            --- Hybrid weight provided by PDAF

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_assimilate_lnetf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__distribute_state_pdaf : Callable[[int, 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__init_dim_obs_pdaf : Callable[[int, 
                                                                          int], int],
                                        py__obs_op_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__prepoststep_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                        py__init_n_domains_p_pdaf : Callable[[int, 
                                                                              int], int],
                                        py__init_dim_l_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int], int],
                                        py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            int], int],
                                        py__likelihood_l_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          float], float],
                                        py__next_observation_pdaf : Callable[[int, 
                                                                              int, 
                                                                              int, 
                                                                              float], tuple[int, 
                                                                              int, 
                                                                              float]],
                                        outflag: int) -> int:
    r"""LNETF for a single DA step using
    non-diagnoal observation error covariance matrix.

    See :func:`pyPDAF.PDAF.localomi_assimilate` for
    using diagnoal observation error covariance matrix.
    The non-linear filter is proposed in [1]_.
    The filter type is set in :func:`pyPDAF.PDAF.init`.
    This function should be called at each model time step.
    The function is a combination of
    :func:`pyPDAF.PDAF.localomi_put_state_lnetf_nondiagR`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. py__likelihood_l_pdaf
            4. core DA algorithm
        7. py__prepoststep_state_pdaf
        8. py__distribute_state_pdaf
        9. py__next_observation_pdaf

    References
    ----------
    .. [1] Tdter, J., and B. Ahrens, 2015:
           A second-order exact ensemble square root filter
           for nonlinear data assimilation. Mon. Wea. Rev.,
           143, 13471367, doi:10.1175/MWR-D-14-00108.1.

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute likelihood and apply localization

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- nput vector holding the local residual

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_assimilate_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__distribute_state_pdaf : Callable[[int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__init_dim_obs_pdaf : Callable[[int, 
                                                                    int], int],
                                  py__obs_op_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__prepoststep_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                  py__init_n_domains_p_pdaf : Callable[[int, 
                                                                        int], int],
                                  py__init_dim_l_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int], int],
                                  py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      int], int],
                                  py__prodRinvA_l_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                  py__next_observation_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        float], tuple[int, 
                                                                        int, 
                                                                        float]],
                                  outflag: int) -> int:
    r"""Domain local filters for a single DA step
    using non-diagnoal observation error covariance matrix.

    Here, this function call is used for LE(S)TKF [1]_ and LSEIK [1]_
    The filter type is set in :func:`pyPDAF.PDAF.init`.
    This function should be called at each model time step.
    The function is a combination of
    :func:`pyPDAF.PDAF.localomi_put_state_local_nondiagR`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. py__init_obs_l_pdaf
            4. py__prodRinvA_l_pdaf
            5. core DA algorithm
        7. py__prepoststep_state_pdaf
        8. py__distribute_state_pdaf
        9. py__next_observation_pdaf

    References
    ----------
    .. [1] Nerger, L., Janji, T., Schrter, J., Hiller, W. (2012). 
           A unification of ensemble square root Kalman filters. 
           Monthly Weather Review, 140, 2335-2345.
           doi:10.1175/MWR-D-11-00102.1

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product of inverse of R with matrix A

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_put_state (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                        py__init_dim_obs_pdaf : Callable[[int, int], int],
                        py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                        py__prepoststep_pdaf : Callable[[int, int, int, 
                                                         int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                         int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                        py__init_n_domains_p_pdaf : Callable[[int, int], int],
                        py__init_dim_l_pdaf : Callable[[int, int, int], int],
                        py__init_dim_obs_l_pdaf : Callable[[int, int, int, 
                                                            int], int],
                        outflag: int) -> int:
    r"""Domain local filters for a single DA step
    using diagnoal observation error covariance matrix
    without post-processing, distributing analysis,
    and setting next observation step.

    Here, this function call is used for LE(S)TKF [1]_, 
    LSEIK [1]_, LNETF [2]_, and LKNETF [3]_.
    The filter type is set in :func:`pyPDAF.PDAF.init`.
    Compared to :func:`pyPDAF.PDAF.localomi_assimilate_local`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    The LESTKF is a more efficient equivalent to the LETKF.

    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. core DA algorithm

    References
    ----------
    .. [1] Nerger, L., Janji, T., Schrter, J., Hiller, W. (2012). 
           A unification of ensemble square root Kalman filters. 
           Monthly Weather Review, 140, 2335-2345.
           doi:10.1175/MWR-D-11-00102.1
    .. [2] Tdter, J., and B. Ahrens, 2015:
           A second-order exact ensemble square root filter
           for nonlinear data assimilation. Mon. Wea. Rev.,
           143, 13471367, doi:10.1175/MWR-D-14-00108.1.
    .. [3] Nerger, L.. (2022) 
           Data assimilation for nonlinear systems with
           a hybrid nonlinear Kalman ensemble transform filter. 
           Q J R Meteorol Soc, 620640. doi:10.1002/qj.4221

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_put_state_en3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                       py__init_dim_obs_pdaf : Callable[[int, 
                                                                         int], int],
                                       py__obs_op_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                       py__cvt_ens_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                       py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        int, 
                                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                       py__obs_op_lin_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int, 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                       py__obs_op_adj_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int, 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                       py__init_n_domains_p_pdaf : Callable[[int, 
                                                                             int], int],
                                       py__init_dim_l_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int], int],
                                       py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           int], int],
                                       py__prepoststep_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        int, 
                                                                        int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                        int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                       outflag: int) -> int:
    r"""3DEnVar for a single DA step where
    the ensemble anomaly is generated by LESTKF
    using diagnoal observation error covariance matrix
    without post-processing, distributing analysis,
    and setting next observation step.

    Compared to
    :func:`pyPDAF.PDAF.localomi_assimilate_en3dvar_lestkf`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    The background error covariance matrix is estimated by ensemble.
    The 3DEnVar only calculates the analysis of the ensemble mean.
    An LESTKF is used to generate ensemble perturbations.
    This function should be called at each model time step.

    User-supplied function are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. Starting the iterative optimisation:
            1. py__cvt_ens_pdaf
            2. py__obs_op_lin_pdaf
            3. py__obs_op_adj_pdaf
            4. py__cvt_adj_ens_pdaf
            5. core DA algorithm
        6. py__cvt_ens_pdaf
        7. Perform LESTKF:
            1. py__init_n_domains_p_pdaf
            2. py__init_dim_obs_pdaf
            3. py__obs_op_pdaf
               (for each ensemble member)
            4. loop over each local domain:
                1. py__init_dim_l_pdaf
                2. py__init_dim_obs_l_pdaf
                3. core DA algorithm

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_put_state_en3dvar_lestkf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                py__init_dim_obs_pdaf : Callable[[int, 
                                                                                  int], int],
                                                py__obs_op_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                py__prodRinvA_pdaf : Callable[[int, 
                                                                               int, 
                                                                               int, 
                                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                                py__cvt_ens_pdaf : Callable[[int, 
                                                                             int, 
                                                                             int, 
                                                                             int, 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                                 int, 
                                                                                 int, 
                                                                                 int, 
                                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                 np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                py__obs_op_lin_pdaf : Callable[[int, 
                                                                                int, 
                                                                                int, 
                                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                py__obs_op_adj_pdaf : Callable[[int, 
                                                                                int, 
                                                                                int, 
                                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                py__prodRinvA_l_pdaf : Callable[[int, 
                                                                                 int, 
                                                                                 int, 
                                                                                 int, 
                                                                                 np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                                py__init_n_domains_p_pdaf : Callable[[int, 
                                                                                      int], int],
                                                py__init_dim_l_pdaf : Callable[[int, 
                                                                                int, 
                                                                                int], int],
                                                py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                                    int, 
                                                                                    int, 
                                                                                    int], int],
                                                py__prepoststep_pdaf : Callable[[int, 
                                                                                 int, 
                                                                                 int, 
                                                                                 int, 
                                                                                 int, 
                                                                                 np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                 int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                                outflag: int) -> int:
    r"""3DEnVar for a single DA step without post-processing,
    distributing analysis, and setting next observation step.

    Here, the ensemble anomaly is generated by LESTKF
    using non-diagnoal observation error covariance matrix.

    Compared to
    :func:`pyPDAF.PDAF.localomi_assimilate_en3dvar_lestkf_nondiagR`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    The background error covariance matrix is
    estimated by ensemble.
    The 3DEnVar only calculates the analysis of the ensemble mean.
    An LESTKF is used to generate ensemble perturbations.
    This function should be called at each model time step.

    User-supplied function are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. Starting the iterative optimisation:
            1. py__cvt_ens_pdaf
            2. py__obs_op_lin_pdaf
            3. py__prodRinvA_pdaf
            4. py__obs_op_adj_pdaf
            5. py__cvt_adj_ens_pdaf
            6. core DA algorithm
        6. py__cvt_ens_pdaf
        7. Perform LESTKF:
            1. py__init_n_domains_p_pdaf
            2. py__init_dim_obs_pdaf
            3. py__obs_op_pdaf
               (for each ensemble member)
            4. loop over each local domain:
                1. py__init_dim_l_pdaf
                2. py__init_dim_obs_l_pdaf
                3. py__prodRinvA_l_pdaf
                4. core DA algorithm

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one
                (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_put_state_hyb3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__init_dim_obs_pdaf : Callable[[int, 
                                                                          int], int],
                                        py__obs_op_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__cvt_ens_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__cvt_pdaf : Callable[[int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__cvt_adj_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__obs_op_lin_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__obs_op_adj_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__init_n_domains_p_pdaf : Callable[[int, 
                                                                              int], int],
                                        py__init_dim_l_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int], int],
                                        py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            int], int],
                                        py__prepoststep_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                        outflag: int) -> int:
    r"""Hybrid 3DEnVar for a single DA step
    using diagnoal observation error covariance matrix
    without post-processing, distributing analysis,
    and setting next observation step.

    Here, the background error covariance is
    hybridised by a static background error covariance,
    and a flow-dependent background error covariance
    estimated from ensemble.

    Compared to
    :func:`pyPDAF.PDAF.localomi_assimilate_hyb3dvar_lestkf`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    The 3DVar generates an ensemble mean and
    the ensemble perturbation is generated by
    LESTKF in this implementation.
    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. The iterative optimisation:
            1. py__cvt_pdaf
            2. py__cvt_ens_pdaf
            3. py__obs_op_lin_pdaf
            4. py__obs_op_adj_pdaf
            5. py__cvt_adj_pdaf
            6. py__cvt_adj_ens_pdaf
            7. core DA algorithm
        6. py__cvt_pdaf
        7. py__cvt_ens_pdaf
        8. Perform LESTKF:
            1. py__init_n_domains_p_pdaf
            2. py__init_dim_obs_pdaf
            3. py__obs_op_pdaf
               (for each ensemble member)
            4. loop over each local domain:
                1. py__init_dim_l_pdaf
                2. py__init_dim_obs_l_pdaf
                3. core DA algorithm

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_put_state_hyb3dvar_lestkf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__init_dim_obs_pdaf : Callable[[int, 
                                                                                   int], int],
                                                 py__obs_op_pdaf : Callable[[int, 
                                                                             int, 
                                                                             int, 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__prodRinvA_pdaf : Callable[[int, 
                                                                                int, 
                                                                                int, 
                                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                                 py__cvt_ens_pdaf : Callable[[int, 
                                                                              int, 
                                                                              int, 
                                                                              int, 
                                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__cvt_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__cvt_adj_pdaf : Callable[[int, 
                                                                              int, 
                                                                              int, 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__obs_op_lin_pdaf : Callable[[int, 
                                                                                 int, 
                                                                                 int, 
                                                                                 np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__obs_op_adj_pdaf : Callable[[int, 
                                                                                 int, 
                                                                                 int, 
                                                                                 np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__prodRinvA_l_pdaf : Callable[[int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                                 py__init_n_domains_p_pdaf : Callable[[int, 
                                                                                       int], int],
                                                 py__init_dim_l_pdaf : Callable[[int, 
                                                                                 int, 
                                                                                 int], int],
                                                 py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                                     int, 
                                                                                     int, 
                                                                                     int], int],
                                                 py__prepoststep_pdaf : Callable[[int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                  int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                                 outflag: int) -> int:
    r"""Hybrid 3DEnVar for a single DA step
    using non-diagnoal observation error covariance matrix
    without post-processing, distributing analysis,
    and setting next observation step.

    Here, the background error covariance is
    hybridised by a static background error covariance,
    and a flow-dependent background error covariance
    estimated from ensemble.

    Compared to
    :func:`pyPDAF.PDAF.localomi_assimilate_hyb3dvar_lestkf_nondiagR`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    The 3DVar generates an ensemble mean and
    the ensemble perturbation is generated by
    LESTKF in this implementation.
    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. The iterative optimisation:
            1. py__cvt_pdaf
            2. py__cvt_ens_pdaf
            3. py__obs_op_lin_pdaf
            4. py__prodRinvA_pdaf
            5. py__obs_op_adj_pdaf
            6. py__cvt_adj_pdaf
            7. py__cvt_adj_ens_pdaf
            8. core DA algorithm
        6. py__cvt_pdaf
        7. py__cvt_ens_pdaf
        8. Perform LESTKF:
            1. py__init_n_domains_p_pdaf
            2. py__init_dim_obs_pdaf
            3. py__obs_op_pdaf
               (for each ensemble member)
            4. loop over each local domain:
                1. py__init_dim_l_pdaf
                2. py__init_dim_obs_l_pdaf
                3. py__prodRinvA_l_pdaf
                4. core DA algorithm

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one
                (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_put_state_lknetf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__init_dim_obs_pdaf : Callable[[int, 
                                                                          int], int],
                                        py__obs_op_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__prepoststep_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                        py__init_n_domains_p_pdaf : Callable[[int, 
                                                                              int], int],
                                        py__init_dim_l_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int], int],
                                        py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            int], int],
                                        py__prodRinvA_l_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                        py__prodRinvA_hyb_l_pdaf : Callable[[int, 
                                                                             int, 
                                                                             int, 
                                                                             int, 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                             float, 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                        py__likelihood_l_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          float], float],
                                        py__likelihood_hyb_l_pdaf : Callable[[int, 
                                                                              int, 
                                                                              int, 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                              float, 
                                                                              float], float],
                                        outflag: int) -> int:
    r"""LKNETF for a single DA step
    using non-diagnoal observation error covariance matrix
    without post-processing, distributing analysis,
    and setting next observation step.

    See :func:`pyPDAF.PDAF.localomi_assimilate`
    for using diagnoal observation error covariance matrix.
    The non-linear filter is proposed in [1]_.
    The filter type is set in :func:`pyPDAF.PDAF.init`.

    Compared to
    :func:`pyPDAF.PDAF.localomi_assimilate_lknetf_nondiagR`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. py__prodRinvA_pdaf
            4. py__likelihood_l_pdaf
            5. core DA algorithm
            6. py__obs_op_pdaf
               (only called with `HKN` and `HNK` options
               called for each ensemble member)
            7. py__likelihood_hyb_l_pda
            8. py__prodRinvA_hyb_l_pdaf

    References
    ----------
    .. [1] Nerger, L.. (2022) 
           Data assimilation for nonlinear systems with
           a hybrid nonlinear Kalman ensemble transform filter.
           Q J R Meteorol Soc, 620640. doi:10.1002/qj.4221

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__prodRinvA_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, dim_ens:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, A_l:ndarray[tuple[dim_obs_l, dim_ens], np.float64], C_l:ndarray[tuple[dim_obs_l, dim_ens], np.float64]]
        Product R^-1 A on local analysis domain with hybrid weight

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **dim_ens** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **gamma** : float

            --- Hybrid weight provided by PDAF

        * **A_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Output matrix


    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute likelihood and apply localization

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- nput vector holding the local residual

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    py__likelihood_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, likely_l:float]
        Compute likelihood and apply localization with tempering

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Input vector holding the local residual

        * **gamma** : float

            --- Hybrid weight provided by PDAF

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_put_state_lnetf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                       py__init_dim_obs_pdaf : Callable[[int, 
                                                                         int], int],
                                       py__obs_op_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                       py__prepoststep_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        int, 
                                                                        int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                        int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                       py__init_n_domains_p_pdaf : Callable[[int, 
                                                                             int], int],
                                       py__init_dim_l_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int], int],
                                       py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           int], int],
                                       py__likelihood_l_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         float], float],
                                       outflag: int) -> int:
    r"""LNETF for a single DA step
    using non-diagnoal observation error covariance matrix
    without post-processing, distributing analysis,
    and setting next observation step.

    See :func:`pyPDAF.PDAF.localomi_put_state`
    for using diagnoal observation error covariance matrix.
    The non-linear filter is proposed in [1]_.
    The filter type is set in :func:`pyPDAF.PDAF.init`.

    Compared to
    :func:`pyPDAF.PDAF.omi_assimilate_lnetf_nondiagR`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. py__likelihood_l_pdaf
            4. core DA algorithm
    
    References
    ----------
    .. [1] Tdter, J., and B. Ahrens, 2015:
           A second-order exact ensemble square root filter
           for nonlinear data assimilation. Mon. Wea. Rev.,
           143, 13471367, doi:10.1175/MWR-D-14-00108.1.

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute likelihood and apply localization

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- nput vector holding the local residual

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_put_state_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                 py__init_dim_obs_pdaf : Callable[[int, 
                                                                   int], int],
                                 py__obs_op_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                 py__prepoststep_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                  int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                 py__init_n_domains_p_pdaf : Callable[[int, 
                                                                       int], int],
                                 py__init_dim_l_pdaf : Callable[[int, int, 
                                                                 int], int],
                                 py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     int], int],
                                 py__prodRinvA_l_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                 outflag: int) -> int:
    r"""Domain local filters for a single DA step
    using non-diagnoal observation error covariance matrix
    without post-processing, distributing analysis,
    and setting next observation step.

    Here, this function call is used for LE(S)TKF [1]_ and LSEIK [1]_
    The filter type is set in :func:`pyPDAF.PDAF.init`.

    Compared to
    :func:`pyPDAF.PDAF.localomi_assimilate_local_nondiagR`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. py__init_obs_l_pdaf
            4. py__prodRinvA_l_pdaf
            5. core DA algorithm
    
    References
    ----------
    .. [1] Nerger, L., Janji, T., Schrter, J., Hiller, W. (2012). 
           A unification of ensemble square root Kalman filters. 
           Monthly Weather Review, 140, 2335-2345.
           doi:10.1175/MWR-D-11-00102.1

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product of inverse of R with matrix A

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_assimilate_en3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__distribute_state_pdaf : Callable[[int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__init_dim_obs_pdaf : Callable[[int, 
                                                                       int], int],
                                     py__obs_op_pdaf : Callable[[int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__init_obs_pdaf : Callable[[int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__prodRinvA_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                     py__cvt_ens_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__obs_op_lin_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__obs_op_adj_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__init_dim_obs_f_pdaf : Callable[[int, 
                                                                         int], int],
                                     py__obs_op_f_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__init_obs_f_pdaf : Callable[[int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__init_obs_l_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__prodRinvA_l_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                     py__init_n_domains_p_pdaf : Callable[[int, 
                                                                           int], int],
                                     py__init_dim_l_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int], int],
                                     py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         int], int],
                                     py__g2l_obs_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                                  int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                                     py__init_obsvar_pdaf : Callable[[int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      float], float],
                                     py__init_obsvar_l_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        int, 
                                                                        float], float],
                                     py__prepoststep_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                      int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                     py__next_observation_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           float], tuple[int, 
                                                                           int, 
                                                                           float]]
                                    ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.localomi_assimilate_en3dvar_lestkf`
    or :func:`pyPDAF.PDAF.localomi_assimilate_en3dvar_lestkf_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions
    and improved efficiency.

    3DEnVar for a single DA step where the ensemble anomaly
    is generated by LESTKF.
    The background error covariance matrix is estimated by ensemble.
    The 3DEnVar only calculates the analysis of the ensemble mean.
    An LESTKF is used to generate ensemble perturbations.
    This function should be called at each model time step.

    The function is a combination of
    :func:`pyPDAF.PDAF.local_put_state_en3dvar_lestkf`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. py__init_obs_pdaf
        6. Starting the iterative optimisation:
            1. py__cvt_ens_pdaf
            2. py__obs_op_lin_pdaf
            3. py__prodRinvA_pdaf
            4. py__obs_op_adj_pdaf
            5. py__cvt_adj_ens_pdaf
            6. core DA algorithm
        7. py__cvt_ens_pdaf
        8. Perform LESTKF:
            1. py__init_n_domains_p_pdaf
            2. py__init_dim_obs_pdaf
            3. py__obs_op_pdaf
               (for each ensemble member)
            4. py__init_obs_pdaf
               (if global adaptive forgetting factor is used
               `type_forget=1` in :func:`pyPDAF.PDAF.init`)
            5. py__init_obsvar_pdaf
               (if global adaptive forgetting factor is used)
            6. loop over each local domain:
                1. py__init_dim_l_pdaf
                2. py__init_dim_obs_l_pdaf
                3. py__g2l_obs_pdaf
                   (localise mean ensemble in observation space)
                4. py__init_obs_l_pdaf
                5. py__g2l_obs_pdaf
                   (localise each ensemble member in observation space)
                6. py__init_obsvar_l_pdaf
                   (only called if local adaptive forgetting factor
                   `type_forget=2` is used)
                7. py__prodRinvA_l_pdaf
                8. core DA algorithm
        9. py__prepoststep_state_pdaf
        10. py__distribute_state_pdaf
        11. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_assimilate_en3dvar_lestkf`
       and :func:`pyPDAF.PDAF.localomi_assimilate_en3dvar_lestkf_nondiagR`

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one
                (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f:ndarray[tuple[dim_obs_f], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of the full observation vector

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of observations

        **Callback Returns**

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_assimilate_hyb3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                      py__distribute_state_pdaf : Callable[[int, 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                      py__init_dim_obs_pdaf : Callable[[int, 
                                                                        int], int],
                                      py__obs_op_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                      py__init_obs_pdaf : Callable[[int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                      py__prodRinvA_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                      py__cvt_ens_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                      py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int, 
                                                                       int, 
                                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                      py__cvt_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                      py__cvt_adj_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                      py__obs_op_lin_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                      py__obs_op_adj_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                      py__init_dim_obs_f_pdaf : Callable[[int, 
                                                                          int], int],
                                      py__obs_op_f_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                      py__init_obs_f_pdaf : Callable[[int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                      py__init_obs_l_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                      py__prodRinvA_l_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int, 
                                                                       int, 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                      py__init_n_domains_p_pdaf : Callable[[int, 
                                                                            int], int],
                                      py__init_dim_l_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int], int],
                                      py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          int], int],
                                      py__g2l_obs_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                                   int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                                      py__init_obsvar_pdaf : Callable[[int, 
                                                                       int, 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                       float], float],
                                      py__init_obsvar_l_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         int, 
                                                                         float], float],
                                      py__prepoststep_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int, 
                                                                       int, 
                                                                       int, 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                       int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                      py__next_observation_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            float], tuple[int, 
                                                                            int, 
                                                                            float]]
                                     ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.localomi_assimilate_hyb3dvar_lestkf`
    or :func:`pyPDAF.PDAF.localomi_assimilate_hyb3dvar_lestkf_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions
    and improved efficiency.

    Hybrid 3DEnVar for a single DA step where
    the background error covariance is hybridised by
    a static background error covariance,
    and a flow-dependent background error covariance
    estimated from ensemble.
    The 3DVar generates an ensemble mean and
    the ensemble perturbation is generated by
    LESTKF in this implementation.
    This function should be called at each model time step.

    The function is a combination of
    :func:`pyPDAF.PDAF.local_put_state_hyb3dvar_lestkf`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. py__init_obs_pdaf
        6. The iterative optimisation:
            1. py__cvt_pdaf
            2. py__cvt_ens_pdaf
            3. py__obs_op_lin_pdaf
            4. py__prodRinvA_pdaf
            5. py__obs_op_adj_pdaf
            6. py__cvt_adj_pdaf
            7. py__cvt_adj_ens_pdaf
            8. core DA algorithm
        7. py__cvt_pdaf
        8. py__cvt_ens_pdaf
        9. Perform LESTKF:
            1. py__init_n_domains_p_pdaf
            2. py__init_dim_obs_pdaf
            3. py__obs_op_pdaf
               (for each ensemble member)
            4. py__init_obs_pdaf
               (if global adaptive forgetting factor
               `type_forget=1` in :func:`pyPDAF.PDAF.init`)
            5. py__init_obsvar_pdaf
               (if global adaptive forgetting factor is used)
            6. loop over each local domain:
                1. py__init_dim_l_pdaf
                2. py__init_dim_obs_l_pdaf
                3. py__g2l_obs_pdaf
                   (localise mean ensemble in observation space)
                4. py__init_obs_l_pdaf
                5. py__g2l_obs_pdaf
                   (localise each ensemble member
                   in observation space)
                6. py__init_obsvar_l_pdaf
                   (only called if local adaptive forgetting
                   factor `type_forget=2` is used)
                7. py__prodRinvA_l_pdaf
                8. core DA algorithm
        10. py__prepoststep_state_pdaf
        11. py__distribute_state_pdaf
        12. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_assimilate_hyb3dvar_lestkf`
       and :func:`pyPDAF.PDAF.localomi_assimilate_hyb3dvar_lestkf_nondiagR`

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one
                (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f:ndarray[tuple[dim_obs_f], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of the full observation vector

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of observations

        **Callback Returns**

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_assimilate_lestkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__distribute_state_pdaf : Callable[[int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__init_dim_obs_pdaf : Callable[[int, int], int],
                             py__obs_op_pdaf : Callable[[int, int, int, 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__init_obs_l_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__prepoststep_pdaf : Callable[[int, int, 
                                                              int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                             py__prodRinvA_l_pdaf : Callable[[int, int, 
                                                              int, int, 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                             py__init_n_domains_p_pdaf : Callable[[int, 
                                                                   int], int],
                             py__init_dim_l_pdaf : Callable[[int, int, 
                                                             int], int],
                             py__init_dim_obs_l_pdaf : Callable[[int, int, 
                                                                 int, int], int],
                             py__g2l_obs_pdaf : Callable[[int, int, int, 
                                                          int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                          int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                          int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                             py__init_obsvar_pdaf : Callable[[int, int, 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              float], float],
                             py__init_obsvar_l_pdaf : Callable[[int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                int, float], float],
                             py__next_observation_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   float], tuple[int, 
                                                                   int, 
                                                                   float]]
                            ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.localomi_assimilate`
    or :func:`pyPDAF.PDAF.localomi_assimilate_nondiagR`.

    PDAFlocal-OMI modules require fewer user-supplied
    functions and improved efficiency.

    Local ESTKF (error space transform Kalman filter) [1]_ for a single DA step without OMI.
    The LESTKF is a more efficient equivalent to the LETKF.

    This function should be called at each model time step.
    The function is a combination of
    :func:`pyPDAF.PDAF.local_put_state_lestkf`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. py__init_obs_pdaf
           (if global adaptive forgetting factor
           `type_forget=1` is used
           in :func:`pyPDAF.PDAF.init`)
        7. py__init_obsvar_pdaf (if global adaptive
           forgetting factor is used)
        8. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. py__g2l_obs_pdaf (localise mean ensemble
               in observation space)
            4. py__init_obs_l_pdaf
            5. py__g2l_obs_pdaf
               (localise each ensemble member
               in observation space)
            6. py__init_obsvar_l_pdaf
               (only called if local adaptive forgetting
               factor `type_forget=2` is used)
            7. py__prodRinvA_l_pdaf
            8. core DA algorithm
        9. py__prepoststep_state_pdaf
        10. py__distribute_state_pdaf
        11. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_assimilate`
       and :func:`pyPDAF.PDAF.localomi_assimilate_nondiagR`

    References
    ----------
    .. [1] Nerger, L., Janji, T., Schrter, J., Hiller, W. (2012). 
           A unification of ensemble square root Kalman filters. 
           Monthly Weather Review, 140, 2335-2345. doi:10.1175/MWR-D-11-00102.1

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_assimilate_letkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__distribute_state_pdaf : Callable[[int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_dim_obs_pdaf : Callable[[int, int], int],
                            py__obs_op_pdaf : Callable[[int, int, int, 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_obs_l_pdaf : Callable[[int, int, int, 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__prepoststep_pdaf : Callable[[int, int, 
                                                             int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                            py__prodRinvA_l_pdaf : Callable[[int, int, 
                                                             int, int, 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                            py__init_n_domains_p_pdaf : Callable[[int, 
                                                                  int], int],
                            py__init_dim_l_pdaf : Callable[[int, int, int], int],
                            py__init_dim_obs_l_pdaf : Callable[[int, int, 
                                                                int, int], int],
                            py__g2l_obs_pdaf : Callable[[int, int, int, 
                                                         int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                         int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                         int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                            py__init_obsvar_pdaf : Callable[[int, int, 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             float], float],
                            py__init_obsvar_l_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               int, float], float],
                            py__next_observation_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  float], tuple[int, 
                                                                  int, 
                                                                  float]]
                           ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.localomi_assimilate`
    or :func:`pyPDAF.PDAF.localomi_assimilate_nondiagR`.

    PDAFlocal-OMI modules require fewer user-supplied
    functions and improved efficiency.

    Local ensemble transform Kalman filter (LETKF) [1]_ for a single DA step without OMI.
    Implementation is based on [2]_.
    Note that the LESTKF is a more efficient equivalent to the LETKF.

    This function should be called at each model time step.
    The function is a combination of
    :func:`pyPDAF.PDAF.local_put_state_letkf`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. py__init_obs_pdaf
           (if global adaptive forgetting factor
           `type_forget=1` is used
           in :func:`pyPDAF.PDAF.init`)
        7. py__init_obsvar_pdaf (if global adaptive
           forgetting factor is used)
        8. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. py__g2l_obs_pdaf (localise mean ensemble
               in observation space)
            4. py__init_obs_l_pdaf
            5. py__g2l_obs_pdaf (localise each ensemble member
               in observation space)
            6. py__init_obsvar_l_pdaf
               (only called if local adaptive forgetting
               factor `type_forget=2` is used)
            7. py__prodRinvA_l_pdaf
            8. core DA algorithm
        9. py__prepoststep_state_pdaf
        10. py__distribute_state_pdaf
        11. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_assimilate`
       and :func:`pyPDAF.PDAF.localomi_assimilate_nondiagR`

    References
    ----------
    .. [1] Hunt, B. R., Kostelich, E. J., & Szunyogh, I. (2007).
           Efficient data assimilation for spatiotemporal chaos:
           A local ensemble transform Kalman filter. 
           Physica D: Nonlinear Phenomena, 230(1-2), 112-126.
    .. [2] Nerger, L., Janji, T., Schrter, J., Hiller, W. (2012). 
           A unification of ensemble square root Kalman filters. 
           Monthly Weather Review, 140, 2335-2345.
           doi:10.1175/MWR-D-11-00102.1

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_assimilate_lknetf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__distribute_state_pdaf : Callable[[int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__init_dim_obs_pdaf : Callable[[int, int], int],
                             py__obs_op_pdaf : Callable[[int, int, int, 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__init_obs_l_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__prepoststep_pdaf : Callable[[int, int, 
                                                              int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                             py__prodRinvA_l_pdaf : Callable[[int, int, 
                                                              int, int, 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                             py__prodRinvA_hyb_l_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  float, 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                             py__init_n_domains_p_pdaf : Callable[[int, 
                                                                   int], int],
                             py__init_dim_l_pdaf : Callable[[int, int, 
                                                             int], int],
                             py__init_dim_obs_l_pdaf : Callable[[int, int, 
                                                                 int, int], int],
                             py__g2l_obs_pdaf : Callable[[int, int, int, 
                                                          int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                          int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                          int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                             py__init_obsvar_pdaf : Callable[[int, int, 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              float], float],
                             py__init_obsvar_l_pdaf : Callable[[int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                int, float], float],
                             py__likelihood_l_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               float], float],
                             py__likelihood_hyb_l_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   float, 
                                                                   float], float],
                             py__next_observation_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   float], tuple[int, 
                                                                   int, 
                                                                   float]]
                            ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.localomi_assimilate`
    or :func:`pyPDAF.PDAF.localomi_assimilate_lknetf_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions
    and improved efficiency.

    A hybridised LETKF and LNETF [1]_ for a single DA step.
    The LNETF computes the distribution up to
    the second moment similar to Kalman filters
    but using a nonlinear weighting similar to
    particle filters. This leads to an equal weights
    assumption for the prior ensemble.
    The hybridisation with LETKF is expected to
    lead to improved performance for
    quasi-Gaussian problems.
    The function should be called at each model step.

    The function is a combination of
    :func:`pyPDAF.PDAF.local_put_state_lknetf`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf
           (for each ensemble member)
        6. py__init_obs_pdaf
           (if global adaptive forgetting factor `type_forget=1`
           is used in :func:`pyPDAF.PDAF.init`)
        7. py__init_obsvar_pdaf (if global adaptive
           forgetting factor is used)
        8. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. py__g2l_obs_pdaf
               (localise each ensemble member in observation space)
            4. py__init_obs_l_pdaf
            5. py__init_obsvar_l_pdaf
               (only called if local adaptive forgetting
               factor `type_forget=2` is used)
            6. py__prodRinvA_pdaf
            7. py__likelihood_l_pdaf
            8. core DA algorithm
        9. py__obs_op_pdaf
           (only called with `HKN` and `HNK` options called
           for each ensemble member)
        10. py__likelihood_hyb_l_pda
        11. py__init_obsvar_l_pdaf
            (only called if local adaptive forgetting factor
            `type_forget=2` is used)
        12. py__prodRinvA_hyb_l_pdaf
        13. py__prepoststep_state_pdaf
        14. py__distribute_state_pdaf
        15. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_assimilate`
       and :func:`pyPDAF.PDAF.localomi_assimilate_lknetf_nondiagR`

    References
    ----------
    .. [1] Nerger, L.. (2022) 
           Data assimilation for nonlinear systems with
           a hybrid nonlinear Kalman ensemble transform filter. 
           Q J R Meteorol Soc, 620640. doi:10.1002/qj.4221

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__prodRinvA_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, dim_ens:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, A_l:ndarray[tuple[dim_obs_l, dim_ens], np.float64], C_l:ndarray[tuple[dim_obs_l, dim_ens], np.float64]]
        Provide product R^-1 A on local analysis domain with hybrid weight

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **dim_ens** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **gamma** : float

            --- Hybrid weight provided by PDAF

        * **A_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance


    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute likelihood

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- nput vector holding the local residual

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    py__likelihood_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, likely_l:float]
        Compute likelihood with hybrid weight

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Input vector holding the local residual

        * **gamma** : float

            --- Hybrid weight provided by PDAF

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_assimilate_lnetf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__distribute_state_pdaf : Callable[[int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_dim_obs_pdaf : Callable[[int, int], int],
                            py__obs_op_pdaf : Callable[[int, int, int, 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_obs_l_pdaf : Callable[[int, int, int, 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__prepoststep_pdaf : Callable[[int, int, 
                                                             int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                            py__likelihood_l_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              float], float],
                            py__init_n_domains_p_pdaf : Callable[[int, 
                                                                  int], int],
                            py__init_dim_l_pdaf : Callable[[int, int, int], int],
                            py__init_dim_obs_l_pdaf : Callable[[int, int, 
                                                                int, int], int],
                            py__g2l_obs_pdaf : Callable[[int, int, int, 
                                                         int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                         int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                         int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                            py__next_observation_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  float], tuple[int, 
                                                                  int, 
                                                                  float]]
                           ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.localomi_assimilate`
    or :func:`pyPDAF.PDAF.localomi_assimilate_lnetf_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions
    and improved efficiency.

    Local Nonlinear Ensemble Transform Filter (LNETF) [1]_
    for a single DA step.
    The nonlinear filter computes the distribution up to
    the second moment similar to Kalman filters
    but it uses a nonlinear weighting similar to
    particle filters. This leads to an equal weights
    assumption for the prior ensemble at each step.
    This function should be called at each model time step.

    The function is a combination of
    :func:`pyPDAF.PDAF.local_put_state_lnetf`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. py__init_obs_l_pdaf
            4. py__g2l_obs_pdaf (localise each ensemble member
               in observation space)
            5. py__likelihood_l_pdaf
            6. core DA algorithm
        7. py__prepoststep_state_pdaf
        8. py__distribute_state_pdaf
        9. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_assimilate`
       and :func:`pyPDAF.PDAF.localomi_assimilate_lnetf_nondiagR`

    References
    ----------
    .. [1] Tdter, J., and B. Ahrens, 2015:
           A second-order exact ensemble square root filter
           for nonlinear data assimilation. Mon. Wea. Rev.,
           143, 13471367, doi:10.1175/MWR-D-14-00108.1.

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- nput vector holding the local residual

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_assimilate_lseik (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__distribute_state_pdaf : Callable[[int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_dim_obs_pdaf : Callable[[int, int], int],
                            py__obs_op_pdaf : Callable[[int, int, int, 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_obs_l_pdaf : Callable[[int, int, int, 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__prepoststep_pdaf : Callable[[int, int, 
                                                             int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                            py__prodRinvA_l_pdaf : Callable[[int, int, 
                                                             int, int, 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                            py__init_n_domains_p_pdaf : Callable[[int, 
                                                                  int], int],
                            py__init_dim_l_pdaf : Callable[[int, int, int], int],
                            py__init_dim_obs_l_pdaf : Callable[[int, int, 
                                                                int, int], int],
                            py__g2l_obs_pdaf : Callable[[int, int, int, 
                                                         int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                         int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                         int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                            py__init_obsvar_pdaf : Callable[[int, int, 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             float], float],
                            py__init_obsvar_l_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               int, float], float],
                            py__next_observation_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  float], tuple[int, 
                                                                  int, 
                                                                  float]]
                           ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.localomi_assimilate`
    or :func:`pyPDAF.PDAF.localomi_assimilate_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions
    and improved efficiency.

    Local singular evolutive interpolated Kalman filter [1]_
    for a single DA step.
    This function should be called at each model time step.

    The function is a combination of
    :func:`pyPDAF.PDAF.local_put_state_lseik` and :func:`pyPDAF.PDAF.get_state`

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. py__init_obs_pdaf
           (if global adaptive forgetting factor `type_forget=1`
           is used in :func:`pyPDAF.PDAF.init`)
        7. py__init_obsvar_pdaf
           (if global adaptive forgetting factor is used)
        8. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. py__g2l_obs_pdaf (localise mean ensemble
               in observation space)
            4. py__init_obs_l_pdaf
            5. py__g2l_obs_pdaf
               (localise each ensemble member in observation space)
            6. py__init_obsvar_l_pdaf
               (only called if local adaptive forgetting factor
               `type_forget=2` is used)
            7. py__prodRinvA_l_pdaf
            8. core DA algorithm
        9. py__prepoststep_state_pdaf
        10. py__distribute_state_pdaf
        11. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_assimilate`
       and :func:`pyPDAF.PDAF.localomi_assimilate_nondiagR`

    References
    ----------
    .. [1] Pham, D. T., Verron, J., & Roubaud, M. C. (1998).
           A singular evolutive extended Kalman filter
           for data assimilation
           in oceanography. Journal of Marine systems, 16(3-4), 323-340.

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        distribute a state vector from pdaf to the model/any arrays

        **Callback Parameters**

        * **dim_p** : int

            --- PE-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance


    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide number of forecast time steps until
        next assimilations, model physical time and
        end of assimilation cycles

        **Callback Parameters**

        * **stepnow** : int

            --- the current time step given by PDAF

        * **nsteps** : int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit** : int

            --- whether to exit forecasting (1 for exit)

        * **time** : float

            --- current model (physical) time

        **Callback Returns**

        * **nsteps**:int

            --- number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation

        * **doexit**:int

            --- whether to exit forecasting (1 for exit)

        * **time**:float

            --- current model (physical) time



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_put_state_en3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__init_dim_obs_pdaf : Callable[[int, 
                                                                      int], int],
                                    py__obs_op_pdaf : Callable[[int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__init_obs_pdaf : Callable[[int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__prodRinvA_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                    py__cvt_ens_pdaf : Callable[[int, int, 
                                                                 int, int, 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__obs_op_lin_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__obs_op_adj_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__init_dim_obs_f_pdaf : Callable[[int, 
                                                                        int], int],
                                    py__obs_op_f_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__init_obs_f_pdaf : Callable[[int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__init_obs_l_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__prodRinvA_l_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                    py__init_n_domains_p_pdaf : Callable[[int, 
                                                                          int], int],
                                    py__init_dim_l_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int], int],
                                    py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        int], int],
                                    py__g2l_obs_pdaf : Callable[[int, int, 
                                                                 int, int, 
                                                                 np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                                 int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                                    py__init_obsvar_pdaf : Callable[[int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     float], float],
                                    py__init_obsvar_l_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int, 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                       int, 
                                                                       float], float],
                                    py__prepoststep_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]]]]
                                   ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf`
    or :func:`pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions
    and improved efficiency.

    3DEnVar for a single DA step without post-processing,
    distributing analysis, and setting next observation step,
    where the ensemble anomaly is generated by LESTKF.

    Compared to
    :func:`pyPDAF.PDAF.local_assimilate_en3dvar_lestkf`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    The background error covariance matrix is estimated by ensemble.
    The 3DEnVar only calculates the analysis of the ensemble mean.
    An LESTKF is used to generate ensemble perturbations.
    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. py__init_obs_pdaf
        6. Starting the iterative optimisation:
            1. py__cvt_ens_pdaf
            2. py__obs_op_lin_pdaf
            3. py__prodRinvA_pdaf
            4. py__obs_op_adj_pdaf
            5. py__cvt_adj_ens_pdaf
            6. core DA algorithm
        7. py__cvt_ens_pdaf
        8. Perform LESTKF:
            1. py__init_n_domains_p_pdaf
            2. py__init_dim_obs_pdaf
            3. py__obs_op_pdaf
               (for each ensemble member)
            4. py__init_obs_pdaf
               (if global adaptive forgetting factor is used
               `type_forget=1` in :func:`pyPDAF.PDAF.init`)
            5. py__init_obsvar_pdaf
               (if global adaptive forgetting factor is used)
            6. loop over each local domain:
                1. py__init_dim_l_pdaf
                2. py__init_dim_obs_l_pdaf
                3. py__g2l_obs_pdaf
                   (localise mean ensemble in observation space)
                4. py__init_obs_l_pdaf
                5. py__g2l_obs_pdaf
                   (localise each ensemble member in observation space)
                6. py__init_obsvar_l_pdaf
                   (only called if local adaptive forgetting factor
                   `type_forget=2` is used)
                7. py__prodRinvA_l_pdaf
                8. core DA algorithm

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf`
       and :func:`pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf_nondiagR`

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one
                (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f:ndarray[tuple[dim_obs_f], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of the full observation vector

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of observations

        **Callback Returns**

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_put_state_hyb3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__init_dim_obs_pdaf : Callable[[int, 
                                                                       int], int],
                                     py__obs_op_pdaf : Callable[[int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__init_obs_pdaf : Callable[[int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__prodRinvA_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                     py__cvt_ens_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__cvt_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__cvt_adj_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__obs_op_lin_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__obs_op_adj_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__init_dim_obs_f_pdaf : Callable[[int, 
                                                                         int], int],
                                     py__obs_op_f_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__init_obs_f_pdaf : Callable[[int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__init_obs_l_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__prodRinvA_l_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                     py__init_n_domains_p_pdaf : Callable[[int, 
                                                                           int], int],
                                     py__init_dim_l_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int], int],
                                     py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         int], int],
                                     py__g2l_obs_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                                  int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                                     py__init_obsvar_pdaf : Callable[[int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      float], float],
                                     py__init_obsvar_l_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        int, 
                                                                        float], float],
                                     py__prepoststep_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                      int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]]]
                                    ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf`
    or :func:`pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions
    and improved efficiency.

    Hybrid 3DEnVar for a single DA step using
    non-diagnoal observation error covariance matrix
    without post-processing, distributing analysis,
    and setting next observation step, where
    the background error covariance is hybridised by
    a static background error covariance,
    and a flow-dependent background error covariance
    estimated from ensemble.

    Compared to
    :func:`pyPDAF.PDAF.local_assimilate_hyb3dvar_lestkf`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    The 3DVar generates an ensemble mean and
    the ensemble perturbation is generated by
    LESTKF in this implementation.
    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. py__init_obs_pdaf
        6. The iterative optimisation:
            1. py__cvt_pdaf
            2. py__cvt_ens_pdaf
            3. py__obs_op_lin_pdaf
            4. py__prodRinvA_pdaf
            5. py__obs_op_adj_pdaf
            6. py__cvt_adj_pdaf
            7. py__cvt_adj_ens_pdaf
            8. core DA algorithm
        7. py__cvt_pdaf
        8. py__cvt_ens_pdaf
        9. Perform LESTKF:
            1. py__init_n_domains_p_pdaf
            2. py__init_dim_obs_pdaf
            3. py__obs_op_pdaf
               (for each ensemble member)
            4. py__init_obs_pdaf
               (if global adaptive forgetting factor
               `type_forget=1` in :func:`pyPDAF.PDAF.init`)
            5. py__init_obsvar_pdaf
               (if global adaptive forgetting factor is used)
            6. loop over each local domain:
                1. py__init_dim_l_pdaf
                2. py__init_dim_obs_l_pdaf
                3. py__g2l_obs_pdaf
                   (localise mean ensemble in observation space)
                4. py__init_obs_l_pdaf
                5. py__g2l_obs_pdaf
                   (localise each ensemble member
                   in observation space)
                6. py__init_obsvar_l_pdaf
                   (only called if local adaptive forgetting
                   factor `type_forget=2` is used)
                7. py__prodRinvA_l_pdaf
                8. core DA algorithm

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf`
       and :func:`pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf_nondiagR`

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Number of observations at current time step (i.e. the size of the observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one
                (or the rank of the initial covariance matrix)

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **A_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_p** : ndarray[tuple[dim_obs_p, rank], np.float64]

            --- Output matrix


    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cvec_ens** : int

            --- Dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **v_p** : ndarray[tuple[dim_cvec_ens], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local state increment


    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_ens** : int

            --- Ensemble size

        * **dim_cv_ens_p** : int

            --- PE-local dimension of control vector

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local input vector

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cv_ens_p], np.float64]

            --- PE-local result vector


    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        **Callback Returns**

        * **Vv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)


    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * **iter** : int

            --- Iteration of optimization

        * **dim_p** : int

            --- PE-local observation dimension

        * **dim_cvec** : int

            --- Dimension of control vector

        * **Vcv_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local result vector (state vector increment)

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector

        **Callback Returns**

        * **cv_p** : ndarray[tuple[dim_cvec], np.float64]

            --- PE-local control vector


    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state


    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- PE-local dimension of state

        * **dim_obs_p** : int

            --- Dimension of observed state

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- PE-local observed state

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- PE-local model state


    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector (i.e. the result after applying the observation operator to state_p)


    py__init_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f:ndarray[tuple[dim_obs_f], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of the full observation vector

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of observations

        **Callback Returns**

        * **observation_f** : ndarray[tuple[dim_obs_f], np.float64]

            --- Full vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_put_state_lestkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_dim_obs_pdaf : Callable[[int, int], int],
                            py__obs_op_pdaf : Callable[[int, int, int, 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_obs_l_pdaf : Callable[[int, int, int, 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__prepoststep_pdaf : Callable[[int, int, 
                                                             int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                            py__prodRinvA_l_pdaf : Callable[[int, int, 
                                                             int, int, 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                            py__init_n_domains_p_pdaf : Callable[[int, 
                                                                  int], int],
                            py__init_dim_l_pdaf : Callable[[int, int, int], int],
                            py__init_dim_obs_l_pdaf : Callable[[int, int, 
                                                                int, int], int],
                            py__g2l_obs_pdaf : Callable[[int, int, int, 
                                                         int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                         int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                         int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                            py__init_obsvar_pdaf : Callable[[int, int, 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             float], float],
                            py__init_obsvar_l_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               int, float], float]
                           ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.localomi_put_state`
    or :func:`pyPDAF.PDAF.localomi_put_state_nondiagR`.

    PDAFlocal-OMI modules require fewer
    user-supplied functions and improved efficiency.

    Local ESTKF (error space transform Kalman filter) [1]_ for a single DA step without OMI.

    Compared to :func:`pyPDAF.PDAF.local_assimilate_lestkf`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    The LESTKF is a more efficient equivalent to the LETKF.

    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. py__init_obs_pdaf
           (if global adaptive forgetting factor
           `type_forget=1` is used
           in :func:`pyPDAF.PDAF.init`)
        7. py__init_obsvar_pdaf (if global adaptive
           forgetting factor is used)
        8. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. py__g2l_obs_pdaf (localise mean ensemble
               in observation space)
            4. py__init_obs_l_pdaf
            5. py__g2l_obs_pdaf
               (localise each ensemble member
               in observation space)
            6. py__init_obsvar_l_pdaf
               (only called if local adaptive forgetting
               factor `type_forget=2` is used)
            7. py__prodRinvA_l_pdaf
            8. core DA algorithm

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_put_state`
       and :func:`pyPDAF.PDAF.localomi_put_state_nondiagR`

    References
    ----------
    .. [1] Nerger, L., Janji, T., Schrter, J., Hiller, W. (2012). 
           A unification of ensemble square root Kalman filters. 
           Monthly Weather Review, 140, 2335-2345.
           doi:10.1175/MWR-D-11-00102.1

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_put_state_letkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                           py__init_dim_obs_pdaf : Callable[[int, int], int],
                           py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                           py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                           py__init_obs_l_pdaf : Callable[[int, int, int, 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                           py__prepoststep_pdaf : Callable[[int, int, int, 
                                                            int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                           py__prodRinvA_l_pdaf : Callable[[int, int, int, 
                                                            int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                           py__init_n_domains_p_pdaf : Callable[[int, int], int],
                           py__init_dim_l_pdaf : Callable[[int, int, int], int],
                           py__init_dim_obs_l_pdaf : Callable[[int, int, 
                                                               int, int], int],
                           py__g2l_obs_pdaf : Callable[[int, int, int, 
                                                        int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                        int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                        int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                           py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            float], float],
                           py__init_obsvar_l_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              int, float], float]
                          ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.localomi_put_state`
    or :func:`pyPDAF.PDAF.localomi_put_state_nondiagR`.

    PDAFlocal-OMI modules require fewer user-supplied
    functions and improved efficiency.

    Local ensemble transform Kalman filter (LETKF) [1]_
    for a single DA step without OMI. Implementation is
    based on [2]_.

    Compared to :func:`pyPDAF.PDAF.local_assimilate_letkf`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    Note that the LESTKF is a more efficient equivalent to the LETKF.

    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. py__init_obs_pdaf
           (if global adaptive forgetting factor
           `type_forget=1` is used
           in :func:`pyPDAF.PDAF.init`)
        7. py__init_obsvar_pdaf (if global adaptive
           forgetting factor is used)
        8. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. py__g2l_obs_pdaf (localise mean ensemble
               in observation space)
            4. py__init_obs_l_pdaf
            5. py__g2l_obs_pdaf (localise each ensemble member
               in observation space)
            6. py__init_obsvar_l_pdaf
               (only called if local adaptive forgetting
               factor `type_forget=2` is used)
            7. py__prodRinvA_l_pdaf
            8. core DA algorithm

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_put_state`
       and :func:`pyPDAF.PDAF.localomi_put_state_nondiagR`

    References
    ----------
    .. [1] Hunt, B. R., Kostelich, E. J., & Szunyogh, I. (2007).
           Efficient data assimilation for spatiotemporal chaos:
           A local ensemble transform Kalman filter. 
           Physica D: Nonlinear Phenomena, 230(1-2), 112-126.
    .. [2] Nerger, L., Janji, T., Schrter, J., Hiller, W. (2012). 
           A unification of ensemble square root Kalman filters. 
           Monthly Weather Review, 140, 2335-2345.
           doi:10.1175/MWR-D-11-00102.1

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_put_state_lknetf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_dim_obs_pdaf : Callable[[int, int], int],
                            py__obs_op_pdaf : Callable[[int, int, int, 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_obs_l_pdaf : Callable[[int, int, int, 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__prepoststep_pdaf : Callable[[int, int, 
                                                             int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                            py__prodRinvA_l_pdaf : Callable[[int, int, 
                                                             int, int, 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                            py__prodRinvA_hyb_l_pdaf : Callable[[int, int, 
                                                                 int, int, 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 float, 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                            py__init_n_domains_p_pdaf : Callable[[int, 
                                                                  int], int],
                            py__init_dim_l_pdaf : Callable[[int, int, int], int],
                            py__init_dim_obs_l_pdaf : Callable[[int, int, 
                                                                int, int], int],
                            py__g2l_obs_pdaf : Callable[[int, int, int, 
                                                         int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                         int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                         int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                            py__init_obsvar_pdaf : Callable[[int, int, 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             float], float],
                            py__init_obsvar_l_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               int, float], float],
                            py__likelihood_l_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              float], float],
                            py__likelihood_hyb_l_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  float, 
                                                                  float], float]
                           ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.localomi_put_state`
    or :func:`pyPDAF.PDAF.localomi_put_state_lknetf_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions
    and improved efficiency.

    A hybridised LETKF and LNETF [1]_ for a single DA step.

    Compared to :func:`pyPDAF.PDAF.local_assimilate_lknetf`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    The LNETF computes the distribution up to
    the second moment similar to Kalman filters
    but using a nonlinear weighting similar to
    particle filters. This leads to an equal weights
    assumption for the prior ensemble.
    The hybridisation with LETKF is expected to
    lead to improved performance for
    quasi-Gaussian problems.
    The function should be called at each model step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf
           (for each ensemble member)
        6. py__init_obs_pdaf
           (if global adaptive forgetting factor `type_forget=1`
           is used in :func:`pyPDAF.PDAF.init`)
        7. py__init_obsvar_pdaf (if global adaptive
           forgetting factor is used)
        8. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. py__g2l_obs_pdaf
               (localise each ensemble member
               in observation space)
            4. py__init_obs_l_pdaf
            5. py__init_obsvar_l_pdaf
               (only called if local adaptive forgetting
               factor `type_forget=2` is used)
            6. py__prodRinvA_pdaf
            7. py__likelihood_l_pdaf
            8. core DA algorithm
        9. py__obs_op_pdaf
           (only called with `HKN` and `HNK` options
           called for each ensemble member)
        10. py__likelihood_hyb_l_pda
        11. py__init_obsvar_l_pdaf
            (only called if local adaptive forgetting
            factor `type_forget=2` is used)
        12. py__prodRinvA_hyb_l_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_put_state`
       and :func:`pyPDAF.PDAF.localomi_put_state_lknetf_nondiagR`

    References
    ----------
    .. [1] Nerger, L.. (2022)
           Data assimilation for nonlinear systems with
           a hybrid nonlinear Kalman ensemble transform filter.
           Q J R Meteorol Soc, 620640. doi:10.1002/qj.4221

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__prodRinvA_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, dim_ens:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, A_l:ndarray[tuple[dim_obs_l, dim_ens], np.float64], C_l:ndarray[tuple[dim_obs_l, dim_ens], np.float64]]
        Provide product R^-1 A on local analysis domain with hybrid weight

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **dim_ens** : int

            --- Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **gamma** : float

            --- Hybrid weight provided by PDAF

        * **A_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, dim_ens], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance


    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute likelihood

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- nput vector holding the local residual

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    py__likelihood_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, likely_l:float]
        Compute likelihood with hybrid weight

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Input vector holding the local residual

        * **gamma** : float

            --- Hybrid weight provided by PDAF

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_put_state_lnetf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                           py__init_dim_obs_pdaf : Callable[[int, int], int],
                           py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                           py__init_obs_l_pdaf : Callable[[int, int, int, 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                           py__prepoststep_pdaf : Callable[[int, int, int, 
                                                            int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                           py__likelihood_l_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             float], float],
                           py__init_n_domains_p_pdaf : Callable[[int, int], int],
                           py__init_dim_l_pdaf : Callable[[int, int, int], int],
                           py__init_dim_obs_l_pdaf : Callable[[int, int, 
                                                               int, int], int],
                           py__g2l_obs_pdaf : Callable[[int, int, int, 
                                                        int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                        int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                        int], np.ndarray[tuple[int], np.dtype[np.intc]]]
                          ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.localomi_put_state`
    or :func:`pyPDAF.PDAF.localomi_put_state_lnetf_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions
    and improved efficiency.

    Local Nonlinear Ensemble Transform Filter (LNETF) [1]_
    for a single DA step.

    Compared to :func:`pyPDAF.PDAF.local_assimilate_lnetf`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    The nonlinear filter computes the distribution up to
    the second moment similar to Kalman filters
    but it uses a nonlinear weighting similar to
    particle filters. This leads to an equal weights
    assumption for the prior ensemble at each step.
    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. py__init_obs_l_pdaf
            4. py__g2l_obs_pdaf (localise each ensemble member
               in observation space)
            5. py__likelihood_l_pdaf
            6. core DA algorithm

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_put_state`
       and :func:`pyPDAF.PDAF.localomi_put_state_lnetf_nondiagR`

    References
    ----------
    .. [1] Tdter, J., and B. Ahrens, 2015:
           A second-order exact ensemble square root filter
           for nonlinear data assimilation. Mon. Wea. Rev.,
           143, 13471367, doi:10.1175/MWR-D-14-00108.1.

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **resid_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- nput vector holding the local residual

        * **likely_l** : float

            --- Output value of the local likelihood

        **Callback Returns**

        * **likely_l**:float

            --- Output value of the local likelihood


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_put_state_lseik (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                           py__init_dim_obs_pdaf : Callable[[int, int], int],
                           py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                           py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                           py__init_obs_l_pdaf : Callable[[int, int, int, 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                           py__prepoststep_pdaf : Callable[[int, int, int, 
                                                            int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                           py__prodRinvA_l_pdaf : Callable[[int, int, int, 
                                                            int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                           py__init_n_domains_p_pdaf : Callable[[int, int], int],
                           py__init_dim_l_pdaf : Callable[[int, int, int], int],
                           py__init_dim_obs_l_pdaf : Callable[[int, int, 
                                                               int, int], int],
                           py__g2l_obs_pdaf : Callable[[int, int, int, 
                                                        int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                        int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                        int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                           py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            float], float],
                           py__init_obsvar_l_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              int, float], float]
                          ) -> int:
    r"""It is recommended to use
    :func:`pyPDAF.PDAF.localomi_put_state`
    or :func:`pyPDAF.PDAF.localomi_put_state_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions
    and improved efficiency.

    Local singular evolutive interpolated Kalman filter [1]_
    for a single DA step.

    Compared to :func:`pyPDAF.PDAF.local_assimilate_lseik`,
    this function has no :func:`get_state` call.
    This means that the analysis is not post-processed,
    and distributed to the model forecast
    by user-supplied functions. The next DA step will
    not be assigned by user-supplied functions as well.
    This function is typically used when there are
    not enough CPUs to run the ensemble in parallel,
    and some ensemble members have to be run serially.
    The :func:`pyPDAF.PDAF.get_state` function follows this
    function call to ensure the sequential DA.

    This function should be called at each model time step.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. py__init_obs_pdaf
           (if global adaptive forgetting factor `type_forget=1`
           is used in :func:`pyPDAF.PDAF.init`)
        7. py__init_obsvar_pdaf
           (if global adaptive forgetting factor is used)
        8. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. py__g2l_obs_pdaf (localise mean ensemble
               in observation space)
            4. py__init_obs_l_pdaf
            5. py__g2l_obs_pdaf
               (localise each ensemble member in observation space)
            6. py__init_obsvar_l_pdaf
               (only called if local adaptive forgetting
               factor `type_forget=2` is used)
            7. py__prodRinvA_l_pdaf
            8. core DA algorithm
    
    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_put_state`
       and :func:`pyPDAF.PDAF.localomi_put_state_nondiagR`

    References
    ----------
    .. [1] Pham, D. T., Verron, J., & Roubaud, M. C. (1998).
           A singular evolutive extended Kalman filter
           for data assimilation
           in oceanography. Journal of Marine systems, 16(3-4), 323-340.

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Collect state vector from model/any arrays to pdaf arrays

        **Callback Parameters**

        * **dim_p** : int

            --- pe-local state dimension

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- local state vector


    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        The primary purpose of this function is to
        obtain the dimension of the observation vector.
        In OMI, in this function, one also sets the properties
        of `obs_f`, read the observation vector from
        files, setting the observation error variance
        when diagonal observation error covariance matrix
        is used. The `pyPDAF.PDAF.omi_gather_obs` function
        is also called here.

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **dim_obs_p** : int

            --- dimension of observation vector

        **Callback Returns**

        * **dim_obs_p**:int

            --- dimension of observation vector


    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_p** : int

            --- Size of state vector
                (local part in case of parallel decomposed state)

        * **dim_obs_p** : int

            --- Size of PE-local observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- Model state vector

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * **m_state_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Observed state vector
                (i.e. the result after applying the observation operator to state_p)


    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of the observation vector

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        **Callback Returns**

        * **observation_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations


    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local size of the observation vector

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        **Callback Returns**

        * **observation_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations


    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_l:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        Preprocesse the ensemble before analysis
        and postprocess the ensemble before
        distributing to the model for next forecast

        **Callback Parameters**

        * **step** : int

            --- current time step
                (negative for call before analysis/preprocessing)

        * **dim_p** : int

            --- PE-local state vector dimension

        * **dim_ens** : int

            --- number of ensemble members

        * **dim_ens_l** : int

            --- number of ensemble members run serially
                on each model task

        * **dim_obs_p** : int

            --- PE-local dimension of observation vector

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble

        * **flag** : int

            --- pdaf status flag

        **Callback Returns**

        * **state_p** : ndarray[tuple[dim_p], np.float64]

            --- pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)

        * **uinv** : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            --- Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.

        * **ens_p** : ndarray[tuple[dim_p, dim_ens], np.float64]

            --- PE-local ensemble


    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Number of local observations at current time step (i.e. the size of the local observation vector)

        * **rank** : int

            --- Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * **obs_l** : ndarray[tuple[dim_obs_l], np.float64]

            --- Local vector of observations

        * **A_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Input matrix provided by PDAF

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix

        **Callback Returns**

        * **C_l** : ndarray[tuple[dim_obs_l, rank], np.float64]

            --- Output matrix


    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **n_domains_p** : int

            --- pe-local number of analysis domains

        **Callback Returns**

        * **n_domains_p**:int

            --- pe-local number of analysis domains


    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * **step** : int

            --- current time step

        * **domain_p** : int

            --- current local analysis domain

        * **dim_l** : int

            --- local state dimension

        **Callback Returns**

        * **dim_l**:int

            --- local state dimension


    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * **domain_p** : int

            --- index of current local analysis domain

        * **step** : int

            --- current time step

        * **dim_obs_f** : int

            --- full dimension of observation vector

        * **dim_obs_l** : int

            --- local dimension of observation vector

        **Callback Returns**

        * **dim_obs_l**:int

            --- local dimension of observation vector


    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_f** : int

            --- Size of full observation vector for model sub-domain

        * **dim_obs_l** : int

            --- Size of observation vector for local analysis domain

        * **mstate_f** : ndarray[tuple[dim_p], np.intc]

            --- Full observation vector for model sub-domain

        * **dim_p** : int

            --- Size of full observation vector for model sub-domain

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain

        * **dim_l** : int

            --- Size of observation vector for local analysis domain

        **Callback Returns**

        * **mstate_l** : ndarray[tuple[dim_l], np.intc]

            --- Observation vector for local analysis domain


    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * **step** : int

            --- Current time step

        * **dim_obs_p** : int

            --- Size of observation vector

        * **obs_p** : ndarray[tuple[dim_obs_p], np.float64]

            --- Vector of observations

        * **meanvar** : float

            --- Mean observation error variance

        **Callback Returns**

        * **meanvar**:float

            --- Mean observation error variance


    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * **domain_p** : int

            --- Index of current local analysis domain

        * **step** : int

            --- Current time step

        * **dim_obs_l** : int

            --- Local dimension of observation vector

        * **obs_l** : ndarray[tuple[dim_obs_p], np.float64]

            --- Local observation vector

        * **dim_obs_p** : int

            --- Dimension of local observation vector

        * **meanvar_l** : float

            --- Mean local observation error variance

        **Callback Returns**

        * **meanvar_l**:float

            --- Mean local observation error variance



    Returns
    -------
    outflag : int
        Status flag
    """
    ...

