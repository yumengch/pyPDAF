import numpy as np
from typing import Callable

def assimilate_3dvar (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_dim_obs_pdaf : Callable[[int, int], int],
                      py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__prodRinvA_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                      py__cvt_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__cvt_adj_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__obs_op_lin_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__obs_op_adj_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                       int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                      py__next_observation_pdaf : Callable[[int, int, int, 
                                                            float], tuple[int, 
                                                            int, float]]
                     ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_assimilate_3dvar or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one(or the rank of the initial covariance matrix)

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * A_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix\n

    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_cvec : int

            * Dimension of control vector

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)\n

    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_cvec : int

            * Dimension of control vector

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector\n

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state\n

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide time step, time and dimension of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n


    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def assimilate_en3dvar_estkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__distribute_state_pdaf : Callable[[int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__init_dim_obs_pdaf : Callable[[int, int], int],
                              py__obs_op_pdaf : Callable[[int, int, int, 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__prodRinvA_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                              py__cvt_ens_pdaf : Callable[[int, int, int, 
                                                           int, np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__cvt_adj_ens_pdaf : Callable[[int, int, 
                                                               int, int, 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__obs_op_lin_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__obs_op_adj_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__init_obsvar_pdaf : Callable[[int, int, 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               float], float],
                              py__prepoststep_pdaf : Callable[[int, int, 
                                                               int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                              py__next_observation_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    float], tuple[int, 
                                                                    int, 
                                                                    float]]
                             ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_assimilate_en3dvar_estkf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one(or the rank of the initial covariance matrix)

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * A_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix\n

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local dimension of state

        * dim_ens : int

            * Ensemble size

        * dim_cvec_ens : int

            * Dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * v_p : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment\n

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_ens : int

            * Ensemble size

        * dim_cv_ens_p : int

            * PE-local dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector\n

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state\n

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state\n

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of observation vector

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * meanvar : float

            * Mean observation error variance

        **Callback Returns**

        * meanvar:float

            * Mean observation error variance\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide time step, time and dimension of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n


    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def assimilate_en3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__distribute_state_pdaf : Callable[[int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__init_dim_obs_pdaf : Callable[[int, int], int],
                               py__obs_op_pdaf : Callable[[int, int, int, 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__init_obs_pdaf : Callable[[int, int, 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__prodRinvA_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                               py__cvt_ens_pdaf : Callable[[int, int, int, 
                                                            int, np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__cvt_adj_ens_pdaf : Callable[[int, int, 
                                                                int, int, 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__obs_op_lin_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__obs_op_adj_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__init_dim_obs_f_pdaf : Callable[[int, 
                                                                   int], int],
                               py__obs_op_f_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__init_obs_f_pdaf : Callable[[int, int, 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__init_obs_l_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__prodRinvA_l_pdaf : Callable[[int, int, 
                                                                int, int, 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                               py__init_n_domains_p_pdaf : Callable[[int, 
                                                                     int], int],
                               py__init_dim_l_pdaf : Callable[[int, int, 
                                                               int], int],
                               py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int], int],
                               py__g2l_state_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__l2g_state_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__g2l_obs_pdaf : Callable[[int, int, int, 
                                                            int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                            int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                            int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                               py__init_obsvar_pdaf : Callable[[int, int, 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                float], float],
                               py__init_obsvar_l_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  int, 
                                                                  float], float],
                               py__prepoststep_pdaf : Callable[[int, int, 
                                                                int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                               py__next_observation_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     float], tuple[int, 
                                                                     int, 
                                                                     float]],
                               outflag: int) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_assimilate_en3dvar_lestkf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one(or the rank of the initial covariance matrix)

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * A_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix\n

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local dimension of state

        * dim_ens : int

            * Ensemble size

        * dim_cvec_ens : int

            * Dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * v_p : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment\n

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_ens : int

            * Ensemble size

        * dim_cv_ens_p : int

            * PE-local dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector\n

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state\n

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state\n

    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_f:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of the full observation vector

        **Callback Returns**

        * dim_obs_f:int

            * Size of the full observation vector\n

    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_f:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_f:ndarray[tuple[dim_obs_f], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_f : int

            * Size of full observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f:ndarray[tuple[dim_obs_f], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of the full observation vector

        * observation_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of observations

        **Callback Returns**

        * observation_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of observations\n

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local size of the observation vector

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations\n

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * A_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_p : int

            * pe-local full state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * dim_l : int

            * local state dimension

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain\n

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * dim_p : int

            * pe-local full state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector\n

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of full observation vector for model sub-domain

        * dim_obs_l : int

            * Size of observation vector for local analysis domain

        * mstate_f : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * dim_p : int

            * Size of full observation vector for model sub-domain

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * dim_l : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain\n

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of observation vector

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * meanvar : float

            * Mean observation error variance

        **Callback Returns**

        * meanvar:float

            * Mean observation error variance\n

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local dimension of observation vector

        * obs_l : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * dim_obs_p : int

            * Dimension of local observation vector

        * meanvar_l : float

            * Mean local observation error variance

        **Callback Returns**

        * meanvar_l:float

            * Mean local observation error variance\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide time step, time and dimension of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def assimilate_enkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_dim_obs_pdaf : Callable[[int, int], int],
                     py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                     py__add_obs_err_pdaf : Callable[[int, int, np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                     py__init_obs_covar_pdaf : Callable[[int, int, int, 
                                                         float, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         bool], tuple[float, 
                                                         bool]],
                     py__next_observation_pdaf : Callable[[int, int, int, 
                                                           float], tuple[int, 
                                                           int, float]]
                    ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_assimilate_enkf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__add_obs_err_pdaf : Callable[step:int, dim_obs_p:int, C_p:ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]]
        Add obs error covariance R to HPH in EnKF

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Dimension of observation vector

        * C_p : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            * Matrix to that observation covariance R is added

        **Callback Returns**

        * C_p : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            * Matrix to that observation covariance R is added\n

    py__init_obs_covar_pdaf : Callable[step:int, dim_obs:int, dim_obs_p:int, covar:float, obs_p:ndarray[tuple[dim_obs_p], np.float64], isdiag:bool]
        Initialize obs. error cov. matrix R in EnKF

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs : int

            * Global size of observation vector

        * dim_obs_p : int

            * Size of process-local observation vector

        * covar : float

            * Observation error covariance matrix

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Process-local vector of observations

        * isdiag : bool

            * 

        **Callback Returns**

        * covar:float

            * Observation error covariance matrix\n
        * isdiag:bool

            * \n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n


    Returns
    -------
    flag : int
        Status flag
    """
    ...

def assimilate_estkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_dim_obs_pdaf : Callable[[int, int], int],
                      py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                       int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                      py__prodRinvA_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                      py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       float], float],
                      py__next_observation_pdaf : Callable[[int, int, int, 
                                                            float], tuple[int, 
                                                            int, float]]
                     ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_assimilate_estkf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 HV

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one(or the rank of the initial covariance matrix)

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * A_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix\n

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of observation vector

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * meanvar : float

            * Mean observation error variance

        **Callback Returns**

        * meanvar:float

            * Mean observation error variance\n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n


    Returns
    -------
    flag : int
        Status flag
    """
    ...

def assimilate_etkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_dim_obs_pdaf : Callable[[int, int], int],
                     py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                     py__prodRinvA_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                     py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      float], float],
                     py__next_observation_pdaf : Callable[[int, int, int, 
                                                           float], tuple[int, 
                                                           int, float]]
                    ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_assimilate_etkf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 HV

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one(or the rank of the initial covariance matrix)

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * A_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix\n

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of observation vector

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * meanvar : float

            * Mean observation error variance

        **Callback Returns**

        * meanvar:float

            * Mean observation error variance\n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n


    Returns
    -------
    flag : int
        Status flag
    """
    ...

def assimilate_hyb3dvar_estkf (py__collect_state_pdaf : Callable[[int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__distribute_state_pdaf : Callable[[int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__init_dim_obs_pdaf : Callable[[int, int], int],
                               py__obs_op_pdaf : Callable[[int, int, int, 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__init_obs_pdaf : Callable[[int, int, 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__prodRinvA_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                               py__cvt_ens_pdaf : Callable[[int, int, int, 
                                                            int, np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__cvt_adj_ens_pdaf : Callable[[int, int, 
                                                                int, int, 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__cvt_pdaf : Callable[[int, int, int, 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__cvt_adj_pdaf : Callable[[int, int, int, 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__obs_op_lin_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__obs_op_adj_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__init_obsvar_pdaf : Callable[[int, int, 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                float], float],
                               py__prepoststep_pdaf : Callable[[int, int, 
                                                                int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                               py__next_observation_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     float], tuple[int, 
                                                                     int, 
                                                                     float]]
                              ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_assimilate_hyb3dvar_estkf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one(or the rank of the initial covariance matrix)

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * A_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix\n

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local dimension of state

        * dim_ens : int

            * Ensemble size

        * dim_cvec_ens : int

            * Dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * v_p : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment\n

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_ens : int

            * Ensemble size

        * dim_cv_ens_p : int

            * PE-local dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector\n

    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_cvec : int

            * Dimension of control vector

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)\n

    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_cvec : int

            * Dimension of control vector

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector\n

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state\n

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state\n

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of observation vector

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * meanvar : float

            * Mean observation error variance

        **Callback Returns**

        * meanvar:float

            * Mean observation error variance\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide time step, time and dimension of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n


    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def assimilate_hyb3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__distribute_state_pdaf : Callable[[int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__init_dim_obs_pdaf : Callable[[int, 
                                                                  int], int],
                                py__obs_op_pdaf : Callable[[int, int, int, 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__init_obs_pdaf : Callable[[int, int, 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__prodRinvA_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                py__cvt_ens_pdaf : Callable[[int, int, 
                                                             int, int, 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__cvt_adj_ens_pdaf : Callable[[int, int, 
                                                                 int, int, 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__cvt_pdaf : Callable[[int, int, int, 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__cvt_adj_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__obs_op_lin_pdaf : Callable[[int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__obs_op_adj_pdaf : Callable[[int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__init_dim_obs_f_pdaf : Callable[[int, 
                                                                    int], int],
                                py__obs_op_f_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__init_obs_f_pdaf : Callable[[int, int, 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__init_obs_l_pdaf : Callable[[int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__prodRinvA_l_pdaf : Callable[[int, int, 
                                                                 int, int, 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                py__init_n_domains_p_pdaf : Callable[[int, 
                                                                      int], int],
                                py__init_dim_l_pdaf : Callable[[int, int, 
                                                                int], int],
                                py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    int], int],
                                py__g2l_state_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__l2g_state_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__g2l_obs_pdaf : Callable[[int, int, 
                                                             int, int, 
                                                             np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                             int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                             int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                                py__init_obsvar_pdaf : Callable[[int, int, 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 float], float],
                                py__init_obsvar_l_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   int, 
                                                                   float], float],
                                py__prepoststep_pdaf : Callable[[int, int, 
                                                                 int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                 int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                py__next_observation_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      float], tuple[int, 
                                                                      int, 
                                                                      float]]
                               ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_assimilate_hyb3dvar_lestkf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one(or the rank of the initial covariance matrix)

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * A_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix\n

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local dimension of state

        * dim_ens : int

            * Ensemble size

        * dim_cvec_ens : int

            * Dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * v_p : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment\n

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_ens : int

            * Ensemble size

        * dim_cv_ens_p : int

            * PE-local dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector\n

    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_cvec : int

            * Dimension of control vector

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)\n

    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_cvec : int

            * Dimension of control vector

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector\n

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state\n

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state\n

    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_f:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of the full observation vector

        **Callback Returns**

        * dim_obs_f:int

            * Size of the full observation vector\n

    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_f:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_f:ndarray[tuple[dim_obs_f], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_f : int

            * Size of full observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f:ndarray[tuple[dim_obs_f], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of the full observation vector

        * observation_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of observations

        **Callback Returns**

        * observation_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of observations\n

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local size of the observation vector

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations\n

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * A_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_p : int

            * pe-local full state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * dim_l : int

            * local state dimension

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain\n

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * dim_p : int

            * pe-local full state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector\n

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of full observation vector for model sub-domain

        * dim_obs_l : int

            * Size of observation vector for local analysis domain

        * mstate_f : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * dim_p : int

            * Size of full observation vector for model sub-domain

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * dim_l : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain\n

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of observation vector

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * meanvar : float

            * Mean observation error variance

        **Callback Returns**

        * meanvar:float

            * Mean observation error variance\n

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local dimension of observation vector

        * obs_l : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * dim_obs_p : int

            * Dimension of local observation vector

        * meanvar_l : float

            * Mean local observation error variance

        **Callback Returns**

        * meanvar_l:float

            * Mean local observation error variance\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide time step, time and dimension of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n


    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def assimilate_lenkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_dim_obs_pdaf : Callable[[int, int], int],
                      py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                       int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                      py__localize_covar_pdaf : Callable[[int, int, np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]]], tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                      py__add_obs_err_pdaf : Callable[[int, int, np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                      py__init_obs_covar_pdaf : Callable[[int, int, int, 
                                                          float, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          bool], tuple[float, 
                                                          bool]],
                      py__next_observation_pdaf : Callable[[int, int, int, 
                                                            float], tuple[int, 
                                                            int, float]]
                     ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_assimilate_lenkf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__localize_covar_pdaf : Callable[dim_p:int, dim_obs:int, hp_p:ndarray[tuple[dim_obs, dim_p], np.float64], hph:ndarray[tuple[dim_obs, dim_obs], np.float64]]
        Apply localization to HP and HPH^T

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * dim_obs : int

            * number of observations

        * hp_p : ndarray[tuple[dim_obs, dim_p], np.float64]

            * pe local part of matrix hp

        * hph : ndarray[tuple[dim_obs, dim_obs], np.float64]

            * matrix hph

        **Callback Returns**

        * hp_p : ndarray[tuple[dim_obs, dim_p], np.float64]

            * pe local part of matrix hp\n
        * hph : ndarray[tuple[dim_obs, dim_obs], np.float64]

            * matrix hph\n

    py__add_obs_err_pdaf : Callable[step:int, dim_obs_p:int, C_p:ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]]
        Add obs error covariance R to HPH in EnKF

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Dimension of observation vector

        * C_p : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            * Matrix to that observation covariance R is added

        **Callback Returns**

        * C_p : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            * Matrix to that observation covariance R is added\n

    py__init_obs_covar_pdaf : Callable[step:int, dim_obs:int, dim_obs_p:int, covar:float, obs_p:ndarray[tuple[dim_obs_p], np.float64], isdiag:bool]
        Initialize obs. error cov. matrix R in EnKF

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs : int

            * Global size of observation vector

        * dim_obs_p : int

            * Size of process-local observation vector

        * covar : float

            * Observation error covariance matrix

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Process-local vector of observations

        * isdiag : bool

            * 

        **Callback Returns**

        * covar:float

            * Observation error covariance matrix\n
        * isdiag:bool

            * \n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n


    Returns
    -------
    flag : int
        Status flag
    """
    ...

def assimilate_lestkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__init_dim_obs_pdaf : Callable[[int, int], int],
                       py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__init_obs_l_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__prepoststep_pdaf : Callable[[int, int, int, 
                                                        int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                        int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                       py__prodRinvA_l_pdaf : Callable[[int, int, int, 
                                                        int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                       py__init_n_domains_p_pdaf : Callable[[int, int], int],
                       py__init_dim_l_pdaf : Callable[[int, int, int], int],
                       py__init_dim_obs_l_pdaf : Callable[[int, int, int, 
                                                           int], int],
                       py__g2l_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__l2g_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__g2l_obs_pdaf : Callable[[int, int, int, int, 
                                                    np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                    int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                    int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                       py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        float], float],
                       py__init_obsvar_l_pdaf : Callable[[int, int, int, 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          int, float], float],
                       py__next_observation_pdaf : Callable[[int, int, 
                                                             int, float], tuple[int, 
                                                             int, float]]
                      ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_assimilate_lestkf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local size of the observation vector

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * A_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_p : int

            * pe-local full state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * dim_l : int

            * local state dimension

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain\n

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * dim_p : int

            * pe-local full state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector\n

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of full observation vector for model sub-domain

        * dim_obs_l : int

            * Size of observation vector for local analysis domain

        * mstate_f : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * dim_p : int

            * Size of full observation vector for model sub-domain

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * dim_l : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain\n

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of observation vector

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * meanvar : float

            * Mean observation error variance

        **Callback Returns**

        * meanvar:float

            * Mean observation error variance\n

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local dimension of observation vector

        * obs_l : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * dim_obs_p : int

            * Dimension of local observation vector

        * meanvar_l : float

            * Mean local observation error variance

        **Callback Returns**

        * meanvar_l:float

            * Mean local observation error variance\n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n


    Returns
    -------
    flag : int
        Status flag
    """
    ...

def assimilate_letkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_dim_obs_pdaf : Callable[[int, int], int],
                      py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_obs_l_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                       int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                      py__prodRinvA_l_pdaf : Callable[[int, int, int, int, 
                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                      py__init_n_domains_p_pdaf : Callable[[int, int], int],
                      py__init_dim_l_pdaf : Callable[[int, int, int], int],
                      py__init_dim_obs_l_pdaf : Callable[[int, int, int, 
                                                          int], int],
                      py__g2l_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__l2g_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__g2l_obs_pdaf : Callable[[int, int, int, int, 
                                                   np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                   int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                   int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                      py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       float], float],
                      py__init_obsvar_l_pdaf : Callable[[int, int, int, 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         int, float], float],
                      py__next_observation_pdaf : Callable[[int, int, int, 
                                                            float], tuple[int, 
                                                            int, float]]
                     ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_assimilate_letkf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local size of the observation vector

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * A_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_p : int

            * pe-local full state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * dim_l : int

            * local state dimension

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain\n

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * dim_p : int

            * pe-local full state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector\n

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of full observation vector for model sub-domain

        * dim_obs_l : int

            * Size of observation vector for local analysis domain

        * mstate_f : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * dim_p : int

            * Size of full observation vector for model sub-domain

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * dim_l : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain\n

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of observation vector

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * meanvar : float

            * Mean observation error variance

        **Callback Returns**

        * meanvar:float

            * Mean observation error variance\n

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local dimension of observation vector

        * obs_l : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * dim_obs_p : int

            * Dimension of local observation vector

        * meanvar_l : float

            * Mean local observation error variance

        **Callback Returns**

        * meanvar_l:float

            * Mean local observation error variance\n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n


    Returns
    -------
    flag : int
        Status flag
    """
    ...

def assimilate_lnetf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_dim_obs_pdaf : Callable[[int, int], int],
                      py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_obs_l_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                       int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                      py__likelihood_l_pdaf : Callable[[int, int, int, 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        float], float],
                      py__init_n_domains_p_pdaf : Callable[[int, int], int],
                      py__init_dim_l_pdaf : Callable[[int, int, int], int],
                      py__init_dim_obs_l_pdaf : Callable[[int, int, int, 
                                                          int], int],
                      py__g2l_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__l2g_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__g2l_obs_pdaf : Callable[[int, int, int, int, 
                                                   np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                   int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                   int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                      py__next_observation_pdaf : Callable[[int, int, int, 
                                                            float], tuple[int, 
                                                            int, float]]
                     ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_assimilate_lnetf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local size of the observation vector

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * resid_l : ndarray[tuple[dim_obs_l], np.float64]

            * nput vector holding the local residual

        * likely_l : float

            * Output value of the local likelihood

        **Callback Returns**

        * likely_l:float

            * Output value of the local likelihood\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_p : int

            * pe-local full state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * dim_l : int

            * local state dimension

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain\n

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * dim_p : int

            * pe-local full state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector\n

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of full observation vector for model sub-domain

        * dim_obs_l : int

            * Size of observation vector for local analysis domain

        * mstate_f : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * dim_p : int

            * Size of full observation vector for model sub-domain

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * dim_l : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain\n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n


    Returns
    -------
    flag : int
        Status flag
    """
    ...

def assimilate_lknetf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__init_dim_obs_pdaf : Callable[[int, int], int],
                       py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__init_obs_l_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__prepoststep_pdaf : Callable[[int, int, int, 
                                                        int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                        int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                       py__prodRinvA_l_pdaf : Callable[[int, int, int, 
                                                        int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                       py__prodRinvA_hyb_l_pdaf : Callable[[int, int, int, 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            float, float], float],
                       py__init_n_domains_p_pdaf : Callable[[int, int], int],
                       py__init_dim_l_pdaf : Callable[[int, int, int], int],
                       py__init_dim_obs_l_pdaf : Callable[[int, int, int, 
                                                           int], int],
                       py__g2l_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__l2g_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__g2l_obs_pdaf : Callable[[int, int, int, int, 
                                                    np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                    int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                    int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                       py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        float], float],
                       py__init_obsvar_l_pdaf : Callable[[int, int, int, 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          int, float], float],
                       py__likelihood_l_pdaf : Callable[[int, int, int, 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         float], float],
                       py__likelihood_hyb_l_pdaf : Callable[[int, int, 
                                                             int, int, 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             float, np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                       py__next_observation_pdaf : Callable[[int, int, 
                                                             int, float], tuple[int, 
                                                             int, float]]
                      ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_assimilate_lknetf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local size of the observation vector

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * A_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix\n

    py__prodRinvA_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, likely_l:float]
        Provide product R^-1 A on local analysis domain with hybrid weight

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * resid_l : ndarray[tuple[dim_obs_l], np.float64]

            * Input vector holding the local residual

        * gamma : float

            * Hybrid weight provided by PDAF

        * likely_l : float

            * Output value of the local likelihood

        **Callback Returns**

        * likely_l:float

            * Output value of the local likelihood\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_p : int

            * pe-local full state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * dim_l : int

            * local state dimension

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain\n

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * dim_p : int

            * pe-local full state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector\n

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of full observation vector for model sub-domain

        * dim_obs_l : int

            * Size of observation vector for local analysis domain

        * mstate_f : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * dim_p : int

            * Size of full observation vector for model sub-domain

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * dim_l : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain\n

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of observation vector

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * meanvar : float

            * Mean observation error variance

        **Callback Returns**

        * meanvar:float

            * Mean observation error variance\n

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local dimension of observation vector

        * obs_l : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * dim_obs_p : int

            * Dimension of local observation vector

        * meanvar_l : float

            * Mean local observation error variance

        **Callback Returns**

        * meanvar_l:float

            * Mean local observation error variance\n

    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute likelihood

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * resid_l : ndarray[tuple[dim_obs_l], np.float64]

            * nput vector holding the local residual

        * likely_l : float

            * Output value of the local likelihood

        **Callback Returns**

        * likely_l:float

            * Output value of the local likelihood\n

    py__likelihood_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Compute likelihood with hybrid weight

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * rank : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * gamma : float

            * Hybrid weight provided by PDAF

        * A_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix\n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide time step, time and dimension of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n


    Returns
    -------
    flag : int
        Status flag
    """
    ...

def assimilate_lseik (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_dim_obs_pdaf : Callable[[int, int], int],
                      py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_obs_l_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                       int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                      py__prodRinvA_l_pdaf : Callable[[int, int, int, int, 
                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                      py__init_n_domains_p_pdaf : Callable[[int, int], int],
                      py__init_dim_l_pdaf : Callable[[int, int, int], int],
                      py__init_dim_obs_l_pdaf : Callable[[int, int, int, 
                                                          int], int],
                      py__g2l_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__l2g_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__g2l_obs_pdaf : Callable[[int, int, int, int, 
                                                   np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                   int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                   int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                      py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       float], float],
                      py__init_obsvar_l_pdaf : Callable[[int, int, int, 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         int, float], float],
                      py__next_observation_pdaf : Callable[[int, int, int, 
                                                            float], tuple[int, 
                                                            int, float]]
                     ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_assimilate_lseik or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local size of the observation vector

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * A_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_p : int

            * pe-local full state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * dim_l : int

            * local state dimension

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain\n

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * dim_p : int

            * pe-local full state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector\n

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of full observation vector for model sub-domain

        * dim_obs_l : int

            * Size of observation vector for local analysis domain

        * mstate_f : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * dim_p : int

            * Size of full observation vector for model sub-domain

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * dim_l : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain\n

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of observation vector

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * meanvar : float

            * Mean observation error variance

        **Callback Returns**

        * meanvar:float

            * Mean observation error variance\n

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local dimension of observation vector

        * obs_l : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * dim_obs_p : int

            * Dimension of local observation vector

        * meanvar_l : float

            * Mean local observation error variance

        **Callback Returns**

        * meanvar_l:float

            * Mean local observation error variance\n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n


    Returns
    -------
    flag : int
        Status flag
    """
    ...

def assimilate_netf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_dim_obs_pdaf : Callable[[int, int], int],
                     py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                     py__likelihood_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     float], float],
                     py__next_observation_pdaf : Callable[[int, int, int, 
                                                           float], tuple[int, 
                                                           int, float]]
                    ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_assimilate_netf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__likelihood_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], resid:ndarray[tuple[dim_obs_p], np.float64], likely:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * resid : ndarray[tuple[dim_obs_p], np.float64]

            * Input vector holding the residual

        * likely : float

            * Output value of the likelihood

        **Callback Returns**

        * likely:float

            * Output value of the likelihood\n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n


    Returns
    -------
    flag : int
        Status flag
    """
    ...

def assimilate_pf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                   py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                   py__init_dim_obs_pdaf : Callable[[int, int], int],
                   py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                   py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                   py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                    int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                    int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                   py__likelihood_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                   float], float],
                   py__next_observation_pdaf : Callable[[int, int, int, 
                                                         float], tuple[int, 
                                                         int, float]]
                  ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_assimilate_pf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__likelihood_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], resid:ndarray[tuple[dim_obs_p], np.float64], likely:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * resid : ndarray[tuple[dim_obs_p], np.float64]

            * Input vector holding the residual

        * likely : float

            * Output value of the likelihood

        **Callback Returns**

        * likely:float

            * Output value of the likelihood\n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n


    Returns
    -------
    flag : int
        Status flag
    """
    ...

def assimilate_seek (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_dim_obs_pdaf : Callable[[int, int], int],
                     py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                     py__prodRinvA_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                     py__next_observation_pdaf : Callable[[int, int, int, 
                                                           float], tuple[int, 
                                                           int, float]]
                    ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_assimilate_seek or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 HV

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one(or the rank of the initial covariance matrix)

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * A_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix\n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n


    Returns
    -------
    flag : int
        Status flag
    """
    ...

def assimilate_seik (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_dim_obs_pdaf : Callable[[int, int], int],
                     py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                     py__prodRinvA_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                     py__next_observation_pdaf : Callable[[int, int, int, 
                                                           float], tuple[int, 
                                                           int, float]]
                    ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_assimilate_seik or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 HV

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one(or the rank of the initial covariance matrix)

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * A_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix\n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n


    Returns
    -------
    flag : int
        Status flag
    """
    ...

def assimilate_prepost (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                        py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                        py__prepoststep_pdaf : Callable[[int, int, int, 
                                                         int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                         int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                        py__next_observation_pdaf : Callable[[int, int, 
                                                              int, float], tuple[int, 
                                                              int, float]]
                       ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_assimilate_prepost or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n


    Returns
    -------
    flag : int
        Status flag
    """
    ...

def deallocate () -> None:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_deallocate or PDAF source files 

    """
    ...

def diag_effsample (weights: np.ndarray[tuple[int], np.dtype[np.float64]]
                   ) -> float:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_diag_effsample or PDAF source files 

    Parameters
    ----------
    weights : ndarray[tuple[dim_sample], np.float64]
        weights of the samples

    Returns
    -------
    effSample : float
        effecfive sample size
    """
    ...

def diag_ensstats (element: int,state: np.ndarray[tuple[int], np.dtype[np.float64]],
                   ens: np.ndarray[tuple[int, int], np.dtype[np.float64]]
                  ) -> tuple[float, float, int]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_diag_ensstats or PDAF source files 

    Parameters
    ----------
    element : int
        ID of element to be used. If element=0, mean values over all elements are computed
    state : ndarray[tuple[dim], np.float64]
        State vector
    ens : ndarray[tuple[dim, dim_ens], np.float64]
        State ensemble

    Returns
    -------
    skewness : float
        Skewness of ensemble
    kurtosis : float
        Kurtosis of ensemble
    status : int
        Status flag (0=success)
    """
    ...

def diag_histogram (ncall: int,element: int,state: np.ndarray[tuple[int], np.dtype[np.float64]],
                    ens: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                    hist: np.ndarray[tuple[int], np.dtype[np.intc]]) -> tuple[np.ndarray[tuple[int], np.dtype[np.intc]], float, int]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_diag_histogram or PDAF source files 

    Parameters
    ----------
    ncall : int
        Number of calls to routine
    element : int
        Element of vector used for histogram
    state : ndarray[tuple[dim], np.float64]
        If element=0, all elements are usedState vector
    ens : ndarray[tuple[dim, dim_ens], np.float64]
        State ensemble
    hist : ndarray[tuple[dim_ens+1], np.intc]
        Histogram about the state

    Returns
    -------
    hist : ndarray[tuple[dim_ens+1], np.intc]
         Histogram about the state
    delta : float
        deviation measure from flat histogram
    status : int
        Status flag (0=success)
    """
    ...

def eofcovar (dim_fields: np.ndarray[tuple[int], np.dtype[np.intc]],offsets: np.ndarray[tuple[int], np.dtype[np.intc]],
              remove_mstate: int,do_mv: int,states: np.ndarray[tuple[int, int], np.dtype[np.float64]],
              meanstate: np.ndarray[tuple[int], np.dtype[np.float64]],verbose: int
             ) -> tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], np.ndarray[tuple[int], np.dtype[np.float64]], 
              np.ndarray[tuple[int], np.dtype[np.float64]], np.ndarray[tuple[int, int], np.dtype[np.float64]], 
              np.ndarray[tuple[int], np.dtype[np.float64]], int]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_eofcovar or PDAF source files 

    Parameters
    ----------
    dim_fields : ndarray[tuple[nfields], np.intc]
        Size of each field
    offsets : ndarray[tuple[nfields], np.intc]
        Start position of each field
    remove_mstate : int
        1: subtract mean state from statesbefore computing EOFs; 0: don't remove
    do_mv : int
        1: Do multivariate scaling; 0: no scalingnfields, dim_fields and offsets are only used if do_mv=1
    states : ndarray[tuple[dim_state, nstates], np.float64]
        State perturbations
    meanstate : ndarray[tuple[dim_state], np.float64]
        Mean state (only changed if remove_mstate=1)
    verbose : int
        Verbosity flag

    Returns
    -------
    states : ndarray[tuple[dim_state, nstates], np.float64]
         State perturbations
    stddev : ndarray[tuple[nfields], np.float64]
         Standard deviation of field variabilityWithout multivariate scaling (do_mv=0), it is stddev = 1.0
    svals : ndarray[tuple[nstates], np.float64]
         Singular values divided by sqrt(nstates-1)
    svec : ndarray[tuple[dim_state, nstates], np.float64]
         Singular vectors
    meanstate : ndarray[tuple[dim_state], np.float64]
         Mean state (only changed if remove_mstate=1)
    status : int
        Status flag
    """
    ...

def gather_dim_obs_f (dim_obs_p: int) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_gather_dim_obs_f or PDAF source files 

    Parameters
    ----------
    dim_obs_p : int
        PE-local observation dimension

    Returns
    -------
    dim_obs_f : int
        Full observation dimension
    """
    ...

def gather_obs_f (obs_p: np.ndarray[tuple[int], np.dtype[np.float64]],dimobs_f: int
                 ) -> tuple[np.ndarray[tuple[int], np.dtype[np.float64]], int]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_gather_obs_f or PDAF source files 

    Parameters
    ----------
    obs_p : ndarray[tuple[dimobs_p], np.float64]
        PE-local vector
    dimobs_f : int
        dimension of full gathered obs

    Returns
    -------
    obs_f : ndarray[tuple[dimobs_f], np.float64]
         Full gathered vector
    status : int
        Status flag:(0) no error(1) when PDAF_gather_dim_obs_f not executed before
    """
    ...

def gather_obs_f2 (coords_p: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                   dimobs_f: int) -> tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], int]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_gather_obs_f2 or PDAF source files 

    Parameters
    ----------
    coords_p : ndarray[tuple[nrows, dimobs_p], np.float64]
        PE-local array
    dimobs_f : int
        dimension of full gathered obs

    Returns
    -------
    coords_f : ndarray[tuple[nrows, dimobs_f], np.float64]
         Full gathered array
    status : int
        Status flag:(0) no error(1) when PDAF_gather dim_obs_f not executed before
    """
    ...

def generate_obs (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                  py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                  py__init_dim_obs_f_pdaf : Callable[[int, int], int],
                  py__obs_op_f_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                  py__get_obs_f_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                  py__init_obserr_f_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                  py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                   int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                   int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                  py__next_observation_pdaf : Callable[[int, int, int, 
                                                        float], tuple[int, 
                                                        int, float]]
                 ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_generate_obs or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_f:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of the full observation vector

        **Callback Returns**

        * dim_obs_f:int

            * Size of the full observation vector\n

    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_f:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_f:ndarray[tuple[dim_obs_f], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_f : int

            * Size of full observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)\n

    py__get_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f:ndarray[tuple[dim_obs_f], np.float64]]
        Provide observation vector to user

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of the full observation vector

        * observation_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of synthetic observations (process-local)

        **Callback Returns**

        * observation_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of synthetic observations (process-local)\n

    py__init_obserr_f_pdaf : Callable[step:int, dim_obs_f:int, obs_f:ndarray[tuple[dim_obs_f], np.float64], obserr_f:ndarray[tuple[dim_obs_f], np.float64]]
        Initialize vector of observation error standard deviations

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_f : int

            * Full dimension of observation vector

        * obs_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observation vector

        * obserr_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observation error stddev

        **Callback Returns**

        * obserr_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observation error stddev\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n


    Returns
    -------
    flag : int
        Status flag
    """
    ...

def get_assim_flag () -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_get_assim_flag or PDAF source files 


    Returns
    -------
    did_assim : int
        Flag: (1) for assimilation; (0) else
    """
    ...

def get_ensstats () -> tuple[np.ndarray[tuple[int, ], np.dtype[float]], np.ndarray[tuple[int, ], np.dtype[float]], 
                   int]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_get_ensstats or PDAF source files 


    Returns
    -------
    dims : ndarray[tuple[1], np.intc]
         dimension of pointer
    c_skew_ptr : ndarray[float]
        Pointer to skewness array
    c_kurt_ptr : ndarray[float]
        Pointer to kurtosis array
    status : int
        Status flag
    """
    ...

def get_localfilter () -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_get_localfilter or PDAF source files 


    Returns
    -------
    lfilter : int
        Whether the filter is domain-localized
    """
    ...

def get_memberid (memberid: int) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_get_memberid or PDAF source files 

    Parameters
    ----------
    memberid : int
        Index in the local ensemble

    Returns
    -------
    memberid : int
        Index in the local ensemble
    """
    ...

def get_obsmemberid (memberid: int) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_get_obsmemberid or PDAF source files 

    Parameters
    ----------
    memberid : int
        Index in the local observed ensemble

    Returns
    -------
    memberid : int
        Index in the local observed ensemble
    """
    ...

def get_smootherens () -> tuple[np.ndarray[tuple[int, ], np.dtype[float]], int, int]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_get_smootherens or PDAF source files 


    Returns
    -------
    c_sens_point : ndarray[float]
        Pointer to smoother array
    maxlag : int
        Number of past timesteps processed in sens
    dims : ndarray[tuple[3], np.intc]
         dimension of pointer
    status : int
        Status flag
    """
    ...

def get_state (steps: int,doexit: int,py__next_observation_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            float], tuple[int, 
                                                                            int, 
                                                                            float]],
               py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
               py__prepoststep_pdaf : Callable[[int, int, int, int, int, 
                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
               flag: int) -> tuple[int, float, int, int]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_get_state or PDAF source files 

    Parameters
    ----------
    steps : int
        Flag and number of time steps
    doexit : int
        Whether to exit from forecasts
    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    flag : int
        Status flag

    Returns
    -------
    steps : int
        Flag and number of time steps
    time : float
        current model time
    doexit : int
        Whether to exit from forecasts
    flag : int
        Status flag
    """
    ...

def init (filtertype: int,subtype: int,stepnull: int,param_int: np.ndarray[tuple[int], np.dtype[np.intc]],
          param_real: np.ndarray[tuple[int], np.dtype[np.float64]],COMM_model: int,
          COMM_filter: int,COMM_couple: int,task_id: int,n_modeltasks: int,
          in_filterpe: bool,py__init_ens_pdaf : Callable[[int, int, int, 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          int]],
          in_screen: int) -> tuple[np.ndarray[tuple[int], np.dtype[np.intc]], np.ndarray[tuple[int], np.dtype[np.float64]], 
                         int]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_init or PDAF source files 

    Parameters
    ----------
    filtertype : int
        Type of filter
    subtype : int
        Sub-type of filter
    stepnull : int
        Initial time step of assimilation
    param_int : ndarray[tuple[dim_pint], np.intc]
        Integer parameter array
    param_real : ndarray[tuple[dim_preal], np.float64]
        Real parameter array
    COMM_model : int
        Model communicator
    COMM_filter : int
        Filter communicator
    COMM_couple : int
        Coupling communicator
    task_id : int
        Id of my ensemble task
    n_modeltasks : int
        Number of parallel model tasks
    in_filterpe : bool
        Is my PE a filter-PE?
    py__init_ens_pdaf : Callable[filtertype:int, dim_p:int, dim_ens:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User-supplied routine for ensemble initialization

        **Callback Parameters**

        * filtertype : int

            * type of filter to initialize

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of ensemble

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local model state

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * array not referenced for ensemble filters

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local model state\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * array not referenced for ensemble filters\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n
        * flag:int

            * pdaf status flag\n

    in_screen : int
        Control screen output:

    Returns
    -------
    param_int : ndarray[tuple[dim_pint], np.intc]
         Integer parameter array
    param_real : ndarray[tuple[dim_preal], np.float64]
         Real parameter array
    flag : int
        Status flag, 0: no error, error codes:
    """
    ...

def local_weight (wtype: int,rtype: int,cradius: float,sradius: float,distance: float,
                  A: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                  var_obs: float,verbose: int) -> float:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_local_weight or PDAF source files 

    Parameters
    ----------
    wtype : int
        Type of weight function
    rtype : int
        Type of regulated weighting
    cradius : float
        Cut-off radius
    sradius : float
        Support radius
    distance : float
        Distance to observation
    A : ndarray[tuple[nrows, ncols], np.float64]
        Input matrix
    var_obs : float
        Observation variance
    verbose : int
        Verbosity flag

    Returns
    -------
    weight : float
        Weights
    """
    ...

def print_info (printtype: int) -> None:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_print_info or PDAF source files 

    Parameters
    ----------
    printtype : int
        Type of screen output
    """
    ...

def put_state_3dvar (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_dim_obs_pdaf : Callable[[int, int], int],
                     py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__prodRinvA_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                     py__cvt_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__cvt_adj_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__obs_op_lin_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__obs_op_adj_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]]]
                    ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_put_state_3dvar or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one(or the rank of the initial covariance matrix)

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * A_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix\n

    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_cvec : int

            * Dimension of control vector

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)\n

    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_cvec : int

            * Dimension of control vector

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector\n

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state\n

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n


    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def put_state_en3dvar_estkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__init_dim_obs_pdaf : Callable[[int, int], int],
                             py__obs_op_pdaf : Callable[[int, int, int, 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__prodRinvA_pdaf : Callable[[int, int, int, 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                             py__cvt_ens_pdaf : Callable[[int, int, int, 
                                                          int, np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__cvt_adj_ens_pdaf : Callable[[int, int, 
                                                              int, int, 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__obs_op_lin_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__obs_op_adj_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__init_obsvar_pdaf : Callable[[int, int, 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              float], float],
                             py__prepoststep_pdaf : Callable[[int, int, 
                                                              int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]]]]
                            ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_put_state_en3dvar_estkf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one(or the rank of the initial covariance matrix)

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * A_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix\n

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local dimension of state

        * dim_ens : int

            * Ensemble size

        * dim_cvec_ens : int

            * Dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * v_p : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment\n

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_ens : int

            * Ensemble size

        * dim_cv_ens_p : int

            * PE-local dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector\n

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state\n

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state\n

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of observation vector

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * meanvar : float

            * Mean observation error variance

        **Callback Returns**

        * meanvar:float

            * Mean observation error variance\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n


    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def put_state_en3dvar_lestkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__init_dim_obs_pdaf : Callable[[int, int], int],
                              py__obs_op_pdaf : Callable[[int, int, int, 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__prodRinvA_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                              py__cvt_ens_pdaf : Callable[[int, int, int, 
                                                           int, np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__cvt_adj_ens_pdaf : Callable[[int, int, 
                                                               int, int, 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__obs_op_lin_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__obs_op_adj_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__init_dim_obs_f_pdaf : Callable[[int, 
                                                                  int], int],
                              py__obs_op_f_pdaf : Callable[[int, int, int, 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__init_obs_f_pdaf : Callable[[int, int, 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__init_obs_l_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__prodRinvA_l_pdaf : Callable[[int, int, 
                                                               int, int, 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                              py__init_n_domains_p_pdaf : Callable[[int, 
                                                                    int], int],
                              py__init_dim_l_pdaf : Callable[[int, int, 
                                                              int], int],
                              py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  int], int],
                              py__g2l_state_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__l2g_state_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__g2l_obs_pdaf : Callable[[int, int, int, 
                                                           int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                           int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                           int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                              py__init_obsvar_pdaf : Callable[[int, int, 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               float], float],
                              py__init_obsvar_l_pdaf : Callable[[int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 int, float], float],
                              py__prepoststep_pdaf : Callable[[int, int, 
                                                               int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]]]]
                             ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_put_state_en3dvar_lestkf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one(or the rank of the initial covariance matrix)

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * A_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix\n

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local dimension of state

        * dim_ens : int

            * Ensemble size

        * dim_cvec_ens : int

            * Dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * v_p : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment\n

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_ens : int

            * Ensemble size

        * dim_cv_ens_p : int

            * PE-local dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector\n

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state\n

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state\n

    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_f:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of the full observation vector

        **Callback Returns**

        * dim_obs_f:int

            * Size of the full observation vector\n

    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_f:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_f:ndarray[tuple[dim_obs_f], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_f : int

            * Size of full observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f:ndarray[tuple[dim_obs_f], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of the full observation vector

        * observation_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of observations

        **Callback Returns**

        * observation_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of observations\n

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local size of the observation vector

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations\n

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * A_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_p : int

            * pe-local full state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * dim_l : int

            * local state dimension

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain\n

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * dim_p : int

            * pe-local full state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector\n

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of full observation vector for model sub-domain

        * dim_obs_l : int

            * Size of observation vector for local analysis domain

        * mstate_f : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * dim_p : int

            * Size of full observation vector for model sub-domain

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * dim_l : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain\n

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of observation vector

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * meanvar : float

            * Mean observation error variance

        **Callback Returns**

        * meanvar:float

            * Mean observation error variance\n

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local dimension of observation vector

        * obs_l : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * dim_obs_p : int

            * Dimension of local observation vector

        * meanvar_l : float

            * Mean local observation error variance

        **Callback Returns**

        * meanvar_l:float

            * Mean local observation error variance\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n


    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def put_state_enkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__init_dim_obs_pdaf : Callable[[int, int], int],
                    py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                    py__add_obs_err_pdaf : Callable[[int, int, np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                    py__init_obs_covar_pdaf : Callable[[int, int, int, 
                                                        float, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        bool], tuple[float, 
                                                        bool]]
                   ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_put_state_enkf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__add_obs_err_pdaf : Callable[step:int, dim_obs_p:int, C_p:ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]]
        Add obs error covariance R to HPH in EnKF

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Dimension of observation vector

        * C_p : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            * Matrix to that observation covariance R is added

        **Callback Returns**

        * C_p : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            * Matrix to that observation covariance R is added\n

    py__init_obs_covar_pdaf : Callable[step:int, dim_obs:int, dim_obs_p:int, covar:float, obs_p:ndarray[tuple[dim_obs_p], np.float64], isdiag:bool]
        Initialize obs. error cov. matrix R in EnKF

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs : int

            * Global size of observation vector

        * dim_obs_p : int

            * Size of process-local observation vector

        * covar : float

            * Observation error covariance matrix

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Process-local vector of observations

        * isdiag : bool

            * 

        **Callback Returns**

        * covar:float

            * Observation error covariance matrix\n
        * isdiag:bool

            * \n


    Returns
    -------
    flag : int
        Status flag
    """
    ...

def put_state_estkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_dim_obs_pdaf : Callable[[int, int], int],
                     py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                     py__prodRinvA_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                     py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      float], float]
                    ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_put_state_estkf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one(or the rank of the initial covariance matrix)

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * A_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix\n

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of observation vector

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * meanvar : float

            * Mean observation error variance

        **Callback Returns**

        * meanvar:float

            * Mean observation error variance\n


    Returns
    -------
    flag : int
        Status flag
    """
    ...

def put_state_etkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__init_dim_obs_pdaf : Callable[[int, int], int],
                    py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                    py__prodRinvA_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                    py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     float], float]
                   ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_put_state_etkf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one(or the rank of the initial covariance matrix)

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * A_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix\n

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of observation vector

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * meanvar : float

            * Mean observation error variance

        **Callback Returns**

        * meanvar:float

            * Mean observation error variance\n


    Returns
    -------
    flag : int
        Status flag
    """
    ...

def put_state_generate_obs (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_dim_obs_f_pdaf : Callable[[int, int], int],
                            py__obs_op_f_pdaf : Callable[[int, int, int, 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__get_obs_f_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_obserr_f_pdaf : Callable[[int, int, 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__prepoststep_pdaf : Callable[[int, int, 
                                                             int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]]]
                           ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_put_state_generate_obs or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_f:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of the full observation vector

        **Callback Returns**

        * dim_obs_f:int

            * Size of the full observation vector\n

    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_f:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_f:ndarray[tuple[dim_obs_f], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_f : int

            * Size of full observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)\n

    py__get_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f:ndarray[tuple[dim_obs_f], np.float64]]
        Provide observation vector to user

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of the full observation vector

        * observation_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of synthetic observations (process-local)

        **Callback Returns**

        * observation_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of synthetic observations (process-local)\n

    py__init_obserr_f_pdaf : Callable[step:int, dim_obs_f:int, obs_f:ndarray[tuple[dim_obs_f], np.float64], obserr_f:ndarray[tuple[dim_obs_f], np.float64]]
        Initialize vector of observation errors

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_f : int

            * Full dimension of observation vector

        * obs_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observation vector

        * obserr_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observation error stddev

        **Callback Returns**

        * obserr_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observation error stddev\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n


    Returns
    -------
    flag : int
        Status flag
    """
    ...

def put_state_hyb3dvar_estkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__init_dim_obs_pdaf : Callable[[int, int], int],
                              py__obs_op_pdaf : Callable[[int, int, int, 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__prodRinvA_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                              py__cvt_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__cvt_adj_pdaf : Callable[[int, int, int, 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__cvt_ens_pdaf : Callable[[int, int, int, 
                                                           int, np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__cvt_adj_ens_pdaf : Callable[[int, int, 
                                                               int, int, 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__obs_op_lin_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__obs_op_adj_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                              py__init_obsvar_pdaf : Callable[[int, int, 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               float], float],
                              py__prepoststep_pdaf : Callable[[int, int, 
                                                               int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]]]]
                             ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_put_state_hyb3dvar_estkf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one(or the rank of the initial covariance matrix)

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * A_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix\n

    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_cvec : int

            * Dimension of control vector

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)\n

    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_cvec : int

            * Dimension of control vector

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector\n

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local dimension of state

        * dim_ens : int

            * Ensemble size

        * dim_cvec_ens : int

            * Dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * v_p : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment\n

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_ens : int

            * Ensemble size

        * dim_cv_ens_p : int

            * PE-local dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector\n

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state\n

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state\n

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of observation vector

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * meanvar : float

            * Mean observation error variance

        **Callback Returns**

        * meanvar:float

            * Mean observation error variance\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n


    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def put_state_hyb3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__init_dim_obs_pdaf : Callable[[int, int], int],
                               py__obs_op_pdaf : Callable[[int, int, int, 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__init_obs_pdaf : Callable[[int, int, 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__prodRinvA_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                               py__cvt_ens_pdaf : Callable[[int, int, int, 
                                                            int, np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__cvt_adj_ens_pdaf : Callable[[int, int, 
                                                                int, int, 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__cvt_pdaf : Callable[[int, int, int, 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__cvt_adj_pdaf : Callable[[int, int, int, 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__obs_op_lin_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__obs_op_adj_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__init_dim_obs_f_pdaf : Callable[[int, 
                                                                   int], int],
                               py__obs_op_f_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__init_obs_f_pdaf : Callable[[int, int, 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__init_obs_l_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__prodRinvA_l_pdaf : Callable[[int, int, 
                                                                int, int, 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                               py__init_n_domains_p_pdaf : Callable[[int, 
                                                                     int], int],
                               py__init_dim_l_pdaf : Callable[[int, int, 
                                                               int], int],
                               py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int], int],
                               py__g2l_state_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__l2g_state_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                               py__g2l_obs_pdaf : Callable[[int, int, int, 
                                                            int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                            int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                            int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                               py__init_obsvar_pdaf : Callable[[int, int, 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                float], float],
                               py__init_obsvar_l_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  int, 
                                                                  float], float],
                               py__prepoststep_pdaf : Callable[[int, int, 
                                                                int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]]]]
                              ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_put_state_hyb3dvar_lestkf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one(or the rank of the initial covariance matrix)

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * A_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix\n

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local dimension of state

        * dim_ens : int

            * Ensemble size

        * dim_cvec_ens : int

            * Dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * v_p : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment\n

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_ens : int

            * Ensemble size

        * dim_cv_ens_p : int

            * PE-local dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector\n

    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_cvec : int

            * Dimension of control vector

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)\n

    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_cvec : int

            * Dimension of control vector

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector\n

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state\n

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state\n

    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_f:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of the full observation vector

        **Callback Returns**

        * dim_obs_f:int

            * Size of the full observation vector\n

    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_f:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_f:ndarray[tuple[dim_obs_f], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_f : int

            * Size of full observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f:ndarray[tuple[dim_obs_f], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of the full observation vector

        * observation_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of observations

        **Callback Returns**

        * observation_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of observations\n

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local size of the observation vector

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations\n

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * A_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_p : int

            * pe-local full state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * dim_l : int

            * local state dimension

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain\n

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * dim_p : int

            * pe-local full state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector\n

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of full observation vector for model sub-domain

        * dim_obs_l : int

            * Size of observation vector for local analysis domain

        * mstate_f : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * dim_p : int

            * Size of full observation vector for model sub-domain

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * dim_l : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain\n

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of observation vector

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * meanvar : float

            * Mean observation error variance

        **Callback Returns**

        * meanvar:float

            * Mean observation error variance\n

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local dimension of observation vector

        * obs_l : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * dim_obs_p : int

            * Dimension of local observation vector

        * meanvar_l : float

            * Mean local observation error variance

        **Callback Returns**

        * meanvar_l:float

            * Mean local observation error variance\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n


    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def put_state_lenkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_dim_obs_pdaf : Callable[[int, int], int],
                     py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                     py__localize_covar_pdaf : Callable[[int, int, np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]]], tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                     py__add_obs_err_pdaf : Callable[[int, int, np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                     py__init_obs_covar_pdaf : Callable[[int, int, int, 
                                                         float, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         bool], tuple[float, 
                                                         bool]]
                    ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_put_state_lenkf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__localize_covar_pdaf : Callable[dim_p:int, dim_obs:int, hp_p:ndarray[tuple[dim_obs, dim_p], np.float64], hph:ndarray[tuple[dim_obs, dim_obs], np.float64]]
        Apply localization to HP and HPH^T

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * dim_obs : int

            * number of observations

        * hp_p : ndarray[tuple[dim_obs, dim_p], np.float64]

            * pe local part of matrix hp

        * hph : ndarray[tuple[dim_obs, dim_obs], np.float64]

            * matrix hph

        **Callback Returns**

        * hp_p : ndarray[tuple[dim_obs, dim_p], np.float64]

            * pe local part of matrix hp\n
        * hph : ndarray[tuple[dim_obs, dim_obs], np.float64]

            * matrix hph\n

    py__add_obs_err_pdaf : Callable[step:int, dim_obs_p:int, C_p:ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]]
        Add obs error covariance R to HPH in EnKF

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Dimension of observation vector

        * C_p : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            * Matrix to that observation covariance R is added

        **Callback Returns**

        * C_p : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]

            * Matrix to that observation covariance R is added\n

    py__init_obs_covar_pdaf : Callable[step:int, dim_obs:int, dim_obs_p:int, covar:float, obs_p:ndarray[tuple[dim_obs_p], np.float64], isdiag:bool]
        Initialize obs. error cov. matrix R in EnKF

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs : int

            * Global size of observation vector

        * dim_obs_p : int

            * Size of process-local observation vector

        * covar : float

            * Observation error covariance matrix

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Process-local vector of observations

        * isdiag : bool

            * 

        **Callback Returns**

        * covar:float

            * Observation error covariance matrix\n
        * isdiag:bool

            * \n


    Returns
    -------
    flag : int
        Status flag
    """
    ...

def put_state_lestkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_dim_obs_pdaf : Callable[[int, int], int],
                      py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_obs_l_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                       int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                      py__prodRinvA_l_pdaf : Callable[[int, int, int, int, 
                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                      py__init_n_domains_p_pdaf : Callable[[int, int], int],
                      py__init_dim_l_pdaf : Callable[[int, int, int], int],
                      py__init_dim_obs_l_pdaf : Callable[[int, int, int, 
                                                          int], int],
                      py__g2l_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__l2g_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__g2l_obs_pdaf : Callable[[int, int, int, int, 
                                                   np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                   int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                   int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                      py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       float], float],
                      py__init_obsvar_l_pdaf : Callable[[int, int, int, 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         int, float], float]
                     ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_put_state_lestkf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local size of the observation vector

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * A_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_p : int

            * pe-local full state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * dim_l : int

            * local state dimension

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain\n

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * dim_p : int

            * pe-local full state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector\n

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of full observation vector for model sub-domain

        * dim_obs_l : int

            * Size of observation vector for local analysis domain

        * mstate_f : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * dim_p : int

            * Size of full observation vector for model sub-domain

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * dim_l : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain\n

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of observation vector

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * meanvar : float

            * Mean observation error variance

        **Callback Returns**

        * meanvar:float

            * Mean observation error variance\n

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local dimension of observation vector

        * obs_l : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * dim_obs_p : int

            * Dimension of local observation vector

        * meanvar_l : float

            * Mean local observation error variance

        **Callback Returns**

        * meanvar_l:float

            * Mean local observation error variance\n


    Returns
    -------
    flag : int
        Status flag
    """
    ...

def put_state_letkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_dim_obs_pdaf : Callable[[int, int], int],
                     py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_obs_l_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                     py__prodRinvA_l_pdaf : Callable[[int, int, int, int, 
                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                     py__init_n_domains_p_pdaf : Callable[[int, int], int],
                     py__init_dim_l_pdaf : Callable[[int, int, int], int],
                     py__init_dim_obs_l_pdaf : Callable[[int, int, int, 
                                                         int], int],
                     py__g2l_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__l2g_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__g2l_obs_pdaf : Callable[[int, int, int, int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                  int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                  int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                     py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      float], float],
                     py__init_obsvar_l_pdaf : Callable[[int, int, int, 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        int, float], float]
                    ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_put_state_letkf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local size of the observation vector

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * A_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_p : int

            * pe-local full state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * dim_l : int

            * local state dimension

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain\n

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * dim_p : int

            * pe-local full state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector\n

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of full observation vector for model sub-domain

        * dim_obs_l : int

            * Size of observation vector for local analysis domain

        * mstate_f : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * dim_p : int

            * Size of full observation vector for model sub-domain

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * dim_l : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain\n

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of observation vector

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * meanvar : float

            * Mean observation error variance

        **Callback Returns**

        * meanvar:float

            * Mean observation error variance\n

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local dimension of observation vector

        * obs_l : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * dim_obs_p : int

            * Dimension of local observation vector

        * meanvar_l : float

            * Mean local observation error variance

        **Callback Returns**

        * meanvar_l:float

            * Mean local observation error variance\n


    Returns
    -------
    flag : int
        Status flag
    """
    ...

def put_state_lnetf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_dim_obs_pdaf : Callable[[int, int], int],
                     py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_obs_l_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                     py__likelihood_l_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       float], float],
                     py__init_n_domains_p_pdaf : Callable[[int, int], int],
                     py__init_dim_l_pdaf : Callable[[int, int, int], int],
                     py__init_dim_obs_l_pdaf : Callable[[int, int, int, 
                                                         int], int],
                     py__g2l_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__l2g_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__g2l_obs_pdaf : Callable[[int, int, int, int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                  int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                  int], np.ndarray[tuple[int], np.dtype[np.intc]]]
                    ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_put_state_lnetf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local size of the observation vector

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * resid_l : ndarray[tuple[dim_obs_l], np.float64]

            * nput vector holding the local residual

        * likely_l : float

            * Output value of the local likelihood

        **Callback Returns**

        * likely_l:float

            * Output value of the local likelihood\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_p : int

            * pe-local full state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * dim_l : int

            * local state dimension

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain\n

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * dim_p : int

            * pe-local full state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector\n

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of full observation vector for model sub-domain

        * dim_obs_l : int

            * Size of observation vector for local analysis domain

        * mstate_f : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * dim_p : int

            * Size of full observation vector for model sub-domain

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * dim_l : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain\n


    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def put_state_lknetf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_dim_obs_pdaf : Callable[[int, int], int],
                      py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_obs_l_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                       int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                      py__prodRinvA_l_pdaf : Callable[[int, int, int, int, 
                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                      py__prodRinvA_hyb_l_pdaf : Callable[[int, int, int, 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           float, float], float],
                      py__init_n_domains_p_pdaf : Callable[[int, int], int],
                      py__init_dim_l_pdaf : Callable[[int, int, int], int],
                      py__init_dim_obs_l_pdaf : Callable[[int, int, int, 
                                                          int], int],
                      py__g2l_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__l2g_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__g2l_obs_pdaf : Callable[[int, int, int, int, 
                                                   np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                   int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                   int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                      py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       float], float],
                      py__init_obsvar_l_pdaf : Callable[[int, int, int, 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         int, float], float],
                      py__likelihood_l_pdaf : Callable[[int, int, int, 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        float], float],
                      py__likelihood_hyb_l_pdaf : Callable[[int, int, int, 
                                                            int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            float, np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]]
                     ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_put_state_lknetf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local size of the observation vector

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * A_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix\n

    py__prodRinvA_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, likely_l:float]
        Provide product R^-1 A on local analysis domain with hybrid weight

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * resid_l : ndarray[tuple[dim_obs_l], np.float64]

            * Input vector holding the local residual

        * gamma : float

            * Hybrid weight provided by PDAF

        * likely_l : float

            * Output value of the local likelihood

        **Callback Returns**

        * likely_l:float

            * Output value of the local likelihood\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_p : int

            * pe-local full state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * dim_l : int

            * local state dimension

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain\n

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * dim_p : int

            * pe-local full state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector\n

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of full observation vector for model sub-domain

        * dim_obs_l : int

            * Size of observation vector for local analysis domain

        * mstate_f : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * dim_p : int

            * Size of full observation vector for model sub-domain

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * dim_l : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain\n

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of observation vector

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * meanvar : float

            * Mean observation error variance

        **Callback Returns**

        * meanvar:float

            * Mean observation error variance\n

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local dimension of observation vector

        * obs_l : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * dim_obs_p : int

            * Dimension of local observation vector

        * meanvar_l : float

            * Mean local observation error variance

        **Callback Returns**

        * meanvar_l:float

            * Mean local observation error variance\n

    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute likelihood

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * resid_l : ndarray[tuple[dim_obs_l], np.float64]

            * nput vector holding the local residual

        * likely_l : float

            * Output value of the local likelihood

        **Callback Returns**

        * likely_l:float

            * Output value of the local likelihood\n

    py__likelihood_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Compute likelihood with hybrid weight

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * rank : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * gamma : float

            * Hybrid weight provided by PDAF

        * A_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix\n


    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def put_state_lseik (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_dim_obs_pdaf : Callable[[int, int], int],
                     py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__init_obs_l_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                      int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                     py__prodRinvA_l_pdaf : Callable[[int, int, int, int, 
                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                     py__init_n_domains_p_pdaf : Callable[[int, int], int],
                     py__init_dim_l_pdaf : Callable[[int, int, int], int],
                     py__init_dim_obs_l_pdaf : Callable[[int, int, int, 
                                                         int], int],
                     py__g2l_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__l2g_state_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                     py__g2l_obs_pdaf : Callable[[int, int, int, int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                  int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                  int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                     py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      float], float],
                     py__init_obsvar_l_pdaf : Callable[[int, int, int, 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        int, float], float]
                    ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_put_state_lseik or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local size of the observation vector

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * A_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_p : int

            * pe-local full state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * dim_l : int

            * local state dimension

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain\n

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * dim_p : int

            * pe-local full state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector\n

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of full observation vector for model sub-domain

        * dim_obs_l : int

            * Size of observation vector for local analysis domain

        * mstate_f : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * dim_p : int

            * Size of full observation vector for model sub-domain

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * dim_l : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain\n

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of observation vector

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * meanvar : float

            * Mean observation error variance

        **Callback Returns**

        * meanvar:float

            * Mean observation error variance\n

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local dimension of observation vector

        * obs_l : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * dim_obs_p : int

            * Dimension of local observation vector

        * meanvar_l : float

            * Mean local observation error variance

        **Callback Returns**

        * meanvar_l:float

            * Mean local observation error variance\n


    Returns
    -------
    flag : int
        Status flag
    """
    ...

def put_state_netf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__init_dim_obs_pdaf : Callable[[int, int], int],
                    py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                    py__likelihood_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    float], float]
                   ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_put_state_netf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__likelihood_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], resid:ndarray[tuple[dim_obs_p], np.float64], likely:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * resid : ndarray[tuple[dim_obs_p], np.float64]

            * Input vector holding the residual

        * likely : float

            * Output value of the likelihood

        **Callback Returns**

        * likely:float

            * Output value of the likelihood\n


    Returns
    -------
    flag : int
        Status flag
    """
    ...

def put_state_pf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                  py__init_dim_obs_pdaf : Callable[[int, int], int],
                  py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                  py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                  py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                   int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                   int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                  py__likelihood_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                  float], float]
                 ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_put_state_pf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__likelihood_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], resid:ndarray[tuple[dim_obs_p], np.float64], likely:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * resid : ndarray[tuple[dim_obs_p], np.float64]

            * Input vector holding the residual

        * likely : float

            * Output value of the likelihood

        **Callback Returns**

        * likely:float

            * Output value of the likelihood\n


    Returns
    -------
    flag : int
        Status flag
    """
    ...

def put_state_prepost (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                       py__prepoststep_pdaf : Callable[[int, int, int, 
                                                        int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                        int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]]]]
                      ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_put_state_prepost or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n


    Returns
    -------
    flag : int
        Status flag
    """
    ...

def put_state_seek (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__init_dim_obs_pdaf : Callable[[int, int], int],
                    py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                    py__prodRinvA_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]]
                   ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_put_state_seek or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 HV

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one(or the rank of the initial covariance matrix)

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * A_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix\n


    Returns
    -------
    flag : int
        Status flag
    """
    ...

def put_state_seik (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__init_dim_obs_pdaf : Callable[[int, int], int],
                    py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                    py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                     int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                    py__prodRinvA_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                    py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     float], float]
                   ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_put_state_seik or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one(or the rank of the initial covariance matrix)

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * A_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix\n

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of observation vector

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * meanvar : float

            * Mean observation error variance

        **Callback Returns**

        * meanvar:float

            * Mean observation error variance\n


    Returns
    -------
    flag : int
        Status flag
    """
    ...

def reset_forget (forget_in: float) -> None:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_reset_forget or PDAF source files 

    Parameters
    ----------
    forget_in : float
        New value of forgetting factor
    """
    ...

def SampleEns (modes: np.ndarray[tuple[int, int], np.dtype[np.float64]],
               svals: np.ndarray[tuple[int], np.dtype[np.float64]],state: np.ndarray[tuple[int], np.dtype[np.float64]],
               verbose: int,flag: int) -> tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], np.ndarray[tuple[int], np.dtype[np.float64]], 
                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                      int]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_SampleEns or PDAF source files 

    Parameters
    ----------
    modes : ndarray[tuple[dim, dim_ens-1], np.float64]
        Array of EOF modes
    svals : ndarray[tuple[dim_ens-1], np.float64]
        Vector of singular values
    state : ndarray[tuple[dim], np.float64]
        PE-local model state
    verbose : int
        Verbosity flag
    flag : int
        Status flag

    Returns
    -------
    modes : ndarray[tuple[dim, dim_ens-1], np.float64]
         Array of EOF modes
    state : ndarray[tuple[dim], np.float64]
         PE-local model state
    ens : ndarray[tuple[dim, dim_ens], np.float64]
         State ensemble
    flag : int
        Status flag
    """
    ...

def set_debug_flag (debugval: int) -> None:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_set_debug_flag or PDAF source files 

    Parameters
    ----------
    debugval : int
        Value of debugging flag; print debug information for >0
    """
    ...

def set_ens_pointer () -> tuple[np.ndarray[tuple[int, ], np.dtype[float]], int]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_set_ens_pointer or PDAF source files 


    Returns
    -------
    c_ens_point : ndarray[float]
        Pointer to smoother array
    dims : ndarray[tuple[2], np.intc]
         dimension of the pointer
    status : int
        Status flag
    """
    ...

def set_smootherens (maxlag: int) -> tuple[np.ndarray[tuple[int, ], np.dtype[float]], int]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_set_smootherens or PDAF source files 

    Parameters
    ----------
    maxlag : int
        Number of past timesteps processed in sens

    Returns
    -------
    c_sens_point : ndarray[float]
        Pointer to smoother array
    dims : ndarray[tuple[3], np.intc]
         dimension of the pointer
    status : int
        Status flag
    """
    ...

def seik_TtimesA (A: np.ndarray[tuple[int, int], np.dtype[np.float64]]
                 ) -> np.ndarray[tuple[int, int], np.dtype[np.float64]]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_seik_TtimesA or PDAF source files 

    Parameters
    ----------
    A : ndarray[tuple[rank, dim_col], np.float64]
        Input matrix

    Returns
    -------
    B : ndarray[tuple[rank+1, dim_col], np.float64]
         Output matrix (TA)
    """
    ...

def etkf_Tleft (A: np.ndarray[tuple[int, int], np.dtype[np.float64]]) -> np.ndarray[tuple[int, int], np.dtype[np.float64]]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_etkf_Tleft or PDAF source files 

    Parameters
    ----------
    A : ndarray[tuple[dim_ens, dim], np.float64]
        Input/output matrix

    Returns
    -------
    A : ndarray[tuple[dim_ens, dim], np.float64]
         Input/output matrix
    """
    ...

def estkf_OmegaA (A: np.ndarray[tuple[int, int], np.dtype[np.float64]]
                 ) -> np.ndarray[tuple[int, int], np.dtype[np.float64]]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_estkf_OmegaA or PDAF source files 

    Parameters
    ----------
    A : ndarray[tuple[rank, dim_col], np.float64]
        Input matrix

    Returns
    -------
    B : ndarray[tuple[rank+1, dim_col], np.float64]
         Output matrix (TA)
    """
    ...

def enkf_omega (seed: np.ndarray[tuple[int], np.dtype[np.intc]],omega: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                norm: float,otype: int,screen: int) -> tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], float]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_enkf_omega or PDAF source files 

    Parameters
    ----------
    seed : ndarray[tuple[4], np.intc]
        Seed for random number generation
    omega : ndarray[tuple[dim_ens, r], np.float64]
        Random matrix
    norm : float
        Norm for ensemble transformation
    otype : int
        Type of omega
    screen : int
        Verbosity flag

    Returns
    -------
    omega : ndarray[tuple[dim_ens, r], np.float64]
         Random matrix
    norm : float
        Norm for ensemble transformation
    """
    ...

def seik_omega (omega: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                omegatype: int,screen: int) -> np.ndarray[tuple[int, int], np.dtype[np.float64]]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_seik_omega or PDAF source files 

    Parameters
    ----------
    omega : ndarray[tuple[rank+1, rank], np.float64]
        Matrix Omega
    omegatype : int
        Select type of omega
    screen : int
        Verbosity flag

    Returns
    -------
    omega : ndarray[tuple[rank+1, rank], np.float64]
         Matrix Omega
    """
    ...

def incremental (steps: int,py__dist_stateinc_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               int, int], None]
                ) -> None:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_incremental or PDAF source files 

    Parameters
    ----------
    steps : int
        Time steps over which increment is distributed
    py__dist_stateinc_pdaf : Callable[dim_p:int, state_inc_p:ndarray[tuple[dim_p], np.float64], first:int, steps:int]
        Add state increment during integration

        **Callback Parameters**

        * dim_p : int

            * Dimension of PE-local state

        * state_inc_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state vector

        * first : int

            * Flag for first call of each forecast

        * steps : int

            * number of time steps in forecast

        **Callback Returns**


    """
    ...

def add_increment (state_p: np.ndarray[tuple[int], np.dtype[np.float64]]
                  ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_add_increment or PDAF source files 

    Parameters
    ----------
    state_p : ndarray[tuple[dim_p], np.float64]
        State vector

    Returns
    -------
    state_p : ndarray[tuple[dim_p], np.float64]
         State vector
    """
    ...

def local_weights (wtype: int,cradius: float,sradius: float,distance: np.ndarray[tuple[int], np.dtype[np.float64]],
                   verbose: int) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_local_weights or PDAF source files 

    Parameters
    ----------
    wtype : int
        Type of weight function(0): unit weight (=1 up to distance=cradius)(1): exponential decrease (1/e at distance=sradius; 0 for distance>cradius)(2): 5th order polynomial (Gaspari&Cohn 1999; 0 for distance>cradius)
    cradius : float
        Parameter for cut-off
    sradius : float
        Support radius
    distance : ndarray[tuple[dim], np.float64]
        Array holding distances
    verbose : int
        Verbosity flag

    Returns
    -------
    weight : ndarray[tuple[dim], np.float64]
         Array for weights
    """
    ...

def diag_CRPS (element: int,oens: np.ndarray[tuple[int, int], np.dtype[np.float64]],
               obs: np.ndarray[tuple[int], np.dtype[np.float64]]) -> tuple[float, float, float, float, int]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_diag_CRPS or PDAF source files 

    Parameters
    ----------
    element : int
        ID of element to be used. If element=0, mean values over all elements are computed
    oens : ndarray[tuple[dim, dim_ens], np.float64]
        State ensemble
    obs : ndarray[tuple[dim], np.float64]
        State ensemble

    Returns
    -------
    CRPS : float
        CRPS
    reli : float
        Reliability
    resol : float
        resolution
    uncert : float
        uncertainty
    status : int
        Status flag (0=success)
    """
    ...

def force_analysis () -> None:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_force_analysis or PDAF source files 

    """
    ...

def gather_obs_f2_flex (dim_obs_f: int,coords_p: np.ndarray[tuple[int, int], np.dtype[np.float64]]
                       ) -> tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], int]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_gather_obs_f2_flex or PDAF source files 

    Parameters
    ----------
    dim_obs_f : int
        Full observation dimension
    coords_p : ndarray[tuple[nrows, dim_obs_p], np.float64]
        PE-local array

    Returns
    -------
    coords_f : ndarray[tuple[nrows, dim_obs_f], np.float64]
         Full gathered array
    status : int
        Status flag: (0) no error
    """
    ...

def gather_obs_f_flex (dim_obs_f: int,obs_p: np.ndarray[tuple[int], np.dtype[np.float64]]
                      ) -> tuple[np.ndarray[tuple[int], np.dtype[np.float64]], int]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_gather_obs_f_flex or PDAF source files 

    Parameters
    ----------
    dim_obs_f : int
        Full observation dimension
    obs_p : ndarray[tuple[dim_obs_p], np.float64]
        PE-local vector

    Returns
    -------
    obs_f : ndarray[tuple[dim_obs_f], np.float64]
         Full gathered vector
    status : int
        Status flag: (0) no error
    """
    ...

def prepost (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
             py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
             py__prepoststep_pdaf : Callable[[int, int, int, int, int, 
                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                              int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                              np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
             py__next_observation_pdaf : Callable[[int, int, int, float], tuple[int, 
                                                   int, float]]
            ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_prepost or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide time step, time and dimension of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n


    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def set_memberid (memberid: int) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_set_memberid or PDAF source files 

    Parameters
    ----------
    memberid : int
        Index in the local ensemble

    Returns
    -------
    memberid : int
        Index in the local ensemble
    """
    ...

def set_comm_pdaf (in_COMM_pdaf: int) -> None:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_set_comm_pdaf or PDAF source files 

    Parameters
    ----------
    in_COMM_pdaf : int
        MPI communicator for PDAF
    """
    ...

def set_offline_mode (screen: int) -> None:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_set_offline_mode or PDAF source files 

    Parameters
    ----------
    screen : int
        Verbosity flag
    """
    ...

def print_domain_stats (n_domains_p: int) -> None:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_print_domain_stats or PDAF source files 

    Parameters
    ----------
    n_domains_p : int
        Number of PE-local analysis domains
    """
    ...

def init_local_obsstats () -> None:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_init_local_obsstats or PDAF source files 

    """
    ...

def incr_local_obsstats (dim_obs_l: int) -> None:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_incr_local_obsstats or PDAF source files 

    Parameters
    ----------
    dim_obs_l : int
        Number of locally assimilated observations
    """
    ...

def print_local_obsstats (screen: int) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_print_local_obsstats or PDAF source files 

    Parameters
    ----------
    screen : int
        Verbosity flag

    Returns
    -------
    n_domains_with_obs : int
        number of domains with observations
    """
    ...

def omit_obs_omi (state_p: np.ndarray[tuple[int], np.dtype[np.float64]],
                  ens_p: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                  obs_p: np.ndarray[tuple[int], np.dtype[np.float64]],py__init_obs_pdaf : Callable[[int, 
                                                                                                    int, 
                                                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                  py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                  compute_mean: int,screen: int) -> tuple[np.ndarray[tuple[int], np.dtype[np.float64]], np.ndarray[tuple[int], np.dtype[np.float64]], 
                                              ]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAF_omit_obs_omi or PDAF source files 

    Parameters
    ----------
    state_p : ndarray[tuple[dim_p], np.float64]
        on exit: PE-local forecast mean state
    ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]
        PE-local state ensemble
    obs_p : ndarray[tuple[dim_obs_p], np.float64]
        PE-local observation vector
    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    compute_mean : int
        (1) compute mean; (0) state_p holds mean
    screen : int
        Verbosity flag

    Returns
    -------
    state_p : ndarray[tuple[dim_p], np.float64]
         on exit: PE-local forecast mean state
    obs_p : ndarray[tuple[dim_obs_p], np.float64]
         PE-local observation vector
    """
    ...

def omi_init (n_obs: int) -> None:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_init or PDAF source files 

    Parameters
    ----------
    n_obs : int
        number of observations
    """
    ...

def omi_set_doassim (i_obs: int,doassim: int) -> None:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_set_doassim or PDAF source files 

    Parameters
    ----------
    i_obs : int
        index of observations
    doassim : int
        setter value
    """
    ...

def omi_set_disttype (i_obs: int,disttype: int) -> None:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_set_disttype or PDAF source files 

    Parameters
    ----------
    i_obs : int
        index of observations
    disttype : int
        setter value
    """
    ...

def omi_set_ncoord (i_obs: int,ncoord: int) -> None:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_set_ncoord or PDAF source files 

    Parameters
    ----------
    i_obs : int
        index of observations
    ncoord : int
        setter value
    """
    ...

def omi_set_id_obs_p (i_obs: int,id_obs_p: np.ndarray[tuple[int, int], np.dtype[np.intc]]
                     ) -> None:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_set_id_obs_p or PDAF source files 

    Parameters
    ----------
    i_obs : int
        index of observations
    id_obs_p : ndarray[tuple[nrows, dim_obs_p], np.intc]
        setter value
    """
    ...

def omi_set_icoeff_p (i_obs: int,icoeff_p: np.ndarray[tuple[int, int], np.dtype[np.float64]]
                     ) -> None:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_set_icoeff_p or PDAF source files 

    Parameters
    ----------
    i_obs : int
        index of observations
    icoeff_p : ndarray[tuple[nrows, dim_obs_p], np.float64]
        setter value
    """
    ...

def omi_set_domainsize (i_obs: int,domainsize: np.ndarray[tuple[int], np.dtype[np.float64]]
                       ) -> None:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_set_domainsize or PDAF source files 

    Parameters
    ----------
    i_obs : int
        index of observations
    domainsize : ndarray[tuple[ncoord], np.float64]
        setter value
    """
    ...

def omi_set_obs_err_type (i_obs: int,obs_err_type: int) -> None:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_set_obs_err_type or PDAF source files 

    Parameters
    ----------
    i_obs : int
        index of observations
    obs_err_type : int
        setter value
    """
    ...

def omi_set_use_global_obs (i_obs: int,use_global_obs: int) -> None:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_set_use_global_obs or PDAF source files 

    Parameters
    ----------
    i_obs : int
        index of observations
    use_global_obs : int
        setter value
    """
    ...

def omi_set_inno_omit (i_obs: int,inno_omit: float) -> None:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_set_inno_omit or PDAF source files 

    Parameters
    ----------
    i_obs : int
        index of observations
    inno_omit : float
        setter value
    """
    ...

def omi_set_inno_omit_ivar (i_obs: int,inno_omit_ivar: float) -> None:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_set_inno_omit_ivar or PDAF source files 

    Parameters
    ----------
    i_obs : int
        index of observations
    inno_omit_ivar : float
        setter value
    """
    ...

def omi_gather_obs (i_obs: int,obs_p: np.ndarray[tuple[int], np.dtype[np.float64]],
                    ivar_obs_p: np.ndarray[tuple[int], np.dtype[np.float64]],
                    ocoord_p: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                    cradius: float) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/pdafomi_gather_obs or PDAF source files 

    Parameters
    ----------
    i_obs : int
        index of observations
    obs_p : ndarray[tuple[dim_obs_p], np.float64]
        pe-local observation vector
    ivar_obs_p : ndarray[tuple[dim_obs_p], np.float64]
        pe-local inverse observation error variance
    ocoord_p : ndarray[tuple[thisobs(i_obs)%ncoord, dim_obs_p], np.float64]
        pe-local observation coordinates
    cradius : float
        localization radius

    Returns
    -------
    dim_obs : int
        Full number of observations
    """
    ...

def omi_gather_obsstate (i_obs: int,obsstate_p: np.ndarray[tuple[int], np.dtype[np.float64]],
                         obsstate_f: np.ndarray[tuple[int], np.dtype[np.float64]]
                        ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_gather_obsstate or PDAF source files 

    Parameters
    ----------
    i_obs : int
        index of observations
    obsstate_p : ndarray[tuple[thisobs(i_obs)%dim_obs_p], np.float64]
        Vector of process-local observed state
    obsstate_f : ndarray[tuple[nobs_f_all], np.float64]
        Full observed vector for all types

    Returns
    -------
    obsstate_f : ndarray[tuple[nobs_f_all], np.float64]
         Full observed vector for all types
    """
    ...

def omi_set_domain_limits (lim_coords: np.ndarray[tuple[int, int], np.dtype[np.float64]]
                          ) -> None:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_set_domain_limits or PDAF source files 

    Parameters
    ----------
    lim_coords : ndarray[tuple[2, 2], np.float64]
        geographic coordinate array (1: longitude, 2: latitude)
    """
    ...

def omi_set_debug_flag (debugval: int) -> None:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_set_debug_flag or PDAF source files 

    Parameters
    ----------
    debugval : int
        Value for debugging flag
    """
    ...

def omi_deallocate_obs (i_obs: int) -> None:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_deallocate_obs or PDAF source files 

    Parameters
    ----------
    i_obs : int
        index of observations
    """
    ...

def omi_obs_op_gridpoint (i_obs: int,state_p: np.ndarray[tuple[int], np.dtype[np.float64]],
                          obs_f_all: np.ndarray[tuple[int], np.dtype[np.float64]]
                         ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_obs_op_gridpoint or PDAF source files 

    Parameters
    ----------
    i_obs : int
        index of observations
    state_p : ndarray[tuple[dim_p], np.float64]
        PE-local model state (dim_p)
    obs_f_all : ndarray[tuple[nobs_f_all], np.float64]
        Full observed state for all observation types (nobs_f_all)

    Returns
    -------
    obs_f_all : ndarray[tuple[nobs_f_all], np.float64]
         Full observed state for all observation types (nobs_f_all)
    """
    ...

def omi_obs_op_gridavg (i_obs: int,nrows: int,state_p: np.ndarray[tuple[int], np.dtype[np.float64]],
                        obs_f_all: np.ndarray[tuple[int], np.dtype[np.float64]]
                       ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_obs_op_gridavg or PDAF source files 

    Parameters
    ----------
    i_obs : int
        index of observations
    nrows : int
        Number of values to be averaged
    state_p : ndarray[tuple[dim_p], np.float64]
        PE-local model state (dim_p)
    obs_f_all : ndarray[tuple[nobs_f_all], np.float64]
        Full observed state for all observation types (nobs_f_all)

    Returns
    -------
    obs_f_all : ndarray[tuple[nobs_f_all], np.float64]
         Full observed state for all observation types (nobs_f_all)
    """
    ...

def omi_obs_op_interp_lin (i_obs: int,nrows: int,state_p: np.ndarray[tuple[int], np.dtype[np.float64]],
                           obs_f_all: np.ndarray[tuple[int], np.dtype[np.float64]]
                          ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_obs_op_interp_lin or PDAF source files 

    Parameters
    ----------
    i_obs : int
        index of observations
    nrows : int
        Number of values to be averaged
    state_p : ndarray[tuple[dim_p], np.float64]
        PE-local model state (dim_p)
    obs_f_all : ndarray[tuple[nobs_f_all], np.float64]
        Full observed state for all observation types (nobs_f_all)

    Returns
    -------
    obs_f_all : ndarray[tuple[nobs_f_all], np.float64]
         Full observed state for all observation types (nobs_f_all)
    """
    ...

def omi_obs_op_adj_gridavg (i_obs: int,nrows: int,state_p: np.ndarray[tuple[int], np.dtype[np.float64]],
                            obs_f_all: np.ndarray[tuple[int], np.dtype[np.float64]]
                           ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_obs_op_adj_gridavg or PDAF source files 

    Parameters
    ----------
    i_obs : int
        index of observations
    nrows : int
        Number of values to be averaged
    state_p : ndarray[tuple[dim_p], np.float64]
        PE-local model state (dim_p)
    obs_f_all : ndarray[tuple[nobs_f_all], np.float64]
        Full observed state for all observation types (nobs_f_all)

    Returns
    -------
    state_p : ndarray[tuple[dim_p], np.float64]
         PE-local model state (dim_p)
    """
    ...

def omi_obs_op_adj_gridpoint (i_obs: int,state_p: np.ndarray[tuple[int], np.dtype[np.float64]],
                              obs_f_all: np.ndarray[tuple[int], np.dtype[np.float64]]
                             ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_obs_op_adj_gridpoint or PDAF source files 

    Parameters
    ----------
    i_obs : int
        index of observations
    state_p : ndarray[tuple[dim_p], np.float64]
        PE-local model state (dim_p)
    obs_f_all : ndarray[tuple[nobs_f_all], np.float64]
        Full observed state for all observation types (nobs_f_all)

    Returns
    -------
    state_p : ndarray[tuple[dim_p], np.float64]
         PE-local model state (dim_p)
    """
    ...

def omi_obs_op_adj_interp_lin (i_obs: int,nrows: int,state_p: np.ndarray[tuple[int], np.dtype[np.float64]],
                               obs_f_all: np.ndarray[tuple[int], np.dtype[np.float64]]
                              ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_obs_op_adj_interp_lin or PDAF source files 

    Parameters
    ----------
    i_obs : int
        index of observations
    nrows : int
        Number of values to be averaged
    state_p : ndarray[tuple[dim_p], np.float64]
        PE-local model state (dim_p)
    obs_f_all : ndarray[tuple[nobs_f_all], np.float64]
        Full observed state for all observation types (nobs_f_all)

    Returns
    -------
    state_p : ndarray[tuple[dim_p], np.float64]
         PE-local model state (dim_p)
    """
    ...

def omi_get_interp_coeff_tri (gpc: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                              oc: np.ndarray[tuple[int], np.dtype[np.float64]],
                              icoeff: np.ndarray[tuple[int], np.dtype[np.float64]]
                             ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_get_interp_coeff_tri or PDAF source files 

    Parameters
    ----------
    gpc : ndarray[tuple[3, 2], np.float64]
        Coordinates of grid points; dim(3,2)
    oc : ndarray[tuple[2], np.float64]
        3 rows; each containing lon and lat coordinatesCoordinates of observation; dim(2)
    icoeff : ndarray[tuple[3], np.float64]
        Interpolation coefficients; dim(3)

    Returns
    -------
    icoeff : ndarray[tuple[3], np.float64]
         Interpolation coefficients; dim(3)
    """
    ...

def omi_get_interp_coeff_lin1D (gpc: np.ndarray[tuple[int], np.dtype[np.float64]],
                                oc: float,icoeff: np.ndarray[tuple[int], np.dtype[np.float64]]
                               ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_get_interp_coeff_lin1D or PDAF source files 

    Parameters
    ----------
    gpc : ndarray[tuple[2], np.float64]
        Coordinates of grid points (dim=2)
    oc : float
        Coordinates of observation
    icoeff : ndarray[tuple[2], np.float64]
        Interpolation coefficients (dim=2)

    Returns
    -------
    icoeff : ndarray[tuple[2], np.float64]
         Interpolation coefficients (dim=2)
    """
    ...

def omi_get_interp_coeff_lin (gpc: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                              oc: np.ndarray[tuple[int], np.dtype[np.float64]],
                              icoeff: np.ndarray[tuple[int], np.dtype[np.float64]]
                             ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_get_interp_coeff_lin or PDAF source files 

    Parameters
    ----------
    gpc : ndarray[tuple[num_gp, n_dim], np.float64]
        Coordinates of grid points
    oc : ndarray[tuple[n_dim], np.float64]
        Coordinates of observation
    icoeff : ndarray[tuple[num_gp], np.float64]
        Interpolation coefficients (num_gp)

    Returns
    -------
    icoeff : ndarray[tuple[num_gp], np.float64]
         Interpolation coefficients (num_gp)
    """
    ...

def omi_assimilate_3dvar (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__init_dim_obs_pdaf : Callable[[int, int], int],
                          py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__cvt_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__cvt_adj_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__obs_op_lin_pdaf : Callable[[int, int, int, 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__obs_op_adj_pdaf : Callable[[int, int, int, 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__prepoststep_pdaf : Callable[[int, int, int, 
                                                           int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                          py__next_observation_pdaf : Callable[[int, int, 
                                                                int, float], tuple[int, 
                                                                int, float]],
                          outflag: int) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_assimilate_3dvar or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_cvec : int

            * Dimension of control vector

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)\n

    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_cvec : int

            * Dimension of control vector

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector\n

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state\n

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_assimilate_en3dvar_estkf (py__collect_state_pdaf : Callable[[int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__distribute_state_pdaf : Callable[[int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__init_dim_obs_pdaf : Callable[[int, 
                                                                    int], int],
                                  py__obs_op_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__cvt_ens_pdaf : Callable[[int, int, 
                                                               int, int, 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__obs_op_lin_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__obs_op_adj_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__prepoststep_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                  py__next_observation_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        float], tuple[int, 
                                                                        int, 
                                                                        float]],
                                  outflag: int) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_assimilate_en3dvar_estkf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local dimension of state

        * dim_ens : int

            * Ensemble size

        * dim_cvec_ens : int

            * Dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * v_p : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment\n

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_ens : int

            * Ensemble size

        * dim_cv_ens_p : int

            * PE-local dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector\n

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state\n

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_assimilate_en3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__distribute_state_pdaf : Callable[[int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__init_dim_obs_f_pdaf : Callable[[int, 
                                                                       int], int],
                                   py__obs_op_f_pdaf : Callable[[int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__cvt_ens_pdaf : Callable[[int, int, 
                                                                int, int, 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__obs_op_lin_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__obs_op_adj_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__init_n_domains_p_pdaf : Callable[[int, 
                                                                         int], int],
                                   py__init_dim_l_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int], int],
                                   py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int, 
                                                                       int], int],
                                   py__g2l_state_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__l2g_state_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__prepoststep_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                   py__next_observation_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         float], tuple[int, 
                                                                         int, 
                                                                         float]],
                                   outflag: int) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_assimilate_en3dvar_lestkf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_f:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of the full observation vector

        **Callback Returns**

        * dim_obs_f:int

            * Size of the full observation vector\n

    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_f:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_f:ndarray[tuple[dim_obs_f], np.float64]]
        Full observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_f : int

            * Size of full observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)\n

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local dimension of state

        * dim_ens : int

            * Ensemble size

        * dim_cvec_ens : int

            * Dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * v_p : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment\n

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_ens : int

            * Ensemble size

        * dim_cv_ens_p : int

            * PE-local dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector\n

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state\n

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_p : int

            * pe-local full state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * dim_l : int

            * local state dimension

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain\n

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from local state

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * dim_p : int

            * pe-local full state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_assimilate_global (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                           py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                           py__init_dim_obs_pdaf : Callable[[int, int], int],
                           py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                           py__prepoststep_pdaf : Callable[[int, int, int, 
                                                            int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                           py__next_observation_pdaf : Callable[[int, int, 
                                                                 int, float], tuple[int, 
                                                                 int, float]]
                          ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_assimilate_global or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n


    Returns
    -------
    flag : int
        Status flag
    """
    ...

def omi_assimilate_hyb3dvar_estkf (py__collect_state_pdaf : Callable[[int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__distribute_state_pdaf : Callable[[int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__init_dim_obs_pdaf : Callable[[int, 
                                                                     int], int],
                                   py__obs_op_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__cvt_ens_pdaf : Callable[[int, int, 
                                                                int, int, 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__cvt_pdaf : Callable[[int, int, int, 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__cvt_adj_pdaf : Callable[[int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__obs_op_lin_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__obs_op_adj_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__prepoststep_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                   py__next_observation_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         float], tuple[int, 
                                                                         int, 
                                                                         float]],
                                   outflag: int) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_assimilate_hyb3dvar_estkf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply ensemble control vector transform matrix to control vector

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local dimension of state

        * dim_ens : int

            * Ensemble size

        * dim_cvec_ens : int

            * Dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * v_p : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment\n

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint ensemble control vector transform matrix

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_ens : int

            * Ensemble size

        * dim_cv_ens_p : int

            * PE-local dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector\n

    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_cvec : int

            * Dimension of control vector

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)\n

    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_cvec : int

            * Dimension of control vector

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector\n

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state\n

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_assimilate_hyb3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__distribute_state_pdaf : Callable[[int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__init_dim_obs_f_pdaf : Callable[[int, 
                                                                        int], int],
                                    py__obs_op_f_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__cvt_ens_pdaf : Callable[[int, int, 
                                                                 int, int, 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__cvt_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__cvt_adj_pdaf : Callable[[int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__obs_op_lin_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__obs_op_adj_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__init_n_domains_p_pdaf : Callable[[int, 
                                                                          int], int],
                                    py__init_dim_l_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int], int],
                                    py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        int], int],
                                    py__g2l_state_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__l2g_state_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__prepoststep_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                    py__next_observation_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          float], tuple[int, 
                                                                          int, 
                                                                          float]],
                                    outflag: int) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_assimilate_hyb3dvar_lestkf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_f:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of the full observation vector

        **Callback Returns**

        * dim_obs_f:int

            * Size of the full observation vector\n

    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_f:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_f:ndarray[tuple[dim_obs_f], np.float64]]
        Full observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_f : int

            * Size of full observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)\n

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local dimension of state

        * dim_ens : int

            * Ensemble size

        * dim_cvec_ens : int

            * Dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * v_p : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment\n

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_ens : int

            * Ensemble size

        * dim_cv_ens_p : int

            * PE-local dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector\n

    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_cvec : int

            * Dimension of control vector

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)\n

    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_cvec : int

            * Dimension of control vector

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector\n

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state\n

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_p : int

            * pe-local full state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * dim_l : int

            * local state dimension

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain\n

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from local state

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * dim_p : int

            * pe-local full state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_assimilate_lenkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__init_dim_obs_pdaf : Callable[[int, int], int],
                          py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__prepoststep_pdaf : Callable[[int, int, int, 
                                                           int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                          py__localize_covar_pdaf : Callable[[int, int, 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]]], tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                          py__next_observation_pdaf : Callable[[int, int, 
                                                                int, float], tuple[int, 
                                                                int, float]]
                         ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_assimilate_lenkf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__localize_covar_pdaf : Callable[dim_p:int, dim_obs:int, hp_p:ndarray[tuple[dim_obs, dim_p], np.float64], hph:ndarray[tuple[dim_obs, dim_obs], np.float64]]
        Apply localization to HP and HPH^T

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * dim_obs : int

            * number of observations

        * hp_p : ndarray[tuple[dim_obs, dim_p], np.float64]

            * pe local part of matrix hp

        * hph : ndarray[tuple[dim_obs, dim_obs], np.float64]

            * matrix hph

        **Callback Returns**

        * hp_p : ndarray[tuple[dim_obs, dim_p], np.float64]

            * pe local part of matrix hp\n
        * hph : ndarray[tuple[dim_obs, dim_obs], np.float64]

            * matrix hph\n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n


    Returns
    -------
    flag : int
        Status flag
    """
    ...

def omi_assimilate_local (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__init_dim_obs_pdaf : Callable[[int, int], int],
                          py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__prepoststep_pdaf : Callable[[int, int, int, 
                                                           int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                          py__init_n_domains_p_pdaf : Callable[[int, int], int],
                          py__init_dim_l_pdaf : Callable[[int, int, int], int],
                          py__init_dim_obs_l_pdaf : Callable[[int, int, 
                                                              int, int], int],
                          py__g2l_state_pdaf : Callable[[int, int, int, 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__l2g_state_pdaf : Callable[[int, int, int, 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__next_observation_pdaf : Callable[[int, int, 
                                                                int, float], tuple[int, 
                                                                int, float]]
                         ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_assimilate_local or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_p : int

            * pe-local full state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * dim_l : int

            * local state dimension

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain\n

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * dim_p : int

            * pe-local full state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector\n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n


    Returns
    -------
    flag : int
        Status flag
    """
    ...

def omi_generate_obs (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__init_dim_obs_f_pdaf : Callable[[int, int], int],
                      py__obs_op_f_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__get_obs_f_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                      py__prepoststep_pdaf : Callable[[int, int, int, int, 
                                                       int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                      py__next_observation_pdaf : Callable[[int, int, int, 
                                                            float], tuple[int, 
                                                            int, float]]
                     ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_generate_obs or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_f:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of the full observation vector

        **Callback Returns**

        * dim_obs_f:int

            * Size of the full observation vector\n

    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_f:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_f:ndarray[tuple[dim_obs_f], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_f : int

            * Size of full observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)\n

    py__get_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f:ndarray[tuple[dim_obs_f], np.float64]]
        Provide observation vector to user

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of the full observation vector

        * observation_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of synthetic observations (process-local)

        **Callback Returns**

        * observation_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of synthetic observations (process-local)\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step and time of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n


    Returns
    -------
    flag : int
        Status flag
    """
    ...

def omi_put_state_3dvar (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                         py__init_dim_obs_pdaf : Callable[[int, int], int],
                         py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                         py__cvt_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                         py__cvt_adj_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                         py__obs_op_lin_pdaf : Callable[[int, int, int, 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                         py__obs_op_adj_pdaf : Callable[[int, int, int, 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                         py__prepoststep_pdaf : Callable[[int, int, int, 
                                                          int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                         outflag: int) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_put_state_3dvar or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_cvec : int

            * Dimension of control vector

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)\n

    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_cvec : int

            * Dimension of control vector

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector\n

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state\n

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_put_state_en3dvar_estkf (py__collect_state_pdaf : Callable[[int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                 py__init_dim_obs_pdaf : Callable[[int, 
                                                                   int], int],
                                 py__obs_op_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                 py__cvt_ens_pdaf : Callable[[int, int, 
                                                              int, int, 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                 py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                 py__obs_op_lin_pdaf : Callable[[int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                 py__obs_op_adj_pdaf : Callable[[int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                 py__prepoststep_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                  int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                 outflag: int) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_put_state_en3dvar_estkf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local dimension of state

        * dim_ens : int

            * Ensemble size

        * dim_cvec_ens : int

            * Dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * v_p : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment\n

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_ens : int

            * Ensemble size

        * dim_cv_ens_p : int

            * PE-local dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector\n

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state\n

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_put_state_en3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__init_dim_obs_f_pdaf : Callable[[int, 
                                                                      int], int],
                                  py__obs_op_f_pdaf : Callable[[int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__cvt_ens_pdaf : Callable[[int, int, 
                                                               int, int, 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__obs_op_lin_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__obs_op_adj_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__init_n_domains_p_pdaf : Callable[[int, 
                                                                        int], int],
                                  py__init_dim_l_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int], int],
                                  py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      int], int],
                                  py__g2l_state_pdaf : Callable[[int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__l2g_state_pdaf : Callable[[int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__prepoststep_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                  outflag: int) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_put_state_en3dvar_lestkf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_f:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of the full observation vector

        **Callback Returns**

        * dim_obs_f:int

            * Size of the full observation vector\n

    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_f:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_f:ndarray[tuple[dim_obs_f], np.float64]]
        Full observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_f : int

            * Size of full observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)\n

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local dimension of state

        * dim_ens : int

            * Ensemble size

        * dim_cvec_ens : int

            * Dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * v_p : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment\n

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_ens : int

            * Ensemble size

        * dim_cv_ens_p : int

            * PE-local dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector\n

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state\n

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_p : int

            * pe-local full state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * dim_l : int

            * local state dimension

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain\n

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from local state

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * dim_p : int

            * pe-local full state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_put_state_generate_obs (py__collect_state_pdaf : Callable[[int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__init_dim_obs_f_pdaf : Callable[[int, 
                                                                    int], int],
                                py__obs_op_f_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__get_obs_f_pdaf : Callable[[int, int, 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                py__prepoststep_pdaf : Callable[[int, int, 
                                                                 int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                 int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]]]]
                               ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_put_state_generate_obs or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_f:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of the full observation vector

        **Callback Returns**

        * dim_obs_f:int

            * Size of the full observation vector\n

    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_f:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_f:ndarray[tuple[dim_obs_f], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_f : int

            * Size of full observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)\n

    py__get_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f:ndarray[tuple[dim_obs_f], np.float64]]
        Provide observation vector to user

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of the full observation vector

        * observation_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of synthetic observations (process-local)

        **Callback Returns**

        * observation_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of synthetic observations (process-local)\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n


    Returns
    -------
    flag : int
        Status flag
    """
    ...

def omi_put_state_global (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__init_dim_obs_pdaf : Callable[[int, int], int],
                          py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                          py__prepoststep_pdaf : Callable[[int, int, int, 
                                                           int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int, int], np.dtype[np.float64]]]]
                         ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_put_state_global or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n


    Returns
    -------
    flag : int
        Status flag
    """
    ...

def omi_put_state_hyb3dvar_estkf (py__collect_state_pdaf : Callable[[int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__init_dim_obs_pdaf : Callable[[int, 
                                                                    int], int],
                                  py__obs_op_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__cvt_ens_pdaf : Callable[[int, int, 
                                                               int, int, 
                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__cvt_pdaf : Callable[[int, int, int, 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__cvt_adj_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__obs_op_lin_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__obs_op_adj_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__prepoststep_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                  outflag: int) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_put_state_hyb3dvar_estkf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply ensemble control vector transform matrix to control vector

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local dimension of state

        * dim_ens : int

            * Ensemble size

        * dim_cvec_ens : int

            * Dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * v_p : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment\n

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint ensemble control vector transform matrix

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_ens : int

            * Ensemble size

        * dim_cv_ens_p : int

            * PE-local dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector\n

    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_cvec : int

            * Dimension of control vector

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)\n

    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_cvec : int

            * Dimension of control vector

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector\n

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state\n

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_put_state_hyb3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__init_dim_obs_f_pdaf : Callable[[int, 
                                                                       int], int],
                                   py__obs_op_f_pdaf : Callable[[int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__cvt_ens_pdaf : Callable[[int, int, 
                                                                int, int, 
                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__cvt_pdaf : Callable[[int, int, int, 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__cvt_adj_pdaf : Callable[[int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__obs_op_lin_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__obs_op_adj_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__init_n_domains_p_pdaf : Callable[[int, 
                                                                         int], int],
                                   py__init_dim_l_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int], int],
                                   py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int, 
                                                                       int], int],
                                   py__g2l_state_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__l2g_state_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                   py__prepoststep_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                   outflag: int) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_put_state_hyb3dvar_lestkf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_f:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of the full observation vector

        **Callback Returns**

        * dim_obs_f:int

            * Size of the full observation vector\n

    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_f:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_f:ndarray[tuple[dim_obs_f], np.float64]]
        Full observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_f : int

            * Size of full observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)\n

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local dimension of state

        * dim_ens : int

            * Ensemble size

        * dim_cvec_ens : int

            * Dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * v_p : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment\n

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_ens : int

            * Ensemble size

        * dim_cv_ens_p : int

            * PE-local dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector\n

    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_cvec : int

            * Dimension of control vector

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)\n

    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_cvec : int

            * Dimension of control vector

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector\n

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state\n

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_p : int

            * pe-local full state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * dim_l : int

            * local state dimension

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain\n

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from local state

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * dim_p : int

            * pe-local full state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def omi_put_state_lenkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                         py__init_dim_obs_pdaf : Callable[[int, int], int],
                         py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                         py__prepoststep_pdaf : Callable[[int, int, int, 
                                                          int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                         py__localize_covar_pdaf : Callable[[int, int, 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]], tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]]]
                        ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_put_state_lenkf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__localize_covar_pdaf : Callable[dim_p:int, dim_obs:int, hp_p:ndarray[tuple[dim_obs, dim_p], np.float64], hph:ndarray[tuple[dim_obs, dim_obs], np.float64]]
        Apply localization to HP and HPH^T

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * dim_obs : int

            * number of observations

        * hp_p : ndarray[tuple[dim_obs, dim_p], np.float64]

            * pe local part of matrix hp

        * hph : ndarray[tuple[dim_obs, dim_obs], np.float64]

            * matrix hph

        **Callback Returns**

        * hp_p : ndarray[tuple[dim_obs, dim_p], np.float64]

            * pe local part of matrix hp\n
        * hph : ndarray[tuple[dim_obs, dim_obs], np.float64]

            * matrix hph\n


    Returns
    -------
    flag : int
        Status flag
    """
    ...

def omi_put_state_local (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                         py__init_dim_obs_pdaf : Callable[[int, int], int],
                         py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                         py__prepoststep_pdaf : Callable[[int, int, int, 
                                                          int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                         py__init_n_domains_p_pdaf : Callable[[int, int], int],
                         py__init_dim_l_pdaf : Callable[[int, int, int], int],
                         py__init_dim_obs_l_pdaf : Callable[[int, int, 
                                                             int, int], int],
                         py__g2l_state_pdaf : Callable[[int, int, int, 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                         py__l2g_state_pdaf : Callable[[int, int, int, 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]]
                        ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_put_state_local or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__g2l_state_pdaf : Callable[step:int, domain_p:int, dim_p:int, state_p:ndarray[tuple[dim_p], np.float64], dim_l:int, state_l:ndarray[tuple[dim_l], np.float64]]
        Get state on local ana. domain from full state

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_p : int

            * pe-local full state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        * dim_l : int

            * local state dimension

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        **Callback Returns**

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain\n

    py__l2g_state_pdaf : Callable[step:int, domain_p:int, dim_l:int, state_l:ndarray[tuple[dim_l], np.float64], dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Init full state from state on local analysis domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        * state_l : ndarray[tuple[dim_l], np.float64]

            * state vector on local analysis domain

        * dim_p : int

            * pe-local full state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local full state vector\n


    Returns
    -------
    flag : int
        Status flag
    """
    ...

def omi_init_obs_f_cb (step: int,dim_obs_f: int,observation_f: np.ndarray[tuple[int], np.dtype[np.float64]]
                      ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_init_obs_f_cb or PDAF source files 

    Parameters
    ----------
    step : int
        Current time step
    dim_obs_f : int
        Dimension of full observation vector
    observation_f : ndarray[tuple[dim_obs_f], np.float64]
        Full observation vector

    Returns
    -------
    observation_f : ndarray[tuple[dim_obs_f], np.float64]
         Full observation vector
    """
    ...

def omi_init_obsvar_cb (step: int,dim_obs_p: int,obs_p: np.ndarray[tuple[int], np.dtype[np.float64]],
                        meanvar: float) -> float:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_init_obsvar_cb or PDAF source files 

    Parameters
    ----------
    step : int
        Current time step
    dim_obs_p : int
        PE-local dimension of observation vector
    obs_p : ndarray[tuple[dim_obs_p], np.float64]
        PE-local observation vector
    meanvar : float
        Mean observation error variance

    Returns
    -------
    meanvar : float
        Mean observation error variance
    """
    ...

def omi_g2l_obs_cb (domain_p: int,step: int,dim_obs_f: int,dim_obs_l: int,
                    ostate_f: np.ndarray[tuple[int], np.dtype[np.float64]],
                    ostate_l: np.ndarray[tuple[int], np.dtype[np.float64]]
                   ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_g2l_obs_cb or PDAF source files 

    Parameters
    ----------
    domain_p : int
        Index of current local analysis domain
    step : int
        Current time step
    dim_obs_f : int
        Dimension of full PE-local observation vector
    dim_obs_l : int
        Dimension of local observation vector
    ostate_f : ndarray[tuple[dim_obs_f], np.float64]
        Full PE-local obs.ervation vector
    ostate_l : ndarray[tuple[dim_obs_l], np.float64]
        Observation vector on local domain

    Returns
    -------
    ostate_l : ndarray[tuple[dim_obs_l], np.float64]
         Observation vector on local domain
    """
    ...

def omi_init_obs_l_cb (domain_p: int,step: int,dim_obs_l: int,observation_l: np.ndarray[tuple[int], np.dtype[np.float64]]
                      ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_init_obs_l_cb or PDAF source files 

    Parameters
    ----------
    domain_p : int
        Index of current local analysis domain index
    step : int
        Current time step
    dim_obs_l : int
        Local dimension of observation vector
    observation_l : ndarray[tuple[dim_obs_l], np.float64]
        Local observation vector

    Returns
    -------
    observation_l : ndarray[tuple[dim_obs_l], np.float64]
         Local observation vector
    """
    ...

def omi_init_obsvar_l_cb (domain_p: int,step: int,dim_obs_l: int,obs_l: np.ndarray[tuple[int], np.dtype[np.float64]],
                          meanvar_l: float) -> float:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_init_obsvar_l_cb or PDAF source files 

    Parameters
    ----------
    domain_p : int
        Index of current local analysis domain
    step : int
        Current time step
    dim_obs_l : int
        Local dimension of observation vector
    obs_l : ndarray[tuple[dim_obs_l], np.float64]
        Local observation vector
    meanvar_l : float
        Mean local observation error variance

    Returns
    -------
    meanvar_l : float
        Mean local observation error variance
    """
    ...

def omi_prodRinvA_l_cb (domain_p: int,step: int,dim_obs_l: int,rank: int,
                        obs_l: np.ndarray[tuple[int], np.dtype[np.float64]],
                        A_l: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                        C_l: np.ndarray[tuple[int, int], np.dtype[np.float64]]
                       ) -> tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                      ]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_prodRinvA_l_cb or PDAF source files 

    Parameters
    ----------
    domain_p : int
        Index of current local analysis domain
    step : int
        Current time step
    dim_obs_l : int
        Dimension of local observation vector
    rank : int
        Rank of initial covariance matrix
    obs_l : ndarray[tuple[dim_obs_l], np.float64]
        Local vector of observations
    A_l : ndarray[tuple[dim_obs_l, rank], np.float64]
        Input matrix
    C_l : ndarray[tuple[dim_obs_l, rank], np.float64]
        Output matrix

    Returns
    -------
    A_l : ndarray[tuple[dim_obs_l, rank], np.float64]
         Input matrix
    C_l : ndarray[tuple[dim_obs_l, rank], np.float64]
         Output matrix
    """
    ...

def omi_likelihood_l_cb (domain_p: int,step: int,dim_obs_l: int,obs_l: np.ndarray[tuple[int], np.dtype[np.float64]],
                         resid_l: np.ndarray[tuple[int], np.dtype[np.float64]],
                         lhood_l: float) -> tuple[np.ndarray[tuple[int], np.dtype[np.float64]], float]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_likelihood_l_cb or PDAF source files 

    Parameters
    ----------
    domain_p : int
        Current local analysis domain
    step : int
        Current time step
    dim_obs_l : int
        PE-local dimension of obs. vector
    obs_l : ndarray[tuple[dim_obs_l], np.float64]
        PE-local vector of observations
    resid_l : ndarray[tuple[dim_obs_l], np.float64]
        Input vector of residuum
    lhood_l : float
        Output vector - log likelihood

    Returns
    -------
    resid_l : ndarray[tuple[dim_obs_l], np.float64]
         Input vector of residuum
    lhood_l : float
        Output vector - log likelihood
    """
    ...

def omi_prodRinvA_cb (step: int,dim_obs_p: int,ncol: int,obs_p: np.ndarray[tuple[int], np.dtype[np.float64]],
                      A_p: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                      C_p: np.ndarray[tuple[int, int], np.dtype[np.float64]]
                     ) -> np.ndarray[tuple[int, int], np.dtype[np.float64]]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_prodRinvA_cb or PDAF source files 

    Parameters
    ----------
    step : int
        Current time step
    dim_obs_p : int
        Dimension of PE-local observation vector
    ncol : int
        Number of columns in A_p and C_p
    obs_p : ndarray[tuple[dim_obs_p], np.float64]
        PE-local vector of observations
    A_p : ndarray[tuple[dim_obs_p, ncol], np.float64]
        Input matrix
    C_p : ndarray[tuple[dim_obs_p, ncol], np.float64]
        Output matrix

    Returns
    -------
    C_p : ndarray[tuple[dim_obs_p, ncol], np.float64]
         Output matrix
    """
    ...

def omi_likelihood_cb (step: int,dim_obs: int,obs: np.ndarray[tuple[int], np.dtype[np.float64]],
                       resid: np.ndarray[tuple[int], np.dtype[np.float64]],
                       lhood: float) -> float:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_likelihood_cb or PDAF source files 

    Parameters
    ----------
    step : int
        Current time step
    dim_obs : int
        PE-local dimension of obs. vector
    obs : ndarray[tuple[dim_obs], np.float64]
        PE-local vector of observations
    resid : ndarray[tuple[dim_obs], np.float64]
        Input vector of residuum
    lhood : float
        Output vector - log likelihood

    Returns
    -------
    lhood : float
        Output vector - log likelihood
    """
    ...

def omi_add_obs_error_cb (step: int,dim_obs_p: int,C_p: np.ndarray[tuple[int, int], np.dtype[np.float64]]
                         ) -> np.ndarray[tuple[int, int], np.dtype[np.float64]]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_add_obs_error_cb or PDAF source files 

    Parameters
    ----------
    step : int
        Current time step
    dim_obs_p : int
        Dimension of PE-local observation vector
    C_p : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]
        Matrix to which R is added

    Returns
    -------
    C_p : ndarray[tuple[dim_obs_p, dim_obs_p], np.float64]
         Matrix to which R is added
    """
    ...

def omi_init_obscovar_cb (step: int,dim_obs: int,dim_obs_p: int,covar: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                          m_state_p: np.ndarray[tuple[int], np.dtype[np.float64]],
                          isdiag: bool) -> tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], bool]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_init_obscovar_cb or PDAF source files 

    Parameters
    ----------
    step : int
        Current time step
    dim_obs : int
        Dimension of observation vector
    dim_obs_p : int
        PE-local dimension of obs. vector
    covar : ndarray[tuple[dim_obs, dim_obs], np.float64]
        Observation error covar. matrix
    m_state_p : ndarray[tuple[dim_obs_p], np.float64]
        Observation vector
    isdiag : bool
        Whether matrix R is diagonal

    Returns
    -------
    covar : ndarray[tuple[dim_obs, dim_obs], np.float64]
         Observation error covar. matrix
    isdiag : bool
        Whether matrix R is diagonal
    """
    ...

def omi_init_obserr_f_cb (step: int,dim_obs_f: int,obs_f: np.ndarray[tuple[int], np.dtype[np.float64]],
                          obserr_f: np.ndarray[tuple[int], np.dtype[np.float64]]
                         ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_init_obserr_f_cb or PDAF source files 

    Parameters
    ----------
    step : int
        Current time step
    dim_obs_f : int
        Full dimension of observation vector
    obs_f : ndarray[tuple[dim_obs_f], np.float64]
        Full observation vector
    obserr_f : ndarray[tuple[dim_obs_f], np.float64]
        Full observation error stddev

    Returns
    -------
    obserr_f : ndarray[tuple[dim_obs_f], np.float64]
         Full observation error stddev
    """
    ...

def omi_prodRinvA_hyb_l_cb (domain_p: int,step: int,dim_obs_l: int,rank: int,
                            obs_l: np.ndarray[tuple[int], np.dtype[np.float64]],
                            alpha: float,A_l: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                            C_l: np.ndarray[tuple[int, int], np.dtype[np.float64]]
                           ) -> tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                          ]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_prodRinvA_hyb_l_cb or PDAF source files 

    Parameters
    ----------
    domain_p : int
        Index of current local analysis domain
    step : int
        Current time step
    dim_obs_l : int
        Dimension of local observation vector
    rank : int
        Rank of initial covariance matrix
    obs_l : ndarray[tuple[dim_obs_l], np.float64]
        Local vector of observations
    alpha : float
        Hybrid weight
    A_l : ndarray[tuple[dim_obs_l, rank], np.float64]
        Input matrix
    C_l : ndarray[tuple[dim_obs_l, rank], np.float64]
        Output matrix

    Returns
    -------
    A_l : ndarray[tuple[dim_obs_l, rank], np.float64]
         Input matrix
    C_l : ndarray[tuple[dim_obs_l, rank], np.float64]
         Output matrix
    """
    ...

def omi_likelihood_hyb_l_cb (domain_p: int,step: int,dim_obs_l: int,obs_l: np.ndarray[tuple[int], np.dtype[np.float64]],
                             resid_l: np.ndarray[tuple[int], np.dtype[np.float64]],
                             alpha: float,lhood_l: float) -> tuple[np.ndarray[tuple[int], np.dtype[np.float64]], float]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_likelihood_hyb_l_cb or PDAF source files 

    Parameters
    ----------
    domain_p : int
        Current local analysis domain
    step : int
        Current time step
    dim_obs_l : int
        PE-local dimension of obs. vector
    obs_l : ndarray[tuple[dim_obs_l], np.float64]
        PE-local vector of observations
    resid_l : ndarray[tuple[dim_obs_l], np.float64]
        Input vector of residuum
    alpha : float
        Hybrid weight
    lhood_l : float
        Output vector - log likelihood

    Returns
    -------
    resid_l : ndarray[tuple[dim_obs_l], np.float64]
         Input vector of residuum
    lhood_l : float
        Output vector - log likelihood
    """
    ...

def omi_obsstats_l (screen: int) -> None:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_obsstats_l or PDAF source files 

    Parameters
    ----------
    screen : int
        Verbosity flag
    """
    ...

def omi_weights_l (verbose: int,locweight: int,cradius: np.ndarray[tuple[int], np.dtype[np.float64]],
                   sradius: np.ndarray[tuple[int], np.dtype[np.float64]],
                   matA: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                   ivar_obs_l: np.ndarray[tuple[int], np.dtype[np.float64]],
                   dist_l: np.ndarray[tuple[int], np.dtype[np.float64]]
                  ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_weights_l or PDAF source files 

    Parameters
    ----------
    verbose : int
        Verbosity flag
    locweight : int
        Localization weight type
    cradius : ndarray[tuple[nobs_l], np.float64]
        Localization cut-off radius
    sradius : ndarray[tuple[nobs_l], np.float64]
        support radius for weight functions
    matA : ndarray[tuple[nobs_l, ncols], np.float64]
        
    ivar_obs_l : ndarray[tuple[nobs_l], np.float64]
        Local vector of inverse obs. variances (nobs_l)
    dist_l : ndarray[tuple[nobs_l], np.float64]
        Local vector of obs. distances (nobs_l)

    Returns
    -------
    weight_l : ndarray[tuple[nobs_l], np.float64]
         Output: vector of weights
    """
    ...

def omi_weights_l_sgnl (verbose: int,locweight: int,cradius: float,sradius: float,
                        matA: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                        ivar_obs_l: np.ndarray[tuple[int], np.dtype[np.float64]],
                        dist_l: np.ndarray[tuple[int], np.dtype[np.float64]]
                       ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_weights_l_sgnl or PDAF source files 

    Parameters
    ----------
    verbose : int
        Verbosity flag
    locweight : int
        Localization weight type
    cradius : float
        Localization cut-off radius
    sradius : float
        support radius for weight functions
    matA : ndarray[tuple[nobs_l, ncols], np.float64]
        
    ivar_obs_l : ndarray[tuple[nobs_l], np.float64]
        Local vector of inverse obs. variances (nobs_l)
    dist_l : ndarray[tuple[nobs_l], np.float64]
        Local vector of obs. distances (nobs_l)

    Returns
    -------
    weight_l : ndarray[tuple[nobs_l], np.float64]
         Output: vector of weights
    """
    ...

def omi_check_error (flag: int) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_check_error or PDAF source files 

    Parameters
    ----------
    flag : int
        Error flag

    Returns
    -------
    flag : int
        Error flag
    """
    ...

def omi_gather_obsdims () -> None:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_gather_obsdims or PDAF source files 

    """
    ...

def omi_obsstats (screen: int) -> None:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_obsstats or PDAF source files 

    Parameters
    ----------
    screen : int
        Verbosity flag
    """
    ...

def omi_init_dim_obs_l_iso (i_obs: int,coords_l: np.ndarray[tuple[int], np.dtype[np.float64]],
                            locweight: int,cradius: float,sradius: float,
                            cnt_obs_l: int) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_init_dim_obs_l_iso or PDAF source files 

    Parameters
    ----------
    i_obs : int
        index of observation type
    coords_l : ndarray[tuple[ncoord], np.float64]
        Coordinates of current analysis domain
    locweight : int
        Type of localization function
    cradius : float
        Localization cut-off radius (single or vector)
    sradius : float
        Support radius of localization function (single or vector)
    cnt_obs_l : int
        Local dimension of current observation vector

    Returns
    -------
    cnt_obs_l : int
        Local dimension of current observation vector
    """
    ...

def omi_init_dim_obs_l_noniso (i_obs: int,coords_l: np.ndarray[tuple[int], np.dtype[np.float64]],
                               locweight: int,cradius: np.ndarray[tuple[int], np.dtype[np.float64]],
                               sradius: np.ndarray[tuple[int], np.dtype[np.float64]],
                               cnt_obs_l: int) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_init_dim_obs_l_noniso or PDAF source files 

    Parameters
    ----------
    i_obs : int
        index of observation type
    coords_l : ndarray[tuple[ncoord], np.float64]
        Coordinates of current analysis domain
    locweight : int
        Type of localization function
    cradius : ndarray[tuple[ncoord], np.float64]
        Vector of localization cut-off radii
    sradius : ndarray[tuple[ncoord], np.float64]
        Vector of support radii of localization function
    cnt_obs_l : int
        Local dimension of current observation vector

    Returns
    -------
    cnt_obs_l : int
        Local dimension of current observation vector
    """
    ...

def omi_init_dim_obs_l_noniso_locweights (i_obs: int,coords_l: np.ndarray[tuple[int], np.dtype[np.float64]],
                                          locweights: np.ndarray[tuple[int], np.dtype[np.intc]],
                                          cradius: np.ndarray[tuple[int], np.dtype[np.float64]],
                                          sradius: np.ndarray[tuple[int], np.dtype[np.float64]],
                                          cnt_obs_l: int) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_init_dim_obs_l_noniso_locweights or PDAF source files 

    Parameters
    ----------
    i_obs : int
        index of observation type
    coords_l : ndarray[tuple[ncoord], np.float64]
        Coordinates of current analysis domain
    locweights : ndarray[tuple[2], np.intc]
        Types of localization function
    cradius : ndarray[tuple[ncoord], np.float64]
        Vector of localization cut-off radii
    sradius : ndarray[tuple[ncoord], np.float64]
        Vector of support radii of localization function
    cnt_obs_l : int
        Local dimension of current observation vector

    Returns
    -------
    cnt_obs_l : int
        Local dimension of current observation vector
    """
    ...

def omi_localize_covar_iso (i_obs: int,locweight: int,cradius: float,sradius: float,
                            coords: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                            HP: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                            HPH: np.ndarray[tuple[int, int], np.dtype[np.float64]]
                           ) -> tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                          ]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_localize_covar_iso or PDAF source files 

    Parameters
    ----------
    i_obs : int
        index of observation type
    locweight : int
        Localization weight type
    cradius : float
        localization radius
    sradius : float
        support radius for weight functions
    coords : ndarray[tuple[ncoord, dim_p], np.float64]
        Coordinates of state vector elements
    HP : ndarray[tuple[dim_obs, dim_p], np.float64]
        Matrix HP, dimension (nobs, dim)
    HPH : ndarray[tuple[dim_obs, dim_obs], np.float64]
        Matrix HPH, dimension (nobs, nobs)

    Returns
    -------
    HP : ndarray[tuple[dim_obs, dim_p], np.float64]
         Matrix HP, dimension (nobs, dim)
    HPH : ndarray[tuple[dim_obs, dim_obs], np.float64]
         Matrix HPH, dimension (nobs, nobs)
    """
    ...

def omi_localize_covar_noniso (i_obs: int,locweight: int,cradius: np.ndarray[tuple[int], np.dtype[np.float64]],
                               sradius: np.ndarray[tuple[int], np.dtype[np.float64]],
                               coords: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                               HP: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                               HPH: np.ndarray[tuple[int, int], np.dtype[np.float64]]
                              ) -> tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                             ]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_localize_covar_noniso or PDAF source files 

    Parameters
    ----------
    i_obs : int
        Data type with full observation
    locweight : int
        Localization weight type
    cradius : ndarray[tuple[ncoord], np.float64]
        Vector of localization cut-off radii
    sradius : ndarray[tuple[ncoord], np.float64]
        Vector of support radii of localization function
    coords : ndarray[tuple[ncoord, dim_p], np.float64]
        Coordinates of state vector elements
    HP : ndarray[tuple[dim_obs, dim_p], np.float64]
        Matrix HP, dimension (nobs, dim)
    HPH : ndarray[tuple[dim_obs, dim_obs], np.float64]
        Matrix HPH, dimension (nobs, nobs)

    Returns
    -------
    HP : ndarray[tuple[dim_obs, dim_p], np.float64]
         Matrix HP, dimension (nobs, dim)
    HPH : ndarray[tuple[dim_obs, dim_obs], np.float64]
         Matrix HPH, dimension (nobs, nobs)
    """
    ...

def omi_localize_covar_noniso_locweights (i_obs: int,locweights: np.ndarray[tuple[int], np.dtype[np.intc]],
                                          cradius: np.ndarray[tuple[int], np.dtype[np.float64]],
                                          sradius: np.ndarray[tuple[int], np.dtype[np.float64]],
                                          coords: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                                          HP: np.ndarray[tuple[int, int], np.dtype[np.float64]],
                                          HPH: np.ndarray[tuple[int, int], np.dtype[np.float64]]
                                         ) -> tuple[np.ndarray[tuple[int, int], np.dtype[np.float64]], np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                        ]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_localize_covar_noniso_locweights or PDAF source files 

    Parameters
    ----------
    i_obs : int
        index of observation type
    locweights : ndarray[tuple[2], np.intc]
        Types of localization function
    cradius : ndarray[tuple[ncoord], np.float64]
        Vector of localization cut-off radii
    sradius : ndarray[tuple[ncoord], np.float64]
        Vector of support radii of localization function
    coords : ndarray[tuple[ncoord, dim_p], np.float64]
        Coordinates of state vector elements
    HP : ndarray[tuple[dim_obs, dim_p], np.float64]
        Matrix HP, dimension (nobs, dim)
    HPH : ndarray[tuple[dim_obs, dim_obs], np.float64]
        Matrix HPH, dimension (nobs, nobs)

    Returns
    -------
    HP : ndarray[tuple[dim_obs, dim_p], np.float64]
         Matrix HP, dimension (nobs, dim)
    HPH : ndarray[tuple[dim_obs, dim_obs], np.float64]
         Matrix HPH, dimension (nobs, nobs)
    """
    ...

def omi_omit_by_inno_l_cb (domain_p: int,dim_obs_l: int,resid_l: np.ndarray[tuple[int], np.dtype[np.float64]],
                           obs_l: np.ndarray[tuple[int], np.dtype[np.float64]]
                          ) -> tuple[np.ndarray[tuple[int], np.dtype[np.float64]], np.ndarray[tuple[int], np.dtype[np.float64]], 
                         ]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_omit_by_inno_l_cb or PDAF source files 

    Parameters
    ----------
    domain_p : int
        Current local analysis domain
    dim_obs_l : int
        PE-local dimension of obs. vector
    resid_l : ndarray[tuple[dim_obs_l], np.float64]
        Input vector of residuum
    obs_l : ndarray[tuple[dim_obs_l], np.float64]
        Input vector of local observations

    Returns
    -------
    resid_l : ndarray[tuple[dim_obs_l], np.float64]
         Input vector of residuum
    obs_l : ndarray[tuple[dim_obs_l], np.float64]
         Input vector of local observations
    """
    ...

def omi_omit_by_inno_cb (dim_obs_f: int,resid_f: np.ndarray[tuple[int], np.dtype[np.float64]],
                         obs_f: np.ndarray[tuple[int], np.dtype[np.float64]]
                        ) -> tuple[np.ndarray[tuple[int], np.dtype[np.float64]], np.ndarray[tuple[int], np.dtype[np.float64]], 
                       ]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFomi_omit_by_inno_cb or PDAF source files 

    Parameters
    ----------
    dim_obs_f : int
        Full dimension of obs. vector
    resid_f : ndarray[tuple[dim_obs_f], np.float64]
        Input vector of residuum
    obs_f : ndarray[tuple[dim_obs_f], np.float64]
        Input vector of full observations

    Returns
    -------
    resid_f : ndarray[tuple[dim_obs_f], np.float64]
         Input vector of residuum
    obs_f : ndarray[tuple[dim_obs_f], np.float64]
         Input vector of full observations
    """
    ...

def local_set_indices (map: np.ndarray[tuple[int], np.dtype[np.intc]]) -> None:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFlocal_set_indices or PDAF source files 

    Parameters
    ----------
    map : ndarray[tuple[dim_l], np.intc]
        Index array for mapping
    """
    ...

def local_set_increment_weights (weights: np.ndarray[tuple[int], np.dtype[np.float64]]
                                ) -> None:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFlocal_set_increment_weights or PDAF source files 

    Parameters
    ----------
    weights : ndarray[tuple[dim_l], np.float64]
        Weights array
    """
    ...

def local_clear_increment_weights () -> None:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFlocal_clear_increment_weights or PDAF source files 

    """
    ...

def local_g2l_cb (step: int,domain_p: int,dim_p: int,state_p: np.ndarray[tuple[int], np.dtype[np.float64]],
                  dim_l: int,state_l: np.ndarray[tuple[int], np.dtype[np.float64]]
                 ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFlocal_g2l_cb or PDAF source files 

    Parameters
    ----------
    step : int
        Current time step
    domain_p : int
        Current local analysis domain
    dim_p : int
        PE-local full state dimension
    state_p : ndarray[tuple[dim_p], np.float64]
        PE-local full state vector
    dim_l : int
        Local state dimension
    state_l : ndarray[tuple[dim_l], np.float64]
        State vector on local analysis domain

    Returns
    -------
    state_l : ndarray[tuple[dim_l], np.float64]
         State vector on local analysis domain
    """
    ...

def local_l2g_cb (step: int,domain_p: int,dim_l: int,state_l: np.ndarray[tuple[int], np.dtype[np.float64]],
                  dim_p: int,state_p: np.ndarray[tuple[int], np.dtype[np.float64]]
                 ) -> np.ndarray[tuple[int], np.dtype[np.float64]]:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFlocal_l2g_cb or PDAF source files 

    Parameters
    ----------
    step : int
        Current time step
    domain_p : int
        Current local analysis domain
    dim_l : int
        Local state dimension
    state_l : ndarray[tuple[dim_l], np.float64]
        State vector on local analysis domain
    dim_p : int
        PE-local full state dimension
    state_p : ndarray[tuple[dim_p], np.float64]
        PE-local full state vector

    Returns
    -------
    state_p : ndarray[tuple[dim_p], np.float64]
         PE-local full state vector
    """
    ...

def localomi_assimilate (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                         py__distribute_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                         py__init_dim_obs_f_pdaf : Callable[[int, int], int],
                         py__obs_op_f_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                         py__prepoststep_pdaf : Callable[[int, int, int, 
                                                          int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                         py__init_n_domains_p_pdaf : Callable[[int, int], int],
                         py__init_dim_l_pdaf : Callable[[int, int, int], int],
                         py__init_dim_obs_l_pdaf : Callable[[int, int, 
                                                             int, int], int],
                         py__next_observation_pdaf : Callable[[int, int, 
                                                               int, float], tuple[int, 
                                                               int, float]],
                         outflag: int) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFlocalomi_assimilate or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_f:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of the full observation vector

        **Callback Returns**

        * dim_obs_f:int

            * Size of the full observation vector\n

    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_f:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_f:ndarray[tuple[dim_obs_f], np.float64]]
        Full observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_f : int

            * Size of full observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_assimilate_en3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__distribute_state_pdaf : Callable[[int, 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__init_dim_obs_f_pdaf : Callable[[int, 
                                                                            int], int],
                                        py__obs_op_f_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__cvt_ens_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__obs_op_lin_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__obs_op_adj_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__init_n_domains_p_pdaf : Callable[[int, 
                                                                              int], int],
                                        py__init_dim_l_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int], int],
                                        py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            int], int],
                                        py__prepoststep_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                        py__next_observation_pdaf : Callable[[int, 
                                                                              int, 
                                                                              int, 
                                                                              float], tuple[int, 
                                                                              int, 
                                                                              float]],
                                        outflag: int) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFlocalomi_assimilate_en3dvar_lestkf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_f:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of the full observation vector

        **Callback Returns**

        * dim_obs_f:int

            * Size of the full observation vector\n

    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_f:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_f:ndarray[tuple[dim_obs_f], np.float64]]
        Full observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_f : int

            * Size of full observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)\n

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local dimension of state

        * dim_ens : int

            * Ensemble size

        * dim_cvec_ens : int

            * Dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * v_p : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment\n

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_ens : int

            * Ensemble size

        * dim_cv_ens_p : int

            * PE-local dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector\n

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state\n

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_assimilate_en3dvar_lestkf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__distribute_state_pdaf : Callable[[int, 
                                                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__init_dim_obs_pdaf : Callable[[int, 
                                                                                   int], int],
                                                 py__obs_op_pdaf : Callable[[int, 
                                                                             int, 
                                                                             int, 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__prodRinvA_pdaf : Callable[[int, 
                                                                                int, 
                                                                                int, 
                                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                                 py__cvt_ens_pdaf : Callable[[int, 
                                                                              int, 
                                                                              int, 
                                                                              int, 
                                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__obs_op_lin_pdaf : Callable[[int, 
                                                                                 int, 
                                                                                 int, 
                                                                                 np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__obs_op_adj_pdaf : Callable[[int, 
                                                                                 int, 
                                                                                 int, 
                                                                                 np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__prodRinvA_l_pdaf : Callable[[int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                                 py__init_n_domains_p_pdaf : Callable[[int, 
                                                                                       int], int],
                                                 py__init_dim_l_pdaf : Callable[[int, 
                                                                                 int, 
                                                                                 int], int],
                                                 py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                                     int, 
                                                                                     int, 
                                                                                     int], int],
                                                 py__prepoststep_pdaf : Callable[[int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                  int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                                 py__next_observation_pdaf : Callable[[int, 
                                                                                       int, 
                                                                                       int, 
                                                                                       float], tuple[int, 
                                                                                       int, 
                                                                                       float]],
                                                 outflag: int) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFlocalomi_assimilate_en3dvar_lestkf_nondiagR or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one(or the rank of the initial covariance matrix)

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * A_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix\n

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local dimension of state

        * dim_ens : int

            * Ensemble size

        * dim_cvec_ens : int

            * Dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * v_p : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment\n

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_ens : int

            * Ensemble size

        * dim_cv_ens_p : int

            * PE-local dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector\n

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state\n

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state\n

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A with localization

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * A_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_assimilate_hyb3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                         py__distribute_state_pdaf : Callable[[int, 
                                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                         py__init_dim_obs_f_pdaf : Callable[[int, 
                                                                             int], int],
                                         py__obs_op_f_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int, 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                         py__cvt_ens_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                         py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          int, 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                         py__cvt_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                         py__cvt_adj_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                         py__obs_op_lin_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                         py__obs_op_adj_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                         py__init_n_domains_p_pdaf : Callable[[int, 
                                                                               int], int],
                                         py__init_dim_l_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int], int],
                                         py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                             int, 
                                                                             int, 
                                                                             int], int],
                                         py__prepoststep_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          int, 
                                                                          int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                          int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                         py__next_observation_pdaf : Callable[[int, 
                                                                               int, 
                                                                               int, 
                                                                               float], tuple[int, 
                                                                               int, 
                                                                               float]],
                                         outflag: int) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFlocalomi_assimilate_hyb3dvar_lestkf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_f:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of the full observation vector

        **Callback Returns**

        * dim_obs_f:int

            * Size of the full observation vector\n

    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_f:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_f:ndarray[tuple[dim_obs_f], np.float64]]
        Full observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_f : int

            * Size of full observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)\n

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local dimension of state

        * dim_ens : int

            * Ensemble size

        * dim_cvec_ens : int

            * Dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * v_p : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment\n

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_ens : int

            * Ensemble size

        * dim_cv_ens_p : int

            * PE-local dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector\n

    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_cvec : int

            * Dimension of control vector

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)\n

    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_cvec : int

            * Dimension of control vector

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector\n

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state\n

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_assimilate_hyb3dvar_lestkf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                  py__distribute_state_pdaf : Callable[[int, 
                                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                  py__init_dim_obs_pdaf : Callable[[int, 
                                                                                    int], int],
                                                  py__obs_op_pdaf : Callable[[int, 
                                                                              int, 
                                                                              int, 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                  py__prodRinvA_pdaf : Callable[[int, 
                                                                                 int, 
                                                                                 int, 
                                                                                 np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                                  py__cvt_ens_pdaf : Callable[[int, 
                                                                               int, 
                                                                               int, 
                                                                               int, 
                                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                  py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                                   int, 
                                                                                   int, 
                                                                                   int, 
                                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                  py__cvt_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                  py__cvt_adj_pdaf : Callable[[int, 
                                                                               int, 
                                                                               int, 
                                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                  py__obs_op_lin_pdaf : Callable[[int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                  py__obs_op_adj_pdaf : Callable[[int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                  py__prodRinvA_l_pdaf : Callable[[int, 
                                                                                   int, 
                                                                                   int, 
                                                                                   int, 
                                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                                  py__init_n_domains_p_pdaf : Callable[[int, 
                                                                                        int], int],
                                                  py__init_dim_l_pdaf : Callable[[int, 
                                                                                  int, 
                                                                                  int], int],
                                                  py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                                      int, 
                                                                                      int, 
                                                                                      int], int],
                                                  py__prepoststep_pdaf : Callable[[int, 
                                                                                   int, 
                                                                                   int, 
                                                                                   int, 
                                                                                   int, 
                                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                   int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                                  py__next_observation_pdaf : Callable[[int, 
                                                                                        int, 
                                                                                        int, 
                                                                                        float], tuple[int, 
                                                                                        int, 
                                                                                        float]],
                                                  outflag: int) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFlocalomi_assimilate_hyb3dvar_lestkf_nondiagR or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one(or the rank of the initial covariance matrix)

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * A_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix\n

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local dimension of state

        * dim_ens : int

            * Ensemble size

        * dim_cvec_ens : int

            * Dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * v_p : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment\n

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_ens : int

            * Ensemble size

        * dim_cv_ens_p : int

            * PE-local dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector\n

    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_cvec : int

            * Dimension of control vector

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)\n

    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_cvec : int

            * Dimension of control vector

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector\n

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state\n

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state\n

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * A_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_assimilate_lknetf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                         py__distribute_state_pdaf : Callable[[int, 
                                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                         py__init_dim_obs_pdaf : Callable[[int, 
                                                                           int], int],
                                         py__obs_op_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                         py__prepoststep_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          int, 
                                                                          int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                          int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                         py__init_n_domains_p_pdaf : Callable[[int, 
                                                                               int], int],
                                         py__init_dim_l_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int], int],
                                         py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                             int, 
                                                                             int, 
                                                                             int], int],
                                         py__prodRinvA_l_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                         py__prodRinvA_hyb_l_pdaf : Callable[[int, 
                                                                              int, 
                                                                              int, 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                              float, 
                                                                              float], float],
                                         py__likelihood_l_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                           float], float],
                                         py__likelihood_hyb_l_pdaf : Callable[[int, 
                                                                               int, 
                                                                               int, 
                                                                               int, 
                                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                               float, 
                                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                         py__next_observation_pdaf : Callable[[int, 
                                                                               int, 
                                                                               int, 
                                                                               float], tuple[int, 
                                                                               int, 
                                                                               float]],
                                         outflag: int) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFlocalomi_assimilate_lknetf_nondiagR or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * A_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix\n

    py__prodRinvA_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, likely_l:float]
        Product R^-1 A on local analysis domain with hybrid weight

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * resid_l : ndarray[tuple[dim_obs_l], np.float64]

            * Input vector holding the local residual

        * gamma : float

            * Hybrid weight provided by PDAF

        * likely_l : float

            * Output value of the local likelihood

        **Callback Returns**

        * likely_l:float

            * Output value of the local likelihood\n

    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute likelihood and apply localization

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * resid_l : ndarray[tuple[dim_obs_l], np.float64]

            * nput vector holding the local residual

        * likely_l : float

            * Output value of the local likelihood

        **Callback Returns**

        * likely_l:float

            * Output value of the local likelihood\n

    py__likelihood_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Compute likelihood and apply localization with tempering

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * rank : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * gamma : float

            * Hybrid weight provided by PDAF

        * A_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix\n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_assimilate_lnetf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__distribute_state_pdaf : Callable[[int, 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__init_dim_obs_pdaf : Callable[[int, 
                                                                          int], int],
                                        py__obs_op_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__prepoststep_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                        py__init_n_domains_p_pdaf : Callable[[int, 
                                                                              int], int],
                                        py__init_dim_l_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int], int],
                                        py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            int], int],
                                        py__likelihood_l_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          float], float],
                                        py__next_observation_pdaf : Callable[[int, 
                                                                              int, 
                                                                              int, 
                                                                              float], tuple[int, 
                                                                              int, 
                                                                              float]],
                                        outflag: int) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFlocalomi_assimilate_lnetf_nondiagR or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute likelihood and apply localization

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * resid_l : ndarray[tuple[dim_obs_l], np.float64]

            * nput vector holding the local residual

        * likely_l : float

            * Output value of the local likelihood

        **Callback Returns**

        * likely_l:float

            * Output value of the local likelihood\n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_assimilate_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__distribute_state_pdaf : Callable[[int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__init_dim_obs_pdaf : Callable[[int, 
                                                                    int], int],
                                  py__obs_op_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                  py__prepoststep_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                  py__init_n_domains_p_pdaf : Callable[[int, 
                                                                        int], int],
                                  py__init_dim_l_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int], int],
                                  py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      int], int],
                                  py__prodRinvA_l_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                  py__next_observation_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        float], tuple[int, 
                                                                        int, 
                                                                        float]],
                                  outflag: int) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFlocalomi_assimilate_nondiagR or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product of inverse of R with matrix A

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * A_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix\n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Provide time step, time and dimension of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_put_state (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                        py__init_dim_obs_f_pdaf : Callable[[int, int], int],
                        py__obs_op_f_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                        py__prepoststep_pdaf : Callable[[int, int, int, 
                                                         int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                         int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                        py__init_n_domains_p_pdaf : Callable[[int, int], int],
                        py__init_dim_l_pdaf : Callable[[int, int, int], int],
                        py__init_dim_obs_l_pdaf : Callable[[int, int, int, 
                                                            int], int],
                        outflag: int) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFlocalomi_put_state or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_f:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of the full observation vector

        **Callback Returns**

        * dim_obs_f:int

            * Size of the full observation vector\n

    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_f:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_f:ndarray[tuple[dim_obs_f], np.float64]]
        Full observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_f : int

            * Size of full observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_put_state_en3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                       py__init_dim_obs_f_pdaf : Callable[[int, 
                                                                           int], int],
                                       py__obs_op_f_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                       py__cvt_ens_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                       py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        int, 
                                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                       py__obs_op_lin_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int, 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                       py__obs_op_adj_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int, 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                       py__init_n_domains_p_pdaf : Callable[[int, 
                                                                             int], int],
                                       py__init_dim_l_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int], int],
                                       py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           int], int],
                                       py__prepoststep_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        int, 
                                                                        int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                        int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                       outflag: int) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFlocalomi_put_state_en3dvar_lestkf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_f:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of the full observation vector

        **Callback Returns**

        * dim_obs_f:int

            * Size of the full observation vector\n

    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_f:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_f:ndarray[tuple[dim_obs_f], np.float64]]
        Full observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_f : int

            * Size of full observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)\n

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local dimension of state

        * dim_ens : int

            * Ensemble size

        * dim_cvec_ens : int

            * Dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * v_p : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment\n

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_ens : int

            * Ensemble size

        * dim_cv_ens_p : int

            * PE-local dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector\n

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state\n

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_put_state_en3dvar_lestkf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                py__init_dim_obs_pdaf : Callable[[int, 
                                                                                  int], int],
                                                py__obs_op_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                py__prodRinvA_pdaf : Callable[[int, 
                                                                               int, 
                                                                               int, 
                                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                               np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                                py__cvt_ens_pdaf : Callable[[int, 
                                                                             int, 
                                                                             int, 
                                                                             int, 
                                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                                 int, 
                                                                                 int, 
                                                                                 int, 
                                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                 np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                py__obs_op_lin_pdaf : Callable[[int, 
                                                                                int, 
                                                                                int, 
                                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                py__obs_op_adj_pdaf : Callable[[int, 
                                                                                int, 
                                                                                int, 
                                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                py__prodRinvA_l_pdaf : Callable[[int, 
                                                                                 int, 
                                                                                 int, 
                                                                                 int, 
                                                                                 np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                                py__init_n_domains_p_pdaf : Callable[[int, 
                                                                                      int], int],
                                                py__init_dim_l_pdaf : Callable[[int, 
                                                                                int, 
                                                                                int], int],
                                                py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                                    int, 
                                                                                    int, 
                                                                                    int], int],
                                                py__prepoststep_pdaf : Callable[[int, 
                                                                                 int, 
                                                                                 int, 
                                                                                 int, 
                                                                                 int, 
                                                                                 np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                 int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                                outflag: int) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFlocalomi_put_state_en3dvar_lestkf_nondiagR or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one(or the rank of the initial covariance matrix)

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * A_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix\n

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local dimension of state

        * dim_ens : int

            * Ensemble size

        * dim_cvec_ens : int

            * Dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * v_p : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment\n

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_ens : int

            * Ensemble size

        * dim_cv_ens_p : int

            * PE-local dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector\n

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state\n

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state\n

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * A_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_put_state_hyb3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__init_dim_obs_f_pdaf : Callable[[int, 
                                                                            int], int],
                                        py__obs_op_f_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__cvt_ens_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__cvt_pdaf : Callable[[int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__cvt_adj_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__obs_op_lin_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__obs_op_adj_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__init_n_domains_p_pdaf : Callable[[int, 
                                                                              int], int],
                                        py__init_dim_l_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int], int],
                                        py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            int], int],
                                        py__prepoststep_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                        outflag: int) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFlocalomi_put_state_hyb3dvar_lestkf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_f:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of the full observation vector

        **Callback Returns**

        * dim_obs_f:int

            * Size of the full observation vector\n

    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_f:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_f:ndarray[tuple[dim_obs_f], np.float64]]
        Full observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_f : int

            * Size of full observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)\n

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local dimension of state

        * dim_ens : int

            * Ensemble size

        * dim_cvec_ens : int

            * Dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * v_p : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment\n

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_ens : int

            * Ensemble size

        * dim_cv_ens_p : int

            * PE-local dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector\n

    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_cvec : int

            * Dimension of control vector

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)\n

    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_cvec : int

            * Dimension of control vector

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector\n

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state\n

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_put_state_hyb3dvar_lestkf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__init_dim_obs_pdaf : Callable[[int, 
                                                                                   int], int],
                                                 py__obs_op_pdaf : Callable[[int, 
                                                                             int, 
                                                                             int, 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__prodRinvA_pdaf : Callable[[int, 
                                                                                int, 
                                                                                int, 
                                                                                np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                                 py__cvt_ens_pdaf : Callable[[int, 
                                                                              int, 
                                                                              int, 
                                                                              int, 
                                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__cvt_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__cvt_adj_pdaf : Callable[[int, 
                                                                              int, 
                                                                              int, 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__obs_op_lin_pdaf : Callable[[int, 
                                                                                 int, 
                                                                                 int, 
                                                                                 np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__obs_op_adj_pdaf : Callable[[int, 
                                                                                 int, 
                                                                                 int, 
                                                                                 np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                                 py__prodRinvA_l_pdaf : Callable[[int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                                 py__init_n_domains_p_pdaf : Callable[[int, 
                                                                                       int], int],
                                                 py__init_dim_l_pdaf : Callable[[int, 
                                                                                 int, 
                                                                                 int], int],
                                                 py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                                     int, 
                                                                                     int, 
                                                                                     int], int],
                                                 py__prepoststep_pdaf : Callable[[int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  int, 
                                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                  int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                                 outflag: int) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFlocalomi_put_state_hyb3dvar_lestkf_nondiagR or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one(or the rank of the initial covariance matrix)

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * A_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix\n

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local dimension of state

        * dim_ens : int

            * Ensemble size

        * dim_cvec_ens : int

            * Dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * v_p : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment\n

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_ens : int

            * Ensemble size

        * dim_cv_ens_p : int

            * PE-local dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector\n

    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_cvec : int

            * Dimension of control vector

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)\n

    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_cvec : int

            * Dimension of control vector

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector\n

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state\n

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state\n

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * A_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_put_state_lknetf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__init_dim_obs_pdaf : Callable[[int, 
                                                                          int], int],
                                        py__obs_op_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                        py__prepoststep_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                        py__init_n_domains_p_pdaf : Callable[[int, 
                                                                              int], int],
                                        py__init_dim_l_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int], int],
                                        py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            int], int],
                                        py__prodRinvA_l_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                        py__prodRinvA_hyb_l_pdaf : Callable[[int, 
                                                                             int, 
                                                                             int, 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                             float, 
                                                                             float], float],
                                        py__likelihood_l_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                          float], float],
                                        py__likelihood_hyb_l_pdaf : Callable[[int, 
                                                                              int, 
                                                                              int, 
                                                                              int, 
                                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                              float, 
                                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                        outflag: int) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFlocalomi_put_state_lknetf_nondiagR or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * A_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix\n

    py__prodRinvA_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, likely_l:float]
        Product R^-1 A on local analysis domain with hybrid weight

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * resid_l : ndarray[tuple[dim_obs_l], np.float64]

            * Input vector holding the local residual

        * gamma : float

            * Hybrid weight provided by PDAF

        * likely_l : float

            * Output value of the local likelihood

        **Callback Returns**

        * likely_l:float

            * Output value of the local likelihood\n

    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute likelihood and apply localization

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * resid_l : ndarray[tuple[dim_obs_l], np.float64]

            * nput vector holding the local residual

        * likely_l : float

            * Output value of the local likelihood

        **Callback Returns**

        * likely_l:float

            * Output value of the local likelihood\n

    py__likelihood_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Compute likelihood and apply localization with tempering

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * rank : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * gamma : float

            * Hybrid weight provided by PDAF

        * A_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix\n

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_put_state_lnetf_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                          np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                       py__init_dim_obs_pdaf : Callable[[int, 
                                                                         int], int],
                                       py__obs_op_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                       py__prepoststep_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        int, 
                                                                        int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                        int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                        np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                       py__init_n_domains_p_pdaf : Callable[[int, 
                                                                             int], int],
                                       py__init_dim_l_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int], int],
                                       py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           int], int],
                                       py__likelihood_l_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         float], float],
                                       outflag: int) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFlocalomi_put_state_lnetf_nondiagR or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute likelihood and apply localization

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * resid_l : ndarray[tuple[dim_obs_l], np.float64]

            * nput vector holding the local residual

        * likely_l : float

            * Output value of the local likelihood

        **Callback Returns**

        * likely_l:float

            * Output value of the local likelihood\n

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def localomi_put_state_nondiagR (py__collect_state_pdaf : Callable[[int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                 py__init_dim_obs_pdaf : Callable[[int, 
                                                                   int], int],
                                 py__obs_op_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                 py__prepoststep_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                  int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                 py__init_n_domains_p_pdaf : Callable[[int, 
                                                                       int], int],
                                 py__init_dim_l_pdaf : Callable[[int, int, 
                                                                 int], int],
                                 py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     int], int],
                                 py__prodRinvA_l_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                 outflag: int) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFlocalomi_put_state_nondiagR or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of full observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Full observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize local dimimension of obs. vector

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product of inverse of R with matrix A

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * A_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix\n

    outflag : int
        Status flag

    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_assimilate_en3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__distribute_state_pdaf : Callable[[int, 
                                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__init_dim_obs_pdaf : Callable[[int, 
                                                                       int], int],
                                     py__obs_op_pdaf : Callable[[int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__init_obs_pdaf : Callable[[int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__prodRinvA_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                     py__cvt_ens_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__obs_op_lin_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__obs_op_adj_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__init_dim_obs_f_pdaf : Callable[[int, 
                                                                         int], int],
                                     py__obs_op_f_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__init_obs_f_pdaf : Callable[[int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__init_obs_l_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__prodRinvA_l_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                     py__init_n_domains_p_pdaf : Callable[[int, 
                                                                           int], int],
                                     py__init_dim_l_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int], int],
                                     py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         int], int],
                                     py__g2l_obs_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                                  int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                                     py__init_obsvar_pdaf : Callable[[int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      float], float],
                                     py__init_obsvar_l_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        int, 
                                                                        float], float],
                                     py__prepoststep_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                      int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                     py__next_observation_pdaf : Callable[[int, 
                                                                           int, 
                                                                           int, 
                                                                           float], tuple[int, 
                                                                           int, 
                                                                           float]]
                                    ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFlocal_assimilate_en3dvar_lestkf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one(or the rank of the initial covariance matrix)

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * A_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix\n

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local dimension of state

        * dim_ens : int

            * Ensemble size

        * dim_cvec_ens : int

            * Dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * v_p : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment\n

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_ens : int

            * Ensemble size

        * dim_cv_ens_p : int

            * PE-local dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector\n

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state\n

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state\n

    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_f:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of the full observation vector

        **Callback Returns**

        * dim_obs_f:int

            * Size of the full observation vector\n

    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_f:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_f:ndarray[tuple[dim_obs_f], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_f : int

            * Size of full observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f:ndarray[tuple[dim_obs_f], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of the full observation vector

        * observation_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of observations

        **Callback Returns**

        * observation_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of observations\n

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local size of the observation vector

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations\n

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * A_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of full observation vector for model sub-domain

        * dim_obs_l : int

            * Size of observation vector for local analysis domain

        * mstate_f : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * dim_p : int

            * Size of full observation vector for model sub-domain

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * dim_l : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain\n

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of observation vector

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * meanvar : float

            * Mean observation error variance

        **Callback Returns**

        * meanvar:float

            * Mean observation error variance\n

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local dimension of observation vector

        * obs_l : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * dim_obs_p : int

            * Dimension of local observation vector

        * meanvar_l : float

            * Mean local observation error variance

        **Callback Returns**

        * meanvar_l:float

            * Mean local observation error variance\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide time step, time and dimension of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n


    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_assimilate_hyb3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                      py__distribute_state_pdaf : Callable[[int, 
                                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                      py__init_dim_obs_pdaf : Callable[[int, 
                                                                        int], int],
                                      py__obs_op_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                      py__init_obs_pdaf : Callable[[int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                      py__prodRinvA_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                      py__cvt_ens_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                      py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int, 
                                                                       int, 
                                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                      py__cvt_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                      py__cvt_adj_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                      py__obs_op_lin_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                      py__obs_op_adj_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                      py__init_dim_obs_f_pdaf : Callable[[int, 
                                                                          int], int],
                                      py__obs_op_f_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                      py__init_obs_f_pdaf : Callable[[int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                      py__init_obs_l_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                      py__prodRinvA_l_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int, 
                                                                       int, 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                      py__init_n_domains_p_pdaf : Callable[[int, 
                                                                            int], int],
                                      py__init_dim_l_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int], int],
                                      py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                          int, 
                                                                          int, 
                                                                          int], int],
                                      py__g2l_obs_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                                   int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                                      py__init_obsvar_pdaf : Callable[[int, 
                                                                       int, 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                       float], float],
                                      py__init_obsvar_l_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                         int, 
                                                                         float], float],
                                      py__prepoststep_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int, 
                                                                       int, 
                                                                       int, 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                       int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                       np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                                      py__next_observation_pdaf : Callable[[int, 
                                                                            int, 
                                                                            int, 
                                                                            float], tuple[int, 
                                                                            int, 
                                                                            float]]
                                     ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFlocal_assimilate_hyb3dvar_lestkf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one(or the rank of the initial covariance matrix)

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * A_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix\n

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local dimension of state

        * dim_ens : int

            * Ensemble size

        * dim_cvec_ens : int

            * Dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * v_p : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment\n

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_ens : int

            * Ensemble size

        * dim_cv_ens_p : int

            * PE-local dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector\n

    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_cvec : int

            * Dimension of control vector

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)\n

    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_cvec : int

            * Dimension of control vector

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector\n

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state\n

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state\n

    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_f:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of the full observation vector

        **Callback Returns**

        * dim_obs_f:int

            * Size of the full observation vector\n

    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_f:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_f:ndarray[tuple[dim_obs_f], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_f : int

            * Size of full observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f:ndarray[tuple[dim_obs_f], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of the full observation vector

        * observation_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of observations

        **Callback Returns**

        * observation_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of observations\n

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local size of the observation vector

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations\n

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * A_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of full observation vector for model sub-domain

        * dim_obs_l : int

            * Size of observation vector for local analysis domain

        * mstate_f : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * dim_p : int

            * Size of full observation vector for model sub-domain

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * dim_l : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain\n

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of observation vector

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * meanvar : float

            * Mean observation error variance

        **Callback Returns**

        * meanvar:float

            * Mean observation error variance\n

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local dimension of observation vector

        * obs_l : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * dim_obs_p : int

            * Dimension of local observation vector

        * meanvar_l : float

            * Mean local observation error variance

        **Callback Returns**

        * meanvar_l:float

            * Mean local observation error variance\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide time step, time and dimension of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n


    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_assimilate_lestkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__distribute_state_pdaf : Callable[[int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__init_dim_obs_pdaf : Callable[[int, int], int],
                             py__obs_op_pdaf : Callable[[int, int, int, 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__init_obs_l_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__prepoststep_pdaf : Callable[[int, int, 
                                                              int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                             py__prodRinvA_l_pdaf : Callable[[int, int, 
                                                              int, int, 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                             py__init_n_domains_p_pdaf : Callable[[int, 
                                                                   int], int],
                             py__init_dim_l_pdaf : Callable[[int, int, 
                                                             int], int],
                             py__init_dim_obs_l_pdaf : Callable[[int, int, 
                                                                 int, int], int],
                             py__g2l_obs_pdaf : Callable[[int, int, int, 
                                                          int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                          int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                          int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                             py__init_obsvar_pdaf : Callable[[int, int, 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              float], float],
                             py__init_obsvar_l_pdaf : Callable[[int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                int, float], float],
                             py__next_observation_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   float], tuple[int, 
                                                                   int, 
                                                                   float]]
                            ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFlocal_assimilate_lestkf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local size of the observation vector

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * A_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of full observation vector for model sub-domain

        * dim_obs_l : int

            * Size of observation vector for local analysis domain

        * mstate_f : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * dim_p : int

            * Size of full observation vector for model sub-domain

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * dim_l : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain\n

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of observation vector

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * meanvar : float

            * Mean observation error variance

        **Callback Returns**

        * meanvar:float

            * Mean observation error variance\n

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local dimension of observation vector

        * obs_l : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * dim_obs_p : int

            * Dimension of local observation vector

        * meanvar_l : float

            * Mean local observation error variance

        **Callback Returns**

        * meanvar_l:float

            * Mean local observation error variance\n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide time step, time and dimension of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n


    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_assimilate_letkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__distribute_state_pdaf : Callable[[int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_dim_obs_pdaf : Callable[[int, int], int],
                            py__obs_op_pdaf : Callable[[int, int, int, 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_obs_l_pdaf : Callable[[int, int, int, 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__prepoststep_pdaf : Callable[[int, int, 
                                                             int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                            py__prodRinvA_l_pdaf : Callable[[int, int, 
                                                             int, int, 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                            py__init_n_domains_p_pdaf : Callable[[int, 
                                                                  int], int],
                            py__init_dim_l_pdaf : Callable[[int, int, int], int],
                            py__init_dim_obs_l_pdaf : Callable[[int, int, 
                                                                int, int], int],
                            py__g2l_obs_pdaf : Callable[[int, int, int, 
                                                         int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                         int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                         int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                            py__init_obsvar_pdaf : Callable[[int, int, 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             float], float],
                            py__init_obsvar_l_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               int, float], float],
                            py__next_observation_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  float], tuple[int, 
                                                                  int, 
                                                                  float]]
                           ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFlocal_assimilate_letkf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local size of the observation vector

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * A_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of full observation vector for model sub-domain

        * dim_obs_l : int

            * Size of observation vector for local analysis domain

        * mstate_f : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * dim_p : int

            * Size of full observation vector for model sub-domain

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * dim_l : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain\n

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of observation vector

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * meanvar : float

            * Mean observation error variance

        **Callback Returns**

        * meanvar:float

            * Mean observation error variance\n

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local dimension of observation vector

        * obs_l : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * dim_obs_p : int

            * Dimension of local observation vector

        * meanvar_l : float

            * Mean local observation error variance

        **Callback Returns**

        * meanvar_l:float

            * Mean local observation error variance\n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide time step, time and dimension of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n


    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_assimilate_lknetf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__distribute_state_pdaf : Callable[[int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__init_dim_obs_pdaf : Callable[[int, int], int],
                             py__obs_op_pdaf : Callable[[int, int, int, 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                         np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__init_obs_l_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                             py__prepoststep_pdaf : Callable[[int, int, 
                                                              int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                             py__prodRinvA_l_pdaf : Callable[[int, int, 
                                                              int, int, 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                             py__prodRinvA_hyb_l_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  float, 
                                                                  float], float],
                             py__init_n_domains_p_pdaf : Callable[[int, 
                                                                   int], int],
                             py__init_dim_l_pdaf : Callable[[int, int, 
                                                             int], int],
                             py__init_dim_obs_l_pdaf : Callable[[int, int, 
                                                                 int, int], int],
                             py__g2l_obs_pdaf : Callable[[int, int, int, 
                                                          int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                          int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                          int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                             py__init_obsvar_pdaf : Callable[[int, int, 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              float], float],
                             py__init_obsvar_l_pdaf : Callable[[int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                int, float], float],
                             py__likelihood_l_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               float], float],
                             py__likelihood_hyb_l_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   float, 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                             py__next_observation_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   float], tuple[int, 
                                                                   int, 
                                                                   float]]
                            ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFlocal_assimilate_lknetf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local size of the observation vector

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * A_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix\n

    py__prodRinvA_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, likely_l:float]
        Provide product R^-1 A on local analysis domain with hybrid weight

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * resid_l : ndarray[tuple[dim_obs_l], np.float64]

            * Input vector holding the local residual

        * gamma : float

            * Hybrid weight provided by PDAF

        * likely_l : float

            * Output value of the local likelihood

        **Callback Returns**

        * likely_l:float

            * Output value of the local likelihood\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of full observation vector for model sub-domain

        * dim_obs_l : int

            * Size of observation vector for local analysis domain

        * mstate_f : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * dim_p : int

            * Size of full observation vector for model sub-domain

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * dim_l : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain\n

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of observation vector

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * meanvar : float

            * Mean observation error variance

        **Callback Returns**

        * meanvar:float

            * Mean observation error variance\n

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local dimension of observation vector

        * obs_l : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * dim_obs_p : int

            * Dimension of local observation vector

        * meanvar_l : float

            * Mean local observation error variance

        **Callback Returns**

        * meanvar_l:float

            * Mean local observation error variance\n

    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute likelihood

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * resid_l : ndarray[tuple[dim_obs_l], np.float64]

            * nput vector holding the local residual

        * likely_l : float

            * Output value of the local likelihood

        **Callback Returns**

        * likely_l:float

            * Output value of the local likelihood\n

    py__likelihood_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Compute likelihood with hybrid weight

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * rank : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * gamma : float

            * Hybrid weight provided by PDAF

        * A_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix\n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide time step, time and dimension of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n


    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_assimilate_lnetf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__distribute_state_pdaf : Callable[[int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_dim_obs_pdaf : Callable[[int, int], int],
                            py__obs_op_pdaf : Callable[[int, int, int, 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_obs_l_pdaf : Callable[[int, int, int, 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__prepoststep_pdaf : Callable[[int, int, 
                                                             int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                            py__likelihood_l_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              float], float],
                            py__init_n_domains_p_pdaf : Callable[[int, 
                                                                  int], int],
                            py__init_dim_l_pdaf : Callable[[int, int, int], int],
                            py__init_dim_obs_l_pdaf : Callable[[int, int, 
                                                                int, int], int],
                            py__g2l_obs_pdaf : Callable[[int, int, int, 
                                                         int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                         int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                         int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                            py__next_observation_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  float], tuple[int, 
                                                                  int, 
                                                                  float]]
                           ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFlocal_assimilate_lnetf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local size of the observation vector

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * resid_l : ndarray[tuple[dim_obs_l], np.float64]

            * nput vector holding the local residual

        * likely_l : float

            * Output value of the local likelihood

        **Callback Returns**

        * likely_l:float

            * Output value of the local likelihood\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of full observation vector for model sub-domain

        * dim_obs_l : int

            * Size of observation vector for local analysis domain

        * mstate_f : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * dim_p : int

            * Size of full observation vector for model sub-domain

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * dim_l : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain\n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide time step, time and dimension of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n


    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_assimilate_lseik (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__distribute_state_pdaf : Callable[[int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_dim_obs_pdaf : Callable[[int, int], int],
                            py__obs_op_pdaf : Callable[[int, int, int, 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_obs_l_pdaf : Callable[[int, int, int, 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__prepoststep_pdaf : Callable[[int, int, 
                                                             int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                            py__prodRinvA_l_pdaf : Callable[[int, int, 
                                                             int, int, 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                            py__init_n_domains_p_pdaf : Callable[[int, 
                                                                  int], int],
                            py__init_dim_l_pdaf : Callable[[int, int, int], int],
                            py__init_dim_obs_l_pdaf : Callable[[int, int, 
                                                                int, int], int],
                            py__g2l_obs_pdaf : Callable[[int, int, int, 
                                                         int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                         int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                         int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                            py__init_obsvar_pdaf : Callable[[int, int, 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             float], float],
                            py__init_obsvar_l_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               int, float], float],
                            py__next_observation_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  float], tuple[int, 
                                                                  int, 
                                                                  float]]
                           ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFlocal_assimilate_lseik or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__distribute_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to distribute a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local size of the observation vector

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * A_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of full observation vector for model sub-domain

        * dim_obs_l : int

            * Size of observation vector for local analysis domain

        * mstate_f : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * dim_p : int

            * Size of full observation vector for model sub-domain

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * dim_l : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain\n

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of observation vector

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * meanvar : float

            * Mean observation error variance

        **Callback Returns**

        * meanvar:float

            * Mean observation error variance\n

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local dimension of observation vector

        * obs_l : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * dim_obs_p : int

            * Dimension of local observation vector

        * meanvar_l : float

            * Mean local observation error variance

        **Callback Returns**

        * meanvar_l:float

            * Mean local observation error variance\n

    py__next_observation_pdaf : Callable[stepnow:int, nsteps:int, doexit:int, time:float]
        Routine to provide time step, time and dimension of next observation

        **Callback Parameters**

        * stepnow : int

            * number of the current time step

        * nsteps : int

            * number of time steps until next obs

        * doexit : int

            * whether to exit forecasting (1 for exit)

        * time : float

            * current model (physical) time

        **Callback Returns**

        * nsteps:int

            * number of time steps until next obs\n
        * doexit:int

            * whether to exit forecasting (1 for exit)\n
        * time:float

            * current model (physical) time\n


    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_put_state_en3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__init_dim_obs_pdaf : Callable[[int, 
                                                                      int], int],
                                    py__obs_op_pdaf : Callable[[int, int, 
                                                                int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__init_obs_pdaf : Callable[[int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__prodRinvA_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                    py__cvt_ens_pdaf : Callable[[int, int, 
                                                                 int, int, 
                                                                 np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__obs_op_lin_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__obs_op_adj_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__init_dim_obs_f_pdaf : Callable[[int, 
                                                                        int], int],
                                    py__obs_op_f_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__init_obs_f_pdaf : Callable[[int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__init_obs_l_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                    py__prodRinvA_l_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                    py__init_n_domains_p_pdaf : Callable[[int, 
                                                                          int], int],
                                    py__init_dim_l_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int], int],
                                    py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        int], int],
                                    py__g2l_obs_pdaf : Callable[[int, int, 
                                                                 int, int, 
                                                                 np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                                 int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                                    py__init_obsvar_pdaf : Callable[[int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     float], float],
                                    py__init_obsvar_l_pdaf : Callable[[int, 
                                                                       int, 
                                                                       int, 
                                                                       np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                       int, 
                                                                       float], float],
                                    py__prepoststep_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int, int], np.dtype[np.float64]]]]
                                   ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFlocal_put_state_en3dvar_lestkf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one(or the rank of the initial covariance matrix)

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * A_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix\n

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local dimension of state

        * dim_ens : int

            * Ensemble size

        * dim_cvec_ens : int

            * Dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * v_p : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment\n

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_ens : int

            * Ensemble size

        * dim_cv_ens_p : int

            * PE-local dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector\n

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state\n

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state\n

    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_f:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of the full observation vector

        **Callback Returns**

        * dim_obs_f:int

            * Size of the full observation vector\n

    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_f:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_f:ndarray[tuple[dim_obs_f], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_f : int

            * Size of full observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f:ndarray[tuple[dim_obs_f], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of the full observation vector

        * observation_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of observations

        **Callback Returns**

        * observation_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of observations\n

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local size of the observation vector

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations\n

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * A_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of full observation vector for model sub-domain

        * dim_obs_l : int

            * Size of observation vector for local analysis domain

        * mstate_f : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * dim_p : int

            * Size of full observation vector for model sub-domain

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * dim_l : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain\n

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of observation vector

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * meanvar : float

            * Mean observation error variance

        **Callback Returns**

        * meanvar:float

            * Mean observation error variance\n

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local dimension of observation vector

        * obs_l : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * dim_obs_p : int

            * Dimension of local observation vector

        * meanvar_l : float

            * Mean local observation error variance

        **Callback Returns**

        * meanvar_l:float

            * Mean local observation error variance\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n


    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_put_state_hyb3dvar_lestkf (py__collect_state_pdaf : Callable[[int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__init_dim_obs_pdaf : Callable[[int, 
                                                                       int], int],
                                     py__obs_op_pdaf : Callable[[int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__init_obs_pdaf : Callable[[int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__prodRinvA_pdaf : Callable[[int, 
                                                                    int, 
                                                                    int, 
                                                                    np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                    np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                     py__cvt_ens_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__cvt_adj_ens_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__cvt_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__cvt_adj_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__obs_op_lin_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__obs_op_adj_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__init_dim_obs_f_pdaf : Callable[[int, 
                                                                         int], int],
                                     py__obs_op_f_pdaf : Callable[[int, 
                                                                   int, 
                                                                   int, 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                   np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__init_obs_f_pdaf : Callable[[int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__init_obs_l_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int, 
                                                                     np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                                     py__prodRinvA_l_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                                     py__init_n_domains_p_pdaf : Callable[[int, 
                                                                           int], int],
                                     py__init_dim_l_pdaf : Callable[[int, 
                                                                     int, 
                                                                     int], int],
                                     py__init_dim_obs_l_pdaf : Callable[[int, 
                                                                         int, 
                                                                         int, 
                                                                         int], int],
                                     py__g2l_obs_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                                  int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                                     py__init_obsvar_pdaf : Callable[[int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      float], float],
                                     py__init_obsvar_l_pdaf : Callable[[int, 
                                                                        int, 
                                                                        int, 
                                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                        int, 
                                                                        float], float],
                                     py__prepoststep_pdaf : Callable[[int, 
                                                                      int, 
                                                                      int, 
                                                                      int, 
                                                                      int, 
                                                                      np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                      int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                      np.ndarray[tuple[int, int], np.dtype[np.float64]]]]
                                    ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFlocal_put_state_hyb3dvar_lestkf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__prodRinvA_pdaf : Callable[step:int, dim_obs_p:int, rank:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], A_p:ndarray[tuple[dim_obs_p, rank], np.float64], C_p:ndarray[tuple[dim_obs_p, rank], np.float64]]
        Provide product R^-1 A

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Number of observations at current time step (i.e. the size of the observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one(or the rank of the initial covariance matrix)

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * A_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Input matrix provided by PDAF

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_p : ndarray[tuple[dim_obs_p, rank], np.float64]

            * Output matrix\n

    py__cvt_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cvec_ens:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], v_p:ndarray[tuple[dim_cvec_ens], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix (ensemble)

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local dimension of state

        * dim_ens : int

            * Ensemble size

        * dim_cvec_ens : int

            * Dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * v_p : ndarray[tuple[dim_cvec_ens], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local state increment\n

    py__cvt_adj_ens_pdaf : Callable[iter:int, dim_p:int, dim_ens:int, dim_cv_ens_p:int, ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cv_ens_p], np.float64]]
        Apply adjoint control vector transform matrix (ensemble var)

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_ens : int

            * Ensemble size

        * dim_cv_ens_p : int

            * PE-local dimension of control vector

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * PE-local ensemble

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local input vector

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cv_ens_p], np.float64]

            * PE-local result vector\n

    py__cvt_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, cv_p:ndarray[tuple[dim_cvec], np.float64], Vv_p:ndarray[tuple[dim_p], np.float64]]
        Apply control vector transform matrix to control vector

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_cvec : int

            * Dimension of control vector

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        **Callback Returns**

        * Vv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)\n

    py__cvt_adj_pdaf : Callable[iter:int, dim_p:int, dim_cvec:int, Vcv_p:ndarray[tuple[dim_p], np.float64], cv_p:ndarray[tuple[dim_cvec], np.float64]]
        Apply adjoint control vector transform matrix

        **Callback Parameters**

        * iter : int

            * Iteration of optimization

        * dim_p : int

            * PE-local observation dimension

        * dim_cvec : int

            * Dimension of control vector

        * Vcv_p : ndarray[tuple[dim_p], np.float64]

            * PE-local result vector (state vector increment)

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector

        **Callback Returns**

        * cv_p : ndarray[tuple[dim_cvec], np.float64]

            * PE-local control vector\n

    py__obs_op_lin_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Linearized observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state\n

    py__obs_op_adj_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Adjoint observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * PE-local dimension of state

        * dim_obs_p : int

            * Dimension of observed state

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * PE-local observed state

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * PE-local model state\n

    py__init_dim_obs_f_pdaf : Callable[step:int, dim_obs_f:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of the full observation vector

        **Callback Returns**

        * dim_obs_f:int

            * Size of the full observation vector\n

    py__obs_op_f_pdaf : Callable[step:int, dim_p:int, dim_obs_f:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_f:ndarray[tuple[dim_obs_f], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_f : int

            * Size of full observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full observed state (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_f_pdaf : Callable[step:int, dim_obs_f:int, observation_f:ndarray[tuple[dim_obs_f], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of the full observation vector

        * observation_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of observations

        **Callback Returns**

        * observation_f : ndarray[tuple[dim_obs_f], np.float64]

            * Full vector of observations\n

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local size of the observation vector

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations\n

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * A_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of full observation vector for model sub-domain

        * dim_obs_l : int

            * Size of observation vector for local analysis domain

        * mstate_f : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * dim_p : int

            * Size of full observation vector for model sub-domain

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * dim_l : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain\n

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of observation vector

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * meanvar : float

            * Mean observation error variance

        **Callback Returns**

        * meanvar:float

            * Mean observation error variance\n

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local dimension of observation vector

        * obs_l : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * dim_obs_p : int

            * Dimension of local observation vector

        * meanvar_l : float

            * Mean local observation error variance

        **Callback Returns**

        * meanvar_l:float

            * Mean local observation error variance\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n


    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_put_state_lestkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_dim_obs_pdaf : Callable[[int, int], int],
                            py__obs_op_pdaf : Callable[[int, int, int, 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_obs_l_pdaf : Callable[[int, int, int, 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__prepoststep_pdaf : Callable[[int, int, 
                                                             int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                            py__prodRinvA_l_pdaf : Callable[[int, int, 
                                                             int, int, 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                            py__init_n_domains_p_pdaf : Callable[[int, 
                                                                  int], int],
                            py__init_dim_l_pdaf : Callable[[int, int, int], int],
                            py__init_dim_obs_l_pdaf : Callable[[int, int, 
                                                                int, int], int],
                            py__g2l_obs_pdaf : Callable[[int, int, int, 
                                                         int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                         int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                         int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                            py__init_obsvar_pdaf : Callable[[int, int, 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             float], float],
                            py__init_obsvar_l_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               int, float], float]
                           ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFlocal_put_state_lestkf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local size of the observation vector

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * A_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of full observation vector for model sub-domain

        * dim_obs_l : int

            * Size of observation vector for local analysis domain

        * mstate_f : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * dim_p : int

            * Size of full observation vector for model sub-domain

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * dim_l : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain\n

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of observation vector

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * meanvar : float

            * Mean observation error variance

        **Callback Returns**

        * meanvar:float

            * Mean observation error variance\n

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local dimension of observation vector

        * obs_l : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * dim_obs_p : int

            * Dimension of local observation vector

        * meanvar_l : float

            * Mean local observation error variance

        **Callback Returns**

        * meanvar_l:float

            * Mean local observation error variance\n


    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_put_state_letkf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                           py__init_dim_obs_pdaf : Callable[[int, int], int],
                           py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                           py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                           py__init_obs_l_pdaf : Callable[[int, int, int, 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                           py__prepoststep_pdaf : Callable[[int, int, int, 
                                                            int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                           py__prodRinvA_l_pdaf : Callable[[int, int, int, 
                                                            int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                           py__init_n_domains_p_pdaf : Callable[[int, int], int],
                           py__init_dim_l_pdaf : Callable[[int, int, int], int],
                           py__init_dim_obs_l_pdaf : Callable[[int, int, 
                                                               int, int], int],
                           py__g2l_obs_pdaf : Callable[[int, int, int, 
                                                        int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                        int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                        int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                           py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            float], float],
                           py__init_obsvar_l_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              int, float], float]
                          ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFlocal_put_state_letkf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local size of the observation vector

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * A_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of full observation vector for model sub-domain

        * dim_obs_l : int

            * Size of observation vector for local analysis domain

        * mstate_f : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * dim_p : int

            * Size of full observation vector for model sub-domain

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * dim_l : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain\n

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of observation vector

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * meanvar : float

            * Mean observation error variance

        **Callback Returns**

        * meanvar:float

            * Mean observation error variance\n

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local dimension of observation vector

        * obs_l : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * dim_obs_p : int

            * Dimension of local observation vector

        * meanvar_l : float

            * Mean local observation error variance

        **Callback Returns**

        * meanvar_l:float

            * Mean local observation error variance\n


    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_put_state_lknetf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_dim_obs_pdaf : Callable[[int, int], int],
                            py__obs_op_pdaf : Callable[[int, int, int, 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                        np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__init_obs_l_pdaf : Callable[[int, int, int, 
                                                            np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                            py__prepoststep_pdaf : Callable[[int, int, 
                                                             int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                            py__prodRinvA_l_pdaf : Callable[[int, int, 
                                                             int, int, 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                            py__prodRinvA_hyb_l_pdaf : Callable[[int, int, 
                                                                 int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                 float, 
                                                                 float], float],
                            py__init_n_domains_p_pdaf : Callable[[int, 
                                                                  int], int],
                            py__init_dim_l_pdaf : Callable[[int, int, int], int],
                            py__init_dim_obs_l_pdaf : Callable[[int, int, 
                                                                int, int], int],
                            py__g2l_obs_pdaf : Callable[[int, int, int, 
                                                         int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                         int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                         int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                            py__init_obsvar_pdaf : Callable[[int, int, 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             float], float],
                            py__init_obsvar_l_pdaf : Callable[[int, int, 
                                                               int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                               int, float], float],
                            py__likelihood_l_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              float], float],
                            py__likelihood_hyb_l_pdaf : Callable[[int, 
                                                                  int, 
                                                                  int, 
                                                                  int, 
                                                                  np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                                  float, 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                                  np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]]
                           ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFlocal_put_state_lknetf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local size of the observation vector

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * A_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix\n

    py__prodRinvA_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, likely_l:float]
        Provide product R^-1 A on local analysis domain with hybrid weight

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * resid_l : ndarray[tuple[dim_obs_l], np.float64]

            * Input vector holding the local residual

        * gamma : float

            * Hybrid weight provided by PDAF

        * likely_l : float

            * Output value of the local likelihood

        **Callback Returns**

        * likely_l:float

            * Output value of the local likelihood\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of full observation vector for model sub-domain

        * dim_obs_l : int

            * Size of observation vector for local analysis domain

        * mstate_f : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * dim_p : int

            * Size of full observation vector for model sub-domain

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * dim_l : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain\n

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of observation vector

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * meanvar : float

            * Mean observation error variance

        **Callback Returns**

        * meanvar:float

            * Mean observation error variance\n

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local dimension of observation vector

        * obs_l : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * dim_obs_p : int

            * Dimension of local observation vector

        * meanvar_l : float

            * Mean local observation error variance

        **Callback Returns**

        * meanvar_l:float

            * Mean local observation error variance\n

    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute likelihood

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * resid_l : ndarray[tuple[dim_obs_l], np.float64]

            * nput vector holding the local residual

        * likely_l : float

            * Output value of the local likelihood

        **Callback Returns**

        * likely_l:float

            * Output value of the local likelihood\n

    py__likelihood_hyb_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], gamma:float, A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Compute likelihood with hybrid weight

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * rank : int

            * Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * gamma : float

            * Hybrid weight provided by PDAF

        * A_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix\n


    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_put_state_lnetf (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                           py__init_dim_obs_pdaf : Callable[[int, int], int],
                           py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                           py__init_obs_l_pdaf : Callable[[int, int, int, 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                           py__prepoststep_pdaf : Callable[[int, int, int, 
                                                            int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                           py__likelihood_l_pdaf : Callable[[int, int, 
                                                             int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                             float], float],
                           py__init_n_domains_p_pdaf : Callable[[int, int], int],
                           py__init_dim_l_pdaf : Callable[[int, int, int], int],
                           py__init_dim_obs_l_pdaf : Callable[[int, int, 
                                                               int, int], int],
                           py__g2l_obs_pdaf : Callable[[int, int, int, 
                                                        int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                        int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                        int], np.ndarray[tuple[int], np.dtype[np.intc]]]
                          ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFlocal_put_state_lnetf or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local size of the observation vector

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__likelihood_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], resid_l:ndarray[tuple[dim_obs_l], np.float64], likely_l:float]
        Compute observation likelihood for an ensemble member

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * resid_l : ndarray[tuple[dim_obs_l], np.float64]

            * nput vector holding the local residual

        * likely_l : float

            * Output value of the local likelihood

        **Callback Returns**

        * likely_l:float

            * Output value of the local likelihood\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of full observation vector for model sub-domain

        * dim_obs_l : int

            * Size of observation vector for local analysis domain

        * mstate_f : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * dim_p : int

            * Size of full observation vector for model sub-domain

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * dim_l : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain\n


    Returns
    -------
    outflag : int
        Status flag
    """
    ...

def local_put_state_lseik (py__collect_state_pdaf : Callable[[int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                           py__init_dim_obs_pdaf : Callable[[int, int], int],
                           py__obs_op_pdaf : Callable[[int, int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                       np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                           py__init_obs_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                           py__init_obs_l_pdaf : Callable[[int, int, int, 
                                                           np.ndarray[tuple[int], np.dtype[np.float64]]], np.ndarray[tuple[int], np.dtype[np.float64]]],
                           py__prepoststep_pdaf : Callable[[int, int, int, 
                                                            int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            int], tuple[np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]]]],
                           py__prodRinvA_l_pdaf : Callable[[int, int, int, 
                                                            int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]], 
                                                            np.ndarray[tuple[int, int], np.dtype[np.float64]]], np.ndarray[tuple[int, int], np.dtype[np.float64]]],
                           py__init_n_domains_p_pdaf : Callable[[int, int], int],
                           py__init_dim_l_pdaf : Callable[[int, int, int], int],
                           py__init_dim_obs_l_pdaf : Callable[[int, int, 
                                                               int, int], int],
                           py__g2l_obs_pdaf : Callable[[int, int, int, 
                                                        int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                        int, np.ndarray[tuple[int], np.dtype[np.intc]], 
                                                        int], np.ndarray[tuple[int], np.dtype[np.intc]]],
                           py__init_obsvar_pdaf : Callable[[int, int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                            float], float],
                           py__init_obsvar_l_pdaf : Callable[[int, int, 
                                                              int, np.ndarray[tuple[int], np.dtype[np.float64]], 
                                                              int, float], float]
                          ) -> int:
    """See detailed explanation of the routine in https://pdaf.awi.de/trac/wiki/PDAFlocal_put_state_lseik or PDAF source files 

    Parameters
    ----------
    py__collect_state_pdaf : Callable[dim_p:int, state_p:ndarray[tuple[dim_p], np.float64]]
        Routine to collect a state vector

        **Callback Parameters**

        * dim_p : int

            * pe-local state dimension

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * local state vector\n

    py__init_dim_obs_pdaf : Callable[step:int, dim_obs_p:int]
        Initialize dimension of observation vector

        **Callback Parameters**

        * step : int

            * current time step

        * dim_obs_p : int

            * dimension of observation vector

        **Callback Returns**

        * dim_obs_p:int

            * dimension of observation vector\n

    py__obs_op_pdaf : Callable[step:int, dim_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], m_state_p:ndarray[tuple[dim_obs_p], np.float64]]
        Observation operator

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_p : int

            * Size of state vector (local part in case of parallel decomposed state)

        * dim_obs_p : int

            * Size of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * Model state vector

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)

        **Callback Returns**

        * m_state_p : ndarray[tuple[dim_obs_p], np.float64]

            * Observed state vector (i.e. the result after applying the observation operator to state_p)\n

    py__init_obs_pdaf : Callable[step:int, dim_obs_p:int, observation_p:ndarray[tuple[dim_obs_p], np.float64]]
        Initialize PE-local observation vector

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of the observation vector

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        **Callback Returns**

        * observation_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations\n

    py__init_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, observation_l:ndarray[tuple[dim_obs_l], np.float64]]
        Init. observation vector on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local size of the observation vector

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        **Callback Returns**

        * observation_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations\n

    py__prepoststep_pdaf : Callable[step:int, dim_p:int, dim_ens:int, dim_ens_p:int, dim_obs_p:int, state_p:ndarray[tuple[dim_p], np.float64], uinv:ndarray[tuple[dim_ens-1, dim_ens-1], np.float64], ens_p:ndarray[tuple[dim_p, dim_ens], np.float64], flag:int]
        User supplied pre/poststep routine

        **Callback Parameters**

        * step : int

            * current time step (negative for call after forecast)

        * dim_p : int

            * pe-local state dimension

        * dim_ens : int

            * size of state ensemble

        * dim_ens_p : int

            * pe-local size of ensemble

        * dim_obs_p : int

            * pe-local dimension of observation vector

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)

        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u

        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble

        * flag : int

            * pdaf status flag

        **Callback Returns**

        * state_p : ndarray[tuple[dim_p], np.float64]

            * pe-local forecast/analysis state(the array 'state_p' is not generally notinitialized in the case of seik.it can be used freely here.)\n
        * uinv : ndarray[tuple[dim_ens-1, dim_ens-1], np.float64]

            * inverse of matrix u\n
        * ens_p : ndarray[tuple[dim_p, dim_ens], np.float64]

            * pe-local state ensemble\n

    py__prodRinvA_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, rank:int, obs_l:ndarray[tuple[dim_obs_l], np.float64], A_l:ndarray[tuple[dim_obs_l, rank], np.float64], C_l:ndarray[tuple[dim_obs_l, rank], np.float64]]
        Provide product R^-1 A on local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Number of local observations at current time step (i.e. the size of the local observation vector)

        * rank : int

            * Number of the columns in the matrix processes here.This is usually the ensemble size minus one (or the rank of the initial covariance matrix)

        * obs_l : ndarray[tuple[dim_obs_l], np.float64]

            * Local vector of observations

        * A_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Input matrix provided by PDAF

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix

        **Callback Returns**

        * C_l : ndarray[tuple[dim_obs_l, rank], np.float64]

            * Output matrix\n

    py__init_n_domains_p_pdaf : Callable[step:int, n_domains_p:int]
        Provide number of local analysis domains

        **Callback Parameters**

        * step : int

            * current time step

        * n_domains_p : int

            * pe-local number of analysis domains

        **Callback Returns**

        * n_domains_p:int

            * pe-local number of analysis domains\n

    py__init_dim_l_pdaf : Callable[step:int, domain_p:int, dim_l:int]
        Init state dimension for local ana. domain

        **Callback Parameters**

        * step : int

            * current time step

        * domain_p : int

            * current local analysis domain

        * dim_l : int

            * local state dimension

        **Callback Returns**

        * dim_l:int

            * local state dimension\n

    py__init_dim_obs_l_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int]
        Initialize dim. of obs. vector for local ana. domain

        **Callback Parameters**

        * domain_p : int

            * index of current local analysis domain

        * step : int

            * current time step

        * dim_obs_f : int

            * full dimension of observation vector

        * dim_obs_l : int

            * local dimension of observation vector

        **Callback Returns**

        * dim_obs_l:int

            * local dimension of observation vector\n

    py__g2l_obs_pdaf : Callable[domain_p:int, step:int, dim_obs_f:int, dim_obs_l:int, mstate_f:ndarray[tuple[dim_p], np.intc], dim_p:int, mstate_l:ndarray[tuple[dim_l], np.intc], dim_l:int]
        Restrict full obs. vector to local analysis domain

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_f : int

            * Size of full observation vector for model sub-domain

        * dim_obs_l : int

            * Size of observation vector for local analysis domain

        * mstate_f : ndarray[tuple[dim_p], np.intc]

            * Full observation vector for model sub-domain

        * dim_p : int

            * Size of full observation vector for model sub-domain

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain

        * dim_l : int

            * Size of observation vector for local analysis domain

        **Callback Returns**

        * mstate_l : ndarray[tuple[dim_l], np.intc]

            * Observation vector for local analysis domain\n

    py__init_obsvar_pdaf : Callable[step:int, dim_obs_p:int, obs_p:ndarray[tuple[dim_obs_p], np.float64], meanvar:float]
        Initialize mean observation error variance

        **Callback Parameters**

        * step : int

            * Current time step

        * dim_obs_p : int

            * Size of observation vector

        * obs_p : ndarray[tuple[dim_obs_p], np.float64]

            * Vector of observations

        * meanvar : float

            * Mean observation error variance

        **Callback Returns**

        * meanvar:float

            * Mean observation error variance\n

    py__init_obsvar_l_pdaf : Callable[domain_p:int, step:int, dim_obs_l:int, obs_l:ndarray[tuple[dim_obs_p], np.float64], dim_obs_p:int, meanvar_l:float]
        Initialize local mean observation error variance

        **Callback Parameters**

        * domain_p : int

            * Index of current local analysis domain

        * step : int

            * Current time step

        * dim_obs_l : int

            * Local dimension of observation vector

        * obs_l : ndarray[tuple[dim_obs_p], np.float64]

            * Local observation vector

        * dim_obs_p : int

            * Dimension of local observation vector

        * meanvar_l : float

            * Mean local observation error variance

        **Callback Returns**

        * meanvar_l:float

            * Mean local observation error variance\n


    Returns
    -------
    outflag : int
        Status flag
    """
    ...

