import sys
import numpy as np
cimport numpy as cnp
from pyPDAF cimport pdaf_c_cb_interface as pdaf_cb
from pyPDAF.cfi_binding cimport CFI_cdesc_t, CFI_address, CFI_index_t, CFI_establish
from pyPDAF.cfi_binding cimport CFI_attribute_other, CFI_type_double, CFI_type_int
from pyPDAF.cfi_binding cimport CFI_cdesc_rank1, CFI_cdesc_rank2, CFI_cdesc_rank3

try:
    import mpi4py
    mpi4py.rc.initialize = False
except ImportError:
    pass

# Global error handler
def global_except_hook(exctype, value, traceback):
    from traceback import print_exception
    try:
        import mpi4py.MPI

        if mpi4py.MPI.Is_initialized():
            try:
                sys.stderr.write('Uncaught exception was ''detected on rank {}.\n'.format(
                    mpi4py.MPI.COMM_WORLD.Get_rank()))
                print_exception(exctype, value, traceback)
                sys.stderr.write("\n")
                sys.stderr.flush()
            finally:
                try:
                    mpi4py.MPI.COMM_WORLD.Abort(1)
                except Exception as e:
                    sys.stderr.write('MPI Abort failed, this process will hang.\n')
                    sys.stderr.flush()
                    raise e
        else:
            sys.__excepthook__(exctype, value, traceback)
    except ImportError:
        sys.__excepthook__(exctype, value, traceback)

sys.excepthook = global_except_hook

def assimilate_en3dvar_lestkf(py__collect_state_pdaf,
    py__distribute_state_pdaf, py__init_dim_obs_pdaf, py__obs_op_pdaf,
    py__init_obs_pdaf, py__prodrinva_pdaf, py__cvt_ens_pdaf,
    py__cvt_adj_ens_pdaf, py__obs_op_lin_pdaf, py__obs_op_adj_pdaf,
    py__init_dim_obs_f_pdaf, py__obs_op_f_pdaf, py__init_obs_f_pdaf,
    py__init_obs_l_pdaf, py__prodrinva_l_pdaf, py__init_n_domains_p_pdaf,
    py__init_dim_l_pdaf, py__init_dim_obs_l_pdaf, py__g2l_obs_pdaf,
    py__init_obsvar_pdaf, py__init_obsvar_l_pdaf, py__prepoststep_pdaf,
    py__next_observation_pdaf):
    """It is recommended to use
    :func:`pyPDAF.PDAF.localomi_assimilate_en3dvar_lestkf` or
    :func:`pyPDAF.PDAF.localomi_assimilate_en3dvar_lestkf_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions
    and improved efficiency.

    3DEnVar for a single DA step where the ensemble anomaly
    is generated by LESTKF.
    The background error covariance matrix is
    estimated by ensemble.
    The 3DEnVar only calculates the analysis of the ensemble mean.
    An LESTKF is used to generate ensemble perturbations.
    This function should be called at each model time step.

    The function is a combination of
    :func:`pyPDAF.PDAF.put_state_en3dvar_lestkf`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. py__init_obs_pdaf
        6. Starting the iterative optimisation:
            1. py__cvt_ens_pdaf
            2. py__obs_op_lin_pdaf
            3. py__prodRinvA_pdaf
            4. py__obs_op_adj_pdaf
            5. py__cvt_adj_ens_pdaf
            6. core DA algorithm
        7. py__cvt_ens_pdaf
        8. Perform LESTKF:
            1. py__init_n_domains_p_pdaf
            2. py__init_dim_obs_pdaf
            3. py__obs_op_pdaf
               (for each ensemble member)
            4. py__init_obs_pdaf
               (if global adaptive forgetting factor is used
               `type_forget=1` in :func:`pyPDAF.PDAF.init`)
            5. py__init_obsvar_pdaf
               (if global adaptive forgetting factor is used)
            6. loop over each local domain:
                1. py__init_dim_l_pdaf
                2. py__init_dim_obs_l_pdaf
                3. py__g2l_state_pdaf
                4. py__g2l_obs_pdaf
                   (localise mean ensemble in observation space)
                5. py__init_obs_l_pdaf
                6. py__g2l_obs_pdaf
                   (localise each ensemble member
                   in observation space)
                7. py__init_obsvar_l_pdaf
                   (only called if local
                   adaptive forgetting factor
                   `type_forget=2` is used)
                8. py__prodRinvA_l_pdaf
                9. core DA algorithm
                10. py__l2g_state_pdaf
        9. py__prepoststep_state_pdaf
        10. py__distribute_state_pdaf
        11. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_assimilate_en3dvar_lestkf`
       and
       :func:`pyPDAF.PDAF.localomi_assimilate_en3dvar_lestkf_nondiagR`

    Parameters
    ----------
    py__collect_state_pdaf : Callable
        Routine to collect a state vector

        Callback Parameters
        -------------------
        dim_p : int
                pe-local state dimension
        state_p : ndarray[np.float64, ndim=1]
                local state vector
                Array shape: (dim_p)

        Callback Returns
        ----------------
        state_p : ndarray[np.float64, ndim=1]
                local state vector
                Array shape: (dim_p)

    py__distribute_state_pdaf : Callable
        Routine to distribute a state vector

        Callback Parameters
        -------------------
        dim_p : int
                PE-local state dimension
        state_p : ndarray[np.float64, ndim=1]
                PE-local state vector
                Array shape: (dim_p)

        Callback Returns
        ----------------
        state_p : ndarray[np.float64, ndim=1]
                PE-local state vector
                Array shape: (dim_p)

    py__init_dim_obs_pdaf : Callable
        Initialize dimension of observation vector

        Callback Parameters
        -------------------
        step : int
                current time step

        Callback Returns
        ----------------
        dim_obs_p : int
                dimension of observation vector

    py__obs_op_pdaf : Callable
        Observation operator

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_p : int
                Size of state vector
                (local part in case of parallel decomposed state)
        dim_obs_p : int
                Size of PE-local observation vector
        state_p : ndarray[np.float64, ndim=1]
                Model state vector
                Array shape: (dim_p)
        m_state_p : ndarray[np.float64, ndim=1]
                Observed state vector
                (i.e. the result after applying the observation operator to state_p)
                Array shape: (dim_obs_p)

        Callback Returns
        ----------------
        m_state_p : ndarray[np.float64, ndim=1]
                Observed state vector
                (i.e. the result after applying the observation operator to state_p)
                Array shape: (dim_obs_p)

    py__init_obs_pdaf : Callable
        Initialize observation vector

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_obs_p : int
                Size of the observation vector

        Callback Returns
        ----------------
        observation_p : ndarray[np.float64, ndim=1]
                Vector of observations
                Array shape: (dim_obs_p)

    py__prodrinva_pdaf : Callable
        Provide product R^-1 A

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_obs_p : int
                Number of observations at current time step (i.e. the size of the observation vector)
        rank : int
                Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one
                (or the rank of the initial covariance matrix)
        obs_p : ndarray[np.float64, ndim=1]
                Vector of observations
                Array shape: (dim_obs_p)
        a_p : ndarray[np.float64, ndim=2]
                Input matrix provided by PDAF
                Array shape: (dim_obs_p, rank)

        Callback Returns
        ----------------
        c_p : ndarray[np.float64, ndim=2]
                Output matrix
                Array shape: (dim_obs_p, rank)

    py__cvt_ens_pdaf : Callable
        Apply control vector transform matrix (ensemble)

        Callback Parameters
        -------------------
        iter : int
                Iteration of optimization
        dim_p : int
                PE-local dimension of state
        dim_ens : int
                Ensemble size
        dim_cvec_ens : int
                Dimension of control vector
        ens_p : ndarray[np.float64, ndim=2]
                PE-local ensemble
                Array shape: (dim_p, dim_ens)
        v_p : ndarray[np.float64, ndim=1]
                PE-local control vector
                Array shape: (dim_cvec_ens)
        vv_p : ndarray[np.float64, ndim=1]
                PE-local state increment
                Array shape: (dim_p)

        Callback Returns
        ----------------
        vv_p : ndarray[np.float64, ndim=1]
                PE-local state increment
                Array shape: (dim_p)

    py__cvt_adj_ens_pdaf : Callable
        Apply adjoint control vector transform matrix (ensemble var)

        Callback Parameters
        -------------------
        iter : int
                Iteration of optimization
        dim_p : int
                PE-local observation dimension
        dim_ens : int
                Ensemble size
        dim_cv_ens_p : int
                PE-local dimension of control vector
        ens_p : ndarray[np.float64, ndim=2]
                PE-local ensemble
                Array shape: (dim_p, dim_ens)
        vcv_p : ndarray[np.float64, ndim=1]
                PE-local input vector
                Array shape: (dim_p)
        cv_p : ndarray[np.float64, ndim=1]
                PE-local result vector
                Array shape: (dim_cv_ens_p)

        Callback Returns
        ----------------
        cv_p : ndarray[np.float64, ndim=1]
                PE-local result vector
                Array shape: (dim_cv_ens_p)

    py__obs_op_lin_pdaf : Callable
        Linearized observation operator

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_p : int
                PE-local dimension of state
        dim_obs_p : int
                Dimension of observed state
        state_p : ndarray[np.float64, ndim=1]
                PE-local model state
                Array shape: (dim_p)
        m_state_p : ndarray[np.float64, ndim=1]
                PE-local observed state
                Array shape: (dim_obs_p)

        Callback Returns
        ----------------
        m_state_p : ndarray[np.float64, ndim=1]
                PE-local observed state
                Array shape: (dim_obs_p)

    py__obs_op_adj_pdaf : Callable
        Adjoint observation operator

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_p : int
                PE-local dimension of state
        dim_obs_p : int
                Dimension of observed state
        m_state_p : ndarray[np.float64, ndim=1]
                PE-local observed state
                Array shape: (dim_obs_p)
        state_p : ndarray[np.float64, ndim=1]
                PE-local model state
                Array shape: (dim_p)

        Callback Returns
        ----------------
        state_p : ndarray[np.float64, ndim=1]
                PE-local model state
                Array shape: (dim_p)

    py__init_dim_obs_f_pdaf : Callable
        Initialize dimension of observation vector

        Callback Parameters
        -------------------
        step : int
                current time step

        Callback Returns
        ----------------
        dim_obs_p : int
                dimension of observation vector

    py__obs_op_f_pdaf : Callable
        Observation operator

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_p : int
                Size of state vector (local part in case of parallel decomposed state)
        dim_obs_p : int
                Size of observation vector
        state_p : ndarray[np.float64, ndim=1]
                Model state vector
                Array shape: (dim_p)

        Callback Returns
        ----------------
        m_state_p : ndarray[np.float64, ndim=1]
                Observed state vector (i.e. the result after applying the observation operator to state_p)
                Array shape: (dim_obs_p)

    py__init_obs_f_pdaf : Callable
        Initialize PE-local observation vector

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_obs_f : int
                Size of the full observation vector

        Callback Returns
        ----------------
        observation_f : ndarray[np.float64, ndim=1]
                Full vector of observations
                Array shape: (dim_obs_f)

    py__init_obs_l_pdaf : Callable
        Init. observation vector on local analysis domain

        Callback Parameters
        -------------------
        domain_p : int
                Index of current local analysis domain
        step : int
                Current time step
        dim_obs_l : int
                Local size of the observation vector

        Callback Returns
        ----------------
        observation_l : ndarray[np.float64, ndim=1]
                Local vector of observations
                Array shape: (dim_obs_l)

    py__prodrinva_l_pdaf : Callable
        Provide product R^-1 A on local analysis domain

        Callback Parameters
        -------------------
        domain_p : int
                Index of current local analysis domain
        step : int
                Current time step
        dim_obs_l : int
                Number of local observations at current time step (i.e. the size of the local observation vector)
        rank : int
                Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)
        obs_l : ndarray[np.float64, ndim=1]
                Local vector of observations
                Array shape: (dim_obs_l)
        a_l : ndarray[np.float64, ndim=2]
                Input matrix provided by PDAF
                Array shape: (dim_obs_l, rank)

        Callback Returns
        ----------------
        a_l : ndarray[np.float64, ndim=2]
                Input matrix provided by PDAF
                Array shape: (dim_obs_l, rank)
        c_l : ndarray[np.float64, ndim=2]
                Output matrix
                Array shape: (dim_obs_l, rank)

    py__init_n_domains_p_pdaf : Callable
        Provide number of local analysis domains

        Callback Parameters
        -------------------
        step : int
                current time step

        Callback Returns
        ----------------
        n_domains_p : int
                pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable
        Init state dimension for local ana. domain

        Callback Parameters
        -------------------
        step : int
                current time step
        domain_p : int
                current local analysis domain

        Callback Returns
        ----------------
        dim_l : int
                local state dimension

    py__init_dim_obs_l_pdaf : Callable
        Initialize dim. of obs. vector for local ana. domain

        Callback Parameters
        -------------------
        domain_p : int
                index of current local analysis domain
        step : int
                current time step
        dim_obs_f : int
                full dimension of observation vector

        Callback Returns
        ----------------
        dim_obs_l : int
                local dimension of observation vector

    py__g2l_obs_pdaf : Callable
        Restrict full obs. vector to local analysis domain

        Callback Parameters
        -------------------
        domain_p : int
                Index of current local analysis domain
        step : int
                Current time step
        dim_obs_f : int
                Size of full observation vector for model sub-domain
        dim_obs_l : int
                Size of observation vector for local analysis domain
        mstate_f : ndarray[np.intc, ndim=1]
                Full observation vector for model sub-domain
                Array shape: (dim_p)
        dim_p : int
                Size of full observation vector for model sub-domain
        dim_l : int
                Size of observation vector for local analysis domain

        Callback Returns
        ----------------
        mstate_l : ndarray[np.intc, ndim=1]
                Observation vector for local analysis domain
                Array shape: (dim_l)

    py__init_obsvar_pdaf : Callable
        Initialize mean observation error variance

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_obs_p : int
                Size of observation vector
        obs_p : ndarray[np.float64, ndim=1]
                Vector of observations
                Array shape: (dim_obs_p)

        Callback Returns
        ----------------
        meanvar : double
                Mean observation error variance

    py__init_obsvar_l_pdaf : Callable
        Initialize local mean observation error variance

        Callback Parameters
        -------------------
        domain_p : int
                Index of current local analysis domain
        step : int
                Current time step
        dim_obs_l : int
                Local dimension of observation vector
        obs_l : ndarray[np.float64, ndim=1]
                Local observation vector
                Array shape: (dim_obs_p)
        dim_obs_p : int
                Dimension of local observation vector

        Callback Returns
        ----------------
        meanvar_l : double
                Mean local observation error variance

    py__prepoststep_pdaf : Callable
        User supplied pre/poststep routine

        Callback Parameters
        -------------------
        step : int
                current time step
                (negative for call before analysis/preprocessing)
        dim_p : int
                PE-local state vector dimension
        dim_ens : int
                number of ensemble members
        dim_ens_l : int
                number of ensemble members run serially
                on each model task
        dim_obs_p : int
                PE-local dimension of observation vector
        state_p : ndarray[np.float64, ndim=1]
                pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)
                Array shape: (dim_p)
        uinv : ndarray[np.float64, ndim=2]
                Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.
                Array shape: (dim_ens-1, dim_ens-1)
        ens_p : ndarray[np.float64, ndim=2]
                PE-local ensemble
                Array shape: (dim_p, dim_ens)
        flag : int
                pdaf status flag

        Callback Returns
        ----------------
        state_p : ndarray[np.float64, ndim=1]
                pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)
                Array shape: (dim_p)
        uinv : ndarray[np.float64, ndim=2]
                Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.
                Array shape: (dim_ens-1, dim_ens-1)
        ens_p : ndarray[np.float64, ndim=2]
                PE-local ensemble
                Array shape: (dim_p, dim_ens)

    py__next_observation_pdaf : Callable
        Routine to provide time step, time and dimensionof next observation

        Callback Parameters
        -------------------
        stepnow : int
                the current time step given by PDAF

        Callback Returns
        ----------------
        nsteps : int
                number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation
        doexit : int
                whether to exit forecasting (1 for exit)
        time : double
                current model (physical) time


    Returns
    -------
    outflag : int
        Status flag
    """
    pdaf_cb.collect_state_pdaf = <void*>py__collect_state_pdaf
    pdaf_cb.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    pdaf_cb.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    pdaf_cb.obs_op_pdaf = <void*>py__obs_op_pdaf
    pdaf_cb.init_obs_pdaf = <void*>py__init_obs_pdaf
    pdaf_cb.prodrinva_pdaf = <void*>py__prodrinva_pdaf
    pdaf_cb.cvt_ens_pdaf = <void*>py__cvt_ens_pdaf
    pdaf_cb.cvt_adj_ens_pdaf = <void*>py__cvt_adj_ens_pdaf
    pdaf_cb.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    pdaf_cb.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    pdaf_cb.init_dim_obs_f_pdaf = <void*>py__init_dim_obs_f_pdaf
    pdaf_cb.obs_op_f_pdaf = <void*>py__obs_op_f_pdaf
    pdaf_cb.init_obs_f_pdaf = <void*>py__init_obs_f_pdaf
    pdaf_cb.init_obs_l_pdaf = <void*>py__init_obs_l_pdaf
    pdaf_cb.prodrinva_l_pdaf = <void*>py__prodrinva_l_pdaf
    pdaf_cb.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    pdaf_cb.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    pdaf_cb.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    pdaf_cb.g2l_obs_pdaf = <void*>py__g2l_obs_pdaf
    pdaf_cb.init_obsvar_pdaf = <void*>py__init_obsvar_pdaf
    pdaf_cb.init_obsvar_l_pdaf = <void*>py__init_obsvar_l_pdaf
    pdaf_cb.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    pdaf_cb.next_observation_pdaf = <void*>py__next_observation_pdaf
    cdef int  outflag
    with nogil:
        c__pdaflocal_assimilate_en3dvar_lestkf(
                                               pdaf_cb.c__collect_state_pdaf,
                                               pdaf_cb.c__distribute_state_pdaf,
                                               pdaf_cb.c__init_dim_obs_pdaf,
                                               pdaf_cb.c__obs_op_pdaf,
                                               pdaf_cb.c__init_obs_pdaf,
                                               pdaf_cb.c__prodrinva_pdaf,
                                               pdaf_cb.c__cvt_ens_pdaf,
                                               pdaf_cb.c__cvt_adj_ens_pdaf,
                                               pdaf_cb.c__obs_op_lin_pdaf,
                                               pdaf_cb.c__obs_op_adj_pdaf,
                                               pdaf_cb.c__init_dim_obs_f_pdaf,
                                               pdaf_cb.c__obs_op_f_pdaf,
                                               pdaf_cb.c__init_obs_f_pdaf,
                                               pdaf_cb.c__init_obs_l_pdaf,
                                               pdaf_cb.c__prodrinva_l_pdaf,
                                               pdaf_cb.c__init_n_domains_p_pdaf,
                                               pdaf_cb.c__init_dim_l_pdaf,
                                               pdaf_cb.c__init_dim_obs_l_pdaf,
                                               pdaf_cb.c__g2l_obs_pdaf,
                                               pdaf_cb.c__init_obsvar_pdaf,
                                               pdaf_cb.c__init_obsvar_l_pdaf,
                                               pdaf_cb.c__prepoststep_pdaf,
                                               pdaf_cb.c__next_observation_pdaf,
                                               &outflag)

    return outflag


def assimilate_hyb3dvar_lestkf(py__collect_state_pdaf,
    py__distribute_state_pdaf, py__init_dim_obs_pdaf, py__obs_op_pdaf,
    py__init_obs_pdaf, py__prodrinva_pdaf, py__cvt_ens_pdaf,
    py__cvt_adj_ens_pdaf, py__cvt_pdaf, py__cvt_adj_pdaf,
    py__obs_op_lin_pdaf, py__obs_op_adj_pdaf, py__init_dim_obs_f_pdaf,
    py__obs_op_f_pdaf, py__init_obs_f_pdaf, py__init_obs_l_pdaf,
    py__prodrinva_l_pdaf, py__init_n_domains_p_pdaf, py__init_dim_l_pdaf,
    py__init_dim_obs_l_pdaf, py__g2l_obs_pdaf, py__init_obsvar_pdaf,
    py__init_obsvar_l_pdaf, py__prepoststep_pdaf, py__next_observation_pdaf):
    """It is recommended to use
    :func:`pyPDAF.PDAF.localomi_assimilate_hyb3dvar_lestkf` or
    :func:`pyPDAF.PDAF.localomi_assimilate_hyb3dvar_lestkf_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions
    and improved efficiency.

    Hybrid 3DEnVar for a single DA step where
    the background error covariance is hybridised by
    a static background error covariance,
    and a flow-dependent background error covariance
    estimated from ensemble.
    The 3DVar generates an ensemble mean and
    the ensemble perturbation is generated by
    LESTKF in this implementation.
    This function should be called at each model time step.

    The function is a combination of
    :func:`pyPDAF.PDAF.put_state_hyb3dvar_lestkf`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_dim_obs_pdaf
        4. py__obs_op_pdaf
        5. py__init_obs_pdaf
        6. The iterative optimisation:
            1. py__cvt_pdaf
            2. py__cvt_ens_pdaf
            3. py__obs_op_lin_pdaf
            4. py__prodRinvA_pdaf
            5. py__obs_op_adj_pdaf
            6. py__cvt_adj_pdaf
            7. py__cvt_adj_ens_pdaf
            8. core DA algorithm
        7. py__cvt_pdaf
        8. py__cvt_ens_pdaf
        9. Perform LESTKF:
            1. py__init_n_domains_p_pdaf
            2. py__init_dim_obs_pdaf
            3. py__obs_op_pdaf
               (for each ensemble member)
            4. py__init_obs_pdaf
               (if global adaptive forgetting factor
               `type_forget=1` in :func:`pyPDAF.PDAF.init`)
            5. py__init_obsvar_pdaf
               (if global adaptive forgetting factor is used)
            6. loop over each local domain:
                1. py__init_dim_l_pdaf
                2. py__init_dim_obs_l_pdaf
                3. py__g2l_state_pdaf
                4. py__g2l_obs_pdaf
                   (localise mean ensemble in observation space)
                5. py__init_obs_l_pdaf
                6. py__g2l_obs_pdaf
                   (localise each ensemble member
                   in observation space)
                7. py__init_obsvar_l_pdaf
                   (only called if local adaptive forgetting
                   factor `type_forget=2` is used)
                8. py__prodRinvA_l_pdaf
                9. core DA algorithm
                10. py__l2g_state_pdaf
        10. py__prepoststep_state_pdaf
        11. py__distribute_state_pdaf
        12. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_assimilate_hyb3dvar_lestkf`
       and
       :func:`pyPDAF.PDAF.localomi_assimilate_hyb3dvar_lestkf_nondiagR`

    Parameters
    ----------
    py__collect_state_pdaf : Callable
        Routine to collect a state vector

        Callback Parameters
        -------------------
        dim_p : int
                pe-local state dimension
        state_p : ndarray[np.float64, ndim=1]
                local state vector
                Array shape: (dim_p)

        Callback Returns
        ----------------
        state_p : ndarray[np.float64, ndim=1]
                local state vector
                Array shape: (dim_p)

    py__distribute_state_pdaf : Callable
        Routine to distribute a state vector

        Callback Parameters
        -------------------
        dim_p : int
                PE-local state dimension
        state_p : ndarray[np.float64, ndim=1]
                PE-local state vector
                Array shape: (dim_p)

        Callback Returns
        ----------------
        state_p : ndarray[np.float64, ndim=1]
                PE-local state vector
                Array shape: (dim_p)

    py__init_dim_obs_pdaf : Callable
        Initialize dimension of observation vector

        Callback Parameters
        -------------------
        step : int
                current time step

        Callback Returns
        ----------------
        dim_obs_p : int
                dimension of observation vector

    py__obs_op_pdaf : Callable
        Observation operator

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_p : int
                Size of state vector
                (local part in case of parallel decomposed state)
        dim_obs_p : int
                Size of PE-local observation vector
        state_p : ndarray[np.float64, ndim=1]
                Model state vector
                Array shape: (dim_p)
        m_state_p : ndarray[np.float64, ndim=1]
                Observed state vector
                (i.e. the result after applying the observation operator to state_p)
                Array shape: (dim_obs_p)

        Callback Returns
        ----------------
        m_state_p : ndarray[np.float64, ndim=1]
                Observed state vector
                (i.e. the result after applying the observation operator to state_p)
                Array shape: (dim_obs_p)

    py__init_obs_pdaf : Callable
        Initialize observation vector

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_obs_p : int
                Size of the observation vector

        Callback Returns
        ----------------
        observation_p : ndarray[np.float64, ndim=1]
                Vector of observations
                Array shape: (dim_obs_p)

    py__prodrinva_pdaf : Callable
        Provide product R^-1 A

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_obs_p : int
                Number of observations at current time step (i.e. the size of the observation vector)
        rank : int
                Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one
                (or the rank of the initial covariance matrix)
        obs_p : ndarray[np.float64, ndim=1]
                Vector of observations
                Array shape: (dim_obs_p)
        a_p : ndarray[np.float64, ndim=2]
                Input matrix provided by PDAF
                Array shape: (dim_obs_p, rank)

        Callback Returns
        ----------------
        c_p : ndarray[np.float64, ndim=2]
                Output matrix
                Array shape: (dim_obs_p, rank)

    py__cvt_ens_pdaf : Callable
        Apply control vector transform matrix (ensemble)

        Callback Parameters
        -------------------
        iter : int
                Iteration of optimization
        dim_p : int
                PE-local dimension of state
        dim_ens : int
                Ensemble size
        dim_cvec_ens : int
                Dimension of control vector
        ens_p : ndarray[np.float64, ndim=2]
                PE-local ensemble
                Array shape: (dim_p, dim_ens)
        v_p : ndarray[np.float64, ndim=1]
                PE-local control vector
                Array shape: (dim_cvec_ens)
        vv_p : ndarray[np.float64, ndim=1]
                PE-local state increment
                Array shape: (dim_p)

        Callback Returns
        ----------------
        vv_p : ndarray[np.float64, ndim=1]
                PE-local state increment
                Array shape: (dim_p)

    py__cvt_adj_ens_pdaf : Callable
        Apply adjoint control vector transform matrix (ensemble var)

        Callback Parameters
        -------------------
        iter : int
                Iteration of optimization
        dim_p : int
                PE-local observation dimension
        dim_ens : int
                Ensemble size
        dim_cv_ens_p : int
                PE-local dimension of control vector
        ens_p : ndarray[np.float64, ndim=2]
                PE-local ensemble
                Array shape: (dim_p, dim_ens)
        vcv_p : ndarray[np.float64, ndim=1]
                PE-local input vector
                Array shape: (dim_p)
        cv_p : ndarray[np.float64, ndim=1]
                PE-local result vector
                Array shape: (dim_cv_ens_p)

        Callback Returns
        ----------------
        cv_p : ndarray[np.float64, ndim=1]
                PE-local result vector
                Array shape: (dim_cv_ens_p)

    py__cvt_pdaf : Callable
        Apply control vector transform matrix to control vector

        Callback Parameters
        -------------------
        iter : int
                Iteration of optimization
        dim_p : int
                PE-local observation dimension
        dim_cvec : int
                Dimension of control vector
        cv_p : ndarray[np.float64, ndim=1]
                PE-local control vector
                Array shape: (dim_cvec)
        vv_p : ndarray[np.float64, ndim=1]
                PE-local result vector (state vector increment)
                Array shape: (dim_p)

        Callback Returns
        ----------------
        vv_p : ndarray[np.float64, ndim=1]
                PE-local result vector (state vector increment)
                Array shape: (dim_p)

    py__cvt_adj_pdaf : Callable
        Apply adjoint control vector transform matrix

        Callback Parameters
        -------------------
        iter : int
                Iteration of optimization
        dim_p : int
                PE-local observation dimension
        dim_cvec : int
                Dimension of control vector
        vcv_p : ndarray[np.float64, ndim=1]
                PE-local result vector (state vector increment)
                Array shape: (dim_p)
        cv_p : ndarray[np.float64, ndim=1]
                PE-local control vector
                Array shape: (dim_cvec)

        Callback Returns
        ----------------
        cv_p : ndarray[np.float64, ndim=1]
                PE-local control vector
                Array shape: (dim_cvec)

    py__obs_op_lin_pdaf : Callable
        Linearized observation operator

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_p : int
                PE-local dimension of state
        dim_obs_p : int
                Dimension of observed state
        state_p : ndarray[np.float64, ndim=1]
                PE-local model state
                Array shape: (dim_p)
        m_state_p : ndarray[np.float64, ndim=1]
                PE-local observed state
                Array shape: (dim_obs_p)

        Callback Returns
        ----------------
        m_state_p : ndarray[np.float64, ndim=1]
                PE-local observed state
                Array shape: (dim_obs_p)

    py__obs_op_adj_pdaf : Callable
        Adjoint observation operator

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_p : int
                PE-local dimension of state
        dim_obs_p : int
                Dimension of observed state
        m_state_p : ndarray[np.float64, ndim=1]
                PE-local observed state
                Array shape: (dim_obs_p)
        state_p : ndarray[np.float64, ndim=1]
                PE-local model state
                Array shape: (dim_p)

        Callback Returns
        ----------------
        state_p : ndarray[np.float64, ndim=1]
                PE-local model state
                Array shape: (dim_p)

    py__init_dim_obs_f_pdaf : Callable
        Initialize dimension of observation vector

        Callback Parameters
        -------------------
        step : int
                current time step

        Callback Returns
        ----------------
        dim_obs_p : int
                dimension of observation vector

    py__obs_op_f_pdaf : Callable
        Observation operator

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_p : int
                Size of state vector (local part in case of parallel decomposed state)
        dim_obs_p : int
                Size of observation vector
        state_p : ndarray[np.float64, ndim=1]
                Model state vector
                Array shape: (dim_p)

        Callback Returns
        ----------------
        m_state_p : ndarray[np.float64, ndim=1]
                Observed state vector (i.e. the result after applying the observation operator to state_p)
                Array shape: (dim_obs_p)

    py__init_obs_f_pdaf : Callable
        Initialize PE-local observation vector

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_obs_f : int
                Size of the full observation vector

        Callback Returns
        ----------------
        observation_f : ndarray[np.float64, ndim=1]
                Full vector of observations
                Array shape: (dim_obs_f)

    py__init_obs_l_pdaf : Callable
        Init. observation vector on local analysis domain

        Callback Parameters
        -------------------
        domain_p : int
                Index of current local analysis domain
        step : int
                Current time step
        dim_obs_l : int
                Local size of the observation vector

        Callback Returns
        ----------------
        observation_l : ndarray[np.float64, ndim=1]
                Local vector of observations
                Array shape: (dim_obs_l)

    py__prodrinva_l_pdaf : Callable
        Provide product R^-1 A on local analysis domain

        Callback Parameters
        -------------------
        domain_p : int
                Index of current local analysis domain
        step : int
                Current time step
        dim_obs_l : int
                Number of local observations at current time step (i.e. the size of the local observation vector)
        rank : int
                Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)
        obs_l : ndarray[np.float64, ndim=1]
                Local vector of observations
                Array shape: (dim_obs_l)
        a_l : ndarray[np.float64, ndim=2]
                Input matrix provided by PDAF
                Array shape: (dim_obs_l, rank)

        Callback Returns
        ----------------
        a_l : ndarray[np.float64, ndim=2]
                Input matrix provided by PDAF
                Array shape: (dim_obs_l, rank)
        c_l : ndarray[np.float64, ndim=2]
                Output matrix
                Array shape: (dim_obs_l, rank)

    py__init_n_domains_p_pdaf : Callable
        Provide number of local analysis domains

        Callback Parameters
        -------------------
        step : int
                current time step

        Callback Returns
        ----------------
        n_domains_p : int
                pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable
        Init state dimension for local ana. domain

        Callback Parameters
        -------------------
        step : int
                current time step
        domain_p : int
                current local analysis domain

        Callback Returns
        ----------------
        dim_l : int
                local state dimension

    py__init_dim_obs_l_pdaf : Callable
        Initialize dim. of obs. vector for local ana. domain

        Callback Parameters
        -------------------
        domain_p : int
                index of current local analysis domain
        step : int
                current time step
        dim_obs_f : int
                full dimension of observation vector

        Callback Returns
        ----------------
        dim_obs_l : int
                local dimension of observation vector

    py__g2l_obs_pdaf : Callable
        Restrict full obs. vector to local analysis domain

        Callback Parameters
        -------------------
        domain_p : int
                Index of current local analysis domain
        step : int
                Current time step
        dim_obs_f : int
                Size of full observation vector for model sub-domain
        dim_obs_l : int
                Size of observation vector for local analysis domain
        mstate_f : ndarray[np.intc, ndim=1]
                Full observation vector for model sub-domain
                Array shape: (dim_p)
        dim_p : int
                Size of full observation vector for model sub-domain
        dim_l : int
                Size of observation vector for local analysis domain

        Callback Returns
        ----------------
        mstate_l : ndarray[np.intc, ndim=1]
                Observation vector for local analysis domain
                Array shape: (dim_l)

    py__init_obsvar_pdaf : Callable
        Initialize mean observation error variance

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_obs_p : int
                Size of observation vector
        obs_p : ndarray[np.float64, ndim=1]
                Vector of observations
                Array shape: (dim_obs_p)

        Callback Returns
        ----------------
        meanvar : double
                Mean observation error variance

    py__init_obsvar_l_pdaf : Callable
        Initialize local mean observation error variance

        Callback Parameters
        -------------------
        domain_p : int
                Index of current local analysis domain
        step : int
                Current time step
        dim_obs_l : int
                Local dimension of observation vector
        obs_l : ndarray[np.float64, ndim=1]
                Local observation vector
                Array shape: (dim_obs_p)
        dim_obs_p : int
                Dimension of local observation vector

        Callback Returns
        ----------------
        meanvar_l : double
                Mean local observation error variance

    py__prepoststep_pdaf : Callable
        User supplied pre/poststep routine

        Callback Parameters
        -------------------
        step : int
                current time step
                (negative for call before analysis/preprocessing)
        dim_p : int
                PE-local state vector dimension
        dim_ens : int
                number of ensemble members
        dim_ens_l : int
                number of ensemble members run serially
                on each model task
        dim_obs_p : int
                PE-local dimension of observation vector
        state_p : ndarray[np.float64, ndim=1]
                pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)
                Array shape: (dim_p)
        uinv : ndarray[np.float64, ndim=2]
                Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.
                Array shape: (dim_ens-1, dim_ens-1)
        ens_p : ndarray[np.float64, ndim=2]
                PE-local ensemble
                Array shape: (dim_p, dim_ens)
        flag : int
                pdaf status flag

        Callback Returns
        ----------------
        state_p : ndarray[np.float64, ndim=1]
                pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)
                Array shape: (dim_p)
        uinv : ndarray[np.float64, ndim=2]
                Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.
                Array shape: (dim_ens-1, dim_ens-1)
        ens_p : ndarray[np.float64, ndim=2]
                PE-local ensemble
                Array shape: (dim_p, dim_ens)

    py__next_observation_pdaf : Callable
        Routine to provide time step, time and dimensionof next observation

        Callback Parameters
        -------------------
        stepnow : int
                the current time step given by PDAF

        Callback Returns
        ----------------
        nsteps : int
                number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation
        doexit : int
                whether to exit forecasting (1 for exit)
        time : double
                current model (physical) time


    Returns
    -------
    outflag : int
        Status flag
    """
    pdaf_cb.collect_state_pdaf = <void*>py__collect_state_pdaf
    pdaf_cb.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    pdaf_cb.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    pdaf_cb.obs_op_pdaf = <void*>py__obs_op_pdaf
    pdaf_cb.init_obs_pdaf = <void*>py__init_obs_pdaf
    pdaf_cb.prodrinva_pdaf = <void*>py__prodrinva_pdaf
    pdaf_cb.cvt_ens_pdaf = <void*>py__cvt_ens_pdaf
    pdaf_cb.cvt_adj_ens_pdaf = <void*>py__cvt_adj_ens_pdaf
    pdaf_cb.cvt_pdaf = <void*>py__cvt_pdaf
    pdaf_cb.cvt_adj_pdaf = <void*>py__cvt_adj_pdaf
    pdaf_cb.obs_op_lin_pdaf = <void*>py__obs_op_lin_pdaf
    pdaf_cb.obs_op_adj_pdaf = <void*>py__obs_op_adj_pdaf
    pdaf_cb.init_dim_obs_f_pdaf = <void*>py__init_dim_obs_f_pdaf
    pdaf_cb.obs_op_f_pdaf = <void*>py__obs_op_f_pdaf
    pdaf_cb.init_obs_f_pdaf = <void*>py__init_obs_f_pdaf
    pdaf_cb.init_obs_l_pdaf = <void*>py__init_obs_l_pdaf
    pdaf_cb.prodrinva_l_pdaf = <void*>py__prodrinva_l_pdaf
    pdaf_cb.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    pdaf_cb.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    pdaf_cb.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    pdaf_cb.g2l_obs_pdaf = <void*>py__g2l_obs_pdaf
    pdaf_cb.init_obsvar_pdaf = <void*>py__init_obsvar_pdaf
    pdaf_cb.init_obsvar_l_pdaf = <void*>py__init_obsvar_l_pdaf
    pdaf_cb.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    pdaf_cb.next_observation_pdaf = <void*>py__next_observation_pdaf
    cdef int  outflag
    with nogil:
        c__pdaflocal_assimilate_hyb3dvar_lestkf(
                                                pdaf_cb.c__collect_state_pdaf,
                                                pdaf_cb.c__distribute_state_pdaf,
                                                pdaf_cb.c__init_dim_obs_pdaf,
                                                pdaf_cb.c__obs_op_pdaf,
                                                pdaf_cb.c__init_obs_pdaf,
                                                pdaf_cb.c__prodrinva_pdaf,
                                                pdaf_cb.c__cvt_ens_pdaf,
                                                pdaf_cb.c__cvt_adj_ens_pdaf,
                                                pdaf_cb.c__cvt_pdaf,
                                                pdaf_cb.c__cvt_adj_pdaf,
                                                pdaf_cb.c__obs_op_lin_pdaf,
                                                pdaf_cb.c__obs_op_adj_pdaf,
                                                pdaf_cb.c__init_dim_obs_f_pdaf,
                                                pdaf_cb.c__obs_op_f_pdaf,
                                                pdaf_cb.c__init_obs_f_pdaf,
                                                pdaf_cb.c__init_obs_l_pdaf,
                                                pdaf_cb.c__prodrinva_l_pdaf,
                                                pdaf_cb.c__init_n_domains_p_pdaf,
                                                pdaf_cb.c__init_dim_l_pdaf,
                                                pdaf_cb.c__init_dim_obs_l_pdaf,
                                                pdaf_cb.c__g2l_obs_pdaf,
                                                pdaf_cb.c__init_obsvar_pdaf,
                                                pdaf_cb.c__init_obsvar_l_pdaf,
                                                pdaf_cb.c__prepoststep_pdaf,
                                                pdaf_cb.c__next_observation_pdaf,
                                                &outflag)

    return outflag


def assimilate_lseik(py__collect_state_pdaf, py__distribute_state_pdaf,
    py__init_dim_obs_pdaf, py__obs_op_pdaf, py__init_obs_pdaf,
    py__init_obs_l_pdaf, py__prepoststep_pdaf, py__prodrinva_l_pdaf,
    py__init_n_domains_p_pdaf, py__init_dim_l_pdaf,
    py__init_dim_obs_l_pdaf, py__g2l_obs_pdaf, py__init_obsvar_pdaf,
    py__init_obsvar_l_pdaf, py__next_observation_pdaf):
    """It is recommended to use
    :func:`pyPDAF.PDAF.localomi_assimilate`
    or :func:`pyPDAF.PDAF.localomi_assimilate_nondiagR`.

    PDAF-OMI modules require fewer user-supplied
    functions and improved efficiency.

    Local singular evolutive interpolated Kalman filter [1]_
    for a single DA step.
    This function should be called at each model time step.

    The function is a combination of
    :func:`pyPDAF.PDAF.put_state_lseik` and :func:`pyPDAF.PDAF.get_state`

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. py__init_obs_pdaf
           (if global adaptive forgetting factor `type_forget=1`
           is used in :func:`pyPDAF.PDAF.init`)
        7. py__init_obsvar_pdaf
           (if global adaptive forgetting factor is used)
        8. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. py__g2l_state_pdaf
            4. py__g2l_obs_pdaf (localise mean ensemble
               in observation space)
            5. py__init_obs_l_pdaf
            6. py__g2l_obs_pdaf
               (localise each ensemble member in observation space)
            7. py__init_obsvar_l_pdaf
               (only called if local adaptive forgetting
               factor `type_forget=2` is used)
            8. py__prodRinvA_l_pdaf
            9. core DA algorithm
            10. py__l2g_state_pdaf
        9. py__prepoststep_state_pdaf
        10. py__distribute_state_pdaf
        11. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_assimilate`
       and :func:`pyPDAF.PDAF.localomi_assimilate_nondiagR`

    References
    ----------
    .. [1] Pham, D. T., Verron, J., & Roubaud, M. C. (1998).
           A singular evolutive extended Kalman filter
           for data assimilation
           in oceanography. Journal of Marine systems,
           16(3-4), 323-340.

    Parameters
    ----------
    py__collect_state_pdaf : Callable
        Routine to collect a state vector

        Callback Parameters
        -------------------
        dim_p : int
                pe-local state dimension
        state_p : ndarray[np.float64, ndim=1]
                local state vector
                Array shape: (dim_p)

        Callback Returns
        ----------------
        state_p : ndarray[np.float64, ndim=1]
                local state vector
                Array shape: (dim_p)

    py__distribute_state_pdaf : Callable
        Routine to distribute a state vector

        Callback Parameters
        -------------------
        dim_p : int
                PE-local state dimension
        state_p : ndarray[np.float64, ndim=1]
                PE-local state vector
                Array shape: (dim_p)

        Callback Returns
        ----------------
        state_p : ndarray[np.float64, ndim=1]
                PE-local state vector
                Array shape: (dim_p)

    py__init_dim_obs_pdaf : Callable
        Initialize dimension of observation vector

        Callback Parameters
        -------------------
        step : int
                current time step

        Callback Returns
        ----------------
        dim_obs_p : int
                dimension of observation vector

    py__obs_op_pdaf : Callable
        Observation operator

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_p : int
                Size of state vector
                (local part in case of parallel decomposed state)
        dim_obs_p : int
                Size of PE-local observation vector
        state_p : ndarray[np.float64, ndim=1]
                Model state vector
                Array shape: (dim_p)
        m_state_p : ndarray[np.float64, ndim=1]
                Observed state vector
                (i.e. the result after applying the observation operator to state_p)
                Array shape: (dim_obs_p)

        Callback Returns
        ----------------
        m_state_p : ndarray[np.float64, ndim=1]
                Observed state vector
                (i.e. the result after applying the observation operator to state_p)
                Array shape: (dim_obs_p)

    py__init_obs_pdaf : Callable
        Initialize PE-local observation vector

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_obs_p : int
                Size of the observation vector

        Callback Returns
        ----------------
        observation_p : ndarray[np.float64, ndim=1]
                Vector of observations
                Array shape: (dim_obs_p)

    py__init_obs_l_pdaf : Callable
        Init. observation vector on local analysis domain

        Callback Parameters
        -------------------
        domain_p : int
                Index of current local analysis domain
        step : int
                Current time step
        dim_obs_l : int
                Local size of the observation vector

        Callback Returns
        ----------------
        observation_l : ndarray[np.float64, ndim=1]
                Local vector of observations
                Array shape: (dim_obs_l)

    py__prepoststep_pdaf : Callable
        User supplied pre/poststep routine

        Callback Parameters
        -------------------
        step : int
                current time step
                (negative for call before analysis/preprocessing)
        dim_p : int
                PE-local state vector dimension
        dim_ens : int
                number of ensemble members
        dim_ens_l : int
                number of ensemble members run serially
                on each model task
        dim_obs_p : int
                PE-local dimension of observation vector
        state_p : ndarray[np.float64, ndim=1]
                pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)
                Array shape: (dim_p)
        uinv : ndarray[np.float64, ndim=2]
                Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.
                Array shape: (dim_ens-1, dim_ens-1)
        ens_p : ndarray[np.float64, ndim=2]
                PE-local ensemble
                Array shape: (dim_p, dim_ens)
        flag : int
                pdaf status flag

        Callback Returns
        ----------------
        state_p : ndarray[np.float64, ndim=1]
                pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)
                Array shape: (dim_p)
        uinv : ndarray[np.float64, ndim=2]
                Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.
                Array shape: (dim_ens-1, dim_ens-1)
        ens_p : ndarray[np.float64, ndim=2]
                PE-local ensemble
                Array shape: (dim_p, dim_ens)

    py__prodrinva_l_pdaf : Callable
        Provide product R^-1 A on local analysis domain

        Callback Parameters
        -------------------
        domain_p : int
                Index of current local analysis domain
        step : int
                Current time step
        dim_obs_l : int
                Number of local observations at current time step (i.e. the size of the local observation vector)
        rank : int
                Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)
        obs_l : ndarray[np.float64, ndim=1]
                Local vector of observations
                Array shape: (dim_obs_l)
        a_l : ndarray[np.float64, ndim=2]
                Input matrix provided by PDAF
                Array shape: (dim_obs_l, rank)

        Callback Returns
        ----------------
        a_l : ndarray[np.float64, ndim=2]
                Input matrix provided by PDAF
                Array shape: (dim_obs_l, rank)
        c_l : ndarray[np.float64, ndim=2]
                Output matrix
                Array shape: (dim_obs_l, rank)

    py__init_n_domains_p_pdaf : Callable
        Provide number of local analysis domains

        Callback Parameters
        -------------------
        step : int
                current time step

        Callback Returns
        ----------------
        n_domains_p : int
                pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable
        Init state dimension for local ana. domain

        Callback Parameters
        -------------------
        step : int
                current time step
        domain_p : int
                current local analysis domain

        Callback Returns
        ----------------
        dim_l : int
                local state dimension

    py__init_dim_obs_l_pdaf : Callable
        Initialize dim. of obs. vector for local ana. domain

        Callback Parameters
        -------------------
        domain_p : int
                index of current local analysis domain
        step : int
                current time step
        dim_obs_f : int
                full dimension of observation vector

        Callback Returns
        ----------------
        dim_obs_l : int
                local dimension of observation vector

    py__g2l_obs_pdaf : Callable
        Restrict full obs. vector to local analysis domain

        Callback Parameters
        -------------------
        domain_p : int
                Index of current local analysis domain
        step : int
                Current time step
        dim_obs_f : int
                Size of full observation vector for model sub-domain
        dim_obs_l : int
                Size of observation vector for local analysis domain
        mstate_f : ndarray[np.intc, ndim=1]
                Full observation vector for model sub-domain
                Array shape: (dim_p)
        dim_p : int
                Size of full observation vector for model sub-domain
        dim_l : int
                Size of observation vector for local analysis domain

        Callback Returns
        ----------------
        mstate_l : ndarray[np.intc, ndim=1]
                Observation vector for local analysis domain
                Array shape: (dim_l)

    py__init_obsvar_pdaf : Callable
        Initialize mean observation error variance

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_obs_p : int
                Size of observation vector
        obs_p : ndarray[np.float64, ndim=1]
                Vector of observations
                Array shape: (dim_obs_p)

        Callback Returns
        ----------------
        meanvar : double
                Mean observation error variance

    py__init_obsvar_l_pdaf : Callable
        Initialize local mean observation error variance

        Callback Parameters
        -------------------
        domain_p : int
                Index of current local analysis domain
        step : int
                Current time step
        dim_obs_l : int
                Local dimension of observation vector
        obs_l : ndarray[np.float64, ndim=1]
                Local observation vector
                Array shape: (dim_obs_p)
        dim_obs_p : int
                Dimension of local observation vector

        Callback Returns
        ----------------
        meanvar_l : double
                Mean local observation error variance

    py__next_observation_pdaf : Callable
        Routine to provide time step, time and dimensionof next observation

        Callback Parameters
        -------------------
        stepnow : int
                the current time step given by PDAF

        Callback Returns
        ----------------
        nsteps : int
                number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation
        doexit : int
                whether to exit forecasting (1 for exit)
        time : double
                current model (physical) time


    Returns
    -------
    outflag : int
        Status flag
    """
    pdaf_cb.collect_state_pdaf = <void*>py__collect_state_pdaf
    pdaf_cb.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    pdaf_cb.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    pdaf_cb.obs_op_pdaf = <void*>py__obs_op_pdaf
    pdaf_cb.init_obs_pdaf = <void*>py__init_obs_pdaf
    pdaf_cb.init_obs_l_pdaf = <void*>py__init_obs_l_pdaf
    pdaf_cb.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    pdaf_cb.prodrinva_l_pdaf = <void*>py__prodrinva_l_pdaf
    pdaf_cb.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    pdaf_cb.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    pdaf_cb.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    pdaf_cb.g2l_obs_pdaf = <void*>py__g2l_obs_pdaf
    pdaf_cb.init_obsvar_pdaf = <void*>py__init_obsvar_pdaf
    pdaf_cb.init_obsvar_l_pdaf = <void*>py__init_obsvar_l_pdaf
    pdaf_cb.next_observation_pdaf = <void*>py__next_observation_pdaf
    cdef int  outflag
    with nogil:
        c__pdaflocal_assimilate_lseik(pdaf_cb.c__collect_state_pdaf,
                                      pdaf_cb.c__distribute_state_pdaf,
                                      pdaf_cb.c__init_dim_obs_pdaf,
                                      pdaf_cb.c__obs_op_pdaf,
                                      pdaf_cb.c__init_obs_pdaf,
                                      pdaf_cb.c__init_obs_l_pdaf,
                                      pdaf_cb.c__prepoststep_pdaf,
                                      pdaf_cb.c__prodrinva_l_pdaf,
                                      pdaf_cb.c__init_n_domains_p_pdaf,
                                      pdaf_cb.c__init_dim_l_pdaf,
                                      pdaf_cb.c__init_dim_obs_l_pdaf,
                                      pdaf_cb.c__g2l_obs_pdaf,
                                      pdaf_cb.c__init_obsvar_pdaf,
                                      pdaf_cb.c__init_obsvar_l_pdaf,
                                      pdaf_cb.c__next_observation_pdaf,
                                      &outflag)

    return outflag


def assimilate_letkf(py__collect_state_pdaf, py__distribute_state_pdaf,
    py__init_dim_obs_pdaf, py__obs_op_pdaf, py__init_obs_pdaf,
    py__init_obs_l_pdaf, py__prepoststep_pdaf, py__prodrinva_l_pdaf,
    py__init_n_domains_p_pdaf, py__init_dim_l_pdaf,
    py__init_dim_obs_l_pdaf, py__g2l_obs_pdaf, py__init_obsvar_pdaf,
    py__init_obsvar_l_pdaf, py__next_observation_pdaf):
    """It is recommended to use
    :func:`pyPDAF.PDAF.localomi_assimilate`
    or :func:`pyPDAF.PDAF.localomi_assimilate_nondiagR`.

    PDAFlocal-OMI modules require fewer user-supplied
    functions and improved efficiency.

    Local ensemble transform Kalman filter (LETKF) [1]_ for a single DA step without OMI.
    Implementation is based on [2]_.
    Note that the LESTKF is a more efficient equivalent
    to the LETKF.

    This function should be called at each model time step.
    The function is a combination of
    :func:`pyPDAF.PDAF.put_state_letkf`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. py__init_obs_pdaf
           (if global adaptive forgetting factor
           `type_forget=1` is used
           in :func:`pyPDAF.PDAF.init`)
        7. py__init_obsvar_pdaf (if global adaptive
           forgetting factor is used)
        8. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. py__g2l_state_pdaf
            4. py__g2l_obs_pdaf (localise mean ensemble
               in observation space)
            5. py__init_obs_l_pdaf
            6. py__g2l_obs_pdaf (localise each ensemble member
               in observation space)
            7. py__init_obsvar_l_pdaf
               (only called if local adaptive forgetting factor
               `type_forget=2` is used)
            8. py__prodRinvA_l_pdaf
            9. core DA algorithm
            10. py__l2g_state_pdaf
        9. py__prepoststep_state_pdaf
        10. py__distribute_state_pdaf
        11. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_assimilate`
       and :func:`pyPDAF.PDAF.localomi_assimilate_nondiagR`

    References
    ----------
    .. [1] Hunt, B. R., Kostelich, E. J., & Szunyogh, I. (2007).
           Efficient data assimilation for spatiotemporal chaos:
           A local ensemble transform Kalman filter.
           Physica D: Nonlinear Phenomena, 230(1-2), 112-126.
    .. [2] Nerger, L., Janjić, T., Schröter, J., Hiller, W. (2012).
           A unification of ensemble square root Kalman filters.
           Monthly Weather Review, 140, 2335-2345.
           doi:10.1175/MWR-D-11-00102.1

    Parameters
    ----------
    py__collect_state_pdaf : Callable
        Routine to collect a state vector

        Callback Parameters
        -------------------
        dim_p : int
                pe-local state dimension
        state_p : ndarray[np.float64, ndim=1]
                local state vector
                Array shape: (dim_p)

        Callback Returns
        ----------------
        state_p : ndarray[np.float64, ndim=1]
                local state vector
                Array shape: (dim_p)

    py__distribute_state_pdaf : Callable
        Routine to distribute a state vector

        Callback Parameters
        -------------------
        dim_p : int
                PE-local state dimension
        state_p : ndarray[np.float64, ndim=1]
                PE-local state vector
                Array shape: (dim_p)

        Callback Returns
        ----------------
        state_p : ndarray[np.float64, ndim=1]
                PE-local state vector
                Array shape: (dim_p)

    py__init_dim_obs_pdaf : Callable
        Initialize dimension of observation vector

        Callback Parameters
        -------------------
        step : int
                current time step

        Callback Returns
        ----------------
        dim_obs_p : int
                dimension of observation vector

    py__obs_op_pdaf : Callable
        Observation operator

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_p : int
                Size of state vector
                (local part in case of parallel decomposed state)
        dim_obs_p : int
                Size of PE-local observation vector
        state_p : ndarray[np.float64, ndim=1]
                Model state vector
                Array shape: (dim_p)
        m_state_p : ndarray[np.float64, ndim=1]
                Observed state vector
                (i.e. the result after applying the observation operator to state_p)
                Array shape: (dim_obs_p)

        Callback Returns
        ----------------
        m_state_p : ndarray[np.float64, ndim=1]
                Observed state vector
                (i.e. the result after applying the observation operator to state_p)
                Array shape: (dim_obs_p)

    py__init_obs_pdaf : Callable
        Initialize PE-local observation vector

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_obs_p : int
                Size of the observation vector

        Callback Returns
        ----------------
        observation_p : ndarray[np.float64, ndim=1]
                Vector of observations
                Array shape: (dim_obs_p)

    py__init_obs_l_pdaf : Callable
        Init. observation vector on local analysis domain

        Callback Parameters
        -------------------
        domain_p : int
                Index of current local analysis domain
        step : int
                Current time step
        dim_obs_l : int
                Local size of the observation vector

        Callback Returns
        ----------------
        observation_l : ndarray[np.float64, ndim=1]
                Local vector of observations
                Array shape: (dim_obs_l)

    py__prepoststep_pdaf : Callable
        User supplied pre/poststep routine

        Callback Parameters
        -------------------
        step : int
                current time step
                (negative for call before analysis/preprocessing)
        dim_p : int
                PE-local state vector dimension
        dim_ens : int
                number of ensemble members
        dim_ens_l : int
                number of ensemble members run serially
                on each model task
        dim_obs_p : int
                PE-local dimension of observation vector
        state_p : ndarray[np.float64, ndim=1]
                pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)
                Array shape: (dim_p)
        uinv : ndarray[np.float64, ndim=2]
                Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.
                Array shape: (dim_ens-1, dim_ens-1)
        ens_p : ndarray[np.float64, ndim=2]
                PE-local ensemble
                Array shape: (dim_p, dim_ens)
        flag : int
                pdaf status flag

        Callback Returns
        ----------------
        state_p : ndarray[np.float64, ndim=1]
                pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)
                Array shape: (dim_p)
        uinv : ndarray[np.float64, ndim=2]
                Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.
                Array shape: (dim_ens-1, dim_ens-1)
        ens_p : ndarray[np.float64, ndim=2]
                PE-local ensemble
                Array shape: (dim_p, dim_ens)

    py__prodrinva_l_pdaf : Callable
        Provide product R^-1 A on local analysis domain

        Callback Parameters
        -------------------
        domain_p : int
                Index of current local analysis domain
        step : int
                Current time step
        dim_obs_l : int
                Number of local observations at current time step (i.e. the size of the local observation vector)
        rank : int
                Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)
        obs_l : ndarray[np.float64, ndim=1]
                Local vector of observations
                Array shape: (dim_obs_l)
        a_l : ndarray[np.float64, ndim=2]
                Input matrix provided by PDAF
                Array shape: (dim_obs_l, rank)

        Callback Returns
        ----------------
        a_l : ndarray[np.float64, ndim=2]
                Input matrix provided by PDAF
                Array shape: (dim_obs_l, rank)
        c_l : ndarray[np.float64, ndim=2]
                Output matrix
                Array shape: (dim_obs_l, rank)

    py__init_n_domains_p_pdaf : Callable
        Provide number of local analysis domains

        Callback Parameters
        -------------------
        step : int
                current time step

        Callback Returns
        ----------------
        n_domains_p : int
                pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable
        Init state dimension for local ana. domain

        Callback Parameters
        -------------------
        step : int
                current time step
        domain_p : int
                current local analysis domain

        Callback Returns
        ----------------
        dim_l : int
                local state dimension

    py__init_dim_obs_l_pdaf : Callable
        Initialize dim. of obs. vector for local ana. domain

        Callback Parameters
        -------------------
        domain_p : int
                index of current local analysis domain
        step : int
                current time step
        dim_obs_f : int
                full dimension of observation vector

        Callback Returns
        ----------------
        dim_obs_l : int
                local dimension of observation vector

    py__g2l_obs_pdaf : Callable
        Restrict full obs. vector to local analysis domain

        Callback Parameters
        -------------------
        domain_p : int
                Index of current local analysis domain
        step : int
                Current time step
        dim_obs_f : int
                Size of full observation vector for model sub-domain
        dim_obs_l : int
                Size of observation vector for local analysis domain
        mstate_f : ndarray[np.intc, ndim=1]
                Full observation vector for model sub-domain
                Array shape: (dim_p)
        dim_p : int
                Size of full observation vector for model sub-domain
        dim_l : int
                Size of observation vector for local analysis domain

        Callback Returns
        ----------------
        mstate_l : ndarray[np.intc, ndim=1]
                Observation vector for local analysis domain
                Array shape: (dim_l)

    py__init_obsvar_pdaf : Callable
        Initialize mean observation error variance

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_obs_p : int
                Size of observation vector
        obs_p : ndarray[np.float64, ndim=1]
                Vector of observations
                Array shape: (dim_obs_p)

        Callback Returns
        ----------------
        meanvar : double
                Mean observation error variance

    py__init_obsvar_l_pdaf : Callable
        Initialize local mean observation error variance

        Callback Parameters
        -------------------
        domain_p : int
                Index of current local analysis domain
        step : int
                Current time step
        dim_obs_l : int
                Local dimension of observation vector
        obs_l : ndarray[np.float64, ndim=1]
                Local observation vector
                Array shape: (dim_obs_p)
        dim_obs_p : int
                Dimension of local observation vector

        Callback Returns
        ----------------
        meanvar_l : double
                Mean local observation error variance

    py__next_observation_pdaf : Callable
        Routine to provide time step, time and dimensionof next observation

        Callback Parameters
        -------------------
        stepnow : int
                the current time step given by PDAF

        Callback Returns
        ----------------
        nsteps : int
                number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation
        doexit : int
                whether to exit forecasting (1 for exit)
        time : double
                current model (physical) time


    Returns
    -------
    outflag : int
        Status flag
    """
    pdaf_cb.collect_state_pdaf = <void*>py__collect_state_pdaf
    pdaf_cb.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    pdaf_cb.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    pdaf_cb.obs_op_pdaf = <void*>py__obs_op_pdaf
    pdaf_cb.init_obs_pdaf = <void*>py__init_obs_pdaf
    pdaf_cb.init_obs_l_pdaf = <void*>py__init_obs_l_pdaf
    pdaf_cb.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    pdaf_cb.prodrinva_l_pdaf = <void*>py__prodrinva_l_pdaf
    pdaf_cb.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    pdaf_cb.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    pdaf_cb.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    pdaf_cb.g2l_obs_pdaf = <void*>py__g2l_obs_pdaf
    pdaf_cb.init_obsvar_pdaf = <void*>py__init_obsvar_pdaf
    pdaf_cb.init_obsvar_l_pdaf = <void*>py__init_obsvar_l_pdaf
    pdaf_cb.next_observation_pdaf = <void*>py__next_observation_pdaf
    cdef int  outflag
    with nogil:
        c__pdaflocal_assimilate_letkf(pdaf_cb.c__collect_state_pdaf,
                                      pdaf_cb.c__distribute_state_pdaf,
                                      pdaf_cb.c__init_dim_obs_pdaf,
                                      pdaf_cb.c__obs_op_pdaf,
                                      pdaf_cb.c__init_obs_pdaf,
                                      pdaf_cb.c__init_obs_l_pdaf,
                                      pdaf_cb.c__prepoststep_pdaf,
                                      pdaf_cb.c__prodrinva_l_pdaf,
                                      pdaf_cb.c__init_n_domains_p_pdaf,
                                      pdaf_cb.c__init_dim_l_pdaf,
                                      pdaf_cb.c__init_dim_obs_l_pdaf,
                                      pdaf_cb.c__g2l_obs_pdaf,
                                      pdaf_cb.c__init_obsvar_pdaf,
                                      pdaf_cb.c__init_obsvar_l_pdaf,
                                      pdaf_cb.c__next_observation_pdaf,
                                      &outflag)

    return outflag


def assimilate_lestkf(py__collect_state_pdaf, py__distribute_state_pdaf,
    py__init_dim_obs_pdaf, py__obs_op_pdaf, py__init_obs_pdaf,
    py__init_obs_l_pdaf, py__prepoststep_pdaf, py__prodrinva_l_pdaf,
    py__init_n_domains_p_pdaf, py__init_dim_l_pdaf,
    py__init_dim_obs_l_pdaf, py__g2l_obs_pdaf, py__init_obsvar_pdaf,
    py__init_obsvar_l_pdaf, py__next_observation_pdaf):
    """It is recommended to use
    :func:`pyPDAF.PDAF.localomi_assimilate`
    or :func:`pyPDAF.PDAF.localomi_assimilate_nondiagR`.

    PDAFlocal-OMI modules require fewer user-supplied
    functions and improved efficiency.

    Local ESTKF (error space transform Kalman filter) [1]_ for a single DA step without OMI.
    The LESTKF is a more efficient equivalent to the LETKF.

    This function should be called at each model time step.
    The function is a combination of
    :func:`pyPDAF.PDAF.put_state_lestkf`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. py__init_obs_pdaf
           (if global adaptive forgetting factor
           `type_forget=1` is used
           in :func:`pyPDAF.PDAF.init`)
        7. py__init_obsvar_pdaf (if global adaptive
           forgetting factor is used)
        8. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. py__g2l_state_pdaf
            4. py__g2l_obs_pdaf (localise mean ensemble
               in observation space)
            5. py__init_obs_l_pdaf
            6. py__g2l_obs_pdaf
               (localise each ensemble member
               in observation space)
            7. py__init_obsvar_l_pdaf
               (only called if local adaptive
               forgetting factor `type_forget=2` is used)
            8. py__prodRinvA_l_pdaf
            9. core DA algorithm
            10. py__l2g_state_pdaf
        9. py__prepoststep_state_pdaf
        10. py__distribute_state_pdaf
        11. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_assimilate`
       and :func:`pyPDAF.PDAF.localomi_assimilate_nondiagR`

    References
    ----------
    .. [1] Nerger, L., Janjić, T., Schröter, J., Hiller, W. (2012).
           A unification of ensemble square root Kalman filters.
           Monthly Weather Review, 140, 2335-2345.
           doi:10.1175/MWR-D-11-00102.1

    Parameters
    ----------
    py__collect_state_pdaf : Callable
        Routine to collect a state vector

        Callback Parameters
        -------------------
        dim_p : int
                pe-local state dimension
        state_p : ndarray[np.float64, ndim=1]
                local state vector
                Array shape: (dim_p)

        Callback Returns
        ----------------
        state_p : ndarray[np.float64, ndim=1]
                local state vector
                Array shape: (dim_p)

    py__distribute_state_pdaf : Callable
        Routine to distribute a state vector

        Callback Parameters
        -------------------
        dim_p : int
                PE-local state dimension
        state_p : ndarray[np.float64, ndim=1]
                PE-local state vector
                Array shape: (dim_p)

        Callback Returns
        ----------------
        state_p : ndarray[np.float64, ndim=1]
                PE-local state vector
                Array shape: (dim_p)

    py__init_dim_obs_pdaf : Callable
        Initialize dimension of observation vector

        Callback Parameters
        -------------------
        step : int
                current time step

        Callback Returns
        ----------------
        dim_obs_p : int
                dimension of observation vector

    py__obs_op_pdaf : Callable
        Observation operator

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_p : int
                Size of state vector
                (local part in case of parallel decomposed state)
        dim_obs_p : int
                Size of PE-local observation vector
        state_p : ndarray[np.float64, ndim=1]
                Model state vector
                Array shape: (dim_p)
        m_state_p : ndarray[np.float64, ndim=1]
                Observed state vector
                (i.e. the result after applying the observation operator to state_p)
                Array shape: (dim_obs_p)

        Callback Returns
        ----------------
        m_state_p : ndarray[np.float64, ndim=1]
                Observed state vector
                (i.e. the result after applying the observation operator to state_p)
                Array shape: (dim_obs_p)

    py__init_obs_pdaf : Callable
        Initialize PE-local observation vector

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_obs_p : int
                Size of the observation vector

        Callback Returns
        ----------------
        observation_p : ndarray[np.float64, ndim=1]
                Vector of observations
                Array shape: (dim_obs_p)

    py__init_obs_l_pdaf : Callable
        Init. observation vector on local analysis domain

        Callback Parameters
        -------------------
        domain_p : int
                Index of current local analysis domain
        step : int
                Current time step
        dim_obs_l : int
                Local size of the observation vector

        Callback Returns
        ----------------
        observation_l : ndarray[np.float64, ndim=1]
                Local vector of observations
                Array shape: (dim_obs_l)

    py__prepoststep_pdaf : Callable
        User supplied pre/poststep routine

        Callback Parameters
        -------------------
        step : int
                current time step
                (negative for call before analysis/preprocessing)
        dim_p : int
                PE-local state vector dimension
        dim_ens : int
                number of ensemble members
        dim_ens_l : int
                number of ensemble members run serially
                on each model task
        dim_obs_p : int
                PE-local dimension of observation vector
        state_p : ndarray[np.float64, ndim=1]
                pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)
                Array shape: (dim_p)
        uinv : ndarray[np.float64, ndim=2]
                Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.
                Array shape: (dim_ens-1, dim_ens-1)
        ens_p : ndarray[np.float64, ndim=2]
                PE-local ensemble
                Array shape: (dim_p, dim_ens)
        flag : int
                pdaf status flag

        Callback Returns
        ----------------
        state_p : ndarray[np.float64, ndim=1]
                pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)
                Array shape: (dim_p)
        uinv : ndarray[np.float64, ndim=2]
                Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.
                Array shape: (dim_ens-1, dim_ens-1)
        ens_p : ndarray[np.float64, ndim=2]
                PE-local ensemble
                Array shape: (dim_p, dim_ens)

    py__prodrinva_l_pdaf : Callable
        Provide product R^-1 A on local analysis domain

        Callback Parameters
        -------------------
        domain_p : int
                Index of current local analysis domain
        step : int
                Current time step
        dim_obs_l : int
                Number of local observations at current time step (i.e. the size of the local observation vector)
        rank : int
                Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)
        obs_l : ndarray[np.float64, ndim=1]
                Local vector of observations
                Array shape: (dim_obs_l)
        a_l : ndarray[np.float64, ndim=2]
                Input matrix provided by PDAF
                Array shape: (dim_obs_l, rank)

        Callback Returns
        ----------------
        a_l : ndarray[np.float64, ndim=2]
                Input matrix provided by PDAF
                Array shape: (dim_obs_l, rank)
        c_l : ndarray[np.float64, ndim=2]
                Output matrix
                Array shape: (dim_obs_l, rank)

    py__init_n_domains_p_pdaf : Callable
        Provide number of local analysis domains

        Callback Parameters
        -------------------
        step : int
                current time step

        Callback Returns
        ----------------
        n_domains_p : int
                pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable
        Init state dimension for local ana. domain

        Callback Parameters
        -------------------
        step : int
                current time step
        domain_p : int
                current local analysis domain

        Callback Returns
        ----------------
        dim_l : int
                local state dimension

    py__init_dim_obs_l_pdaf : Callable
        Initialize dim. of obs. vector for local ana. domain

        Callback Parameters
        -------------------
        domain_p : int
                index of current local analysis domain
        step : int
                current time step
        dim_obs_f : int
                full dimension of observation vector

        Callback Returns
        ----------------
        dim_obs_l : int
                local dimension of observation vector

    py__g2l_obs_pdaf : Callable
        Restrict full obs. vector to local analysis domain

        Callback Parameters
        -------------------
        domain_p : int
                Index of current local analysis domain
        step : int
                Current time step
        dim_obs_f : int
                Size of full observation vector for model sub-domain
        dim_obs_l : int
                Size of observation vector for local analysis domain
        mstate_f : ndarray[np.intc, ndim=1]
                Full observation vector for model sub-domain
                Array shape: (dim_p)
        dim_p : int
                Size of full observation vector for model sub-domain
        dim_l : int
                Size of observation vector for local analysis domain

        Callback Returns
        ----------------
        mstate_l : ndarray[np.intc, ndim=1]
                Observation vector for local analysis domain
                Array shape: (dim_l)

    py__init_obsvar_pdaf : Callable
        Initialize mean observation error variance

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_obs_p : int
                Size of observation vector
        obs_p : ndarray[np.float64, ndim=1]
                Vector of observations
                Array shape: (dim_obs_p)

        Callback Returns
        ----------------
        meanvar : double
                Mean observation error variance

    py__init_obsvar_l_pdaf : Callable
        Initialize local mean observation error variance

        Callback Parameters
        -------------------
        domain_p : int
                Index of current local analysis domain
        step : int
                Current time step
        dim_obs_l : int
                Local dimension of observation vector
        obs_l : ndarray[np.float64, ndim=1]
                Local observation vector
                Array shape: (dim_obs_p)
        dim_obs_p : int
                Dimension of local observation vector

        Callback Returns
        ----------------
        meanvar_l : double
                Mean local observation error variance

    py__next_observation_pdaf : Callable
        Routine to provide time step, time and dimensionof next observation

        Callback Parameters
        -------------------
        stepnow : int
                the current time step given by PDAF

        Callback Returns
        ----------------
        nsteps : int
                number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation
        doexit : int
                whether to exit forecasting (1 for exit)
        time : double
                current model (physical) time


    Returns
    -------
    outflag : int
        Status flag
    """
    pdaf_cb.collect_state_pdaf = <void*>py__collect_state_pdaf
    pdaf_cb.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    pdaf_cb.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    pdaf_cb.obs_op_pdaf = <void*>py__obs_op_pdaf
    pdaf_cb.init_obs_pdaf = <void*>py__init_obs_pdaf
    pdaf_cb.init_obs_l_pdaf = <void*>py__init_obs_l_pdaf
    pdaf_cb.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    pdaf_cb.prodrinva_l_pdaf = <void*>py__prodrinva_l_pdaf
    pdaf_cb.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    pdaf_cb.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    pdaf_cb.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    pdaf_cb.g2l_obs_pdaf = <void*>py__g2l_obs_pdaf
    pdaf_cb.init_obsvar_pdaf = <void*>py__init_obsvar_pdaf
    pdaf_cb.init_obsvar_l_pdaf = <void*>py__init_obsvar_l_pdaf
    pdaf_cb.next_observation_pdaf = <void*>py__next_observation_pdaf
    cdef int  outflag
    with nogil:
        c__pdaflocal_assimilate_lestkf(pdaf_cb.c__collect_state_pdaf,
                                       pdaf_cb.c__distribute_state_pdaf,
                                       pdaf_cb.c__init_dim_obs_pdaf,
                                       pdaf_cb.c__obs_op_pdaf,
                                       pdaf_cb.c__init_obs_pdaf,
                                       pdaf_cb.c__init_obs_l_pdaf,
                                       pdaf_cb.c__prepoststep_pdaf,
                                       pdaf_cb.c__prodrinva_l_pdaf,
                                       pdaf_cb.c__init_n_domains_p_pdaf,
                                       pdaf_cb.c__init_dim_l_pdaf,
                                       pdaf_cb.c__init_dim_obs_l_pdaf,
                                       pdaf_cb.c__g2l_obs_pdaf,
                                       pdaf_cb.c__init_obsvar_pdaf,
                                       pdaf_cb.c__init_obsvar_l_pdaf,
                                       pdaf_cb.c__next_observation_pdaf,
                                       &outflag)

    return outflag


def assimilate_lnetf(py__collect_state_pdaf, py__distribute_state_pdaf,
    py__init_dim_obs_pdaf, py__obs_op_pdaf, py__init_obs_pdaf,
    py__init_obs_l_pdaf, py__prepoststep_pdaf, py__likelihood_l_pdaf,
    py__init_n_domains_p_pdaf, py__init_dim_l_pdaf,
    py__init_dim_obs_l_pdaf, py__g2l_obs_pdaf, py__next_observation_pdaf):
    """It is recommended to use
    :func:`pyPDAF.PDAF.localomi_assimilate`
    or :func:`pyPDAF.PDAF.localomi_assimilate_lnetf_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions
    and improved efficiency.

    Local Nonlinear Ensemble Transform Filter (LNETF) [1]_
    for a single DA step.
    The nonlinear filter computes the distribution up to
    the second moment similar to Kalman filters but
    it uses a nonlinear weighting similar to
    particle filters. This leads to an equal weights assumption
    for the prior ensemble at each step.
    This function should be called at each model time step.

    The function is a combination of
    :func:`pyPDAF.PDAF.put_state_lnetf`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf (for each ensemble member)
        6. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. py__g2l_state_pdaf
            4. py__init_obs_l_pdaf
            5. py__g2l_obs_pdaf (localise each ensemble
               member in observation space)
            6. py__likelihood_l_pdaf
            7. core DA algorithm
            8. py__l2g_state_pdaf
        7. py__prepoststep_state_pdaf
        8. py__distribute_state_pdaf
        9. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_assimilate`
       and :func:`pyPDAF.PDAF.localomi_assimilate_lnetf_nondiagR`

    References
    ----------
    .. [1] Tödter, J., and B. Ahrens, 2015:
           A second-order exact ensemble square root filter
           for nonlinear data assimilation. Mon. Wea. Rev.,
           143, 1347–1367, doi:10.1175/MWR-D-14-00108.1.

    Parameters
    ----------
    py__collect_state_pdaf : Callable
        Routine to collect a state vector

        Callback Parameters
        -------------------
        dim_p : int
                pe-local state dimension
        state_p : ndarray[np.float64, ndim=1]
                local state vector
                Array shape: (dim_p)

        Callback Returns
        ----------------
        state_p : ndarray[np.float64, ndim=1]
                local state vector
                Array shape: (dim_p)

    py__distribute_state_pdaf : Callable
        Routine to distribute a state vector

        Callback Parameters
        -------------------
        dim_p : int
                PE-local state dimension
        state_p : ndarray[np.float64, ndim=1]
                PE-local state vector
                Array shape: (dim_p)

        Callback Returns
        ----------------
        state_p : ndarray[np.float64, ndim=1]
                PE-local state vector
                Array shape: (dim_p)

    py__init_dim_obs_pdaf : Callable
        Initialize dimension of observation vector

        Callback Parameters
        -------------------
        step : int
                current time step

        Callback Returns
        ----------------
        dim_obs_p : int
                dimension of observation vector

    py__obs_op_pdaf : Callable
        Observation operator

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_p : int
                Size of state vector
                (local part in case of parallel decomposed state)
        dim_obs_p : int
                Size of PE-local observation vector
        state_p : ndarray[np.float64, ndim=1]
                Model state vector
                Array shape: (dim_p)
        m_state_p : ndarray[np.float64, ndim=1]
                Observed state vector
                (i.e. the result after applying the observation operator to state_p)
                Array shape: (dim_obs_p)

        Callback Returns
        ----------------
        m_state_p : ndarray[np.float64, ndim=1]
                Observed state vector
                (i.e. the result after applying the observation operator to state_p)
                Array shape: (dim_obs_p)

    py__init_obs_pdaf : Callable
        Initialize PE-local observation vector

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_obs_p : int
                Size of the observation vector

        Callback Returns
        ----------------
        observation_p : ndarray[np.float64, ndim=1]
                Vector of observations
                Array shape: (dim_obs_p)

    py__init_obs_l_pdaf : Callable
        Init. observation vector on local analysis domain

        Callback Parameters
        -------------------
        domain_p : int
                Index of current local analysis domain
        step : int
                Current time step
        dim_obs_l : int
                Local size of the observation vector

        Callback Returns
        ----------------
        observation_l : ndarray[np.float64, ndim=1]
                Local vector of observations
                Array shape: (dim_obs_l)

    py__prepoststep_pdaf : Callable
        User supplied pre/poststep routine

        Callback Parameters
        -------------------
        step : int
                current time step
                (negative for call before analysis/preprocessing)
        dim_p : int
                PE-local state vector dimension
        dim_ens : int
                number of ensemble members
        dim_ens_l : int
                number of ensemble members run serially
                on each model task
        dim_obs_p : int
                PE-local dimension of observation vector
        state_p : ndarray[np.float64, ndim=1]
                pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)
                Array shape: (dim_p)
        uinv : ndarray[np.float64, ndim=2]
                Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.
                Array shape: (dim_ens-1, dim_ens-1)
        ens_p : ndarray[np.float64, ndim=2]
                PE-local ensemble
                Array shape: (dim_p, dim_ens)
        flag : int
                pdaf status flag

        Callback Returns
        ----------------
        state_p : ndarray[np.float64, ndim=1]
                pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)
                Array shape: (dim_p)
        uinv : ndarray[np.float64, ndim=2]
                Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.
                Array shape: (dim_ens-1, dim_ens-1)
        ens_p : ndarray[np.float64, ndim=2]
                PE-local ensemble
                Array shape: (dim_p, dim_ens)

    py__likelihood_l_pdaf : Callable
        Compute observation likelihood for an ensemble member

        Callback Parameters
        -------------------
        domain_p : int
                Index of current local analysis domain
        step : int
                Current time step
        dim_obs_l : int
                Number of local observations at current time step (i.e. the size of the local observation vector)
        obs_l : ndarray[np.float64, ndim=1]
                Local vector of observations
                Array shape: (dim_obs_l)
        resid_l : ndarray[np.float64, ndim=1]
                nput vector holding the local residual
                Array shape: (dim_obs_l)

        Callback Returns
        ----------------
        resid_l : ndarray[np.float64, ndim=1]
                nput vector holding the local residual
                Array shape: (dim_obs_l)
        likely_l : double
                Output value of the local likelihood

    py__init_n_domains_p_pdaf : Callable
        Provide number of local analysis domains

        Callback Parameters
        -------------------
        step : int
                current time step

        Callback Returns
        ----------------
        n_domains_p : int
                pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable
        Init state dimension for local ana. domain

        Callback Parameters
        -------------------
        step : int
                current time step
        domain_p : int
                current local analysis domain

        Callback Returns
        ----------------
        dim_l : int
                local state dimension

    py__init_dim_obs_l_pdaf : Callable
        Initialize dim. of obs. vector for local ana. domain

        Callback Parameters
        -------------------
        domain_p : int
                index of current local analysis domain
        step : int
                current time step
        dim_obs_f : int
                full dimension of observation vector

        Callback Returns
        ----------------
        dim_obs_l : int
                local dimension of observation vector

    py__g2l_obs_pdaf : Callable
        Restrict full obs. vector to local analysis domain

        Callback Parameters
        -------------------
        domain_p : int
                Index of current local analysis domain
        step : int
                Current time step
        dim_obs_f : int
                Size of full observation vector for model sub-domain
        dim_obs_l : int
                Size of observation vector for local analysis domain
        mstate_f : ndarray[np.intc, ndim=1]
                Full observation vector for model sub-domain
                Array shape: (dim_p)
        dim_p : int
                Size of full observation vector for model sub-domain
        dim_l : int
                Size of observation vector for local analysis domain

        Callback Returns
        ----------------
        mstate_l : ndarray[np.intc, ndim=1]
                Observation vector for local analysis domain
                Array shape: (dim_l)

    py__next_observation_pdaf : Callable
        Routine to provide time step, time and dimensionof next observation

        Callback Parameters
        -------------------
        stepnow : int
                the current time step given by PDAF

        Callback Returns
        ----------------
        nsteps : int
                number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation
        doexit : int
                whether to exit forecasting (1 for exit)
        time : double
                current model (physical) time


    Returns
    -------
    outflag : int
        Status flag
    """
    pdaf_cb.collect_state_pdaf = <void*>py__collect_state_pdaf
    pdaf_cb.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    pdaf_cb.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    pdaf_cb.obs_op_pdaf = <void*>py__obs_op_pdaf
    pdaf_cb.init_obs_pdaf = <void*>py__init_obs_pdaf
    pdaf_cb.init_obs_l_pdaf = <void*>py__init_obs_l_pdaf
    pdaf_cb.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    pdaf_cb.likelihood_l_pdaf = <void*>py__likelihood_l_pdaf
    pdaf_cb.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    pdaf_cb.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    pdaf_cb.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    pdaf_cb.g2l_obs_pdaf = <void*>py__g2l_obs_pdaf
    pdaf_cb.next_observation_pdaf = <void*>py__next_observation_pdaf
    cdef int  outflag
    with nogil:
        c__pdaflocal_assimilate_lnetf(pdaf_cb.c__collect_state_pdaf,
                                      pdaf_cb.c__distribute_state_pdaf,
                                      pdaf_cb.c__init_dim_obs_pdaf,
                                      pdaf_cb.c__obs_op_pdaf,
                                      pdaf_cb.c__init_obs_pdaf,
                                      pdaf_cb.c__init_obs_l_pdaf,
                                      pdaf_cb.c__prepoststep_pdaf,
                                      pdaf_cb.c__likelihood_l_pdaf,
                                      pdaf_cb.c__init_n_domains_p_pdaf,
                                      pdaf_cb.c__init_dim_l_pdaf,
                                      pdaf_cb.c__init_dim_obs_l_pdaf,
                                      pdaf_cb.c__g2l_obs_pdaf,
                                      pdaf_cb.c__next_observation_pdaf,
                                      &outflag)

    return outflag


def assimilate_lknetf(py__collect_state_pdaf, py__distribute_state_pdaf,
    py__init_dim_obs_pdaf, py__obs_op_pdaf, py__init_obs_pdaf,
    py__init_obs_l_pdaf, py__prepoststep_pdaf, py__prodrinva_l_pdaf,
    py__prodrinva_hyb_l_pdaf, py__init_n_domains_p_pdaf,
    py__init_dim_l_pdaf, py__init_dim_obs_l_pdaf, py__g2l_obs_pdaf,
    py__init_obsvar_pdaf, py__init_obsvar_l_pdaf, py__likelihood_l_pdaf,
    py__likelihood_hyb_l_pdaf, py__next_observation_pdaf):
    """It is recommended to use
    :func:`pyPDAF.PDAF.localomi_assimilate`
    or :func:`pyPDAF.PDAF.localomi_assimilate_lknetf_nondiagR`.

    PDAF-OMI modules require fewer user-supplied functions
    and improved efficiency.

    A hybridised LETKF and LNETF [1]_ for a single DA step.
    The LNETF computes the distribution up to
    the second moment similar to Kalman filters but
    using a nonlinear weighting similar to
    particle filters. This leads to an equal weights
    assumption for the prior ensemble.
    The hybridisation with LETKF is expected to lead to
    improved performance for quasi-Gaussian problems.
    The function should be called at each model step.

    The function is a combination of
    :func:`pyPDAF.PDAF.put_state_lknetf`
    and :func:`pyPDAF.PDAF.get_state`.

    User-supplied functions are executed in the following sequence:
        1. py__collect_state_pdaf
        2. py__prepoststep_state_pdaf
        3. py__init_n_domains_p_pdaf
        4. py__init_dim_obs_pdaf
        5. py__obs_op_pdaf
           (for each ensemble member)
        6. py__init_obs_pdaf
           (if global adaptive forgetting factor `type_forget=1`
           is used in :func:`pyPDAF.PDAF.init`)
        7. py__init_obsvar_pdaf (if global adaptive
           forgetting factor is used)
        8. loop over each local domain:
            1. py__init_dim_l_pdaf
            2. py__init_dim_obs_l_pdaf
            3. py__g2l_state_pdaf
            4. py__g2l_obs_pdaf
               (localise each ensemble member
               in observation space)
            5. py__init_obs_l_pdaf
            6. py__init_obsvar_l_pdaf
               (only called if local adaptive forgetting
               factor `type_forget=2` is used)
            7. py__prodRinvA_pdaf
            8. py__likelihood_l_pdaf
            9. core DA algorithm
            10. py__l2g_state_pdaf
        9. py__obs_op_pdaf
           (only called with `HKN` and `HNK` options
           called for each ensemble member)
        10. py__likelihood_hyb_l_pda
        11. py__init_obsvar_l_pdaf
            (only called if local adaptive forgetting
            factor `type_forget=2` is used)
        12. py__prodRinvA_hyb_l_pdaf
        13. py__prepoststep_state_pdaf
        14. py__distribute_state_pdaf
        15. py__next_observation_pdaf

    .. deprecated:: 1.0.0

       This function is replaced by
       :func:`pyPDAF.PDAF.localomi_assimilate`
       and :func:`pyPDAF.PDAF.localomi_assimilate_lknetf_nondiagR`

    References
    ----------
    .. [1] Nerger, L.. (2022)
           Data assimilation for nonlinear systems with
           a hybrid nonlinear Kalman ensemble transform filter.
           Q J R Meteorol Soc, 620–640. doi:10.1002/qj.4221

    Parameters
    ----------
    py__collect_state_pdaf : Callable
        Routine to collect a state vector

        Callback Parameters
        -------------------
        dim_p : int
                pe-local state dimension
        state_p : ndarray[np.float64, ndim=1]
                local state vector
                Array shape: (dim_p)

        Callback Returns
        ----------------
        state_p : ndarray[np.float64, ndim=1]
                local state vector
                Array shape: (dim_p)

    py__distribute_state_pdaf : Callable
        Routine to distribute a state vector

        Callback Parameters
        -------------------
        dim_p : int
                PE-local state dimension
        state_p : ndarray[np.float64, ndim=1]
                PE-local state vector
                Array shape: (dim_p)

        Callback Returns
        ----------------
        state_p : ndarray[np.float64, ndim=1]
                PE-local state vector
                Array shape: (dim_p)

    py__init_dim_obs_pdaf : Callable
        Initialize dimension of observation vector

        Callback Parameters
        -------------------
        step : int
                current time step

        Callback Returns
        ----------------
        dim_obs_p : int
                dimension of observation vector

    py__obs_op_pdaf : Callable
        Observation operator

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_p : int
                Size of state vector
                (local part in case of parallel decomposed state)
        dim_obs_p : int
                Size of PE-local observation vector
        state_p : ndarray[np.float64, ndim=1]
                Model state vector
                Array shape: (dim_p)
        m_state_p : ndarray[np.float64, ndim=1]
                Observed state vector
                (i.e. the result after applying the observation operator to state_p)
                Array shape: (dim_obs_p)

        Callback Returns
        ----------------
        m_state_p : ndarray[np.float64, ndim=1]
                Observed state vector
                (i.e. the result after applying the observation operator to state_p)
                Array shape: (dim_obs_p)

    py__init_obs_pdaf : Callable
        Initialize PE-local observation vector

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_obs_p : int
                Size of the observation vector

        Callback Returns
        ----------------
        observation_p : ndarray[np.float64, ndim=1]
                Vector of observations
                Array shape: (dim_obs_p)

    py__init_obs_l_pdaf : Callable
        Init. observation vector on local analysis domain

        Callback Parameters
        -------------------
        domain_p : int
                Index of current local analysis domain
        step : int
                Current time step
        dim_obs_l : int
                Local size of the observation vector

        Callback Returns
        ----------------
        observation_l : ndarray[np.float64, ndim=1]
                Local vector of observations
                Array shape: (dim_obs_l)

    py__prepoststep_pdaf : Callable
        User supplied pre/poststep routine

        Callback Parameters
        -------------------
        step : int
                current time step
                (negative for call before analysis/preprocessing)
        dim_p : int
                PE-local state vector dimension
        dim_ens : int
                number of ensemble members
        dim_ens_l : int
                number of ensemble members run serially
                on each model task
        dim_obs_p : int
                PE-local dimension of observation vector
        state_p : ndarray[np.float64, ndim=1]
                pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)
                Array shape: (dim_p)
        uinv : ndarray[np.float64, ndim=2]
                Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.
                Array shape: (dim_ens-1, dim_ens-1)
        ens_p : ndarray[np.float64, ndim=2]
                PE-local ensemble
                Array shape: (dim_p, dim_ens)
        flag : int
                pdaf status flag

        Callback Returns
        ----------------
        state_p : ndarray[np.float64, ndim=1]
                pe-local forecast/analysis state
                (the array 'state_p' is generally not
                initialised in the case of ESTKF/ETKF/EnKF/SEIK,
                so it can be used freely here.)
                Array shape: (dim_p)
        uinv : ndarray[np.float64, ndim=2]
                Inverse of the transformation matrix in ETKF and ESKTF;
                inverse of matrix formed by right singular vectors of error
                covariance matrix of ensemble perturbations in SEIK/SEEK.
                not used in EnKF.
                Array shape: (dim_ens-1, dim_ens-1)
        ens_p : ndarray[np.float64, ndim=2]
                PE-local ensemble
                Array shape: (dim_p, dim_ens)

    py__prodrinva_l_pdaf : Callable
        Provide product R^-1 A on local analysis domain

        Callback Parameters
        -------------------
        domain_p : int
                Index of current local analysis domain
        step : int
                Current time step
        dim_obs_l : int
                Number of local observations at current time step (i.e. the size of the local observation vector)
        rank : int
                Number of the columns in the matrix processes here.
                This is usually the ensemble size minus one (or the rank of the initial covariance matrix)
        obs_l : ndarray[np.float64, ndim=1]
                Local vector of observations
                Array shape: (dim_obs_l)
        a_l : ndarray[np.float64, ndim=2]
                Input matrix provided by PDAF
                Array shape: (dim_obs_l, rank)

        Callback Returns
        ----------------
        a_l : ndarray[np.float64, ndim=2]
                Input matrix provided by PDAF
                Array shape: (dim_obs_l, rank)
        c_l : ndarray[np.float64, ndim=2]
                Output matrix
                Array shape: (dim_obs_l, rank)

    py__prodrinva_hyb_l_pdaf : Callable
        Provide product R^-1 A on local analysis domain with hybrid weight

        Callback Parameters
        -------------------
        domain_p : int
                Index of current local analysis domain
        step : int
                Current time step
        dim_obs_l : int
                Number of local observations at current time step (i.e. the size of the local observation vector)
        dim_ens : int
                Number of the columns in the matrix processes here. This is usually the ensemble size minus one (or the rank of the initial covariance matrix)
        obs_l : ndarray[np.float64, ndim=1]
                Local vector of observations
                Array shape: (dim_obs_l)
        gamma : double
                Hybrid weight provided by PDAF
        a_l : ndarray[np.float64, ndim=2]
                Input matrix provided by PDAF
                Array shape: (dim_obs_l, dim_ens)

        Callback Returns
        ----------------
        a_l : ndarray[np.float64, ndim=2]
                Input matrix provided by PDAF
                Array shape: (dim_obs_l, dim_ens)
        c_l : ndarray[np.float64, ndim=2]
                Output matrix
                Array shape: (dim_obs_l, dim_ens)

    py__init_n_domains_p_pdaf : Callable
        Provide number of local analysis domains

        Callback Parameters
        -------------------
        step : int
                current time step

        Callback Returns
        ----------------
        n_domains_p : int
                pe-local number of analysis domains

    py__init_dim_l_pdaf : Callable
        Init state dimension for local ana. domain

        Callback Parameters
        -------------------
        step : int
                current time step
        domain_p : int
                current local analysis domain

        Callback Returns
        ----------------
        dim_l : int
                local state dimension

    py__init_dim_obs_l_pdaf : Callable
        Initialize dim. of obs. vector for local ana. domain

        Callback Parameters
        -------------------
        domain_p : int
                index of current local analysis domain
        step : int
                current time step
        dim_obs_f : int
                full dimension of observation vector

        Callback Returns
        ----------------
        dim_obs_l : int
                local dimension of observation vector

    py__g2l_obs_pdaf : Callable
        Restrict full obs. vector to local analysis domain

        Callback Parameters
        -------------------
        domain_p : int
                Index of current local analysis domain
        step : int
                Current time step
        dim_obs_f : int
                Size of full observation vector for model sub-domain
        dim_obs_l : int
                Size of observation vector for local analysis domain
        mstate_f : ndarray[np.intc, ndim=1]
                Full observation vector for model sub-domain
                Array shape: (dim_p)
        dim_p : int
                Size of full observation vector for model sub-domain
        dim_l : int
                Size of observation vector for local analysis domain

        Callback Returns
        ----------------
        mstate_l : ndarray[np.intc, ndim=1]
                Observation vector for local analysis domain
                Array shape: (dim_l)

    py__init_obsvar_pdaf : Callable
        Initialize mean observation error variance

        Callback Parameters
        -------------------
        step : int
                Current time step
        dim_obs_p : int
                Size of observation vector
        obs_p : ndarray[np.float64, ndim=1]
                Vector of observations
                Array shape: (dim_obs_p)

        Callback Returns
        ----------------
        meanvar : double
                Mean observation error variance

    py__init_obsvar_l_pdaf : Callable
        Initialize local mean observation error variance

        Callback Parameters
        -------------------
        domain_p : int
                Index of current local analysis domain
        step : int
                Current time step
        dim_obs_l : int
                Local dimension of observation vector
        obs_l : ndarray[np.float64, ndim=1]
                Local observation vector
                Array shape: (dim_obs_p)
        dim_obs_p : int
                Dimension of local observation vector

        Callback Returns
        ----------------
        meanvar_l : double
                Mean local observation error variance

    py__likelihood_l_pdaf : Callable
        Compute likelihood

        Callback Parameters
        -------------------
        domain_p : int
                Index of current local analysis domain
        step : int
                Current time step
        dim_obs_l : int
                Number of local observations at current time step (i.e. the size of the local observation vector)
        obs_l : ndarray[np.float64, ndim=1]
                Local vector of observations
                Array shape: (dim_obs_l)
        resid_l : ndarray[np.float64, ndim=1]
                nput vector holding the local residual
                Array shape: (dim_obs_l)

        Callback Returns
        ----------------
        resid_l : ndarray[np.float64, ndim=1]
                nput vector holding the local residual
                Array shape: (dim_obs_l)
        likely_l : double
                Output value of the local likelihood

    py__likelihood_hyb_l_pdaf : Callable
        Compute likelihood with hybrid weight

        Callback Parameters
        -------------------
        domain_p : int
                Index of current local analysis domain
        step : int
                Current time step
        dim_obs_l : int
                Number of local observations at current time step (i.e. the size of the local observation vector)
        obs_l : ndarray[np.float64, ndim=1]
                Local vector of observations
                Array shape: (dim_obs_l)
        resid_l : ndarray[np.float64, ndim=1]
                Input vector holding the local residual
                Array shape: (dim_obs_l)
        gamma : double
                Hybrid weight provided by PDAF

        Callback Returns
        ----------------
        resid_l : ndarray[np.float64, ndim=1]
                Input vector holding the local residual
                Array shape: (dim_obs_l)
        likely_l : double
                Output value of the local likelihood

    py__next_observation_pdaf : Callable
        Routine to provide time step, time and dimensionof next observation

        Callback Parameters
        -------------------
        stepnow : int
                the current time step given by PDAF

        Callback Returns
        ----------------
        nsteps : int
                number of forecast time steps until next assimilation;
                this can also be interpreted as
                number of assimilation function calls
                to perform a new assimilation
        doexit : int
                whether to exit forecasting (1 for exit)
        time : double
                current model (physical) time


    Returns
    -------
    outflag : int
        Status flag
    """
    pdaf_cb.collect_state_pdaf = <void*>py__collect_state_pdaf
    pdaf_cb.distribute_state_pdaf = <void*>py__distribute_state_pdaf
    pdaf_cb.init_dim_obs_pdaf = <void*>py__init_dim_obs_pdaf
    pdaf_cb.obs_op_pdaf = <void*>py__obs_op_pdaf
    pdaf_cb.init_obs_pdaf = <void*>py__init_obs_pdaf
    pdaf_cb.init_obs_l_pdaf = <void*>py__init_obs_l_pdaf
    pdaf_cb.prepoststep_pdaf = <void*>py__prepoststep_pdaf
    pdaf_cb.prodrinva_l_pdaf = <void*>py__prodrinva_l_pdaf
    pdaf_cb.prodrinva_hyb_l_pdaf = <void*>py__prodrinva_hyb_l_pdaf
    pdaf_cb.init_n_domains_p_pdaf = <void*>py__init_n_domains_p_pdaf
    pdaf_cb.init_dim_l_pdaf = <void*>py__init_dim_l_pdaf
    pdaf_cb.init_dim_obs_l_pdaf = <void*>py__init_dim_obs_l_pdaf
    pdaf_cb.g2l_obs_pdaf = <void*>py__g2l_obs_pdaf
    pdaf_cb.init_obsvar_pdaf = <void*>py__init_obsvar_pdaf
    pdaf_cb.init_obsvar_l_pdaf = <void*>py__init_obsvar_l_pdaf
    pdaf_cb.likelihood_l_pdaf = <void*>py__likelihood_l_pdaf
    pdaf_cb.likelihood_hyb_l_pdaf = <void*>py__likelihood_hyb_l_pdaf
    pdaf_cb.next_observation_pdaf = <void*>py__next_observation_pdaf
    cdef int  outflag
    with nogil:
        c__pdaflocal_assimilate_lknetf(pdaf_cb.c__collect_state_pdaf,
                                       pdaf_cb.c__distribute_state_pdaf,
                                       pdaf_cb.c__init_dim_obs_pdaf,
                                       pdaf_cb.c__obs_op_pdaf,
                                       pdaf_cb.c__init_obs_pdaf,
                                       pdaf_cb.c__init_obs_l_pdaf,
                                       pdaf_cb.c__prepoststep_pdaf,
                                       pdaf_cb.c__prodrinva_l_pdaf,
                                       pdaf_cb.c__prodrinva_hyb_l_pdaf,
                                       pdaf_cb.c__init_n_domains_p_pdaf,
                                       pdaf_cb.c__init_dim_l_pdaf,
                                       pdaf_cb.c__init_dim_obs_l_pdaf,
                                       pdaf_cb.c__g2l_obs_pdaf,
                                       pdaf_cb.c__init_obsvar_pdaf,
                                       pdaf_cb.c__init_obsvar_l_pdaf,
                                       pdaf_cb.c__likelihood_l_pdaf,
                                       pdaf_cb.c__likelihood_hyb_l_pdaf,
                                       pdaf_cb.c__next_observation_pdaf,
                                       &outflag)

    return outflag


