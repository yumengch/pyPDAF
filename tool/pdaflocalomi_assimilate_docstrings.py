"""docstrings for PDAFlocalomi_assimilate_xxx functions
"""
docstrings = {}

docstrings['localomi_assimilate'] = \
    "Domain local filters for a single DA step\n    " \
    "using diagnoal observation error covariance matrix.\n\n    " \
    "Here, this function call is used for LE(S)TKF [1]_,\n    " \
    "LSEIK [1]_, LNETF [2]_, and LKNETF [3]_.\n    " \
    "The filter type is set in :func:`pyPDAF.PDAF.init`.\n    " \
    "This function should be called at each model time step.\n    " \
    "The function is a combination of\n    " \
    ":func:`pyPDAF.PDAF.localomi_put_state_local`\n    " \
    "and :func:`pyPDAF.PDAF.get_state`.\n\n    " \
    "User-supplied functions are executed in the following sequence:\n    " \
    "    1. py__collect_state_pdaf\n    "\
    "    2. py__prepoststep_state_pdaf\n    "\
    "    3. py__init_n_domains_p_pdaf\n    "\
    "    4. py__init_dim_obs_pdaf\n    "\
    "    5. py__obs_op_pdaf (for each ensemble member)\n    "\
    "    6. loop over each local domain:\n    " \
    "        1. py__init_dim_l_pdaf\n    "\
    "        2. py__init_dim_obs_l_pdaf\n    "\
    "        3. core DA algorithm\n    " \
    "    7. py__prepoststep_state_pdaf\n    "\
    "    8. py__distribute_state_pdaf\n    "\
    "    9. py__next_observation_pdaf\n" \
    "\n    " \
    "References\n    " \
    "----------\n    " \
    ".. [1] Nerger, L., Janjić, T., Schröter, J., Hiller, W. (2012). \n    " \
    "       A unification of ensemble square root Kalman filters. \n    " \
    "       Monthly Weather Review, 140, 2335-2345.\n    " \
    "       doi:10.1175/MWR-D-11-00102.1\n    " \
    ".. [2] Tödter, J., and B. Ahrens, 2015:\n    "\
    "       A second-order exact ensemble square root filter\n    " \
    "       for nonlinear data assimilation. Mon. Wea. Rev.,\n    " \
    "       143, 1347–1367, doi:10.1175/MWR-D-14-00108.1.\n    " \
    ".. [3] Nerger, L.. (2022) \n    " \
    "       Data assimilation for nonlinear systems with\n    " \
    "       a hybrid nonlinear Kalman ensemble transform filter. \n    " \
    "       Q J R Meteorol Soc, 620–640. doi:10.1002/qj.4221"
docstrings['localomi_assimilate_en3dvar_lestkf'] = \
    "3DEnVar for a single DA step where the ensemble anomaly\n    " \
    "is generated by LESTKF using diagnoal observation\n    " \
    "error covariance matrix.\n\n    " \
    "The background error covariance matrix is estimated by ensemble.\n    " \
    "The 3DEnVar only calculates the analysis of the ensemble mean.\n    " \
    "An LESTKF is used to generate ensemble perturbations.\n    " \
    "This function should be called at each model time step.\n\n    " \
    "The function is a combination of\n    " \
    ":func:`pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf`\n    " \
    "and :func:`pyPDAF.PDAF.get_state`.\n\n    " \
    "User-supplied functions are executed in the following sequence:\n    " \
    "    1. py__collect_state_pdaf\n    " \
    "    2. py__prepoststep_state_pdaf\n    " \
    "    3. py__init_dim_obs_pdaf\n    " \
    "    4. py__obs_op_pdaf\n    " \
    "    5. Starting the iterative optimisation:\n    " \
    "        1. py__cvt_ens_pdaf\n    " \
    "        2. py__obs_op_lin_pdaf\n    " \
    "        3. py__obs_op_adj_pdaf\n    " \
    "        4. py__cvt_adj_ens_pdaf\n    " \
    "        5. core DA algorithm\n    " \
    "    6. py__cvt_ens_pdaf\n    " \
    "    7. Perform LESTKF:\n    " \
    "        1. py__init_n_domains_p_pdaf\n    " \
    "        2. py__init_dim_obs_pdaf\n    " \
    "        3. py__obs_op_pdaf\n    "\
    "           (for each ensemble member)\n    " \
    "        4. loop over each local domain:\n    " \
    "            1. py__init_dim_l_pdaf\n    " \
    "            2. py__init_dim_obs_l_pdaf\n    " \
    "            3. core DA algorithm\n    " \
    "    8. py__prepoststep_state_pdaf\n    " \
    "    9. py__distribute_state_pdaf\n    " \
    "    10. py__next_observation_pdaf"
docstrings['localomi_assimilate_hyb3dvar_lestkf'] = \
    "Hybrid 3DEnVar for a single DA step\n    " \
    "using diagnoal observation error covariance matrix.\n\n    " \
    "Here, the background error covariance is hybridised by\n    " \
    "a static background error covariance,\n    " \
    "and a flow-dependent background error covariance\n    " \
    "estimated from ensemble.\n    " \
    "The 3DVar generates an ensemble mean and\n    " \
    "the ensemble perturbation is generated by\n    " \
    "LESTKF in this implementation.\n    " \
    "This function should be called at each model time step.\n\n    " \
    "The function is a combination of\n    " \
    ":func:`pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf`\n    " \
    "and :func:`pyPDAF.PDAF.get_state`.\n\n    " \
    "User-supplied functions are executed in the following sequence:\n    " \
    "    1. py__collect_state_pdaf\n    " \
    "    2. py__prepoststep_state_pdaf\n    " \
    "    3. py__init_dim_obs_pdaf\n    " \
    "    4. py__obs_op_pdaf\n    " \
    "    5. The iterative optimisation:\n    " \
    "        1. py__cvt_pdaf\n    " \
    "        2. py__cvt_ens_pdaf\n    " \
    "        3. py__obs_op_lin_pdaf\n    " \
    "        4. py__obs_op_adj_pdaf\n    " \
    "        5. py__cvt_adj_pdaf\n    " \
    "        6. py__cvt_adj_ens_pdaf\n    " \
    "        7. core DA algorithm\n    " \
    "    6. py__cvt_pdaf\n    " \
    "    7. py__cvt_ens_pdaf\n    " \
    "    8. Perform LESTKF:\n    " \
    "        1. py__init_n_domains_p_pdaf\n    " \
    "        2. py__init_dim_obs_pdaf\n    " \
    "        3. py__obs_op_pdaf\n    " \
    "           (for each ensemble member)\n    " \
    "        4. loop over each local domain:\n    " \
    "            1. py__init_dim_l_pdaf\n    " \
    "            2. py__init_dim_obs_l_pdaf\n    " \
    "            3. core DA algorithm\n    " \
    "    9. py__prepoststep_state_pdaf\n    " \
    "    10. py__distribute_state_pdaf\n    " \
    "    11. py__next_observation_pdaf"
docstrings['localomi_assimilate_en3dvar_lestkf_nondiagR'] = \
    "3DEnVar for a single DA step where the ensemble anomaly\n    " \
    "is generated by LESTKF using\n    " \
    "non-diagnoal observation error covariance matrix.\n\n    " \
    "Here, the background error covariance matrix is\n    " \
    "estimated by ensemble.\n    " \
    "The 3DEnVar only calculates the analysis of the ensemble mean.\n    " \
    "An LESTKF is used to generate ensemble perturbations.\n    " \
    "This function should be called at each model time step.\n\n    " \
    "The function is a combination of\n    " \
    ":func:`pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf_nondiagR`\n    " \
    "and :func:`pyPDAF.PDAF.get_state`.\n\n    " \
    "User-supplied functions are executed in the following sequence:\n    " \
    "    1. py__collect_state_pdaf\n    " \
    "    2. py__prepoststep_state_pdaf\n    " \
    "    3. py__init_dim_obs_pdaf\n    " \
    "    4. py__obs_op_pdaf\n    " \
    "    5. Starting the iterative optimisation:\n    " \
    "        1. py__cvt_ens_pdaf\n    " \
    "        2. py__obs_op_lin_pdaf\n    " \
    "        3. py__prodRinvA_pdaf\n    " \
    "        4. py__obs_op_adj_pdaf\n    " \
    "        5. py__cvt_adj_ens_pdaf\n    " \
    "        6. core DA algorithm\n    " \
    "    6. py__cvt_ens_pdaf\n    " \
    "    7. Perform LESTKF:\n    " \
    "        1. py__init_n_domains_p_pdaf\n    " \
    "        2. py__init_dim_obs_pdaf\n    " \
    "        3. py__obs_op_pdaf\n    "\
    "           (for each ensemble member)\n    " \
    "        4. loop over each local domain:\n    " \
    "            1. py__init_dim_l_pdaf\n    " \
    "            2. py__init_dim_obs_l_pdaf\n    " \
    "            3. py__prodRinvA_l_pdaf\n    " \
    "            4. core DA algorithm\n    " \
    "    8. py__prepoststep_state_pdaf\n    " \
    "    9. py__distribute_state_pdaf\n    " \
    "    10. py__next_observation_pdaf"
docstrings['localomi_assimilate_hyb3dvar_lestkf_nondiagR'] = \
    "Hybrid 3DEnVar for a single DA step\n    " \
    "using diagnoal observation error covariance matrix.\n\n    " \
    "Here, the background error covariance is\n    " \
    "hybridised by a static background error covariance,\n    " \
    "and a flow-dependent background error covariance\n    " \
    "estimated from ensemble.\n    " \
    "The 3DVar generates an ensemble mean and\n    " \
    "the ensemble perturbation is generated by\n    " \
    "LESTKF in this implementation.\n    " \
    "This function should be called at each model time step.\n\n    " \
    "The function is a combination of\n    " \
    ":func:`pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf_nondiagR`\n    " \
    "and :func:`pyPDAF.PDAF.get_state`.\n\n    " \
    "User-supplied functions are executed in the following sequence:\n    " \
    "    1. py__collect_state_pdaf\n    " \
    "    2. py__prepoststep_state_pdaf\n    " \
    "    3. py__init_dim_obs_pdaf\n    " \
    "    4. py__obs_op_pdaf\n    " \
    "    5. The iterative optimisation:\n    " \
    "        1. py__cvt_pdaf\n    " \
    "        2. py__cvt_ens_pdaf\n    " \
    "        3. py__obs_op_lin_pdaf\n    " \
    "        4. py__prodRinvA_pdaf\n    " \
    "        5. py__obs_op_adj_pdaf\n    " \
    "        6. py__cvt_adj_pdaf\n    " \
    "        7. py__cvt_adj_ens_pdaf\n    " \
    "        8. core DA algorithm\n    " \
    "    6. py__cvt_pdaf\n    " \
    "    7. py__cvt_ens_pdaf\n    " \
    "    8. Perform LESTKF:\n    " \
    "        1. py__init_n_domains_p_pdaf\n    " \
    "        2. py__init_dim_obs_pdaf\n    " \
    "        3. py__obs_op_pdaf\n    " \
    "           (for each ensemble member)\n    " \
    "        4. loop over each local domain:\n    " \
    "            1. py__init_dim_l_pdaf\n    " \
    "            2. py__init_dim_obs_l_pdaf\n    " \
    "            3. py__prodRinvA_l_pdaf\n    " \
    "            4. core DA algorithm\n    " \
    "    9. py__prepoststep_state_pdaf\n    " \
    "    10. py__distribute_state_pdaf\n    " \
    "    11. py__next_observation_pdaf"
docstrings['localomi_assimilate_nondiagR'] = \
    "Domain local filters for a single DA step\n    " \
    "using non-diagnoal observation error covariance matrix.\n\n    " \
    "Here, this function call is used for LE(S)TKF [1]_ and LSEIK [1]_\n    " \
    "The filter type is set in :func:`pyPDAF.PDAF.init`.\n    " \
    "This function should be called at each model time step.\n    " \
    "The function is a combination of\n    " \
    ":func:`pyPDAF.PDAF.localomi_put_state_local_nondiagR`\n    " \
    "and :func:`pyPDAF.PDAF.get_state`.\n\n    " \
    "User-supplied functions are executed in the following sequence:\n    " \
    "    1. py__collect_state_pdaf\n    "\
    "    2. py__prepoststep_state_pdaf\n    "\
    "    3. py__init_n_domains_p_pdaf\n    "\
    "    4. py__init_dim_obs_pdaf\n    "\
    "    5. py__obs_op_pdaf (for each ensemble member)\n    "\
    "    6. loop over each local domain:\n    " \
    "        1. py__init_dim_l_pdaf\n    "\
    "        2. py__init_dim_obs_l_pdaf\n    "\
    "        3. py__init_obs_l_pdaf\n    "\
    "        4. py__prodRinvA_l_pdaf\n    " \
    "        5. core DA algorithm\n    " \
    "    7. py__prepoststep_state_pdaf\n    "\
    "    8. py__distribute_state_pdaf\n    "\
    "    9. py__next_observation_pdaf\n" \
    "\n    " \
    "References\n    " \
    "----------\n    " \
    ".. [1] Nerger, L., Janjić, T., Schröter, J., Hiller, W. (2012). \n    " \
    "       A unification of ensemble square root Kalman filters. \n    " \
    "       Monthly Weather Review, 140, 2335-2345.\n    " \
    "       doi:10.1175/MWR-D-11-00102.1"
docstrings['localomi_assimilate_lnetf_nondiagR'] = \
    "LNETF for a single DA step using\n    " \
    "non-diagnoal observation error covariance matrix.\n\n    " \
    "See :func:`pyPDAF.PDAF.localomi_assimilate` for\n    " \
    "using diagnoal observation error covariance matrix.\n    " \
    "The non-linear filter is proposed in [1]_.\n    " \
    "The filter type is set in :func:`pyPDAF.PDAF.init`.\n    " \
    "This function should be called at each model time step.\n    " \
    "The function is a combination of\n    " \
    ":func:`pyPDAF.PDAF.localomi_put_state_lnetf_nondiagR`\n    " \
    "and :func:`pyPDAF.PDAF.get_state`.\n\n    " \
    "User-supplied functions are executed in the following sequence:\n    " \
    "    1. py__collect_state_pdaf\n    "\
    "    2. py__prepoststep_state_pdaf\n    "\
    "    3. py__init_n_domains_p_pdaf\n    "\
    "    4. py__init_dim_obs_pdaf\n    "\
    "    5. py__obs_op_pdaf (for each ensemble member)\n    "\
    "    6. loop over each local domain:\n    " \
    "        1. py__init_dim_l_pdaf\n    "\
    "        2. py__init_dim_obs_l_pdaf\n    "\
    "        3. py__likelihood_l_pdaf\n    " \
    "        4. core DA algorithm\n    " \
    "    7. py__prepoststep_state_pdaf\n    "\
    "    8. py__distribute_state_pdaf\n    "\
    "    9. py__next_observation_pdaf\n" \
    "\n    " \
    "References\n    " \
    "----------\n    " \
    ".. [1] Tödter, J., and B. Ahrens, 2015:\n    "\
    "       A second-order exact ensemble square root filter\n    " \
    "       for nonlinear data assimilation. Mon. Wea. Rev.,\n    " \
    "       143, 1347–1367, doi:10.1175/MWR-D-14-00108.1."
docstrings['localomi_assimilate_lknetf_nondiagR'] = \
    "LKNETF for a single DA step using\n    " \
    "non-diagnoal observation error covariance matrix.\n\n    " \
    "See :func:`pyPDAF.PDAF.localomi_assimilate` for\n    " \
    "using diagnoal observation error covariance matrix.\n    " \
    "The non-linear filter is proposed in [1]_.\n    " \
    "The filter type is set in :func:`pyPDAF.PDAF.init`.\n    " \
    "This function should be called at each model time step.\n    " \
    "The function is a combination of\n    " \
    ":func:`pyPDAF.PDAF.localomi_put_state_lknetf_nondiagR`\n    " \
    "and :func:`pyPDAF.PDAF.get_state`.\n\n    " \
    "User-supplied functions are executed in the following sequence:\n    " \
    "    1. py__collect_state_pdaf\n    "\
    "    2. py__prepoststep_state_pdaf\n    "\
    "    3. py__init_n_domains_p_pdaf\n    "\
    "    4. py__init_dim_obs_pdaf\n    "\
    "    5. py__obs_op_pdaf (for each ensemble member)\n    "\
    "    6. loop over each local domain:\n    " \
    "        1. py__init_dim_l_pdaf\n    "\
    "        2. py__init_dim_obs_l_pdaf\n    "\
    "        3. py__prodRinvA_pdaf\n    " \
    "        4. py__likelihood_l_pdaf\n    " \
    "        5. core DA algorithm\n    " \
    "        6. py__obs_op_pdaf\n    " \
    "           (only called with `HKN` and `HNK` options\n    " \
    "           called for each ensemble member)\n    " \
    "        7. py__likelihood_hyb_l_pda\n    " \
    "        8. py__prodRinvA_hyb_l_pdaf\n    " \
    "    7. py__prepoststep_state_pdaf\n    "\
    "    8. py__distribute_state_pdaf\n    "\
    "    9. py__next_observation_pdaf\n" \
    "\n    " \
    "References\n    " \
    "----------\n    " \
    ".. [1] Nerger, L.. (2022) \n    " \
    "       Data assimilation for nonlinear systems with\n    " \
    "       a hybrid nonlinear Kalman ensemble transform filter. \n    " \
    "       Q J R Meteorol Soc, 620–640. doi:10.1002/qj.4221"
