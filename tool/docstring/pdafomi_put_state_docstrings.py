"""docstrings for PDAFomi_assimilate_xxx functions
"""
docstrings = {}

docstrings['omi_put_state_3dvar'] = \
    "3DVar DA for a single DA step\n    "\
    "using diagnoal observation error covariance matrix\n    " \
    "without post-processing, distributing analysis,\n    "\
    "and setting next observation step.\n\n    " \
    "See :func:`pyPDAF.PDAF.omi_put_state_3dvar_nondiagR`\n    "\
    "for non-diagonal observation error covariance matrix.\n\n    "\
    "Compared to :func:`pyPDAF.PDAF.omi_assimilate_3dvar`,\n    "\
    "this function has no :func:`get_state` call.\n    " \
    "This means that the analysis is not post-processed,\n    "\
    "and distributed to the model forecast\n    " \
    "by user-supplied functions. The next DA step will\n    "\
    "not be assigned by user-supplied functions as well.\n    " \
    "The :func:`pyPDAF.PDAF.get_state` function follows this\n    "\
    "function call to ensure the sequential DA.\n\n    " \
    "When 3DVar is used, the background error covariance matrix\n    "\
    "has to be modelled for cotrol variable transformation.\n    " \
    "This is a deterministic filtering scheme\n    "\
    "so no ensemble and parallelisation is needed.\n    " \
    "This function should be called at each model time step.\n\n    " \
    "User-supplied functions are executed in the following sequence:\n    " \
    "    1. py__collect_state_pdaf\n    " \
    "    2. py__prepoststep_state_pdaf\n    " \
    "    3. py__init_dim_obs_pdaf\n    " \
    "    4. py__obs_op_pdaf\n    " \
    "    5. Iterative optimisation:\n    " \
    "        1. py__cvt_pdaf\n    " \
    "        2. py__obs_op_lin_pdaf\n    " \
    "        3. py__obs_op_adj_pdaf\n    " \
    "        4. py__cvt_adj_pdaf\n    " \
    "        5. core DA algorithm\n    " \
    "    6. py__cvt_pdaf"
docstrings['omi_put_state_en3dvar_estkf'] = \
    "3DEnVar for a single DA step\n    "\
    "using diagnoal observation error covariance matrix\n    " \
    "without post-processing, distributing analysis,\n    "\
    "and setting next observation step.\n\n    " \
    "See :func:`pyPDAF.PDAF.omi_put_state_en3dvar_estkf_nondiagR`\n    "\
    "for non-diagonal observation error covariance matrix.\n\n    " \
    "Compared to :func:`pyPDAF.PDAF.omi_assimilate_en3dvar_estkf`,\n    "\
    "this function has no :func:`get_state` call.\n    " \
    "This means that the analysis is not post-processed,\n    "\
    "and distributed to the model forecast\n    " \
    "by user-supplied functions. The next DA step will\n    "\
    "not be assigned by user-supplied functions as well.\n    " \
    "This function is typically used when there are\n    "\
    "not enough CPUs to run the ensemble in parallel,\n    "\
    "and some ensemble members have to be run serially.\n    "\
    "The :func:`pyPDAF.PDAF.get_state` function follows this\n    "\
    "function call to ensure the sequential DA.\n\n    " \
    "The background error covariance matrix is\n    "\
    "estimated by an ensemble.\n    " \
    "The 3DEnVar only calculates the analysis of\n    "\
    "the ensemble mean.\n    " \
    "An ESTKF is used along with 3DEnVar to\n    "\
    "generate ensemble perturbations.\n    " \
    "This function should be called at each model time step.\n\n    " \
    "User-supplied functions are executed in the following sequence:\n    " \
    "    1. py__collect_state_pdaf\n    " \
    "    2. py__prepoststep_state_pdaf\n    " \
    "    3. py__init_dim_obs_pdaf\n    " \
    "    4. py__obs_op_pdaf\n    " \
    "    5. the iterative optimisation:\n    " \
    "        1. py__cvt_ens_pdaf\n    " \
    "        2. py__obs_op_lin_pdaf\n    " \
    "        3. py__obs_op_adj_pdaf\n    " \
    "        4. py__cvt_adj_ens_pdaf\n    " \
    "        5. core 3DEnVar algorithm\n    " \
    "    6. py__cvt_ens_pdaf\n    " \
    "    7. ESTKF:\n    " \
    "        1. py__init_dim_obs_pdaf\n    " \
    "        2. py__obs_op_pdaf (for ensemble mean)\n    " \
    "        3. py__obs_op_pdaf (for each ensemble member)\n    " \
    "        4. core ESTKF algorithm"
docstrings['omi_put_state_en3dvar_lestkf'] = \
    "It is recommended to use\n    "\
    ":func:`pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf`\n    "\
    "or :func:`pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf_nondiagR`.\n\n    "\
    "PDAFlocal-OMI modules require fewer user-supplied\n    "\
    "functions and improved efficiency.\n\n    " \
    "3DEnVar for a single DA step where the ensemble anomaly\n    "\
    "is generated by LESTKF using diagnoal observation\n    "\
    "error covariance matrix.\n\n    " \
    "Compared to\n    "\
    ":func:`pyPDAF.PDAF.omi_assimilate_en3dvar_lestkf`,\n    "\
    "this function has no :func:`get_state` call.\n    " \
    "This means that the analysis is not post-processed,\n    "\
    "and distributed to the model forecast\n    " \
    "by user-supplied functions. The next DA step will\n    "\
    "not be assigned by user-supplied functions as well.\n    " \
    "This function is typically used when there are\n    "\
    "not enough CPUs to run the ensemble in parallel,\n    "\
    "and some ensemble members have to be run serially.\n    "\
    "The :func:`pyPDAF.PDAF.get_state` function follows this\n    "\
    "function call to ensure the sequential DA.\n\n    " \
    "The background error covariance matrix is\n    "\
    "estimated by ensemble.\n    " \
    "The 3DEnVar only calculates the analysis of the ensemble mean.\n    " \
    "An LESTKF is used to generate ensemble perturbations.\n    " \
    "This function should be called at each model time step.\n\n    " \
    "User-supplied functions are executed in the following sequence:\n    " \
    "    1. py__collect_state_pdaf\n    " \
    "    2. py__prepoststep_state_pdaf\n    " \
    "    3. py__init_dim_obs_pdaf\n    " \
    "    4. py__obs_op_pdaf\n    " \
    "    5. Starting the iterative optimisation:\n    " \
    "        1. py__cvt_ens_pdaf\n    " \
    "        2. py__obs_op_lin_pdaf\n    " \
    "        3. py__obs_op_adj_pdaf\n    " \
    "        4. py__cvt_adj_ens_pdaf\n    " \
    "        5. core DA algorithm\n    " \
    "    6. py__cvt_ens_pdaf\n    " \
    "    7. Perform LESTKF:\n    " \
    "        1. py__init_n_domains_p_pdaf\n    " \
    "        2. py__init_dim_obs_pdaf\n    " \
    "        3. py__obs_op_pdaf\n    "\
    "           (for each ensemble member)\n    " \
    "        4. loop over each local domain:\n    " \
    "            1. py__init_dim_l_pdaf\n    " \
    "            2. py__init_dim_obs_l_pdaf\n    " \
    "            3. py__g2l_state_pdaf\n    " \
    "            4. core DA algorithm\n    " \
    "            5. py__l2g_state_pdaf\n" \
    "\n    " \
    ".. deprecated:: 1.0.0\n\n    " \
    "   This function is replaced by\n    "\
    "   :func:`pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf`\n    " \
    "   and :func:`pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf_nondiagR`"
docstrings['omi_put_state_hyb3dvar_estkf'] = \
    "Hybrid 3DEnVar for a single DA step\n    "\
    "using diagnoal observation error covariance matrix\n    "\
    "without post-processing, distributing analysis,\n    "\
    "and setting next observation step.\n\n    " \
    "See :func:`pyPDAF.PDAF.omi_put_state_hyb3dvar_estkf_nondiagR`\n    "\
    "for non-diagonal observation error covariance matrix.\n\n    " \
    "Hybrid 3DEnVar for a single DA step where\n    " \
    "the background error covariance is hybridised by\n    "\
    "a static background error covariance,\n    " \
    "and a flow-dependent background error covariance\n    "\
    "estimated from ensemble.\n\n    " \
    "Compared to\n    "\
    ":func:`pyPDAF.PDAF.omi_assimilate_hyb3dvar_estkf`,\n    "\
    "this function has no :func:`get_state` call.\n    " \
    "This means that the analysis is not post-processed,\n    "\
    "and distributed to the model forecast\n    " \
    "by user-supplied functions. The next DA step will\n    "\
    "not be assigned by user-supplied functions as well.\n    " \
    "This function is typically used when there are\n    "\
    "not enough CPUs to run the ensemble in parallel,\n    "\
    "and some ensemble members have to be run serially.\n    "\
    "The :func:`pyPDAF.PDAF.get_state` function follows this\n    "\
    "function call to ensure the sequential DA.\n\n    " \
    "The 3DVar generates an ensemble mean and\n    "\
    "the ensemble perturbation is generated by\n    " \
    "ESTKF in this implementation.\n    " \
    "This function should be called at each model time step.\n\n    " \
    "User-supplied functions are executed in the following sequence:\n    " \
    "    1. py__collect_state_pdaf\n    " \
    "    2. py__prepoststep_state_pdaf\n    " \
    "    3. py__init_dim_obs_pdaf\n    " \
    "    4. py__obs_op_pdaf\n    " \
    "    5. the iterative optimisation:\n    " \
    "        1. py__cvt_pdaf\n    " \
    "        2. py__cvt_ens_pdaf\n    " \
    "        3. py__obs_op_lin_pdaf\n    " \
    "        4. py__obs_op_adj_pdaf\n    " \
    "        5. py__cvt_adj_pdaf\n    " \
    "        6. py__cvt_adj_ens_pdaf\n    " \
    "        7. core 3DEnVar algorithm\n    " \
    "    6. py__cvt_pdaf\n    " \
    "    7. py__cvt_ens_pdaf\n    " \
    "    8. Perform ESTKF:\n    " \
    "        1. py__init_dim_obs_pdaf\n    " \
    "        2. py__obs_op_pdaf\n    "\
    "           (for ensemble mean)\n    " \
    "        3. py__obs_op_pdaf\n    " \
    "           (for each ensemble member)\n    " \
    "        4. core ESTKF algorithm\n"
docstrings['omi_put_state_hyb3dvar_lestkf'] = \
    "It is recommended to use\n    "\
    ":func:`pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf`\n    "\
    "or :func:`pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf_nondiagR`.\n\n    "\
    "PDAFlocal-OMI modules require fewer user-supplied\n    "\
    "functions and improved efficiency.\n\n    " \
    "Hybrid 3DEnVar for a single DA step using\n    "\
    "diagnoal observation error covariance matrix\n    " \
    "without post-processing, distributing analysis,\n    "\
    "and setting next observation step, where\n    " \
    "the background error covariance is hybridised by\n    "\
    "a static background error covariance,\n    " \
    "and a flow-dependent background error covariance\n    "\
    "estimated from ensemble.\n\n    " \
    "Compared to\n    "\
    ":func:`pyPDAF.PDAF.omi_assimilate_hyb3dvar_lestkf`,\n    "\
    "this function has no :func:`get_state` call.\n    " \
    "This means that the analysis is not post-processed,\n    "\
    "and distributed to the model forecast\n    " \
    "by user-supplied functions. The next DA step will\n    "\
    "not be assigned by user-supplied functions as well.\n    " \
    "This function is typically used when there are\n    "\
    "not enough CPUs to run the ensemble in parallel,\n    "\
    "and some ensemble members have to be run serially.\n    "\
    "The :func:`pyPDAF.PDAF.get_state` function follows this\n    "\
    "function call to ensure the sequential DA.\n\n    " \
    "The 3DVar generates an ensemble mean and\n    "\
    "the ensemble perturbation is generated by\n    " \
    "LESTKF in this implementation.\n    " \
    "This function should be called at each model time step.\n\n    " \
    "User-supplied functions are executed in the following sequence:\n    " \
    "    1. py__collect_state_pdaf\n    " \
    "    2. py__prepoststep_state_pdaf\n    " \
    "    3. py__init_dim_obs_pdaf\n    " \
    "    4. py__obs_op_pdaf\n    " \
    "    5. The iterative optimisation:\n    " \
    "        1. py__cvt_pdaf\n    " \
    "        2. py__cvt_ens_pdaf\n    " \
    "        3. py__obs_op_lin_pdaf\n    " \
    "        4. py__obs_op_adj_pdaf\n    " \
    "        5. py__cvt_adj_pdaf\n    " \
    "        6. py__cvt_adj_ens_pdaf\n    " \
    "        7. core DA algorithm\n    " \
    "    6. py__cvt_pdaf\n    " \
    "    7. py__cvt_ens_pdaf\n    " \
    "    8. Perform LESTKF:\n    " \
    "        1. py__init_n_domains_p_pdaf\n    " \
    "        2. py__init_dim_obs_pdaf\n    " \
    "        3. py__obs_op_pdaf\n    " \
    "           (for each ensemble member)\n    " \
    "        4. loop over each local domain:\n    " \
    "            1. py__init_dim_l_pdaf\n    " \
    "            2. py__init_dim_obs_l_pdaf\n    " \
    "            3. py__g2l_state_pdaf\n    " \
    "            4. core DA algorithm\n    " \
    "            5. py__l2g_state_pdaf\n" \
    "\n    " \
    ".. deprecated:: 1.0.0\n\n    " \
    "   This function is replaced by\n    "\
    "   :func:`pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf`\n    " \
    "   and :func:`pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf_nondiagR`"
docstrings['omi_put_state_global'] = \
    "Global filters except for 3DVar for\n    "\
    "a single DA step using diagnoal observation error covariance matrix\n    " \
    "without post-processing, distributing analysis,\n    "\
    "and setting next observation step.\n\n    " \
    "See :func:`pyPDAF.PDAF.omi_put_state_enkf_nondiagR`, \n    " \
    "or :func:`pyPDAF.PDAF.omi_put_state_global_nondiagR`,\n    " \
    "or :func:`pyPDAF.PDAF.omi_put_state_nonlin_nondiagR`\n    "\
    "for non-diagonal observation error covariance matrix.\n\n    " \
    "OMI functions need fewer user-supplied functions and\n    "\
    "improve DA efficiency.\n\n    " \
    "Here, this function call is used for\n    "\
    "global stochastic EnKF [1]_, E(S)TKF [2]_, \n    " \
    "SEEK [2]_, SEIK [2]_, NETF [3]_, and particle filter [4]_.\n    " \
    "The filter type is set in :func:`pyPDAF.PDAF.init`.\n    " \
    "Compared to :func:`pyPDAF.PDAF.omi_assimilate_global`,\n    "\
    "this function has no :func:`get_state` call.\n    " \
    "This means that the analysis is not post-processed,\n    "\
    "and distributed to the model forecast\n    " \
    "by user-supplied functions. The next DA step will\n    "\
    "not be assigned by user-supplied functions as well.\n    " \
    "This function is typically used when there are\n    "\
    "not enough CPUs to run the ensemble in parallel,\n    "\
    "and some ensemble members have to be run serially.\n    "\
    "The :func:`pyPDAF.PDAF.get_state` function follows this\n    "\
    "function call to ensure the sequential DA.\n\n    " \
    "The ESTKF is a more efficient equivalent to the ETKF.\n\n    " \
    "The function should be called at each model time step.\n\n    " \
    "User-supplied functions are executed in the following sequence:\n    " \
    "    1. py__collect_state_pdaf\n    " \
    "    2. py__prepoststep_state_pdaf\n    " \
    "    3. py__init_dim_obs_pdaf\n    " \
    "    4. py__obs_op_pdaf (for ensemble mean)\n    " \
    "    5. py__init_obs_pdaf\n    " \
    "    6. py__obs_op_pdaf (for each ensemble member)\n    " \
    "    7. py__init_obsvar_pdaf (only relevant for\n    "\
    "       adaptive forgetting factor schemes)\n    " \
    "    8. py__prodRinvA_pdaf\n    " \
    "    9. core DA algorithm\n" \
    "\n    " \
    ".. deprecated:: 1.0.0\n\n    " \
    "   This function is replaced by\n    "\
    "   :func:`pyPDAF.PDAF.omi_put_state_global`\n    " \
    "   and :func:`pyPDAF.PDAF.omi_put_state_global_nondiagR`." \
    "\n\n    " \
    "References\n    " \
    "----------\n    " \
    ".. [1] Evensen, G. (1994), \n    "\
    "       Sequential data assimilation with\n    "\
    "       a nonlinear quasi-geostrophic model\n    "\
    "       using Monte Carlo methods to forecast error statistics,\n    "\
    "       J. Geophys. Res., 99(C5), 10143–10162, doi:10.1029/94JC00572.\n    " \
    ".. [2] Nerger, L., Janjić, T., Schröter, J., Hiller, W. (2012). \n    " \
    "       A unification of ensemble square root Kalman filters. \n    " \
    "       Monthly Weather Review, 140, 2335-2345.\n    "\
    "       doi:10.1175/MWR-D-11-00102.1\n    " \
    ".. [3] Tödter, J., and B. Ahrens, 2015:\n    "\
    "       A second-order exact ensemble square root filter\n    " \
    "       for nonlinear data assimilation. Mon. Wea. Rev.,\n    " \
    "       143, 1347–1367, doi:10.1175/MWR-D-14-00108.1.\n    " \
    ".. [4] Van Leeuwen, P. J., Künsch, H. R., Nerger, L.,\n    "\
    "       Potthast, R., & Reich, S. (2019).\n    "\
    "       Particle filters for high‐dimensional geoscience applications:\n    "\
    "       A review. Quarterly Journal of the\n    "\
    "       Royal Meteorological Society, 145(723), 2335-2365."
docstrings['omi_put_state_lenkf'] = \
    "Stochastic EnKF (ensemble Kalman filter)\n    "\
    "with covariance localisation using diagnoal observation\n    "\
    "error covariance matrix\n    "\
    "without post-processing, distributing analysis,\n    "\
    "and setting next observation step.\n\n    " \
    "See :func:`pyPDAF.PDAF.omi_put_state_lenkf_nondiagR`\n    "\
    "for non-diagonal observation error covariance matrix.\n\n    "\
    "Stochastic EnKF (ensemble Kalman filter) with covariance localisation [1]_\n    " \
    "for a single DA step.\n\n    " \
    "Compared to :func:`pyPDAF.PDAF.omi_assimilate_lenkf`,\n    "\
    "this function has no :func:`get_state` call.\n    " \
    "This means that the analysis is not post-processed,\n    "\
    "and distributed to the model forecast\n    " \
    "by user-supplied functions. The next DA step will\n    "\
    "not be assigned by user-supplied functions as well.\n    " \
    "This function is typically used when there are\n    "\
    "not enough CPUs to run the ensemble in parallel,\n    "\
    "and some ensemble members have to be run serially.\n    "\
    "The :func:`pyPDAF.PDAF.get_state` function follows this\n    "\
    "function call to ensure the sequential DA.\n\n    " \
    "This is the only scheme for covariance localisation in PDAF.\n\n    " \
    "This function should be called at each model time step.\n\n    " \
    "User-supplied functions are executed in the following sequence:\n    " \
    "    1. py__collect_state_pdaf\n    " \
    "    2. py__prepoststep_state_pdaf\n    " \
    "    3. py__init_dim_obs_pdaf\n    " \
    "    4. py__obs_op_pdaf (for each ensemble member)\n    " \
    "    5. py__localize_pdaf\n    " \
    "    6. py__obs_op_pdaf (repeated to reduce storage)\n    " \
    "    7. core DA algorith" \
    "\n\n    " \
    "References\n    " \
    "----------\n    " \
    ".. [1] Houtekamer, P. L., and H. L. Mitchell (1998): \n    " \
    "       Data Assimilation Using an Ensemble Kalman Filter Technique.\n    "\
    "       Mon. Wea. Rev., 126, 796–811,\n    "\
    "       doi: 10.1175/1520-0493(1998)126<0796:DAUAEK>2.0.CO;2."
docstrings['omi_put_state_local'] = \
    "It is recommended to use\n    "\
    ":func:`pyPDAF.PDAF.localomi_put_state`\n    "\
    "or :func:`pyPDAF.PDAF.localomi_put_state_nondiagR`,\n    " \
    "or :func:`pyPDAF.PDAF.localomi_put_state_lnetf_nondiagR`,\n    " \
    "or :func:`pyPDAF.PDAF.localomi_put_state_lknetf_nondiagR`.\n\n    " \
    "PDAFlocal-OMI modules require fewer user-supplied\n    "\
    "functions and improved efficiency.\n\n    " \
    "Domain local filters for a single DA step using\n    "\
    "diagnoal observation error covariance matrix\n    " \
    "without post-processing, distributing analysis,\n    "\
    "and setting next observation step.\n\n    " \
    "Here, this function call is used for LE(S)TKF [1]_, \n    " \
    "LSEIK [1]_, LNETF [2]_, and LKNETF [3]_.\n    " \
    "The filter type is set in :func:`pyPDAF.PDAF.init`.\n    " \
    "Compared to :func:`pyPDAF.PDAF.omi_assimilate_local`,\n    "\
    "this function has no :func:`get_state` call.\n    " \
    "This means that the analysis is not post-processed,\n    "\
    "and distributed to the model forecast\n    " \
    "by user-supplied functions. The next DA step will\n    "\
    "not be assigned by user-supplied functions as well.\n    " \
    "This function is typically used when there are\n    "\
    "not enough CPUs to run the ensemble in parallel,\n    "\
    "and some ensemble members have to be run serially.\n    "\
    "The :func:`pyPDAF.PDAF.get_state` function follows this\n    "\
    "function call to ensure the sequential DA.\n\n    " \
    "The LESTKF is a more efficient equivalent to the LETKF.\n\n    " \
    "This function should be called at each model time step.\n\n    " \
    "User-supplied functions are executed in the following sequence:\n    " \
    "    1. py__collect_state_pdaf\n    "\
    "    2. py__prepoststep_state_pdaf\n    "\
    "    3. py__init_n_domains_p_pdaf\n    "\
    "    4. py__init_dim_obs_pdaf\n    "\
    "    5. py__obs_op_pdaf (for each ensemble member)\n    "\
    "    6. loop over each local domain:\n    " \
    "        1. py__init_dim_l_pdaf\n    "\
    "        2. py__init_dim_obs_l_pdaf\n    "\
    "        3. py__g2l_state_pdaf\n    "\
    "        4. core DA algorithm\n    " \
    "        5. py__l2g_state_pdaf\n"\
    "\n    " \
    ".. deprecated:: 1.0.0\n\n    " \
    "   This function is replaced by :func:`pyPDAF.PDAF.omi_put_state`\n    " \
    "   and :func:`pyPDAF.PDAF.localomi_put_state_nondiagR`,\n    " \
    "   and :func:`pyPDAF.PDAF.localomi_put_state_lnetf_nondiagR`,\n    " \
    "   and :func:`pyPDAF.PDAF.localomi_put_state_lknetf_nondiagR`." \
    "\n\n    " \
    "References\n    " \
    "----------\n    " \
    ".. [1] Nerger, L., Janjić, T., Schröter, J., Hiller, W. (2012). \n    " \
    "       A unification of ensemble square root Kalman filters. \n    " \
    "       Monthly Weather Review, 140, 2335-2345.\n    "\
    "       doi:10.1175/MWR-D-11-00102.1\n    " \
    ".. [2] Tödter, J., and B. Ahrens, 2015:\n    "\
    "       A second-order exact ensemble square root filter\n    " \
    "       for nonlinear data assimilation. Mon. Wea. Rev.,\n    " \
    "       143, 1347–1367, doi:10.1175/MWR-D-14-00108.1.\n    " \
    ".. [3] Nerger, L.. (2022) \n    " \
    "       Data assimilation for nonlinear systems with\n    "\
    "       a hybrid nonlinear Kalman ensemble transform filter. \n    " \
    "       Q J R Meteorol Soc, 620–640. doi:10.1002/qj.4221"
docstrings['omi_put_state_generate_obs'] = \
    "Generation of synthetic observations\n    "\
    "based on given error statistics and\n    "\
    "observation operator for diagonal observation\n    "\
    "error covariance matrix\n    " \
    "without post-processing, distributing analysis,\n    "\
    "and setting next observation step.\n\n    " \
    "If non-diagonal observation error covariance matrix has to be used,\n    " \
    "the generic :func:`pyPDAF.PDAF.put_generate_obs` can be used.\n\n    "\
    "The generated synthetic observations are\n    "\
    "based on each member of model forecast.\n    " \
    "Therefore, an ensemble of observations can be obtained.\n    "\
    "In a typical experiment,\n    "\
    "one may only need one ensemble member.\n\n    " \
    "Compared to :func:`pyPDAF.PDAF.omi_generate_obs`,\n    "\
    "this function has no :func:`get_state` call.\n    " \
    "This means that the next DA step will\n    "\
    "not be assigned by user-supplied functions.\n    " \
    "This function is typically used when there are\n    "\
    "not enough CPUs to run the ensemble in parallel,\n    "\
    "and some ensemble members have to be run serially.\n    "\
    "The :func:`pyPDAF.PDAF.get_state` function follows this\n    "\
    "function call to ensure the sequential DA.\n\n    " \
    "The implementation strategy is similar to\n    "\
    "an assimilation step. This means that, \n    " \
    "one can reuse many user-supplied functions\n    "\
    "for assimilation and observation generation.\n\n    " \
    "User-supplied functions are executed in the following sequence:\n    " \
    "    1. py__collect_state_pdaf\n    " \
    "    2. py__prepoststep_state_pdaf\n    " \
    "    3. py__init_dim_obs_pdaf\n    " \
    "    4. py__obs_op_pda\n    " \
    "    5. py__get_obs_f_pdaf"

docstrings['omi_put_state_3dvar_nondiagR'] = \
    "3DVar DA for a single DA step\n    " \
    "using non-diagnoal observation error covariance matrix\n    " \
    "without post-processing, distributing analysis,\n    " \
    "and setting next observation step.\n\n    " \
    "See :func:`pyPDAF.PDAF.omi_put_state_3dvar`\n    " \
    "for simpler user-supplied functions using\n    " \
    "diagonal observation error covariance matrix.\n\n    "\
    "Compared to\n    " \
    ":func:`pyPDAF.PDAF.omi_assimilate_3dvar_nondiagR`,\n    " \
    "this function has no :func:`get_state` call.\n    " \
    "This means that the analysis is not post-processed,\n    " \
    "and distributed to the model forecast\n    " \
    "by user-supplied functions.\n    " \
    "The next DA step will not be assigned\n    " \
    "by user-supplied functions as well.\n    " \
    "The :func:`pyPDAF.PDAF.get_state` function follows this\n    "\
    "function call to ensure the sequential DA.\n\n    " \
    "When 3DVar is used, the background error covariance matrix\n    "\
    "has to be modelled for cotrol variable transformation.\n    " \
    "This is a deterministic filtering scheme\n    " \
    "so no ensemble and parallelisation is needed.\n    " \
    "This function should be called at each model time step.\n\n    " \
    "User-supplied functions are executed in the following sequence:\n    " \
    "    1. py__collect_state_pdaf\n    " \
    "    2. py__prepoststep_state_pdaf\n    " \
    "    3. py__init_dim_obs_pdaf\n    " \
    "    4. py__obs_op_pdaf\n    " \
    "    5. Iterative optimisation:\n    " \
    "        1. py__cvt_pdaf\n    " \
    "        2. py__obs_op_lin_pdaf\n    " \
    "        3. py__prodRinvA_pdaf\n    " \
    "        4. py__obs_op_adj_pdaf\n    " \
    "        5. py__cvt_adj_pdaf\n    " \
    "        6. core DA algorithm\n    " \
    "    6. py__cvt_pdaf"
docstrings['omi_put_state_en3dvar_estkf_nondiagR'] = \
    "3DEnVar for a single DA step\n    " \
    "using non-diagnoal observation error covariance matrix\n    " \
    "without post-processing, distributing analysis,\n    " \
    "and setting next observation step.\n\n    " \
    "See :func:`pyPDAF.PDAF.omi_put_state_en3dvar_estkf`\n    " \
    "for simpler user-supplied functions\n    " \
    "using diagonal observation error covariance matrix.\n\n    " \
    "Compared to\n    " \
    ":func:`pyPDAF.PDAF.omi_assimilate_en3dvar_estkf_nondiagR`,\n    " \
    "this function has no :func:`get_state` call.\n    " \
    "This means that the analysis is not post-processed,\n    " \
    "and distributed to the model forecast\n    " \
    "by user-supplied functions. The next DA step will\n    " \
    "not be assigned by user-supplied functions as well.\n    " \
    "This function is typically used when there are\n    " \
    "not enough CPUs to run the ensemble in parallel,\n    "\
    "and some ensemble members have to be run serially.\n    " \
    "The :func:`pyPDAF.PDAF.get_state` function follows this\n    "\
    "function call to ensure the sequential DA.\n\n    " \
    "The background error covariance matrix is\n    " \
    "estimated by an ensemble.\n    " \
    "The 3DEnVar only calculates the analysis of the ensemble mean.\n    " \
    "An ESTKF is used along with 3DEnVar to generate ensemble perturbations.\n    " \
    "This function should be called at each model time step.\n\n    " \
    "User-supplied functions are executed in the following sequence:\n    " \
    "    1. py__collect_state_pdaf\n    " \
    "    2. py__prepoststep_state_pdaf\n    " \
    "    3. py__init_dim_obs_pdaf\n    " \
    "    4. py__obs_op_pdaf\n    " \
    "    5. the iterative optimisation:\n    " \
    "        1. py__cvt_ens_pdaf\n    " \
    "        2. py__obs_op_lin_pdaf\n    " \
    "        3. py__prodRinvA_pdaf\n    " \
    "        4. py__obs_op_adj_pdaf\n    " \
    "        5. py__cvt_adj_ens_pdaf\n    " \
    "        6. core 3DEnVar algorithm\n    " \
    "    6. py__cvt_ens_pdaf\n    " \
    "    7. ESTKF:\n    " \
    "        1. py__init_dim_obs_pdaf\n    " \
    "        2. py__obs_op_pdaf (for ensemble mean)\n    " \
    "        3. py__obs_op_pdaf (for each ensemble member)\n    " \
    "        4. py__prodRinvA_pdaf\n    " \
    "        5. core ESTKF algorithm"
docstrings['omi_put_state_en3dvar_lestkf_nondiagR'] = \
    "It is recommended to use\n    " \
    ":func:`pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf_nondiagR`\n    "\
    "or :func:`pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf`.\n\n    "\
    "PDAFlocal-OMI modules require fewer user-supplied\n    " \
    "functions and improved efficiency.\n\n    " \
    "3DEnVar for a single DA step without post-processing,\n    " \
    "distributing analysis, and setting next observation step,\n    "\
    "where the ensemble anomaly is generated by LESTKF\n    " \
    "using non-diagnoal observation error covariance matrix.\n\n    " \
    "Compared to\n    " \
    ":func:`pyPDAF.PDAF.omi_assimilate_en3dvar_lestkf_nondiagR`,\n    " \
    "this function has no :func:`get_state` call.\n    " \
    "This means that the analysis is not post-processed,\n    " \
    "and distributed to the model forecast\n    " \
    "by user-supplied functions. The next DA step will\n    " \
    "not be assigned by user-supplied functions as well.\n    " \
    "This function is typically used when there are\n    " \
    "not enough CPUs to run the ensemble in parallel,\n    "\
    "and some ensemble members have to be run serially.\n    " \
    "The :func:`pyPDAF.PDAF.get_state` function follows this\n    "\
    "function call to ensure the sequential DA.\n\n    " \
    "The background error covariance matrix is\n    " \
    "estimated by ensemble.\n    " \
    "The 3DEnVar only calculates the analysis of the ensemble mean.\n    " \
    "An LESTKF is used to generate ensemble perturbations.\n    " \
    "This function should be called at each model time step.\n\n    " \
    "User-supplied functions are executed in the following sequence:\n    " \
    "    1. py__collect_state_pdaf\n    " \
    "    2. py__prepoststep_state_pdaf\n    " \
    "    3. py__init_dim_obs_pdaf\n    " \
    "    4. py__obs_op_pdaf\n    " \
    "    5. Starting the iterative optimisation:\n    " \
    "        1. py__cvt_ens_pdaf\n    " \
    "        2. py__obs_op_lin_pdaf\n    " \
    "        3. py__prodRinvA_pdaf\n    " \
    "        4. py__obs_op_adj_pdaf\n    " \
    "        5. py__cvt_adj_ens_pdaf\n    " \
    "        6. core DA algorithm\n    " \
    "    6. py__cvt_ens_pdaf\n    " \
    "    7. Perform LESTKF:\n    " \
    "        1. py__init_n_domains_p_pdaf\n    " \
    "        2. py__init_dim_obs_pdaf\n    " \
    "        3. py__obs_op_pdaf\n    "\
    "           (for each ensemble member)\n    " \
    "        4. loop over each local domain:\n    " \
    "            1. py__init_dim_l_pdaf\n    " \
    "            2. py__init_dim_obs_l_pdaf\n    " \
    "            3. py__g2l_state_pdaf\n    " \
    "            4. py__prodRinvA_l_pdaf\n    " \
    "            5. core DA algorithm\n    " \
    "            6. py__l2g_state_pdaf\n" \
    "\n    " \
    ".. deprecated:: 1.0.0\n\n    " \
    "   This function is replaced by\n    " \
    "   :func:`pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf_nondiagR`\n    " \
    "   and :func:`pyPDAF.PDAF.localomi_put_state_en3dvar_lestkf`"
docstrings['omi_put_state_hyb3dvar_estkf_nondiagR'] = \
    "Hybrid 3DEnVar for a single DA step\n    " \
    "using non-diagnoal observation error covariance matrix\n    "\
    "without post-processing, distributing analysis,\n    " \
    "and setting next observation step.\n\n    " \
    "See :func:`pyPDAF.PDAF.omi_put_state_hyb3dvar_estkf`\n    " \
    "for simpler user-supplied functions\n    " \
    "using diagonal observation error covariance matrix.\n\n    " \
    "Here the background error covariance is hybridised by\n    " \
    "a static background error covariance,\n    " \
    "and a flow-dependent background error covariance\n    " \
    "estimated from ensemble.\n\n    " \
    "Compared to\n    " \
    ":func:`pyPDAF.PDAF.omi_assimilate_hyb3dvar_estkf_nondiagR`,\n    " \
    "this function has no :func:`get_state` call.\n    " \
    "This means that the analysis is not post-processed,\n    " \
    "and distributed to the model forecast\n    " \
    "by user-supplied functions. The next DA step will\n    " \
    "not be assigned by user-supplied functions as well.\n    " \
    "This function is typically used when there are\n    " \
    "not enough CPUs to run the ensemble in parallel,\n    "\
    "and some ensemble members have to be run serially.\n    " \
    "The :func:`pyPDAF.PDAF.get_state` function follows this\n    "\
    "function call to ensure the sequential DA.\n\n    " \
    "The 3DVar generates an ensemble mean and\n    " \
    "the ensemble perturbation is generated by\n    " \
    "ESTKF in this implementation.\n    " \
    "This function should be called at each model time step.\n\n    " \
    "User-supplied functions are executed in the following sequence:\n    " \
    "    1. py__collect_state_pdaf\n    " \
    "    2. py__prepoststep_state_pdaf\n    " \
    "    3. py__init_dim_obs_pdaf\n    " \
    "    4. py__obs_op_pdaf\n    " \
    "    5. the iterative optimisation:\n    " \
    "        1. py__cvt_pdaf\n    " \
    "        2. py__cvt_ens_pdaf\n    " \
    "        3. py__obs_op_lin_pdaf\n    " \
    "        4. py__prodRinvA_pdaf\n    " \
    "        5. py__obs_op_adj_pdaf\n    " \
    "        6. py__cvt_adj_pdaf\n    " \
    "        7. py__cvt_adj_ens_pdaf\n    " \
    "        8. core 3DEnVar algorithm\n    " \
    "    6. py__cvt_pdaf\n    " \
    "    7. py__cvt_ens_pdaf\n    " \
    "    8. Perform ESTKF:\n    " \
    "        1. py__init_dim_obs_pdaf\n    " \
    "        2. py__obs_op_pdaf\n    "\
    "           (for ensemble mean)\n    " \
    "        3. py__obs_op_pdaf\n    " \
    "           (for each ensemble member)\n    " \
    "        4. py__prodRinvA_pdaf\n    " \
    "        5. core ESTKF algorithm"
docstrings['omi_put_state_hyb3dvar_lestkf_nondiagR'] = \
    "It is recommended to use\n    " \
    ":func:`pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf_nondiagR`\n    "\
    "or :func:`pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf`.\n\n    "\
    "PDAFlocal-OMI modules require fewer user-supplied\n    " \
    "functions and improved efficiency.\n\n    " \
    "Hybrid 3DEnVar for a single DA step\n    " \
    "using non-diagnoal observation error covariance matrix\n    " \
    "without post-processing, distributing analysis,\n    " \
    "and setting next observation step, where\n    " \
    "the background error covariance is hybridised by\n    " \
    "a static background error covariance,\n    " \
    "and a flow-dependent background error covariance\n    " \
    "estimated from ensemble.\n\n    " \
    "Compared to\n    " \
    ":func:`pyPDAF.PDAF.omi_assimilate_hyb3dvar_lestkf_nondiagR`,\n    " \
    "this function has no :func:`get_state` call.\n    " \
    "This means that the analysis is not post-processed,\n    " \
    "and distributed to the model forecast\n    " \
    "by user-supplied functions. The next DA step will\n    " \
    "not be assigned by user-supplied functions as well.\n    " \
    "This function is typically used when there are\n    " \
    "not enough CPUs to run the ensemble in parallel,\n    "\
    "and some ensemble members have to be run serially.\n    " \
    "The :func:`pyPDAF.PDAF.get_state` function follows this\n    "\
    "function call to ensure the sequential DA.\n\n    " \
    "The 3DVar generates an ensemble mean and\n    " \
    "the ensemble perturbation is generated by\n    " \
    "LESTKF in this implementation.\n    " \
    "This function should be called at each model time step.\n\n    " \
    "User-supplied functions are executed in the following sequence:\n    " \
    "    1. py__collect_state_pdaf\n    " \
    "    2. py__prepoststep_state_pdaf\n    " \
    "    3. py__init_dim_obs_pdaf\n    " \
    "    4. py__obs_op_pdaf\n    " \
    "    5. The iterative optimisation:\n    " \
    "        1. py__cvt_pdaf\n    " \
    "        2. py__cvt_ens_pdaf\n    " \
    "        3. py__obs_op_lin_pdaf\n    " \
    "        4. py__prodRinvA_pdaf\n    " \
    "        5. py__obs_op_adj_pdaf\n    " \
    "        6. py__cvt_adj_pdaf\n    " \
    "        7. py__cvt_adj_ens_pdaf\n    " \
    "        8. core DA algorithm\n    " \
    "    6. py__cvt_pdaf\n    " \
    "    7. py__cvt_ens_pdaf\n    " \
    "    8. Perform LESTKF:\n    " \
    "        1. py__init_n_domains_p_pdaf\n    " \
    "        2. py__init_dim_obs_pdaf\n    " \
    "        3. py__obs_op_pdaf\n    " \
    "           (for each ensemble member)\n    " \
    "        4. loop over each local domain:\n    " \
    "            1. py__init_dim_l_pdaf\n    " \
    "            2. py__init_dim_obs_l_pdaf\n    " \
    "            3. py__g2l_state_pdaf\n    " \
    "            4. py__prodRinvA_l_pdaf\n    " \
    "            5. core DA algorithm\n    " \
    "            6. py__l2g_state_pdaf\n" \
    "\n    " \
    ".. deprecated:: 1.0.0\n\n    " \
    "   This function is replaced by\n    " \
    "   :func:`pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf`\n    " \
    "   and :func:`pyPDAF.PDAF.localomi_put_state_hyb3dvar_lestkf_nondiagR`"
docstrings['omi_put_state_enkf_nondiagR'] = \
    "Stochastic EnKF for a single DA step\n    " \
    "using non-diagnoal observation error covariance matrix\n    " \
    "without post-processing, distributing analysis,\n    " \
    "and setting next observation step.\n\n    " \
    "See :func:`pyPDAF.PDAF.omi_put_state_global`\n    " \
    "for simpler user-supplied functions\n    " \
    "using diagonal observation error covariance matrix.\n\n    " \
    "The stochastic EnKF is implemented based on [1]_.\n\n    " \
    "Compared to\n    " \
    ":func:`pyPDAF.PDAF.omi_assimilate_enkf_nondiagR`,\n    " \
    "this function has no :func:`get_state` call.\n    " \
    "This means that the analysis is not post-processed,\n    " \
    "and distributed to the model forecast\n    " \
    "by user-supplied functions. The next DA step will\n    " \
    "not be assigned by user-supplied functions as well.\n    " \
    "This function is typically used when there are\n    " \
    "not enough CPUs to run the ensemble in parallel,\n    "\
    "and some ensemble members have to be run serially.\n    " \
    "The :func:`pyPDAF.PDAF.get_state` function follows this\n    "\
    "function call to ensure the sequential DA.\n\n    " \
    "This function should be called at each model time step. \n\n    " \
    "User-supplied functions are executed in the following sequence:\n    " \
    "    1. py__collect_state_pdaf\n    " \
    "    2. py__prepoststep_state_pdaf\n    " \
    "    3. py__init_dim_obs_pdaf\n    " \
    "    4. py__obs_op_pdaf (for ensemble mean)\n    " \
    "    5. py__add_obs_err_pdaf\n    " \
    "    6. py__init_obscovar_pdaf\n    " \
    "    7. py__obs_op_pdaf (for each ensemble member)\n    " \
    "    8. core DA algorithm" \
    "\n\n    " \
    "References\n    " \
    "----------\n    " \
    ".. [1] Evensen, G. (1994), \n    "\
    "       Sequential data assimilation with\n    " \
    "       a nonlinear quasi-geostrophic model\n    "\
    "       using Monte Carlo methods to forecast error statistics,\n    "\
    "       J. Geophys. Res., 99(C5), 10143–10162, doi:10.1029/94JC00572."
docstrings['omi_put_state_global_nondiagR'] = \
    "Global filters except for 3DVar and stochastic EnKF\n    " \
    "for a single DA step using non-diagnoal observation\n    " \
    "error covariance matrix\n    "\
    "without post-processing, distributing analysis,\n    " \
    "and setting next observation step.\n\n    " \
    "See :func:`pyPDAF.PDAF.omi_put_state_global`\n    " \
    "for simpler user-supplied functions\n    " \
    "using diagonal observation error covariance matrix.\n\n    " \
    "Here, this function call is used for global, E(S)TKF [1]_, \n    " \
    "SEEK [1]_, SEIK [1]_.\n    " \
    "The filter type is set in :func:`pyPDAF.PDAF.init`.\n\n    " \
    "Compared to\n    " \
    ":func:`pyPDAF.PDAF.omi_assimilate_global_nondiagR`,\n    " \
    "this function has no :func:`get_state` call.\n    " \
    "This means that the analysis is not post-processed,\n    " \
    "and distributed to the model forecast\n    " \
    "by user-supplied functions. The next DA step will\n    " \
    "not be assigned by user-supplied functions as well.\n    " \
    "This function is typically used when there are\n    " \
    "not enough CPUs to run the ensemble in parallel,\n    "\
    "and some ensemble members have to be run serially.\n    " \
    "The :func:`pyPDAF.PDAF.get_state` function follows this\n    "\
    "function call to ensure the sequential DA.\n\n    " \
    "This function should be called at each model time step. \n\n    " \
    "User-supplied functions are executed in the following sequence:\n    " \
    "    1. py__collect_state_pdaf\n    " \
    "    2. py__prepoststep_state_pdaf\n    " \
    "    3. py__init_dim_obs_pdaf\n    " \
    "    4. py__obs_op_pdaf (for ensemble mean)\n    " \
    "    5. py__obs_op_pdaf (for each ensemble member)\n    " \
    "    6. py__prodRinvA_pdaf\n    " \
    "    7. core DA algorithm" \
    "\n\n    " \
    "References\n    " \
    "----------\n    " \
    ".. [1] Nerger, L., Janjić, T., Schröter, J., Hiller, W. (2012). \n    " \
    "       A unification of ensemble square root Kalman filters. \n    " \
    "       Monthly Weather Review, 140, 2335-2345.\n    " \
    "       doi:10.1175/MWR-D-11-00102.1"
docstrings['omi_put_state_nonlin_nondiagR'] = \
    "Global nonlinear filters for a single DA step\n    " \
    "using non-diagnoal observation error covariance matrix\n    "\
    "without post-processing, distributing analysis,\n    " \
    "and setting next observation step.\n\n    " \
    "See :func:`pyPDAF.PDAF.omi_put_state_global_nondiagR`\n    " \
    "for simpler user-supplied functions\n    " \
    "using diagonal observation error covariance matrix.\n\n    " \
    "Here, this function call is used for global NETF [1]_,\n    " \
    "and particle filter [2]_.\n    " \
    "The filter type is set in :func:`pyPDAF.PDAF.init`.\n\n    " \
    "Compared to\n    " \
    ":func:`pyPDAF.PDAF.omi_assimilate_nonlin_nondiagR`,\n    " \
    "this function has no :func:`get_state` call.\n    " \
    "This means that the analysis is not post-processed,\n    " \
    "and distributed to the model forecast\n    " \
    "by user-supplied functions. The next DA step will\n    " \
    "not be assigned by user-supplied functions as well.\n    " \
    "This function is typically used when there are\n    " \
    "not enough CPUs to run the ensemble in parallel,\n    "\
    "and some ensemble members have to be run serially.\n    " \
    "The :func:`pyPDAF.PDAF.get_state` function follows this\n    "\
    "function call to ensure the sequential DA.\n\n    " \
    "This function should be called at each model time step. \n\n    " \
    "User-supplied functions are executed in the following sequence:\n    " \
    "    1. py__collect_state_pdaf\n    " \
    "    2. py__prepoststep_state_pdaf\n    " \
    "    3. py__init_dim_obs_pdaf\n    " \
    "    4. py__obs_op_pdaf (for ensemble mean)\n    " \
    "    5. py__obs_op_pdaf (for each ensemble member)\n    " \
    "    6. py__likelihood_pdaf\n    " \
    "    7. core DA algorithm" \
    "\n\n    " \
    "References\n    " \
    "----------\n    " \
    ".. [1] Tödter, J., and B. Ahrens, 2015:\n    "\
    "       A second-order exact ensemble square root filter\n    " \
    "       for nonlinear data assimilation. Mon. Wea. Rev.,\n    " \
    "       143, 1347–1367, doi:10.1175/MWR-D-14-00108.1.\n    " \
    ".. [2] Van Leeuwen, P. J., Künsch, H. R., Nerger, L.,\n    " \
    "       Potthast, R., & Reich, S. (2019).\n    "\
    "       Particle filters for high‐dimensional geoscience applications:\n    "\
    "       A review.\n    " \
    "       Quarterly Journal of the Royal Meteorological Society,\n    " \
    "       145(723), 2335-2365."
docstrings['omi_put_state_lenkf_nondiagR'] = \
    "Covariance localised stochastic EnKF\n    " \
    "for a single DA step using non-diagnoal observation\n    " \
    "error covariance matrix\n    "\
    "without post-processing, distributing analysis,\n    " \
    "and setting next observation step.\n\n    " \
    "See :func:`pyPDAF.PDAF.omi_put_state_lenkf`\n    " \
    "for simpler user-supplied functions\n    " \
    "using diagnoal observation error covariance matrix.\n\n    "\
    "This function is implemented based on [1]_.\n\n    " \
    "This is the only scheme for covariance localisation in PDAF.\n\n    " \
    "Compared to\n    " \
    ":func:`pyPDAF.PDAF.omi_assimilate_lenkf_nondiagR`,\n    " \
    "this function has no :func:`get_state` call.\n    " \
    "This means that the analysis is not post-processed,\n    " \
    "and distributed to the model forecast\n    " \
    "by user-supplied functions. The next DA step will\n    " \
    "not be assigned by user-supplied functions as well.\n    " \
    "This function is typically used when there are\n    " \
    "not enough CPUs to run the ensemble in parallel,\n    "\
    "and some ensemble members have to be run serially.\n    " \
    "The :func:`pyPDAF.PDAF.get_state` function follows this\n    "\
    "function call to ensure the sequential DA.\n\n    " \
    "This function should be called at each model time step.\n\n    " \
    "User-supplied functions are executed in the following sequence:\n    " \
    "    1. py__collect_state_pdaf\n    " \
    "    2. py__prepoststep_state_pdaf\n    " \
    "    3. py__init_dim_obs_pdaf\n    " \
    "    4. py__obs_op_pdaf (for each ensemble member)\n    " \
    "    5. py__localize_pdaf\n    " \
    "    6. py__add_obs_err_pdaf\n    " \
    "    7. py__init_obscovar_pdaf\n    " \
    "    8. py__obs_op_pdaf (repeated to reduce storage)\n    " \
    "    9. core DA algorithm" \
    "\n\n    " \
    "References\n    " \
    "----------\n    " \
    ".. [1] Houtekamer, P. L., and H. L. Mitchell (1998): \n    " \
    "       Data Assimilation Using an Ensemble Kalman Filter Technique.\n    "\
    "       Mon. Wea. Rev., 126, 796–811,\n    "\
    "       doi: 10.1175/1520-0493(1998)126<0796:DAUAEK>2.0.CO;2."
docstrings['omi_put_state_local_nondiagR'] = \
    "It is recommended to use\n    " \
    ":func:`pyPDAF.PDAF.localomi_put_state_nondiagR`\n    "\
    "or :func:`pyPDAF.PDAF.localomi_put_state`.\n\n    " \
    "PDAFlocal-OMI modules require fewer user-supplied\n    " \
    "functions and improved efficiency.\n\n    " \
    "Domain local filters for a single DA step\n    " \
    "using non-diagnoal observation error covariance matrix\n    " \
    "without post-processing, distributing analysis,\n    " \
    "and setting next observation step.\n\n    " \
    "Here, this function call is used for LE(S)TKF [1]_ and LSEIK [1]_\n    " \
    "The filter type is set in :func:`pyPDAF.PDAF.init`.\n\n    " \
    "Compared to\n    " \
    ":func:`pyPDAF.PDAF.omi_assimilate_local_nondiagR`,\n    " \
    "this function has no :func:`get_state` call.\n    " \
    "This means that the analysis is not post-processed,\n    " \
    "and distributed to the model forecast\n    " \
    "by user-supplied functions. The next DA step will\n    " \
    "not be assigned by user-supplied functions as well.\n    " \
    "This function is typically used when there are\n    " \
    "not enough CPUs to run the ensemble in parallel,\n    "\
    "and some ensemble members have to be run serially.\n    " \
    "The :func:`pyPDAF.PDAF.get_state` function follows this\n    "\
    "function call to ensure the sequential DA.\n\n    " \
    "This function should be called at each model time step.\n\n    " \
    "User-supplied functions are executed in the following sequence:\n    " \
    "    1. py__collect_state_pdaf\n    "\
    "    2. py__prepoststep_state_pdaf\n    "\
    "    3. py__init_n_domains_p_pdaf\n    "\
    "    4. py__init_dim_obs_pdaf\n    "\
    "    5. py__obs_op_pdaf (for each ensemble member)\n    "\
    "    6. loop over each local domain:\n    " \
    "        1. py__init_dim_l_pdaf\n    "\
    "        2. py__init_dim_obs_l_pdaf\n    "\
    "        3. py__g2l_state_pdaf\n    "\
    "        4. py__init_obs_l_pdaf\n    "\
    "        5. py__prodRinvA_l_pdaf\n    " \
    "        6. core DA algorithm\n    " \
    "        7. py__l2g_state_pdaf\n" \
    "\n    " \
    ".. deprecated:: 1.0.0\n\n    " \
    "   This function is replaced by\n    " \
    "   :func:`pyPDAF.PDAF.localomi_put_state`\n    " \
    "   and :func:`pyPDAF.PDAF.localomi_put_state_nondiagR`." \
    "\n\n    " \
    "References\n    " \
    "----------\n    " \
    ".. [1] Nerger, L., Janjić, T., Schröter, J., Hiller, W. (2012). \n    " \
    "       A unification of ensemble square root Kalman filters. \n    " \
    "       Monthly Weather Review, 140, 2335-2345. doi:10.1175/MWR-D-11-00102.1"
docstrings['omi_put_state_lnetf_nondiagR'] = \
    "It is recommended to use\n    " \
    ":func:`pyPDAF.PDAF.localomi_put_state_lnetf_nondiagR`\n    "\
    "or :func:`pyPDAF.PDAF.localomi_put_state`.\n\n    " \
    "PDAFlocal-OMI modules require fewer user-supplied\n    " \
    "functions and improved efficiency.\n\n    " \
    "LNETF [1]_ for a single DA step\n    " \
    "using non-diagnoal observation error covariance matrix\n    " \
    "without post-processing, distributing analysis,\n    " \
    "and setting next observation step.\n\n    " \
    "See :func:`pyPDAF.PDAF.localomi_put_state`\n    " \
    "for using diagnoal observation error covariance matrix.\n    " \
    "The filter type is set in :func:`pyPDAF.PDAF.init`.\n\n    " \
    "Compared to\n    " \
    ":func:`pyPDAF.PDAF.omi_assimilate_lnetf_nondiagR`,\n    " \
    "this function has no :func:`get_state` call.\n    " \
    "This means that the analysis is not post-processed,\n    " \
    "and distributed to the model forecast\n    " \
    "by user-supplied functions. The next DA step will\n    " \
    "not be assigned by user-supplied functions as well.\n    " \
    "This function is typically used when there are\n    " \
    "not enough CPUs to run the ensemble in parallel,\n    "\
    "and some ensemble members have to be run serially.\n    " \
    "The :func:`pyPDAF.PDAF.get_state` function follows this\n    "\
    "function call to ensure the sequential DA.\n\n    " \
    "This function should be called at each model time step.\n\n    " \
    "User-supplied functions are executed in the following sequence:\n    " \
    "    1. py__collect_state_pdaf\n    "\
    "    2. py__prepoststep_state_pdaf\n    "\
    "    3. py__init_n_domains_p_pdaf\n    "\
    "    4. py__init_dim_obs_pdaf\n    "\
    "    5. py__obs_op_pdaf (for each ensemble member)\n    "\
    "    6. loop over each local domain:\n    " \
    "        1. py__init_dim_l_pdaf\n    "\
    "        2. py__init_dim_obs_l_pdaf\n    "\
    "        3. py__g2l_state_pdaf\n    "\
    "        4. py__likelihood_l_pdaf\n    " \
    "        5. core DA algorithm\n    " \
    "        6. py__l2g_state_pdaf\n" \
    "\n    " \
    ".. deprecated:: 1.0.0\n\n    " \
    "   This function is replaced by\n    " \
    "   :func:`pyPDAF.PDAF.localomi_put_state`\n    " \
    "   and :func:`pyPDAF.PDAF.localomi_put_state_lnetf_nondiagR`." \
    "\n\n    " \
    "References\n    " \
    "----------\n    " \
    ".. [1] Tödter, J., and B. Ahrens, 2015:\n    "\
    "       A second-order exact ensemble square root filter\n    " \
    "       for nonlinear data assimilation. Mon. Wea. Rev.,\n    " \
    "       143, 1347–1367, doi:10.1175/MWR-D-14-00108.1."
docstrings['omi_put_state_lknetf_nondiagR'] = \
    "It is recommended to use\n    " \
    ":func:`pyPDAF.PDAF.localomi_put_state_lknetf_nondiagR`\n    "\
    "or :func:`pyPDAF.PDAF.localomi_put_state`.\n\n    " \
    "PDAFlocal-OMI modules require fewer user-supplied\n    " \
    "functions and improved efficiency.\n\n    " \
    "LKNETF [1]_ for a single DA step using\n    " \
    "non-diagnoal observation error covariance matrix\n    " \
    "without post-processing, distributing analysis,\n    " \
    "and setting next observation step.\n\n    " \
    "See :func:`pyPDAF.PDAF.localomi_assimilate`\n    " \
    "for using diagnoal observation error covariance matrix.\n    " \
    "The filter type is set in :func:`pyPDAF.PDAF.init`.\n\n    " \
    "Compared to\n    " \
    ":func:`pyPDAF.PDAF.omi_assimilate_lknetf_nondiagR`,\n    " \
    "this function has no :func:`get_state` call.\n    " \
    "This means that the analysis is not post-processed,\n    " \
    "and distributed to the model forecast\n    " \
    "by user-supplied functions. The next DA step will\n    " \
    "not be assigned by user-supplied functions as well.\n    " \
    "This function is typically used when there are\n    " \
    "not enough CPUs to run the ensemble in parallel,\n    "\
    "and some ensemble members have to be run serially.\n    " \
    "The :func:`pyPDAF.PDAF.get_state` function follows this\n    "\
    "function call to ensure the sequential DA.\n\n    " \
    "This function should be called at each model time step.\n\n    " \
    "User-supplied functions are executed in the following sequence:\n    " \
    "    1. py__collect_state_pdaf\n    "\
    "    2. py__prepoststep_state_pdaf\n    "\
    "    3. py__init_n_domains_p_pdaf\n    "\
    "    4. py__init_dim_obs_pdaf\n    "\
    "    5. py__obs_op_pdaf (for each ensemble member)\n    "\
    "    6. loop over each local domain:\n    " \
    "        1. py__init_dim_l_pdaf\n    "\
    "        2. py__init_dim_obs_l_pdaf\n    "\
    "        3. py__g2l_state_pdaf\n    "\
    "        4. py__prodRinvA_pdaf\n    " \
    "        5. py__likelihood_l_pdaf\n    " \
    "        6. core DA algorithm\n    " \
    "        7. py__l2g_state_pdaf\n    "\
    "        8. py__obs_op_pdaf\n    " \
    "           (only called with `HKN` and `HNK` options\n    " \
    "           called for each ensemble member)\n    " \
    "        9. py__likelihood_hyb_l_pda\n    " \
    "        10. py__prodRinvA_hyb_l_pdaf\n" \
    "\n    " \
    ".. deprecated:: 1.0.0\n\n    " \
    "   This function is replaced by\n    " \
    "   :func:`pyPDAF.PDAF.localomi_put_state`\n    " \
    "   and :func:`pyPDAF.PDAF.localomi_put_state_lnetf_nondiagR`." \
    "\n\n    " \
    "References\n    " \
    "----------\n    " \
    ".. [1] Nerger, L.. (2022) \n    " \
    "       Data assimilation for nonlinear systems with\n    " \
    "       a hybrid nonlinear Kalman ensemble transform filter.\n    " \
    "       Q J R Meteorol Soc, 620–640. doi:10.1002/qj.4221"
