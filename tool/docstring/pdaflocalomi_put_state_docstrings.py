"""docstrings for PDAFlocalomi_put_state_xxx functions
"""
docstrings = {}

docstrings['localomi_put_state'] = \
    "Domain local filters for a single DA step\n    " \
    "using diagnoal observation error covariance matrix\n    " \
    "without post-processing, distributing analysis,\n    " \
    "and setting next observation step.\n\n    " \
    "Here, this function call is used for LE(S)TKF [1]_, \n    " \
    "LSEIK [1]_, LNETF [2]_, and LKNETF [3]_.\n    " \
    "The filter type is set in :func:`pyPDAF.PDAF.init`.\n    " \
    "Compared to :func:`pyPDAF.PDAF.localomi_assimilate_local`,\n    " \
    "this function has no :func:`get_state` call.\n    " \
    "This means that the analysis is not post-processed,\n    " \
    "and distributed to the model forecast\n    " \
    "by user-supplied functions. The next DA step will\n    " \
    "not be assigned by user-supplied functions as well.\n    " \
    "This function is typically used when there are\n    " \
    "not enough CPUs to run the ensemble in parallel,\n    "\
    "and some ensemble members have to be run serially.\n    " \
    "The :func:`pyPDAF.PDAF.get_state` function follows this\n    "\
    "function call to ensure the sequential DA.\n\n    " \
    "The LESTKF is a more efficient equivalent to the LETKF.\n\n    " \
    "This function should be called at each model time step.\n\n    " \
    "User-supplied functions are executed in the following sequence:\n    " \
    "    1. py__collect_state_pdaf\n    "\
    "    2. py__prepoststep_state_pdaf\n    "\
    "    3. py__init_n_domains_p_pdaf\n    "\
    "    4. py__init_dim_obs_pdaf\n    "\
    "    5. py__obs_op_pdaf (for each ensemble member)\n    "\
    "    6. loop over each local domain:\n    " \
    "        1. py__init_dim_l_pdaf\n    "\
    "        2. py__init_dim_obs_l_pdaf\n    "\
    "        3. core DA algorithm\n" \
    "\n    " \
    "References\n    " \
    "----------\n    " \
    ".. [1] Nerger, L., Janjić, T., Schröter, J., Hiller, W. (2012). \n    " \
    "       A unification of ensemble square root Kalman filters. \n    " \
    "       Monthly Weather Review, 140, 2335-2345.\n    " \
    "       doi:10.1175/MWR-D-11-00102.1\n    " \
    ".. [2] Tödter, J., and B. Ahrens, 2015:\n    "\
    "       A second-order exact ensemble square root filter\n    " \
    "       for nonlinear data assimilation. Mon. Wea. Rev.,\n    " \
    "       143, 1347–1367, doi:10.1175/MWR-D-14-00108.1.\n    " \
    ".. [3] Nerger, L.. (2022) \n    " \
    "       Data assimilation for nonlinear systems with\n    " \
    "       a hybrid nonlinear Kalman ensemble transform filter. \n    " \
    "       Q J R Meteorol Soc, 620–640. doi:10.1002/qj.4221"
docstrings['localomi_put_state_en3dvar_lestkf'] = \
    "3DEnVar for a single DA step where\n    " \
    "the ensemble anomaly is generated by LESTKF\n    " \
    "using diagnoal observation error covariance matrix\n    " \
    "without post-processing, distributing analysis,\n    " \
    "and setting next observation step.\n\n    " \
    "Compared to\n    " \
    ":func:`pyPDAF.PDAF.localomi_assimilate_en3dvar_lestkf`,\n    " \
    "this function has no :func:`get_state` call.\n    " \
    "This means that the analysis is not post-processed,\n    " \
    "and distributed to the model forecast\n    " \
    "by user-supplied functions. The next DA step will\n    " \
    "not be assigned by user-supplied functions as well.\n    " \
    "This function is typically used when there are\n    " \
    "not enough CPUs to run the ensemble in parallel,\n    "\
    "and some ensemble members have to be run serially.\n    " \
    "The :func:`pyPDAF.PDAF.get_state` function follows this\n    "\
    "function call to ensure the sequential DA.\n\n    " \
    "The background error covariance matrix is estimated by ensemble.\n    " \
    "The 3DEnVar only calculates the analysis of the ensemble mean.\n    " \
    "An LESTKF is used to generate ensemble perturbations.\n    " \
    "This function should be called at each model time step.\n\n    " \
    "User-supplied function are executed in the following sequence:\n    " \
    "    1. py__collect_state_pdaf\n    " \
    "    2. py__prepoststep_state_pdaf\n    " \
    "    3. py__init_dim_obs_pdaf\n    " \
    "    4. py__obs_op_pdaf\n    " \
    "    5. Starting the iterative optimisation:\n    " \
    "        1. py__cvt_ens_pdaf\n    " \
    "        2. py__obs_op_lin_pdaf\n    " \
    "        3. py__obs_op_adj_pdaf\n    " \
    "        4. py__cvt_adj_ens_pdaf\n    " \
    "        5. core DA algorithm\n    " \
    "    6. py__cvt_ens_pdaf\n    " \
    "    7. Perform LESTKF:\n    " \
    "        1. py__init_n_domains_p_pdaf\n    " \
    "        2. py__init_dim_obs_pdaf\n    " \
    "        3. py__obs_op_pdaf\n    "\
    "           (for each ensemble member)\n    " \
    "        4. loop over each local domain:\n    " \
    "            1. py__init_dim_l_pdaf\n    " \
    "            2. py__init_dim_obs_l_pdaf\n    " \
    "            3. core DA algorithm"
docstrings['localomi_put_state_hyb3dvar_lestkf'] = \
    "Hybrid 3DEnVar for a single DA step\n    " \
    "using diagnoal observation error covariance matrix\n    " \
    "without post-processing, distributing analysis,\n    " \
    "and setting next observation step.\n\n    " \
    "Here, the background error covariance is\n    " \
    "hybridised by a static background error covariance,\n    " \
    "and a flow-dependent background error covariance\n    " \
    "estimated from ensemble.\n\n    " \
    "Compared to\n    " \
    ":func:`pyPDAF.PDAF.localomi_assimilate_hyb3dvar_lestkf`,\n    " \
    "this function has no :func:`get_state` call.\n    " \
    "This means that the analysis is not post-processed,\n    " \
    "and distributed to the model forecast\n    " \
    "by user-supplied functions. The next DA step will\n    " \
    "not be assigned by user-supplied functions as well.\n    " \
    "This function is typically used when there are\n    " \
    "not enough CPUs to run the ensemble in parallel,\n    "\
    "and some ensemble members have to be run serially.\n    " \
    "The :func:`pyPDAF.PDAF.get_state` function follows this\n    "\
    "function call to ensure the sequential DA.\n\n    " \
    "The 3DVar generates an ensemble mean and\n    " \
    "the ensemble perturbation is generated by\n    " \
    "LESTKF in this implementation.\n    " \
    "This function should be called at each model time step.\n\n    " \
    "User-supplied functions are executed in the following sequence:\n    " \
    "    1. py__collect_state_pdaf\n    " \
    "    2. py__prepoststep_state_pdaf\n    " \
    "    3. py__init_dim_obs_pdaf\n    " \
    "    4. py__obs_op_pdaf\n    " \
    "    5. The iterative optimisation:\n    " \
    "        1. py__cvt_pdaf\n    " \
    "        2. py__cvt_ens_pdaf\n    " \
    "        3. py__obs_op_lin_pdaf\n    " \
    "        4. py__obs_op_adj_pdaf\n    " \
    "        5. py__cvt_adj_pdaf\n    " \
    "        6. py__cvt_adj_ens_pdaf\n    " \
    "        7. core DA algorithm\n    " \
    "    6. py__cvt_pdaf\n    " \
    "    7. py__cvt_ens_pdaf\n    " \
    "    8. Perform LESTKF:\n    " \
    "        1. py__init_n_domains_p_pdaf\n    " \
    "        2. py__init_dim_obs_pdaf\n    " \
    "        3. py__obs_op_pdaf\n    " \
    "           (for each ensemble member)\n    " \
    "        4. loop over each local domain:\n    " \
    "            1. py__init_dim_l_pdaf\n    " \
    "            2. py__init_dim_obs_l_pdaf\n    " \
    "            3. core DA algorithm"
docstrings['localomi_put_state_en3dvar_lestkf_nondiagR'] = \
    "3DEnVar for a single DA step without post-processing,\n    " \
    "distributing analysis, and setting next observation step.\n\n    "\
    "Here, the ensemble anomaly is generated by LESTKF\n    " \
    "using non-diagnoal observation error covariance matrix.\n\n    " \
    "Compared to\n    " \
    ":func:`pyPDAF.PDAF.localomi_assimilate_en3dvar_lestkf_nondiagR`,\n    " \
    "this function has no :func:`get_state` call.\n    " \
    "This means that the analysis is not post-processed,\n    " \
    "and distributed to the model forecast\n    " \
    "by user-supplied functions. The next DA step will\n    " \
    "not be assigned by user-supplied functions as well.\n    " \
    "This function is typically used when there are\n    " \
    "not enough CPUs to run the ensemble in parallel,\n    "\
    "and some ensemble members have to be run serially.\n    " \
    "The :func:`pyPDAF.PDAF.get_state` function follows this\n    "\
    "function call to ensure the sequential DA.\n\n    " \
    "The background error covariance matrix is\n    " \
    "estimated by ensemble.\n    " \
    "The 3DEnVar only calculates the analysis of the ensemble mean." \
    "\n    " \
    "An LESTKF is used to generate ensemble perturbations.\n    " \
    "This function should be called at each model time step.\n\n    " \
    "User-supplied function are executed in the following sequence:\n    " \
    "    1. py__collect_state_pdaf\n    " \
    "    2. py__prepoststep_state_pdaf\n    " \
    "    3. py__init_dim_obs_pdaf\n    " \
    "    4. py__obs_op_pdaf\n    " \
    "    5. Starting the iterative optimisation:\n    " \
    "        1. py__cvt_ens_pdaf\n    " \
    "        2. py__obs_op_lin_pdaf\n    " \
    "        3. py__prodRinvA_pdaf\n    " \
    "        4. py__obs_op_adj_pdaf\n    " \
    "        5. py__cvt_adj_ens_pdaf\n    " \
    "        6. core DA algorithm\n    " \
    "    6. py__cvt_ens_pdaf\n    " \
    "    7. Perform LESTKF:\n    " \
    "        1. py__init_n_domains_p_pdaf\n    " \
    "        2. py__init_dim_obs_pdaf\n    " \
    "        3. py__obs_op_pdaf\n    "\
    "           (for each ensemble member)\n    " \
    "        4. loop over each local domain:\n    " \
    "            1. py__init_dim_l_pdaf\n    " \
    "            2. py__init_dim_obs_l_pdaf\n    " \
    "            3. py__prodRinvA_l_pdaf\n    " \
    "            4. core DA algorithm"
docstrings['localomi_put_state_hyb3dvar_lestkf_nondiagR'] = \
    "Hybrid 3DEnVar for a single DA step\n    " \
    "using non-diagnoal observation error covariance matrix\n    " \
    "without post-processing, distributing analysis,\n    " \
    "and setting next observation step.\n\n    " \
    "Here, the background error covariance is\n    " \
    "hybridised by a static background error covariance,\n    " \
    "and a flow-dependent background error covariance\n    " \
    "estimated from ensemble.\n\n    " \
    "Compared to\n    " \
    ":func:`pyPDAF.PDAF.localomi_assimilate_hyb3dvar_lestkf_nondiagR`,\n    " \
    "this function has no :func:`get_state` call.\n    " \
    "This means that the analysis is not post-processed,\n    " \
    "and distributed to the model forecast\n    " \
    "by user-supplied functions. The next DA step will\n    " \
    "not be assigned by user-supplied functions as well.\n    " \
    "This function is typically used when there are\n    " \
    "not enough CPUs to run the ensemble in parallel,\n    "\
    "and some ensemble members have to be run serially.\n    " \
    "The :func:`pyPDAF.PDAF.get_state` function follows this\n    "\
    "function call to ensure the sequential DA.\n\n    " \
    "The 3DVar generates an ensemble mean and\n    " \
    "the ensemble perturbation is generated by\n    " \
    "LESTKF in this implementation.\n    " \
    "This function should be called at each model time step.\n\n    " \
    "User-supplied functions are executed in the following sequence:\n    " \
    "    1. py__collect_state_pdaf\n    " \
    "    2. py__prepoststep_state_pdaf\n    " \
    "    3. py__init_dim_obs_pdaf\n    " \
    "    4. py__obs_op_pdaf\n    " \
    "    5. The iterative optimisation:\n    " \
    "        1. py__cvt_pdaf\n    " \
    "        2. py__cvt_ens_pdaf\n    " \
    "        3. py__obs_op_lin_pdaf\n    " \
    "        4. py__prodRinvA_pdaf\n    " \
    "        5. py__obs_op_adj_pdaf\n    " \
    "        6. py__cvt_adj_pdaf\n    " \
    "        7. py__cvt_adj_ens_pdaf\n    " \
    "        8. core DA algorithm\n    " \
    "    6. py__cvt_pdaf\n    " \
    "    7. py__cvt_ens_pdaf\n    " \
    "    8. Perform LESTKF:\n    " \
    "        1. py__init_n_domains_p_pdaf\n    " \
    "        2. py__init_dim_obs_pdaf\n    " \
    "        3. py__obs_op_pdaf\n    " \
    "           (for each ensemble member)\n    " \
    "        4. loop over each local domain:\n    " \
    "            1. py__init_dim_l_pdaf\n    " \
    "            2. py__init_dim_obs_l_pdaf\n    " \
    "            3. py__prodRinvA_l_pdaf\n    " \
    "            4. core DA algorithm"
docstrings['localomi_put_state_nondiagR'] = \
    "Domain local filters for a single DA step\n    " \
    "using non-diagnoal observation error covariance matrix\n    " \
    "without post-processing, distributing analysis,\n    " \
    "and setting next observation step.\n\n    " \
    "Here, this function call is used for LE(S)TKF [1]_ and LSEIK [1]_\n    " \
    "The filter type is set in :func:`pyPDAF.PDAF.init`.\n\n    " \
    "Compared to\n    " \
    ":func:`pyPDAF.PDAF.localomi_assimilate_local_nondiagR`,\n    " \
    "this function has no :func:`get_state` call.\n    " \
    "This means that the analysis is not post-processed,\n    " \
    "and distributed to the model forecast\n    " \
    "by user-supplied functions. The next DA step will\n    " \
    "not be assigned by user-supplied functions as well.\n    " \
    "This function is typically used when there are\n    " \
    "not enough CPUs to run the ensemble in parallel,\n    "\
    "and some ensemble members have to be run serially.\n    " \
    "The :func:`pyPDAF.PDAF.get_state` function follows this\n    "\
    "function call to ensure the sequential DA.\n\n    " \
    "This function should be called at each model time step.\n\n    " \
    "User-supplied functions are executed in the following sequence:\n    " \
    "    1. py__collect_state_pdaf\n    "\
    "    2. py__prepoststep_state_pdaf\n    "\
    "    3. py__init_n_domains_p_pdaf\n    "\
    "    4. py__init_dim_obs_pdaf\n    "\
    "    5. py__obs_op_pdaf (for each ensemble member)\n    "\
    "    6. loop over each local domain:\n    " \
    "        1. py__init_dim_l_pdaf\n    "\
    "        2. py__init_dim_obs_l_pdaf\n    "\
    "        3. py__init_obs_l_pdaf\n    "\
    "        4. py__prodRinvA_l_pdaf\n    " \
    "        5. core DA algorithm\n    " \
    "\n    " \
    "References\n    " \
    "----------\n    " \
    ".. [1] Nerger, L., Janjić, T., Schröter, J., Hiller, W. (2012). \n    " \
    "       A unification of ensemble square root Kalman filters. \n    " \
    "       Monthly Weather Review, 140, 2335-2345.\n    " \
    "       doi:10.1175/MWR-D-11-00102.1"
docstrings['localomi_put_state_lnetf_nondiagR'] = \
    "LNETF for a single DA step\n    " \
    "using non-diagnoal observation error covariance matrix\n    " \
    "without post-processing, distributing analysis,\n    " \
    "and setting next observation step.\n\n    " \
    "See :func:`pyPDAF.PDAF.localomi_put_state`\n    " \
    "for using diagnoal observation error covariance matrix.\n    " \
    "The non-linear filter is proposed in [1]_.\n    " \
    "The filter type is set in :func:`pyPDAF.PDAF.init`.\n\n    " \
    "Compared to\n    " \
    ":func:`pyPDAF.PDAF.omi_assimilate_lnetf_nondiagR`,\n    " \
    "this function has no :func:`get_state` call.\n    " \
    "This means that the analysis is not post-processed,\n    " \
    "and distributed to the model forecast\n    " \
    "by user-supplied functions. The next DA step will\n    " \
    "not be assigned by user-supplied functions as well.\n    " \
    "This function is typically used when there are\n    " \
    "not enough CPUs to run the ensemble in parallel,\n    "\
    "and some ensemble members have to be run serially.\n    " \
    "The :func:`pyPDAF.PDAF.get_state` function follows this\n    "\
    "function call to ensure the sequential DA.\n\n    " \
    "This function should be called at each model time step.\n\n    " \
    "User-supplied functions are executed in the following sequence:\n    " \
    "    1. py__collect_state_pdaf\n    "\
    "    2. py__prepoststep_state_pdaf\n    "\
    "    3. py__init_n_domains_p_pdaf\n    "\
    "    4. py__init_dim_obs_pdaf\n    "\
    "    5. py__obs_op_pdaf (for each ensemble member)\n    "\
    "    6. loop over each local domain:\n    " \
    "        1. py__init_dim_l_pdaf\n    "\
    "        2. py__init_dim_obs_l_pdaf\n    "\
    "        3. py__likelihood_l_pdaf\n    " \
    "        4. core DA algorithm\n    " \
    "\n    " \
    "References\n    " \
    "----------\n    " \
    ".. [1] Tödter, J., and B. Ahrens, 2015:\n    "\
    "       A second-order exact ensemble square root filter\n    " \
    "       for nonlinear data assimilation. Mon. Wea. Rev.,\n    " \
    "       143, 1347–1367, doi:10.1175/MWR-D-14-00108.1."
docstrings['localomi_put_state_lknetf_nondiagR'] = \
    "LKNETF for a single DA step\n    " \
    "using non-diagnoal observation error covariance matrix\n    " \
    "without post-processing, distributing analysis,\n    " \
    "and setting next observation step.\n\n    " \
    "See :func:`pyPDAF.PDAF.localomi_assimilate`\n    " \
    "for using diagnoal observation error covariance matrix.\n    " \
    "The non-linear filter is proposed in [1]_.\n    " \
    "The filter type is set in :func:`pyPDAF.PDAF.init`.\n\n    " \
    "Compared to\n    " \
    ":func:`pyPDAF.PDAF.localomi_assimilate_lknetf_nondiagR`,\n    " \
    "this function has no :func:`get_state` call.\n    " \
    "This means that the analysis is not post-processed,\n    " \
    "and distributed to the model forecast\n    " \
    "by user-supplied functions. The next DA step will\n    " \
    "not be assigned by user-supplied functions as well.\n    " \
    "This function is typically used when there are\n    " \
    "not enough CPUs to run the ensemble in parallel,\n    "\
    "and some ensemble members have to be run serially.\n    " \
    "The :func:`pyPDAF.PDAF.get_state` function follows this\n    "\
    "function call to ensure the sequential DA.\n\n    " \
    "This function should be called at each model time step.\n\n    " \
    "User-supplied functions are executed in the following sequence:\n    " \
    "    1. py__collect_state_pdaf\n    "\
    "    2. py__prepoststep_state_pdaf\n    "\
    "    3. py__init_n_domains_p_pdaf\n    "\
    "    4. py__init_dim_obs_pdaf\n    "\
    "    5. py__obs_op_pdaf (for each ensemble member)\n    "\
    "    6. loop over each local domain:\n    " \
    "        1. py__init_dim_l_pdaf\n    "\
    "        2. py__init_dim_obs_l_pdaf\n    "\
    "        3. py__prodRinvA_pdaf\n    " \
    "        4. py__likelihood_l_pdaf\n    " \
    "        5. core DA algorithm\n    " \
    "        6. py__obs_op_pdaf\n    " \
    "           (only called with `HKN` and `HNK` options\n    " \
    "           called for each ensemble member)\n    " \
    "        7. py__likelihood_hyb_l_pda\n    " \
    "        8. py__prodRinvA_hyb_l_pdaf\n" \
    "\n    " \
    "References\n    " \
    "----------\n    " \
    ".. [1] Nerger, L.. (2022) \n    " \
    "       Data assimilation for nonlinear systems with\n    " \
    "       a hybrid nonlinear Kalman ensemble transform filter.\n    " \
    "       Q J R Meteorol Soc, 620–640. doi:10.1002/qj.4221"
